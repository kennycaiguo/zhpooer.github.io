
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Scala in Action-Functional Programming in Scala | Poe&#39;s World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhpooer">
    
    <meta name="description" content="类型参数化
1
2
3
4
5
6
7
8
9
10
11
12
sealed abstract class Maybe[+A] {
  def isEmpty: Boolean
  def get: A
}
final case class Just[A](value: A) extends Ma">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Poe&#39;s World" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Poe&#39;s World" title="Poe&#39;s World"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Poe&#39;s World">Poe&#39;s World</a></h1>
				<h2 class="blog-motto">竹杖芒鞋轻胜马，一蓑烟雨任平生</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/english-monthly">英语角</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zhpooer.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/07/15/scala-in-action-functional-programming-in-scala/" title="Scala in Action-Functional Programming in Scala" itemprop="url">Scala in Action-Functional Programming in Scala</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://zhpooer.github.io" title="zhpooer">zhpooer</a>
    </p>
  <p class="article-time">
    <time datetime="2014-07-15T03:35:59.000Z" itemprop="datePublished">7月 15 2014</time>
    更新日期:<time datetime="2014-07-17T03:14:41.000Z" itemprop="dateModified">7月 17 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#-"><span class="toc-number">1.</span> <span class="toc-text">类型参数化</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.1.</span> <span class="toc-text">协变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.2.</span> <span class="toc-text">逆变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.3.</span> <span class="toc-text">不变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.4.</span> <span class="toc-text">类型的边界</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#-"><span class="toc-number">2.</span> <span class="toc-text">头等函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scala-collection-hierarchy"><span class="toc-number">3.</span> <span class="toc-text">Scala collection hierarchy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lazy-collections"><span class="toc-number">4.</span> <span class="toc-text">lazy collections</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream"><span class="toc-number">4.1.</span> <span class="toc-text">Stream</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#parallel-collections"><span class="toc-number">5.</span> <span class="toc-text">parallel collections</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-"><span class="toc-number">6.</span> <span class="toc-text">函数式编程</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pure-functional-program"><span class="toc-number">6.1.</span> <span class="toc-text">pure functional program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo-http-server"><span class="toc-number">6.2.</span> <span class="toc-text">DEMO: HTTP server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">6.3.</span> <span class="toc-text">方法和函数</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.1.</span> <span class="toc-text">头等函数的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.2.</span> <span class="toc-text">柯里化函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.3.</span> <span class="toc-text">偏函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.4.</span> <span class="toc-text">递归</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#-"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">尾递归</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#adt"><span class="toc-number">6.3.5.</span> <span class="toc-text">ADT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function-compose"><span class="toc-number">6.3.6.</span> <span class="toc-text">function compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monad"><span class="toc-number">6.3.7.</span> <span class="toc-text">Monad</span></a></li></ol>
		</div>
		
		<h1 id="-">类型参数化</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Maybe</span>[+<span class="title">A</span>] {</span>
  <span class="keyword">def</span> isEmpty: Boolean
  <span class="keyword">def</span> get: A
}
<span class="keyword">final</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Just</span>[<span class="title">A</span>]<span class="params">(value: A)</span> <span class="keyword">extends</span> <span class="title">Maybe</span>[<span class="title">A</span>] {</span>
  <span class="keyword">def</span> isEmpty = <span class="keyword">false</span>
  <span class="keyword">def</span> get = value
}
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">Maybe</span>[<span class="title">Nothing</span>] {</span>
  <span class="keyword">def</span> isEmpty = <span class="keyword">true</span>
  <span class="keyword">def</span> get = <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Nil.get"</span>)
}
</pre></td></tr></table></figure>

<h2 id="-">协变</h2>
<p>When using type parameters for classes or traits,
you can use a + sign along with the type parameter to make it
covariant (like the Maybe class in the previous example).</p>
<p>Covariance allows subclasses to override and use narrower types(Like Nothing)
than their superclass in covariant positions such as
the return value. </p>
<p>Traversable is the parent trait for all the collection types in Scala.</p>
<h2 id="-">逆变</h2>
<p>In the case of covariance, subtyping
can go downward, as you saw in the example of List, but in contravariance it’s the
opposite: subtypes go upward.</p>
<p>Contravariance comes in handy when you have a mutable data structure.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// java 会在运行时报错</span>
<span class="built_in">Object</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];
arr[<span class="number">0</span>] = <span class="string">"Hello, there!"</span>;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>// Scala uses the minus sign (-) to denote contravariance
// and the plus sign (+) <span class="keyword">for</span> covariance.

// 参数是协变的, 返回值是逆变的
trait Function1[-P, +R] { <span class="keyword">...</span> }

val addOne: Function1[Any, Int] = { x: Int =&gt; x + <span class="number">1</span> }

// 此句非法, 因为 any 为所有的对象的父类
val asString: Int =&gt; Int = { x: Int =&gt; (x.toString: Any) }
</pre></td></tr></table></figure>

<h2 id="-">不变</h2>
<p>A type parameter is invariant when it’s neither covariant nor contravariant. All Scala
mutable collection classes are invariant. </p>
<p>如 <code>final class ListBuffer[A]</code>, 在scala中定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; val mxs: ListBuffer[String] = ListBuffer(<span class="string">"pants"</span>)
<span class="label">mxs:</span> scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.ListBuffer</span>[String] = ListBuffer(pants)

scala&gt; val everything: ListBuffer[Any] = mxs 
发生错误, 因为类型是 invariant
</pre></td></tr></table></figure>

<h2 id="-">类型的边界</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Maybe</span>[+<span class="title">A</span>] {</span>
  <span class="keyword">def</span> isEmpty: Boolean
  <span class="keyword">def</span> get: A
  <span class="comment">// 这里报错</span>
  <span class="comment">/// Because A is a covariant type,</span>
  <span class="comment">// Scala doesn’t allow the covariant type as an input parameter. </span>
  <span class="keyword">def</span> getOrElse(<span class="keyword">default</span>: A): A = {
    <span class="keyword">if</span>(isEmpty) <span class="keyword">default</span> <span class="keyword">else</span> get
  }
}
</pre></td></tr></table></figure>

<p>You could solve this problem in two ways:
make the Maybe class an invariant and lose
all the subtyping with Just and Nil, or use type bound. </p>
<p>Scala provides two types of type bound: lower and upper.</p>
<p>An upper type bound T &lt;: A declares that type variable T
is a subtype of a type A, and A is the upper bound. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">defaultToNull</span>[<span class="title">A</span> &lt;:</span> Maybe[_]](p: A) = {
  p.getOrElse(null)
}
</pre></td></tr></table></figure>

<p>A lower bound sets the lower limit of the type parameter.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>sealed abstract class Maybe[+A] {
  def isEmpty: Boolean
  def get: A
  def getOrElse[<span class="link_label">B &gt;: A</span>](<span class="link_url">default: B</span>): B = {
<span class="code">    if(isEmpty) default else get</span>
  }
}
</pre></td></tr></table></figure>

<h1 id="-">头等函数</h1>
<p>A function is called higher order if it takes a function as an argument or returns a
function as a result.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>class List[+A] ...
{
  def map[<span class="link_label">B</span>](<span class="link_url">f: A =&gt; B</span>) : List[B]
}
</pre></td></tr></table></figure>

<blockquote>
<p>Call-by-value, call-by-reference, and call-by-name method invocation<br>Java supports two types of method invocation: call-by-reference and call-by-value.<br>Scala also provides additional method invocation mechanisms called call-by-name and call-by-need. </p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def <span class="keyword">log</span>(m: <span class="built_in">String</span>) <span class="subst">=</span> <span class="keyword">if</span>(logEnabled) println(m)

<span class="comment">// 在这里, popErrorMessage, 总会先被运算</span>
def popErrorMessage <span class="subst">=</span> { popMessageFromASlowQueue() }
<span class="keyword">log</span>(<span class="string">"The error message is "</span> <span class="subst">+</span> popErrorMessage)<span class="built_in">.</span>

<span class="comment">// 但是这样呢? 这是按需</span>
def <span class="keyword">log</span>(m: <span class="subst">=&gt;</span> <span class="built_in">String</span>) <span class="subst">=</span> <span class="keyword">if</span>(logEnabled) println(m)
</pre></td></tr></table></figure>

<p>When passing an existing function (not a function object) as a parameter,
Scala creates a new anonymous function object with an apply method,
which invokes the original function. This is called eta-expansion.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> ++ <span class="keyword">extends</span> <span class="title">Function1</span>[<span class="title">Int</span>, <span class="title">Int</span>]{</span>
  <span class="keyword">def</span> apply(p: Int): Int = p + <span class="number">1</span>
}

<span class="keyword">val</span> ++ = (x: Int) =&gt; x + <span class="number">1</span>

<span class="class"><span class="keyword">object</span> ++ <span class="keyword">extends</span> <span class="params">(Int =&gt; Int)</span> {</span>
  <span class="keyword">def</span> apply(p: Int): Int = p + <span class="number">1</span>
}

<span class="keyword">val</span> addOne: Int =&gt; Int = x =&gt; x + <span class="number">1</span>
<span class="keyword">val</span> addTwo: Int =&gt; Int = x =&gt; x + <span class="number">2</span>
<span class="keyword">val</span> addThree = addOne compose addTwo
<span class="comment">// like this</span>
<span class="keyword">val</span> addThree: Int =&gt; Int = x =&gt; addOne(addTwo(x))
</pre></td></tr></table></figure>

<h1 id="scala-collection-hierarchy">Scala collection hierarchy</h1>
<p><img src="/img/scala_collection_hierarchy.png" alt="scala继承图"></p>
<p>In Scala you can define a traversable object as finite or infinite;
<code>hasDefiniteSize</code> determines whether a collection is finite or infinite. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>import java.util.{Collection =&gt; JCollection, ArrayList }
class JavaToTraversable[<span class="link_label">E</span>](<span class="link_url">javaCollection: JCollection[E]</span>) extends
<span class="code">    Traversable[E] {</span>
  def foreach[<span class="link_label">U</span>](<span class="link_url">f : E =&gt; U</span>): Unit = {
<span class="code">    val iterator = javaCollection.iterator</span>
<span class="code">    while(iterator.hasNext) {</span>
<span class="code">      f(iterator.next)</span>
<span class="code">    }</span>
  }
}
</pre></td></tr></table></figure>

<p>Overall, Vector has better performance characteristics compared to other collection types.</p>
<p>Buffers are always mutable, and most of the collections
I talk about here are internally built using
<code>Buffers</code>. The two common subclasses of Buffers are <code>mutable.ListBuffer</code> and
<code>mutable.ArrayBuffer</code>.</p>
<p>Unlike other collections, a Tuple is a heterogeneous collection where you can store various types of elements.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Artist</span><span class="params">(name: String, genre: String)</span></span>
<span class="keyword">val</span> artists = List(
    Artist(<span class="string">"Pink Floyd"</span>, <span class="string">"Rock"</span>),
    Artist(<span class="string">"Led Zeppelin"</span>, <span class="string">"Rock"</span>),
    Artist(<span class="string">"Michael Jackson"</span>, <span class="string">"Pop"</span>),
    Artist(<span class="string">"Above & Beyond"</span>, <span class="string">"trance"</span>)
)
<span class="keyword">for</span>(Artist(name, genre) &lt;- artists; <span class="keyword">if</span>(genre == <span class="string">"Rock"</span>))
<span class="keyword">yield</span> name

<span class="comment">// 会被翻译为</span>
artists withFilter {
  <span class="keyword">case</span> Artist(name, genre) =&gt; genre == <span class="string">"Rock"</span>
} map {
  <span class="keyword">case</span> Artist(name, genre) =&gt; name
}

<span class="comment">// 不用 filter 的原因, 这样会返回全部, 但是你只想返回头一个</span>
<span class="keyword">val</span> y = list filter {
  <span class="keyword">case</span> i =&gt; go
} map {
  <span class="keyword">case</span> i =&gt; {
    go = <span class="keyword">false</span>
    i
  }
}


<span class="keyword">for</span> {
    ArtistWithAlbums(artist, albums) &lt;- artistsWithAlbums
    album &lt;- albums
    <span class="keyword">if</span>(artist.genre == <span class="string">"Rock"</span>)
} <span class="keyword">yield</span> album
<span class="comment">// 被翻译为</span>
artistsWithAlbums flatMap {
    <span class="keyword">case</span> ArtistWithAlbums(artist, albums) =&gt; albums withFilter {
        album =&gt; artist.genre == <span class="string">"Rock"</span>
    } map { <span class="keyword">case</span> album =&gt; album }
}
</pre></td></tr></table></figure>

<p>scala.Either represents one of the two possible meaningful results, unlike
Option, which returns a single meaningful result or Nothing. Either provides two
subc</p>
<h1 id="lazy-collections">lazy collections</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">// view 是懒计算</span>
<span class="built_in">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)<span class="built_in">.</span>view<span class="built_in">.</span><span class="built_in">map</span>(_ <span class="subst">+</span> <span class="number">1</span>)<span class="built_in">.</span>head

<span class="keyword">import</span> scala<span class="built_in">.</span>io<span class="built_in">.</span>_
<span class="keyword">import</span> scala<span class="built_in">.</span><span class="built_in">xml</span><span class="built_in">.</span><span class="built_in">XML</span>
def tweets(<span class="keyword">handle</span>: <span class="built_in">String</span>) <span class="subst">=</span> {
  println(<span class="string">"processing tweets for "</span> <span class="subst">+</span> <span class="keyword">handle</span>)
  val source <span class="subst">=</span> Source<span class="built_in">.</span>fromURL(<span class="literal">new</span>
      java<span class="built_in">.</span>net<span class="built_in">.</span>URL(<span class="string">"http://search.twitter.com/search.atom?q="</span> <span class="subst">+</span> <span class="keyword">handle</span>))
  val iterator <span class="subst">=</span> source<span class="built_in">.</span>getLines()
  val builder <span class="subst">=</span> <span class="literal">new</span> StringBuilder
  for(line <span class="subst">&lt;-</span> iterator) builder<span class="built_in">.</span>append(line)
  <span class="built_in">XML</span><span class="built_in">.</span>loadString(builder<span class="built_in">.</span>toString)
}

val allTweets <span class="subst">=</span> <span class="built_in">Map</span>(
    <span class="string">"nraychaudhuri"</span> <span class="subst">-&gt; </span>tweets _,
    <span class="string">"ManningBooks"</span> <span class="subst">-&gt; </span>tweets _,
    <span class="string">"bubbl_scala"</span> <span class="subst">-&gt; </span>tweets _
)

<span class="comment">// 可以这样使用</span>
allTweets<span class="built_in">.</span>view<span class="built_in">.</span><span class="built_in">map</span>{ t <span class="subst">=&gt;</span> t<span class="built_in">.</span>_2(t<span class="built_in">.</span>_1)}<span class="built_in">.</span>head
<span class="comment">// Note that starting with Scala 2.8, for-comprehensions are now nonstrict for standard operations.</span>
<span class="comment">// nostrict means lazy collections?</span>
for(t <span class="subst">&lt;-</span> allTweets; <span class="keyword">if</span>(t<span class="built_in">.</span>_1 <span class="subst">==</span> <span class="string">"ManningBooks"</span>)) t<span class="built_in">.</span>_2(t<span class="built_in">.</span>_1)
</pre></td></tr></table></figure>

<h2 id="stream">Stream</h2>
<p>The class Stream implements lazy lists in Scala where elements are evaluated only when
they’re needed. If you want, you can build an infinite list in Scala using Stream ,
and it will consume memory based on your use.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>scala&gt; List(<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>,<span class="string">"five"</span>).zip(Stream.<span class="built_in">from</span>(<span class="number">0</span>))

res88: List[(java.lang.String, Int)] = List((<span class="constant">zero</span>,<span class="number">0</span>), (<span class="constant">one</span>,<span class="number">1</span>), (<span class="constant">two</span>,<span class="number">2</span>),
(<span class="constant">three</span>,<span class="number">3</span>), (<span class="constant">four</span>,<span class="number">4</span>), (<span class="constant">five</span>,<span class="number">5</span>))
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// 斐波那契数列, 这样做没有效率
<span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n: Int)</span>:</span> Int = n match {
  case <span class="number">0</span> =&gt; <span class="number">0</span>
  case <span class="number">1</span> =&gt; <span class="number">1</span>
  case n =&gt; fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)
}

val fib: Stream[Int] = Stream.cons(<span class="number">0</span>, Stream.cons(<span class="number">1</span>,
    fib.zip(fib.tail).map(t =&gt; t._1 + t._2)))
</pre></td></tr></table></figure>

<h1 id="parallel-collections">parallel collections</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; import scala<span class="preprocessor">.collection</span><span class="preprocessor">.parallel</span><span class="preprocessor">.immutable</span>._
import scala<span class="preprocessor">.collection</span><span class="preprocessor">.parallel</span><span class="preprocessor">.immutable</span>._

scala&gt; ParVector(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>)<span class="preprocessor">.map</span> {<span class="built_in">x</span> =&gt;
    println(Thread<span class="preprocessor">.currentThread</span><span class="preprocessor">.getName</span>)<span class="comment">; x / 2 }</span>

// <span class="keyword">In</span> this case tasksupport is changed to ForkJoinTask with four working threads.
import scala<span class="preprocessor">.collection</span><span class="preprocessor">.parallel</span>._
val pv = immutable<span class="preprocessor">.ParVector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
pv<span class="preprocessor">.tasksupport</span> = new ForkJoinTaskSupport(new
scala<span class="preprocessor">.concurrent</span><span class="preprocessor">.forkjoin</span><span class="preprocessor">.ForkJoinPool</span>(<span class="number">4</span>))
</pre></td></tr></table></figure>

<p><img src="/img/par_collection.png" alt="并发集合类继承图"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>val vs = Vector<span class="preprocessor">.range</span>(<span class="number">1</span>, <span class="number">100000</span>)
vs<span class="preprocessor">.par</span><span class="preprocessor">.filter</span>(_ % <span class="number">2</span> == <span class="number">0</span>)

Vector<span class="preprocessor">.range</span>(<span class="number">1</span>, <span class="number">100000</span>)<span class="preprocessor">.par</span><span class="preprocessor">.filter</span>(_ % <span class="number">2</span> == <span class="number">0</span>)<span class="preprocessor">.seq</span>
</pre></td></tr></table></figure>

<p>Operations like `map, flatMap , filter , and forall are good examples of methods that
would be easily parallelized.</p>
<p>If it takes less time to perform the operation than
to create a parallel collection, then using the parallel version will reduce your perfor-
mance. It also depends on the type of collection you’re using. Converting Seq to
ParSeq is much faster than converting List to Vector because there’s no parallel List
implementation, so when you invoke par on List you get Vector back.</p>
<h1 id="-">函数式编程</h1>
<p>A function provides the predictability that for a given input you will always get the
same output.</p>
<p>But what about the functions that depend on some external state and don’t return
the same result all the time? They’re functions but they’re not pure functions. A pure
function doesn’t have side effects.</p>
<p>The value is referential transparency. Referential transparency is a property whereby
an expression could be replaced by its value without affecting the program. </p>
<p><code>val v = add(10, 10) + add(5, 5)</code>
Because add is a pure function, I can replace the function call add(10, 10) with its
result, which is 20, without changing the behavior of the program. And similarly I
could replace add(5, 5) with 10 without affecting the behavior of the program. </p>
<p><strong>methods in Scala don’t have any type; type is only associated with the
enclosing class, whereas functions are represented by a type and object.</strong></p>
<h2 id="pure-functional-program">pure functional program</h2>
<p>If you can start thinking about your program as a collection of subexpressions
combined into one single referentially transparent expression,
you have achieved a purely functional program. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">PureFunctionalProgram</span> {</span>
  <span class="keyword">def</span> main(args: Array[String]):Unit = singleExpression(args.toList)
  <span class="keyword">def</span> singleExpression: List[String] =&gt; (List[Int], List[Int]) = { a =&gt;
    a map (_.toInt) partition (_ &lt; <span class="number">30</span>)
  }
}
<span class="comment">// In this new solution, every time the side property is modified,</span>
<span class="comment">//a new copy of PureSquare is returned</span>
<span class="class"><span class="keyword">class</span> <span class="title">PureSquare</span><span class="params">(val side: Int)</span> {</span>
  <span class="keyword">def</span> newSide(s: Int): PureSquare = <span class="keyword">new</span> PureSquare(s)
  <span class="keyword">def</span> area = side * side
}
</pre></td></tr></table></figure>

<h2 id="demo-http-server">DEMO: HTTP server</h2>
<p>To demonstrate how this works, you’re going to build a simple HTTP server that
only serves files from a directory in which the server is started.
You’re going to implement the HTTP GET command. Like any server,
this HTTP server is full of side effects,
like writing to a socket, reading files from the filesystem,
and so on. Here are your design goals for the server you’re building:</p>
<ul>
<li>Separate the code into different layers, pure code from the side-effecting code.</li>
<li>Respond with the contents of a file for a given HTTP GET request.</li>
<li>Respond with a 404 message when the file requested is missing.</li>
</ul>
<p>Separating pure and side-effecting
(impure) code. The side-effecting code should
form a thin layer around the application.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Pure</span> {</span>
  <span class="class"><span class="keyword">trait</span> <span class="title">Resource</span> {</span>
    <span class="keyword">def</span> exists: Boolean
    <span class="keyword">def</span> contents: List[String]
    <span class="keyword">def</span> contentLength: Int
  }
  <span class="keyword">type</span> ResourceLocator = String =&gt; Resource
  <span class="keyword">type</span> Request = Iterator[Char]
  <span class="keyword">type</span> Response = List[String]
  <span class="keyword">def</span> get(req: Request)(implicit locator: ResourceLocator): Response = {
    <span class="keyword">val</span> requestedResource = req.takeWhile(x =&gt; x != <span class="string">'\n'</span>)
          .mkString.split(<span class="string">" "</span>)(<span class="number">1</span>).drop(<span class="number">1</span>)
    (_200 orElse _404)(locator(requestedResource))
  }
  <span class="keyword">private</span> <span class="keyword">def</span> _200: PartialFunction[Resource, Response] = {
    <span class="keyword">case</span> resource <span class="keyword">if</span>(resource.exists) =&gt;
      <span class="string">"HTTP/1.1 200 OK"</span> ::
      (<span class="string">"Date "</span> + <span class="keyword">new</span> java.util.Date) ::
      <span class="string">"Content-Type: text/html"</span> ::
      (<span class="string">"Content-Length: "</span> + resource.contentLength) ::
      System.getProperty(<span class="string">"line.separator"</span>) ::
      resource.contents
    }
    <span class="keyword">private</span> <span class="keyword">def</span> _404: PartialFunction[Resource, Response] = {
      <span class="keyword">case</span> _ =&gt; List(<span class="string">"HTTP/1.1 404 Not Found"</span>)
    }
}

<span class="comment">// 封装的有副作用的操作</span>
<span class="keyword">import</span> Pure._
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">IOResource</span><span class="params">(name: String)</span> <span class="keyword">extends</span> <span class="title">Resource</span> {</span>
  <span class="keyword">def</span> exists = <span class="keyword">new</span> File(name).exists
  <span class="keyword">def</span> contents = Source.fromFile(name).getLines.toList
  <span class="keyword">def</span> contentLength = Source.fromFile(name).count(x =&gt; <span class="keyword">true</span>)
}
implicit <span class="keyword">val</span> ioResourceLocator: ResourceLocator =
  name =&gt; IOResource(name)
</pre></td></tr></table></figure>

<h2 id="-">方法和函数</h2>
<p>One downside of using methods is that it’s easy
to depend on the state defined by the enclosing class without
explicitly passing the dependencies as parameters
be careful about that because that will take you away from having pure methods.</p>
<p>Scala infuses functional programming with OOP by
transforming functions into objects. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="regexp">//</span> 这是方法
<span class="class"><span class="keyword">class</span> <span class="title">UseResource</span> {</span>
  <span class="regexp">//</span> Here use <span class="keyword">is</span> a method defined <span class="keyword">in</span> the <span class="class"><span class="keyword">class</span> <span class="title">UseResource</span>. </span>
  def use(<span class="attribute">r</span>: Resource): Boolean = {...}
}

<span class="regexp">//</span> 这是函数
val <span class="function"><span class="title">succ</span> = <span class="params">(x: Int)</span> =&gt;</span> x + <span class="number">1</span>
// 也可以这样定义
val succFunction = <span class="keyword">new</span> Function1[Int, Int] {
  def apply(<span class="attribute">x</span>:Int) : Int = x + <span class="number">1</span>
}
<span class="regexp">//</span> Functions <span class="keyword">in</span> Scala are represented <span class="keyword">by</span> a type <span class="keyword">and</span> object,
<span class="regexp">//</span> but methods aren’t. Methods are only associated <span class="reserved">with</span> the enclosing <span class="class"><span class="keyword">class</span>.</span>

<span class="regexp">//</span> 可以这样改写????
val <span class="attribute">use_func</span>: Resource<span class="function"> =&gt;</span> Boolean = (<span class="keyword">new</span> UseResource).use _
</pre></td></tr></table></figure>

<h3 id="-">头等函数的应用</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre>val r: Resource = getResource()
try {
  useResourceToDoUsefulStuff(r)
} finally {
  r.dispose()
}

def use[<span class="link_label">A, B &lt;: Resource </span>](<span class="link_url">r: Resource</span>)(f: Resource =&gt; A): A = {
  try {
<span class="code">    f(r)</span>
  } finally {
<span class="code">    r.dispose()</span>
  }
}

// 面向对象的过程式的写法
val x = Person(firstName, lastName)
x.setInfo(someInfo)
println("log: new person is created")
mailer.mail("new person joined " + x)
x.firstName

// 提供一种函数式的解决思路
def tap[<span class="link_label">A</span>](<span class="link_url">a: A</span>)(sideEffect: A =&gt; Unit): A = {
  sideEffect(a)
  a
}
val x = Person(firstName, lastName)
tap(x) { p =&gt;
  import p._
  setInfo(someInfo)
  println("log: new person is created")
  mailer.mail("new person joined " + x)
}.firstName

// 用上 implicity, 可以这样
object Combinators {
  implicit def kestrel[<span class="link_label">A</span>](<span class="link_url">a: A</span>) = new {
<span class="code">    def tap(sideEffect: A =&gt; Unit): A = {</span>
<span class="code">      sideEffect(a)</span>
<span class="code">      a</span>
<span class="code">    }</span>
  }
}

Person("Nilanjan", "Raychaudhuri").tap(p =&gt; {
  println("First name " + p.firstName)
  Mailer("some address")
}).lastName
</pre></td></tr></table></figure>

<h3 id="-">柯里化函数</h3>
<p>Function currying is a technique for transforming a function that takes
multiple parameters into a function that takes a single parameter.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">def</span> taxIt(s: TaxStrategy, product: String) = { s.taxIt(product) }

<span class="keyword">val</span> taxItF = taxIt _
<span class="comment">// 等同于</span>
taxItF.curried

<span class="comment">// 可以这样直接定义柯里化的函数</span>
<span class="keyword">def</span> taxIt(s: TaxStrategy)(product: String) = { s.taxIt(product) }
</pre></td></tr></table></figure>

<h3 id="-">偏函数</h3>
<p>A partial function is a function that’s only defined
for a subset of input values.</p>
<p>In Scala partial functions are defined by trait PartialFunction[-A, +B] and
extend scala.Function1 trait.</p>
<p>PartialFunction declares the
apply method and an additional method called def isDefinedAt(a: A):Boolean.
This isDefinedAt method determines whether the given partial function is defined
for a given parameter.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>
<span class="comment">// 定义一个偏函数</span>
def intToChar: PartialFunction[Int, Char] = {
  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">'a'</span>
  <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">'c'</span>
}

<span class="comment">// scala 会这样翻译</span>
<span class="keyword">new</span> PartialFunction[Int, Char] {
  def apply(i: Int) = i match {
    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">'a'</span>
    <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">'c'</span>
  }
  def isDefinedAt(i: Int): Boolean = i match {
    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="keyword">true</span>
    <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="keyword">true</span>
    <span class="keyword">case</span> _ =&gt; <span class="keyword">false</span>
  }
}
</pre></td></tr></table></figure>

<p>The PartialFunction trait provides two interesting combinatory methods called
orElse and andThen.</p>
<p>The orElse method lets you combine this partial function with
another partial function. It’s much like if-else.</p>
<p>The andThen lets you compose transformation functions with a partial function
that works on the result produced by the partial function. </p>
<h3 id="-">递归</h3>
<p>Recursion is where a function calls itself.
One of the main benefits of recursion is that it lets you create solutions without
mutation.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(xs: List[Int])</span>:</span> Int = xs match {
  case Nil =&gt; <span class="number">0</span>
  case x :: ys =&gt; x + sum(ys)
}
</pre></td></tr></table></figure>

<h4 id="-">尾递归</h4>
<p>Head recursion is the more traditional way of doing recursion,
where you perform the recursive call
first and then take the return value from the recursive function and
calculate the result.</p>
<p>In tail recursion you perform your calculation first and then execute the recursive
call by passing the result of the current step to the next step.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>// 如果调用过多的, 会造成 栈溢出
<span class="function"><span class="keyword">def</span> <span class="title">length</span>[<span class="title">A</span>]<span class="params">(xs: List[A])</span>:</span> Int = xs match {
  case Nil =&gt; <span class="number">0</span>
  case x :: ys =&gt; <span class="number">1</span> + length(ys)
}
// 尾递归
<span class="function"><span class="keyword">def</span> <span class="title">length2</span>[<span class="title">A</span>]<span class="params">(xs: List[A])</span>:</span> Int = {
  <span class="decorator">@tailrec</span>
  <span class="function"><span class="keyword">def</span> <span class="title">_length</span><span class="params">(xs: List[A], currentLength: Int)</span>:</span> Int = xs match {
    case Nil =&gt; currentLength
    case x :: ys =&gt; _length(ys, currentLength + <span class="number">1</span>)
  }
  _length(xs, <span class="number">0</span>)
}
</pre></td></tr></table></figure>

<h3 id="adt">ADT</h3>
<p>Algebraic data type (ADT) is a classification.
A data type in general is a set of values.</p>
<p>Once you’ve created ADTs, you use them in functions. ADT s become much easier
to deal with if they’re implemented as case classes because pattern matching works
out of the box. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// 用 case class 定义 </span>
<span class="class"><span class="keyword">object</span> <span class="title">ADT</span> {</span>
  <span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Account</span></span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">CheckingAccount</span><span class="params">(accountId: String)</span> <span class="keyword">extends</span> <span class="title">Account</span></span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">SavingAccount</span><span class="params">(accountId: String, limit: Double)</span></span>
      <span class="keyword">extends</span> Account
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PremiumAccount</span><span class="params">(corporateId: String, accountHolder: String)</span></span>
     <span class="keyword">extends</span> Account
}
</pre></td></tr></table></figure>

<h3 id="function-compose">function compose</h3>
<p>To compose the two functions together,
Scala provides a method called andThen, available to all function types
except those with zero arguments. This andThen method behaves similarly to Unix
pipes—it combines two functions in sequence and creates one function.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>def doubleAllEven = evenFilter andThen <span class="built_in">map</span>(<span class="keyword">double</span>)
</pre></td></tr></table></figure>

<p>The only difference between andThen and compose is that the
order of evaluation for compose is right to left.</p>
<ul>
<li>Write pure functions that do one thing and do it well.</li>
<li>Write functions that can compose with other functions.</li>
</ul>
<h3 id="monad">Monad</h3>
<ul>
<li>Monads let you compose functions that don’t compose well,
such as functions that have side effects.</li>
<li>Monads let you order computation within
functional programming so that you can model sequences of actions.</li>
</ul>
<p>This application needs to calculate a
price for a product by following a sequence of steps:</p>
<ol>
<li>Find the base price of the product.</li>
<li>Apply a state code-specific discount to the base price.</li>
<li>Apply a product-specific discount to the result of the previous step.</li>
<li>Apply tax to the result of the previous step to get the final price.</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">PriceCalculatorWithoutMonad</span> {</span>
  <span class="keyword">import</span> Stubs._
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PriceState</span><span class="params">(productId: String, stateCode: String,price: Double)</span></span>
  
  <span class="keyword">def</span> findBasePrice(productId: String, stateCode: String): PriceState = {
    <span class="keyword">val</span> basePrice = findTheBasePrice(productId: String)
    PriceState(productId, stateCode, basePrice)
  }

  <span class="keyword">def</span> applyStateSpecificDiscount(ps: PriceState): PriceState = {
    <span class="keyword">val</span> discount = findStateSpecificDiscount(ps.productId, ps.stateCode)
    ps.copy(price = ps.price - discount)
  }
  
  <span class="keyword">def</span> applyProductSpecificDiscount(ps: PriceState): PriceState = {
    <span class="keyword">val</span> discount = findProductSpecificDiscount(ps.productId)
    ps.copy(price = ps.price - discount)
  }

  <span class="keyword">def</span> applyTax(ps: PriceState): PriceState = {
    <span class="keyword">val</span> tax = calculateTax(ps.productId, ps.price)
    ps.copy(price = ps.price + tax)
  }
  <span class="keyword">def</span> calculatePrice(productId: String, stateCode: String): Double = {
    <span class="keyword">val</span> a = findBasePrice(productId, stateCode)
    <span class="keyword">val</span> b = applyStateSpecificDiscount(a)
    <span class="keyword">val</span> c = applyProductSpecificDiscount(b)
    <span class="keyword">val</span> d = applyTax(c)
    d.price
  }

}
<span class="class"><span class="keyword">object</span> <span class="title">Stubs</span> {</span>
  <span class="keyword">def</span> findTheBasePrice(productId: String) = <span class="number">10.0</span>
  <span class="keyword">def</span> findStateSpecificDiscount(productId: String, stateCode: String) = <span class="number">0.5</span>
  <span class="keyword">def</span> findProductSpecificDiscount(productId: String) = <span class="number">0.5</span>
  <span class="keyword">def</span> calculateTax(productId: String, price: Double) = <span class="number">5.0</span>
}
</pre></td></tr></table></figure>

<p>版本二, 使用 state monad</p>
<p>state monad 详解</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">State</span>[<span class="title">S</span>, +<span class="title">A</span>] {</span>
  <span class="keyword">def</span> apply(s: S): (S, A)
}
<span class="comment">// 状态子(stateMonad), 状态(state)</span>
<span class="comment">// 每一次变化, 都抽象成一个状态</span>
<span class="comment">// 一个状态子(StateMonad), 就是对一次状态变化的封装</span>
<span class="class"><span class="keyword">object</span> <span class="title">StateMonad</span> {</span>
  <span class="class"><span class="keyword">trait</span> <span class="title">State</span>[<span class="title">S</span>, +<span class="title">A</span>] {</span>
    <span class="comment">// 每一次对 状态 操作, 都会产生一个新的状态 S, 以及一个新的值 A</span>
    <span class="comment">// 如Stack,  [a, b, c, d], pop操作后, 新的状态 [b, c, d], 和新的值 a</span>
    <span class="comment">// 对 状态 s 的操作函数的串联</span>
    <span class="keyword">def</span> apply(s: S): (S, A)
    <span class="comment">// 每一次map, 都是对 新的值的操作</span>
    <span class="keyword">def</span> map[B](f: A =&gt; B): State[S, B] = state(apply(_) <span class="keyword">match</span> {
      <span class="keyword">case</span> (s, a) =&gt; (s, f(a))
    })
    <span class="comment">// 每一次 flatmap 是对 状态子 的操作</span>
    <span class="keyword">def</span> flatMap[B](f: A =&gt; State[S, B]): State[S, B] =
      state(apply(_) <span class="keyword">match</span> {
        <span class="keyword">case</span> (s, a) =&gt; f(a)(s)
      })
  }
  <span class="class"><span class="keyword">object</span> <span class="title">State</span> {</span>
    <span class="keyword">def</span> state[S, A](f: S =&gt; (S, A)) = <span class="keyword">new</span> State[S, A] {
      <span class="keyword">def</span> apply(s: S) = f(s)
    }
    <span class="keyword">def</span> init[S]: State[S, S] = state[S, S](s =&gt; (s, s))
    <span class="comment">// 产生一个对 状态操作的 状态子</span>
    <span class="keyword">def</span> modify[S](f: S =&gt; S) =
      init[S] flatMap (s =&gt; state(_ =&gt; (f(s), ())))
  }

}
</pre></td></tr></table></figure>

<p>map and flatMap are critical parts of the
monad interface—without them, no function can become a monad in Scala.</p>
<p>The map method of the State monad helps transform the value inside the State
monad. On the other hand, flatMap helps transition from one state to another. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>
<span class="keyword">def</span> findBasePrice(ps: PriceState): Double
<span class="keyword">def</span> applyStateSpecificDiscount(ps: PriceState): Double
<span class="keyword">def</span> applyProductSpecificDiscount(ps: PriceState): Double
<span class="keyword">def</span> applyTax(ps: PriceState): Double

<span class="keyword">import</span> StateMonad.State._
<span class="keyword">def</span> modifyPriceState(f: PriceState =&gt; Double) =
  modify[PriceState](s =&gt; s.copy(price = f(s)))
<span class="comment">// 整个函数, 都是对 state 进行操作的不完全实现(柯里化函数) 的串联</span>
<span class="keyword">val</span> stateMonad = <span class="keyword">for</span> {
  _ &lt;- modifyPriceState(findBasePrice)
  _ &lt;- modifyPriceState(applyStateSpecificDiscount)
  _ &lt;- modifyPriceState(applyProductSpecificDiscount)
  _ &lt;- modifyPriceState(applyTax)
} <span class="keyword">yield</span> ()

<span class="comment">// 最后可以这样拿来用</span>
<span class="keyword">val</span> initialPriceState = PriceState(productId, stateCode, <span class="number">0.0</span>)
<span class="keyword">val</span> finalPriceState = stateMonad.apply(initialPriceState)._1
<span class="keyword">val</span> finalPrice = finalPriceState.price
</pre></td></tr></table></figure>

<p>翻译后是这样的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>
def calculatePrice2(productId: String, stateCode: String): Double = {
  <span class="comment">// modify 封装对当前状态操作的一个函数, 返回一个状态子</span>
  def modifyPriceState(f: PriceState =&gt; Double) =
    modify[PriceState](s =&gt; s.copy(price = f(s)))
  <span class="comment">// 很像 functor 的 monad 实现</span>
  <span class="comment">// 这里可以看出 flatmap 的意义</span>
  val stateMonad = modifyPriceState(findBasePrice) flatMap {a =&gt;
    modifyPriceState(applyStateSpecificDiscount) flatMap {b =&gt;
      modifyPriceState (applyProductSpecificDiscount) flatMap {c =&gt;
        modifyPriceState (applyTax) map {d =&gt;() }
      }
    }
  }
  val initialPriceState = PriceState(productId, stateCode, <span class="number">0.0</span>)
  val finalPriceState = stateMonad.apply(initialPriceState)._1
  val finalPrice = finalPriceState.price
  finalPrice
}
</pre></td></tr></table></figure>

<p>加入 log 信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>
def calculatePriceWithLog(productId: String, stateCode: String): Double = {
  def modifyPriceState f: PriceState =&gt; Double) =
    modify[PriceState](s =&gt; s.copy(price = f(s)))
  def logStep(f: PriceState =&gt; String) = gets(f)

  <span class="comment">// 每一步都有对 都是对 state 的一个操作的函数</span>
  val stateMonad = <span class="keyword">for</span> {
    _ &lt;- modifyPriceState(findBasePrice)
    a &lt;- logStep(s =&gt; <span class="string">"Base Price "</span> + s)
    _ &lt;- modifyPriceState(applyStateSpecificDiscount)
    b &lt;- logStep(s =&gt; <span class="string">"After state discount "</span> + s)
    _ &lt;- modifyPriceState(applyProductSpecificDiscount)
    c &lt;- logStep(s =&gt; <span class="string">"After product discount "</span> + s)
    _ &lt;- modifyPriceState(applyTax)
    d &lt;- logStep(s =&gt; <span class="string">"After tax "</span> + s)
  } <span class="keyword">yield</span> a :: b :: c :: d :: Nil
  val (finalPriceState, log) =
    stateMonad.apply(PriceState(productId, stateCode, <span class="number">0.0</span>))
  finalPriceState.price

}
<span class="comment">// gets 的定义</span>
def gets[S,A](f: S =&gt; A): State[S, A] =
  init[S] flatMap (s =&gt; state(_ =&gt; (s, f(s))))
</pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/scala/">scala</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://zhpooer.github.io/2014/07/15/scala-in-action-functional-programming-in-scala/" data-title="Scala in Action-Functional Programming in Scala | Poe&#39;s World" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/07/16/传智播客day58-mybatis提高/" title="传智播客day58-Mybatis提高">
  <strong>PREVIOUS:</strong><br/>
  <span>
  传智播客day58-Mybatis提高</span>
</a>
</div>


<div class="next">
<a href="/2014/07/15/传智播客day57-mybatis/"  title="传智播客day57-Mybatis">
 <strong>NEXT:</strong><br/> 
 <span>传智播客day57-Mybatis
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#-"><span class="toc-number">1.</span> <span class="toc-text">类型参数化</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.1.</span> <span class="toc-text">协变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.2.</span> <span class="toc-text">逆变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.3.</span> <span class="toc-text">不变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">1.4.</span> <span class="toc-text">类型的边界</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#-"><span class="toc-number">2.</span> <span class="toc-text">头等函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scala-collection-hierarchy"><span class="toc-number">3.</span> <span class="toc-text">Scala collection hierarchy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lazy-collections"><span class="toc-number">4.</span> <span class="toc-text">lazy collections</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream"><span class="toc-number">4.1.</span> <span class="toc-text">Stream</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#parallel-collections"><span class="toc-number">5.</span> <span class="toc-text">parallel collections</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-"><span class="toc-number">6.</span> <span class="toc-text">函数式编程</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pure-functional-program"><span class="toc-number">6.1.</span> <span class="toc-text">pure functional program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo-http-server"><span class="toc-number">6.2.</span> <span class="toc-text">DEMO: HTTP server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-"><span class="toc-number">6.3.</span> <span class="toc-text">方法和函数</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.1.</span> <span class="toc-text">头等函数的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.2.</span> <span class="toc-text">柯里化函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.3.</span> <span class="toc-text">偏函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-"><span class="toc-number">6.3.4.</span> <span class="toc-text">递归</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#-"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">尾递归</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#adt"><span class="toc-number">6.3.5.</span> <span class="toc-text">ADT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function-compose"><span class="toc-number">6.3.6.</span> <span class="toc-text">function compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#monad"><span class="toc-number">6.3.7.</span> <span class="toc-text">Monad</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AJAX/" title="AJAX">AJAX<sup>1</sup></a></li>
		
			<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
		
			<li><a href="/tags/EL表达式/" title="EL表达式">EL表达式<sup>1</sup></a></li>
		
			<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>2</sup></a></li>
		
			<li><a href="/tags/HttpSession/" title="HttpSession">HttpSession<sup>1</sup></a></li>
		
			<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
		
			<li><a href="/tags/JSP/" title="JSP">JSP<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaBean/" title="JavaBean">JavaBean<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/tags/Mybatis/" title="Mybatis">Mybatis<sup>1</sup></a></li>
		
			<li><a href="/tags/SAX/" title="SAX">SAX<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletRequest/" title="ServletRequest">ServletRequest<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletResponse/" title="ServletResponse">ServletResponse<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring MVC/" title="Spring MVC">Spring MVC<sup>1</sup></a></li>
		
			<li><a href="/tags/String/" title="String">String<sup>1</sup></a></li>
		
			<li><a href="/tags/StringBuffer/" title="StringBuffer">StringBuffer<sup>1</sup></a></li>
		
			<li><a href="/tags/activiti/" title="activiti">activiti<sup>2</sup></a></li>
		
			<li><a href="/tags/cookie/" title="cookie">cookie<sup>1</sup></a></li>
		
			<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://zhpooer.github.io" target="_blank" title="zhpooer">zhpooer</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhpoooer"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
