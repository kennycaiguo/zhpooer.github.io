
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Scala in Action-Concurrency programming | Poe&#39;s World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhpooer">
    
    <meta name="description" content="Think of an actor as an object that processes a message (your request) and
encapsulates state (state is not shared with other actors).
The ability to ">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Poe&#39;s World" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Poe&#39;s World" title="Poe&#39;s World"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Poe&#39;s World">Poe&#39;s World</a></h1>
				<h2 class="blog-motto">竹杖芒鞋轻胜马，一蓑烟雨任平生</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/english-monthly">英语角</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zhpooer.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/07/23/scala-in-action-concurrency-programming/" title="Scala in Action-Concurrency programming" itemprop="url">Scala in Action-Concurrency programming</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://zhpooer.github.io" title="zhpooer">zhpooer</a>
    </p>
  <p class="article-time">
    <time datetime="2014-07-23T12:17:00.000Z" itemprop="datePublished">7月 23 2014</time>
    更新日期:<time datetime="2014-07-24T00:23:07.000Z" itemprop="dateModified">7月 24 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#what-is-concurrent-programming-"><span class="toc-number">1.</span> <span class="toc-text">What is concurrent programming?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new-trends-in-concurrency"><span class="toc-number">2.</span> <span class="toc-text">New trends in concurrency</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#implementing-message-passing-concurrency-with-actors"><span class="toc-number">3.</span> <span class="toc-text">Implementing message-passing concurrency with actors</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#actorsystem"><span class="toc-number">3.1.</span> <span class="toc-text">ActorSystem</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#how-do-scala-actors-work-"><span class="toc-number">3.1.1.</span> <span class="toc-text">How do Scala actors work?</span></a></li></ol></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#divide-and-conquer-using-actors"><span class="toc-number">4.</span> <span class="toc-text">Divide and conquer using actors</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#actordsl"><span class="toc-number">4.1.</span> <span class="toc-text">ActorDSL</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#fault-tolerance-made-easy-with-a-supervisor"><span class="toc-number">5.</span> <span class="toc-text">Fault tolerance made easy with a supervisor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#future-and-promise"><span class="toc-number">6.</span> <span class="toc-text">Future and Promise</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mixing-future-with-actors"><span class="toc-number">6.1.</span> <span class="toc-text">Mixing Future with actors</span></a></li></ol>
		</div>
		
		<p>Think of an actor as an object that processes a message (your request) and
encapsulates state (state is not shared with other actors).
The ability to perform an action in response to an incoming message
is what makes an object an actor. The actor model encourages no shared state architecture. </p>
<p>Think of Future as a proxy object that you can create for a result that will be avail-
able at some later time. You can use Promise to complete a Future by providing the
result. </p>
<h1 id="what-is-concurrent-programming-">What is concurrent programming?</h1>
<p>Concurrency is when more than one task can start and complete in overlapping time
periods.</p>
<p>In parallel programming, you can literally run multiple tasks
at the same time, and it’s possible with multicore processors.
A concurrent program sometimes becomes a parallel program when it’s running in a multicore environment.</p>
<p>But it’s hard to write a correct and bug-free concurrent program.</p>
<ul>
<li>Only a handful of programmers know how to write a correct,
concurrent application or program. The correctness of the program is important.</li>
<li>Debugging multithreaded programs is difficult. The same program that causes
deadlock in production might not have any locking issues when debugging
locally. Sometimes threading issues show up after years of running in production.</li>
<li>Threading encourages shared state concurrency, and it’s hard to make
programs run in parallel because of locks, semaphores, and dependencies between
threads.</li>
</ul>
<h1 id="new-trends-in-concurrency">New trends in concurrency</h1>
<ul>
<li>STM, Software transactional memory</li>
<li>Dataflow concurrency, The principle behind the dataflow concurrency is to share variables across multiple
tasks or threads.</li>
<li>Message passing concurrency, In this concurrency
model, components communicate by sending messages. Messages can be sent
both synchronously and asynchronously, but asynchronously sending messages to
other components is more common. </li>
</ul>
<h1 id="implementing-message-passing-concurrency-with-actors">Implementing message-passing concurrency with actors</h1>
<p>In this concurrency model, actors communicate with each other through sending and
receiving messages. An actor processes incoming messages and executes the actions
associated with it. Typically, these messages are immutable because you shouldn’t
share state between them for reasons discussed previously.</p>
<p>There are two main communication abstractions in actor: send and receive.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// sending msg to actor a
a ! msg

// receive operation
receive {
  case pattern1 =&gt;
  <span class="keyword">...</span>
  case pattern =&gt;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.actor.Actor
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Name</span><span class="params">(name: String)</span></span>
<span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> Name(n) =&gt; println(<span class="string">"Hello "</span> + n)
  }
}
</pre></td></tr></table></figure>

<p>Before sending any messages to the GreetingsActor actor, the actor needs to be
instantiated by creating an ActorSystem. Think of an ActorSystem as the manager of
one or more actors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// libraryDependencies += <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-actor"</span> % <span class="string">"2.1.0"</span>
import akka<span class="preprocessor">.actor</span><span class="preprocessor">.Props</span>
import akka<span class="preprocessor">.actor</span><span class="preprocessor">.ActorSystem</span>

val system = ActorSystem(<span class="string">"greetings"</span>)

val a = system<span class="preprocessor">.actorOf</span>(Props[GreetingsActor], name = <span class="string">"greetings-actor"</span>)
a ! Name(<span class="string">"Nilanjan"</span>)
// shuts down the infrastructure <span class="keyword">and</span> all its actors.
Thread<span class="preprocessor">.sleep</span>(<span class="number">50</span>)
system<span class="preprocessor">.shutdown</span>()
</pre></td></tr></table></figure>

<h2 id="actorsystem">ActorSystem</h2>
<p>An actor system is a hierarchical group of actors that share a common configuration.
It’s also the entry point for creating and looking up actors.</p>
<p>Similarly actors form a hierarchy where parent actors
spawn child actors to delegate work until
it is small enough to be handled by an individual actor.</p>
<p>An ActorSystem is a heavyweight structure that will allocate 1. . .N
threads, so create one per logical subsystem of your application. For example,
you can have one actor system to handle the backend database, another to
handle all the web service calls, and so forth. Actors are very cheap. A given
actor consumes only 300 bytes so you can easily create millions of them.</p>
<p>At the top of the hierarchy is the guardian actor, created automatically with each actor
system. All other actors created by the given actor system become the child of the
guardian actor. In the actor system, each actor has one supervisor (the parent actor)
that automatically takes care of the fault handling. So if an actor crashes, its parent
will automatically restart that actor (more about this later).</p>
<p>The simplest way to create an actor is to create an ActorSystem and use its actorOf
method:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">val</span> system = ActorSystem(name = <span class="string">"word-count"</span>)
<span class="keyword">val</span> m: ActorRef = system.actorOf(Props[SomeActor],
      name = <span class="string">"someActor"</span>)
</pre></td></tr></table></figure>

<p>Note here that when you create an actor in Akka, you never get the direct refer-
ence to the actor. Instead you get back a handle to the actor called ActorRef.
The foremost purpose of ActorRef is to send messages to the actor it rep-
resents.</p>
<p>An actor path uniquely identifies an actor in the actor system.
Because actors are created in a hierarchical structure, they form a similar
structure to a filesystem. 
As a path in a filesystem points to an individual resource,
an actor path identifies an actor reference in an actor system.</p>
<p>Uses the system / method to retrieve the actor
reference of the WordCountWorker actor:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>class WordCountWorker extends Actor { <span class="keyword">...</span> }
<span class="keyword">...</span>
val system = ActorSystem(name = <span class="string">"word-count"</span>)
system.actorOf(Props[WordCountWorker], name = <span class="string">"wordCountWorker"</span>)
<span class="keyword">...</span>
val path: ActorPath = system / <span class="string">"WordCountWorker"</span>
val actorRef: ActorRef = system.actorFor(path)
actorRef ! “some message”
</pre></td></tr></table></figure>

<p>If the actorFor fails to find an actor
pointed to by the path, it returns a reference to the dead-letter mailbox of the actor
system. It’s a synthetic actor where all the undelivered messages are delivered.</p>
<p>The parent actor first stops all the child actors and sends all unprocessed messages to the dead-letter mailbox before ter-
minating itself. </p>
<h3 id="how-do-scala-actors-work-">How do Scala actors work?</h3>
<p>Every actor system comes with a default MessageDispatcher component.
Its responsibility is to send a message to the actor’s mailbox
and execute the actor by invoking the receive block.</p>
<p>Every MessageDispatcher is backed by a thread pool, which is easily
configured using the configuration file.</p>
<p>To send a message to an actor mail-box the ActorRef</p>
<ul>
<li>first sends the message to the MessageDispatcher associated with the actor.</li>
<li>The MessageDispatcher immediately queues the message in the mailbox of the
actor.</li>
<li>The control is immediately returned to the sender of the message. </li>
</ul>
<p>Handling a message is a bit more involved</p>
<ol>
<li>When an actor receives a message in its mailbox, MessageDispatcher schedules
the actor for execution. Sending and handling messages happens in two differ-
ent threads. If a free thread is available in the thread pool that thread is
selected for execution of the actor. If all the threads are busy, the actor will be
executed when threads becomes available.</li>
<li>The available thread reads the messages from the mailbox.</li>
<li>The receive method of the actor is invoked by passing one message at a time.</li>
</ol>
<h1 id="divide-and-conquer-using-actors">Divide and conquer using actors</h1>
<p>In the following example, the challenge is to count the number of words in each file
in a given directory and sort them in ascending order. One way of doing it would be to
loop through all the files in a given directory in a single thread, count the words in
each file, and sort them all together. But that’s sequential. To make it concurrent, we
will implement the divide-and-conquer (also called a fork-join) pattern with actors.</p>
<p>Actor API</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>// <span class="keyword">If</span> a given message doesn’t match any pattern inside the receive method <span class="keyword">then</span> the
// unhandled method <span class="keyword">is</span> called <span class="keyword">with</span> the akka.actor.UnhandledMessage message. 
def unhandled(message: Any): Unit

// This field holds the actor reference <span class="keyword">of</span> this actor. 
val self: ActorRef

// This <span class="keyword">is</span> the ActorRef <span class="keyword">of</span> the actor that sent the last received message. 
final def sender: ActorRef

// This provides the contextual information <span class="keyword">for</span> the actor, the current message, <span class="keyword">and</span> the
// factory methods <span class="keyword">to</span> create child actors. 
val <span class="keyword">context</span>: ActorContext

// This supervisor strategy defines what will happen <span class="keyword">when</span> a failure <span class="keyword">is</span> detected <span class="keyword">in</span> an
// actor. You can override <span class="keyword">to</span> define your own supervisor strategy.
def supervisorStrategy: SupervisorStrategy

def preStart()

// his method <span class="keyword">is</span> called <span class="keyword">on</span> the current instance <span class="keyword">of</span> the actor. This <span class="keyword">is</span> a great place <span class="keyword">to</span>
// clean up. The <span class="keyword">default</span> implementation <span class="keyword">is</span> <span class="keyword">to</span> stop <span class="keyword">all</span> the child actors <span class="keyword">and</span> <span class="keyword">then</span> invoke
// the postStop method.
def preRestart()

// This method <span class="keyword">is</span> called <span class="keyword">after</span> the current actor instance <span class="keyword">is</span> stopped.
def postStop()

// <span class="keyword">Then</span> the postRestart <span class="keyword">is</span> invoked <span class="keyword">on</span> the fresh instance.
// The <span class="keyword">default</span> implementation <span class="keyword">is</span> <span class="keyword">to</span> invoke the preStart method
def postRestart()
</pre></td></tr></table></figure>

<p>you’ll create two actor classes: one that
will scan the directory for all the files and accumulate results, called WordCountMaster,
and another one called WordCountWorker to count words in each file. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="comment">// The docRoot will specify the location of the files and</span>
<span class="comment">// numActors will create the number of worker actors. </span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StartCounting</span><span class="params">(docRoot: String, numActors: Int)</span></span>

<span class="comment">// Message Class</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">FileToCount</span><span class="params">(fileName:String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">WordCount</span><span class="params">(fileName:String, count: Int)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> countWords(fileName:String) = {
    <span class="keyword">val</span> dataFile = <span class="keyword">new</span> File(fileName)
    Source.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">" "</span>).size + _)
  }
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> FileToCount(fileName:String) =&gt;
      <span class="keyword">val</span> count = countWords(fileName)
      sender ! WordCount(fileName, count)
  }
  <span class="keyword">override</span> <span class="keyword">def</span> postStop(): Unit = {
    println(s<span class="string">"Worker actor is stopped: ${self}"</span>)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">WordCountMaster</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">var</span> fileNames: Seq[String] = Nil
  <span class="keyword">var</span> sortedCount : Seq[(String, Int)] = Nil
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> StartCounting(docRoot, numActors) =&gt;
      <span class="keyword">val</span> workers = createWorkers(numActors)
      fileNames = scanFiles(docRoot)
      beginSorting(fileNames, workers)
      
    <span class="keyword">case</span> WordCount(fileName, count) =&gt;
      sortedCount = sortedCount :+ (fileName, count)
      sortedCount = sortedCount.sortWith(_._2 &lt; _._2)
      <span class="keyword">if</span>(sortedCount.size == fileNames.size) {
        println(<span class="string">"final result "</span> + sortedCount)
        finishSorting()
      }
  }
  <span class="keyword">private</span> <span class="keyword">def</span> createWorkers(numActors: Int) = {
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numActors) <span class="keyword">yield</span>
    context.actorOf(Props[WordCountWorker], name = s<span class="string">"worker-${i}"</span>)
  }
  <span class="keyword">private</span> <span class="keyword">def</span> scanFiles(docRoot: String) =
    <span class="keyword">new</span> File(docRoot).list.map(docRoot + _)
    
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">def</span> beginSorting(fileNames: Seq[String], workers: Seq[ActorRef]) {
    fileNames.zipWithIndex.foreach( e =&gt; {
      workers(e._2 % workers.size) ! FileToCount(e._1)
    })
  }
  
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">def</span> finishSorting() {
    context.system.shutdown()
  }
}

<span class="keyword">def</span> main(args: Array[String]) {
  <span class="keyword">val</span> system = ActorSystem(<span class="string">"word-count-system"</span>)
  <span class="keyword">val</span> m = system.actorOf(Props[WordCountMaster], name=<span class="string">"master"</span>)
  m ! StartCounting(<span class="string">"src/main/resources/"</span>, <span class="number">2</span>)
}
</pre></td></tr></table></figure>

<h2 id="actordsl">ActorDSL</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.actor.ActorDSL._

<span class="keyword">val</span> testActor = actor(<span class="keyword">new</span> Act {
  become {
    <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; sender ! <span class="string">"pong"</span>
  }
})

<span class="comment">// Behind the scene Act extends the Actor trait and become adds the behavior of the receive block.</span>
<span class="comment">// Using this DSL syntax you no longer have to create a class.</span>

<span class="class"><span class="keyword">object</span> <span class="title">ActorDSLExample</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">import</span> akka.actor.ActorDSL._
  <span class="keyword">import</span> akka.actor.ActorSystem
  implicit <span class="keyword">val</span> system = ActorSystem(<span class="string">"actor-dsl"</span>)
  <span class="keyword">val</span> testActor = actor(<span class="keyword">new</span> Act {
    become {
      <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; sender ! <span class="string">"pong"</span>
    }
  })
  actor(<span class="keyword">new</span> Act {
    whenStarting { testActor ! <span class="string">"ping"</span>}
    become {
      <span class="keyword">case</span> x =&gt;
        println(x)
        context.system.shutdown()
    }
  })
}
</pre></td></tr></table></figure>

<h1 id="fault-tolerance-made-easy-with-a-supervisor">Fault tolerance made easy with a supervisor</h1>
<p>Think of this supervisor as an actor that links to supervised actors and restarts
them when one dies.</p>
<p>That way, if a node (machine) is down,
you can restart an actor in a different box. Always
remember to delegate the work so that if a crash occurs,
another supervisor can recover.</p>
<p>Akka comes with two restarting strategies: One-for-One and All-for-One.</p>
<p>In the One-for-One strategy, if one actor dies, it’s recreated.</p>
<p>If you have multiple actors that participate in one workflow, restarting a single actor
might not work. In that case, use the All-for-One restart strategy,
in which all actors supervised by a supervisor are restarted
when one of the actors dies.</p>
<p>When no supervisor strategy is defined, it uses the default strategy (OneForOne ),
which restarts the failing child actor in case of Exception.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.actor.SupervisorStrategy._
<span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="comment">//if no pattern matches, the fault is escalated to the parent. </span>
  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = OneForOneStrategy(maxNrOfRetries = <span class="number">3</span>,
        withinTimeRange = <span class="number">5</span> seconds) {
    <span class="keyword">case</span> _: Exception =&gt; Restart
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">WordCountMaster</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = AllForOneStrategy() {
    <span class="keyword">case</span> _: Exception =&gt;
      println(<span class="string">"Restarting..."</span>)
      Restart
  }
}
</pre></td></tr></table></figure>

<h1 id="future-and-promise">Future and Promise</h1>
<p>A Future is an object that can hold a value that may become available, as its name sug-
gests, at a later time.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> ExecutionContext.Implicits.<span class="keyword">global</span>

<span class="function"><span class="keyword">def</span> <span class="title">someFuture</span>[<span class="title">T</span>]:</span> Future[T] = Future {
  someComputation()
}
</pre></td></tr></table></figure>

<p>Since the Future is executed asynchronously we need to specify the
scala.concurrent.ExecutionContext. ExecutionContext is an abstraction over a
thread pool that is responsible for executing all the tasks submitted to it.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>someFuture.onComplete {
  <span class="reserved">case</span> Success<span class="function"><span class="params">(result)</span> =&gt;</span> println(result)
  <span class="reserved">case</span> Failure<span class="function"><span class="params">(t)</span> =&gt;</span> t.printStackTrace
}

val <span class="attribute">promise</span>: Promise[String] = Promise[String]()
val future = promise.future
...
val anotherFuture = Future {
  promise.success(<span class="string">"Done"</span>)
  doSomethingElse()
}

future.onSuccess { <span class="reserved">case</span> msg<span class="function"> =&gt;</span> startTheNextStep() }
</pre></td></tr></table></figure>

<p>A common use case of Future is to perform some computation concurrently without
needing the extra utility of an actor. The most compelling feature of the Scala Future
library is it allows us to compose concurrent operations, which is hard to achieve with
actors.</p>
<p>word count use future</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre>import scala.concurrent.<span class="number">_</span>
import ExecutionContext.Implicits.global
import scala.util.{Success, Failure}
import java.io.File
import scala.io.Source

object main {
  def main(args: Array[String]) {
    val promiseOfFinalResult = Promise[Se<span class="string">q[(String, Int)]</span>]()
    val path = <span class="string">"src/main/resources/"</span>
    val futureWithResult: Future[Se<span class="string">q[(String, Int)]</span>] = <span class="keyword">for</span> {
      files &lt;- scanFiles(path)
      result &lt;- processFiles(files)
    } yield {
      result
    }
    
    futureWithResult.onSuccess {
      case <span class="string">r =&gt;</span> promiseOfFinalResult.success(r)
    }
    promiseOfFinalResult.future.onComplete {
      case Success(result) =&gt; println(result)
      case Failure(t) =&gt; t.printStackTrace
    }
  }
  
  private def processFiles(fileNames: Se<span class="string">q[String]</span>): Future[Se<span class="string">q[(String,Int)]</span>] = {
    val futures: Se<span class="string">q[Future[(String, Int)]</span>] = fileNames.<span class="keyword">map</span>(<span class="string">name =&gt;</span>
        processFile(name))
    val singleFuture: Future[Se<span class="string">q[(String, Int)]</span>] =
    Future.sequence(futures)
    singleFuture.<span class="keyword">map</span>(<span class="string">r =&gt;</span> r.sortWith(<span class="number">_</span>._2 &lt; <span class="number">_</span>._2))
  }
  private def processFile(fileName: String): Future[(String, Int)] =
  Future {
    val dataFile = new File(fileName)
    val wordCount = Source.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(<span class="number">_</span>.<span class="keyword">split</span>(<span class="string">"
    "</span>).size + <span class="number">_</span>)
    (fileName, wordCount)
  } recover {
    case e: java.io.<span class="string">IOException =&gt;</span>
    println(<span class="string">"Something went wrong "</span> + e)
    (fileName, <span class="number">0</span>)
  }
  
  private def scanFiles(docRoot: String):Future[Se<span class="string">q[String]</span>] = Future { new
    File(docRoot).list.<span class="keyword">map</span>(docRoot + <span class="number">_</span>) }
}
</pre></td></tr></table></figure>

<h2 id="mixing-future-with-actors">Mixing Future with actors</h2>
<ul>
<li>Send a message to an actor and receive a response from it. So far we have only
used fire-and-forget using the ! method. But getting a response is also a very
common use case (a.k.a ask pattern).</li>
<li>Reply to sender when some concurrent task ( Future) completes (a.k.a pipe
pattern).</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.pattern.{ask, pipe}
implicit <span class="keyword">val</span> timeout = Timeout(<span class="number">5</span> seconds)
<span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> messageActor = context.actorOf(Props[GreetingsChildActor])
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> name =&gt;
      <span class="keyword">val</span> f: Future[String] = (messageActor ask name).mapTo[String]
      f pipeTo sender
  }
}
<span class="class"><span class="keyword">class</span> <span class="title">GreetingsChildActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = { ...
  }
}
</pre></td></tr></table></figure>

<p>In this case we are using the ask method (you can use ? as well) of
the ActorRef to send and receive a response. Since messages are processed
asynchronously the ask method returns a Future.
The mapTo message allows us to transform
the message from Future[Any] to Future[String]. </p>
<p>The challenge is we don’t know
when the message will be ready so that we can send the reply to the sender. The
pipeTo pattern solves that problem by hooking up with the Future so that when the
future completes it can take the response inside the future and send it to the sender.</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/scala/">scala</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://zhpooer.github.io/2014/07/23/scala-in-action-concurrency-programming/" data-title="Scala in Action-Concurrency programming | Poe&#39;s World" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/07/24/scala-in-action-scalatest/" title="Scala in Action-ScalaTest">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Scala in Action-ScalaTest</span>
</a>
</div>


<div class="next">
<a href="/2014/07/22/传智播客day62-医药集中采购平台-系统管理/"  title="传智播客day62-医药集中采购平台 用户管理">
 <strong>NEXT:</strong><br/> 
 <span>传智播客day62-医药集中采购平台 用户管理
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#what-is-concurrent-programming-"><span class="toc-number">1.</span> <span class="toc-text">What is concurrent programming?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#new-trends-in-concurrency"><span class="toc-number">2.</span> <span class="toc-text">New trends in concurrency</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#implementing-message-passing-concurrency-with-actors"><span class="toc-number">3.</span> <span class="toc-text">Implementing message-passing concurrency with actors</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#actorsystem"><span class="toc-number">3.1.</span> <span class="toc-text">ActorSystem</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#how-do-scala-actors-work-"><span class="toc-number">3.1.1.</span> <span class="toc-text">How do Scala actors work?</span></a></li></ol></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#divide-and-conquer-using-actors"><span class="toc-number">4.</span> <span class="toc-text">Divide and conquer using actors</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#actordsl"><span class="toc-number">4.1.</span> <span class="toc-text">ActorDSL</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#fault-tolerance-made-easy-with-a-supervisor"><span class="toc-number">5.</span> <span class="toc-text">Fault tolerance made easy with a supervisor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#future-and-promise"><span class="toc-number">6.</span> <span class="toc-text">Future and Promise</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mixing-future-with-actors"><span class="toc-number">6.1.</span> <span class="toc-text">Mixing Future with actors</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AJAX/" title="AJAX">AJAX<sup>1</sup></a></li>
		
			<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
		
			<li><a href="/tags/EL表达式/" title="EL表达式">EL表达式<sup>1</sup></a></li>
		
			<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>2</sup></a></li>
		
			<li><a href="/tags/HttpSession/" title="HttpSession">HttpSession<sup>1</sup></a></li>
		
			<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
		
			<li><a href="/tags/JSP/" title="JSP">JSP<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaBean/" title="JavaBean">JavaBean<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/tags/Mybatis/" title="Mybatis">Mybatis<sup>1</sup></a></li>
		
			<li><a href="/tags/SAX/" title="SAX">SAX<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletRequest/" title="ServletRequest">ServletRequest<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletResponse/" title="ServletResponse">ServletResponse<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring MVC/" title="Spring MVC">Spring MVC<sup>1</sup></a></li>
		
			<li><a href="/tags/String/" title="String">String<sup>1</sup></a></li>
		
			<li><a href="/tags/StringBuffer/" title="StringBuffer">StringBuffer<sup>1</sup></a></li>
		
			<li><a href="/tags/activiti/" title="activiti">activiti<sup>2</sup></a></li>
		
			<li><a href="/tags/cookie/" title="cookie">cookie<sup>1</sup></a></li>
		
			<li><a href="/tags/css/" title="css">css<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://zhpooer.github.io" target="_blank" title="zhpooer">zhpooer</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhpoooer"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
