
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>learning scalaz 进阶2 | Poe&#39;s World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhpooer">
    
    <meta name="description" content="Applicative Builder
1
2
3
4
5
scala&gt; (3.some |@| 5.some) {_ + _}
res18: Option[Int] = Some(8)

scala&gt; val f = ({(_: Int) * 2} |@| {(_: Int) + 10">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Poe&#39;s World" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Poe&#39;s World" title="Poe&#39;s World"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Poe&#39;s World">Poe&#39;s World</a></h1>
				<h2 class="blog-motto">竹杖芒鞋轻胜马，一蓑烟雨任平生</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/english-monthly">英语角</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zhpooer.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/07/30/learning-scalaz-进阶2/" title="learning scalaz 进阶2" itemprop="url">learning scalaz 进阶2</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://zhpooer.github.io" title="zhpooer">zhpooer</a>
    </p>
  <p class="article-time">
    <time datetime="2014-07-29T23:48:27.000Z" itemprop="datePublished">7月 30 2014</time>
    更新日期:<time datetime="2014-07-30T06:43:05.000Z" itemprop="dateModified">7月 30 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#applicative-builder"><span class="toc-number">1.</span> <span class="toc-text">Applicative Builder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state-and-statet"><span class="toc-number">2.</span> <span class="toc-text">State and StateT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#either"><span class="toc-number">3.</span> <span class="toc-text">Either</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#validation"><span class="toc-number">4.</span> <span class="toc-text">Validation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nonemptylist-nel-"><span class="toc-number">5.</span> <span class="toc-text">NonEmptyList(Nel)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#some-useful-monadic-functions"><span class="toc-number">6.</span> <span class="toc-text">Some useful monadic functions</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#join"><span class="toc-number">6.1.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filterm"><span class="toc-number">6.2.</span> <span class="toc-text">filterM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foldleftm"><span class="toc-number">6.3.</span> <span class="toc-text">foldLeftM</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#making-a-safe-rpn-calculator"><span class="toc-number">7.</span> <span class="toc-text">Making a safe RPN calculator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#composing-monadic-functions"><span class="toc-number">8.</span> <span class="toc-text">Composing monadic functions</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kleisli"><span class="toc-number">8.1.</span> <span class="toc-text">Kleisli</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reader"><span class="toc-number">8.2.</span> <span class="toc-text">Reader</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#making-monads"><span class="toc-number">9.</span> <span class="toc-text">Making monads</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tree"><span class="toc-number">10.</span> <span class="toc-text">Tree</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#treeloc"><span class="toc-number">10.1.</span> <span class="toc-text">TreeLoc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zipper"><span class="toc-number">10.2.</span> <span class="toc-text">Zipper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#id"><span class="toc-number">10.3.</span> <span class="toc-text">Id</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#lawless-typeclasses"><span class="toc-number">11.</span> <span class="toc-text">Lawless typeclasses</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#length"><span class="toc-number">11.1.</span> <span class="toc-text">Length</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#index"><span class="toc-number">11.2.</span> <span class="toc-text">Index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#each"><span class="toc-number">11.3.</span> <span class="toc-text">Each</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#monad-transformers"><span class="toc-number">12.</span> <span class="toc-text">Monad transformers</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reader-yet-again"><span class="toc-number">12.1.</span> <span class="toc-text">Reader, yet again</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#readert"><span class="toc-number">12.2.</span> <span class="toc-text">ReaderT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stacking-multiple-monad-transformers"><span class="toc-number">12.3.</span> <span class="toc-text">Stacking multiple monad transformers</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#lens"><span class="toc-number">13.</span> <span class="toc-text">Lens</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#using-lens"><span class="toc-number">13.1.</span> <span class="toc-text">Using Lens</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lens-as-a-state-monad"><span class="toc-number">13.2.</span> <span class="toc-text">Lens as a State monad</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lens-laws"><span class="toc-number">13.3.</span> <span class="toc-text">Lens laws</span></a></li></ol>
		</div>
		
		<h1 id="applicative-builder">Applicative Builder</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; (<span class="number">3.</span>some |@| <span class="number">5.</span>some) {_ + _}
res18: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">8</span>)

scala&gt; val f = ({(_: <span class="built_in">Int</span>) * <span class="number">2</span>} |@| {(_: <span class="built_in">Int</span>) + <span class="number">10</span>}) {_ + _}
f: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span> = &lt;function1&gt;
</pre></td></tr></table></figure>

<h1 id="state-and-statet">State and StateT</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>scala&gt; type Stack = List[Int]
defined type alias Stack

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(stack: Stack)</span>:</span> (Int, Stack) = stack match {
         case x :: xs =&gt; (x, xs)
       }
pop: (stack: Stack)(Int, Stack)

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(a: Int, stack: Stack)</span>:</span> (Unit, Stack) = ((), a :: stack)
push: (a: Int, stack: Stack)(Unit, Stack)

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">stackManip</span><span class="params">(stack: Stack)</span>:</span> (Int, Stack) = {
         val (_, newStack1) = push(<span class="number">3</span>, stack)
         val (a, newStack2) = pop(newStack1)
         pop(newStack2)
       }
stackManip: (stack: Stack)(Int, Stack)

scala&gt; stackManip(List(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>))
res0: (Int, Stack) = (<span class="number">5</span>,List(<span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>))
</pre></td></tr></table></figure>

<p>We’ll say that a stateful computation is a function that takes some
state and returns a value along with some new state.
That function would have the following type:<code>s -&gt; (a, s)</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">type</span> State[S, +A] = StateT[Id, S, A]

<span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
<span class="class"><span class="keyword">object</span> <span class="title">State</span> <span class="keyword">extends</span> <span class="title">StateFunctions</span> {</span>
  <span class="keyword">def</span> apply[S, A](f: S =&gt; (S, A)): State[S, A] = <span class="keyword">new</span> StateT[Id, S, A] {
    <span class="keyword">def</span> apply(s: S) = f(s)
  }
}

<span class="class"><span class="keyword">trait</span> <span class="title">StateT</span>[<span class="title">F</span>[+<span class="title">_</span>], <span class="title">S</span>, +<span class="title">A</span>] {</span> self =&gt;
  <span class="javadoc">/** Run and return the final value and state in the context of `F` */</span>
  <span class="keyword">def</span> apply(initial: S): F[(S, A)]

  <span class="javadoc">/** An alias for `apply` */</span>
  <span class="keyword">def</span> run(initial: S): F[(S, A)] = apply(initial)

  <span class="javadoc">/** Calls `run` using `Monoid[S].zero` as the initial state */</span>
  <span class="keyword">def</span> runZero(implicit S: Monoid[S]): F[(S, A)] =
    run(S.zero)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>scala&gt; type Stack = List[Int]
defined type alias Stack

scala&gt; val <span class="keyword">pop</span> = State[Stack, Int] {
         case <span class="built_in">x</span> :: xs =&gt; (xs, <span class="built_in">x</span>)
       }
<span class="label">pop:</span> scalaz<span class="preprocessor">.State</span>[Stack,Int]

scala&gt; def <span class="keyword">push</span>(a: Int) = State[Stack, Unit] {
         case xs =&gt; (a :: xs, ())
       }
<span class="label">push:</span> (a: Int)scalaz<span class="preprocessor">.State</span>[Stack,Unit]

scala&gt; def stackManip: State[Stack, Int] = for {
         _ &lt;- <span class="keyword">push</span>(<span class="number">3</span>)
         a &lt;- <span class="keyword">pop</span>
         b &lt;- <span class="keyword">pop</span>
       } yield(b)
<span class="label">stackManip:</span> scalaz<span class="preprocessor">.State</span>[Stack,Int]

scala&gt; stackManip(List(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>))
<span class="label">res2:</span> (Stack, Int) = (List(<span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>),<span class="number">5</span>)
</pre></td></tr></table></figure>

<p>The State object extends StateFunctions trait, which defines a few helper functions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>trait StateFunctions {
  <span class="function"><span class="keyword">def</span> <span class="title">constantState</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A, s: =&gt; S)</span>:</span> State[S, A] =
    State((_: S) =&gt; (s, a))
  <span class="function"><span class="keyword">def</span> <span class="title">state</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A)</span>:</span> State[S, A] =
    State((_ : S, a))
  <span class="function"><span class="keyword">def</span> <span class="title">init</span>[<span class="title">S</span>]:</span> State[S, S] = State(s =&gt; (s, s))
  <span class="function"><span class="keyword">def</span> <span class="title">get</span>[<span class="title">S</span>]:</span> State[S, S] = init
  <span class="function"><span class="keyword">def</span> <span class="title">gets</span>[<span class="title">S</span>, <span class="title">T</span>]<span class="params">(f: S =&gt; T)</span>:</span> State[S, T] = State(s =&gt; (s, f(s)))
  <span class="function"><span class="keyword">def</span> <span class="title">put</span>[<span class="title">S</span>]<span class="params">(s: S)</span>:</span> State[S, Unit] = State(_ =&gt; (s, ()))
  <span class="function"><span class="keyword">def</span> <span class="title">modify</span>[<span class="title">S</span>]<span class="params">(f: S =&gt; S)</span>:</span> State[S, Unit] = State(s =&gt; {
    val r = f(s);
    (r, ())
  })
  /**
   * Computes the difference between the current <span class="keyword">and</span> previous values of `a`
   */
  <span class="function"><span class="keyword">def</span> <span class="title">delta</span>[<span class="title">A</span>]<span class="params">(a: A)</span><span class="params">(implicit A: Group[A])</span>:</span> State[A, A] = State{
    (prevA) =&gt;
      val diff = A.minus(a, prevA)
      (diff, a)
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">stackyStack</span>:</span> State[Stack, Unit] = <span class="keyword">for</span> {
         stackNow &lt;- get
         r &lt;- <span class="keyword">if</span> (stackNow === List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) put(List(<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>))
              <span class="keyword">else</span> put(List(<span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>))
       } <span class="keyword">yield</span> r
stackyStack: scalaz.State[Stack,Unit]

scala&gt; stackyStack(List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))
res4: (Stack, Unit) = (List(<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>),())


// We can also implement pop <span class="keyword">and</span> push <span class="keyword">in</span> terms of get <span class="keyword">and</span> put:
scala&gt; val pop: State[Stack, Int] = <span class="keyword">for</span> {
         s &lt;- get[Stack]
         val (x :: xs) = s
         _ &lt;- put(xs)
       } <span class="keyword">yield</span> x
pop: scalaz.State[Stack,Int] = scalaz.StateT$$anon$<span class="number">7</span><span class="decorator">@40014da3</span>

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(x: Int)</span>:</span> State[Stack, Unit] = <span class="keyword">for</span> {
         xs &lt;- get[Stack]
         r &lt;- put(x :: xs)
       } <span class="keyword">yield</span> r
push: (x: Int)scalaz.State[Stack,Unit]
</pre></td></tr></table></figure>

<h1 id="either">Either</h1>
<p>We know <code>Either[A, B]</code> from the standard library, but Scalaz 7 
implements its own Either equivalent named <code>\/</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> \/[+<span class="title">A</span>, +<span class="title">B</span>] {</span>
  ...
  <span class="javadoc">/** Return `true` if this disjunction is left. */</span>
  <span class="keyword">def</span> isLeft: Boolean =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(_) =&gt; <span class="keyword">true</span>
      <span class="keyword">case</span> \/-(_) =&gt; <span class="keyword">false</span>
    }

  <span class="javadoc">/** Return `true` if this disjunction is right. */</span>
  <span class="keyword">def</span> isRight: Boolean =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(_) =&gt; <span class="keyword">false</span>
      <span class="keyword">case</span> \/-(_) =&gt; <span class="keyword">true</span>
    }
  ...
  <span class="javadoc">/** Flip the left/right values in this disjunction. Alias for `unary_~` */</span>
  <span class="keyword">def</span> swap: (B \/ A) =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(a) =&gt; \/-(a)
      <span class="keyword">case</span> \/-(b) =&gt; -\/(b)
    }
  <span class="javadoc">/** Flip the left/right values in this disjunction. Alias for `swap` */</span>
  <span class="keyword">def</span> unary_~ : (B \/ A) = swap
  ...
  <span class="javadoc">/** Return the right value of this disjunction or the given default if left. Alias for `|` */</span>
  <span class="keyword">def</span> getOrElse[BB &gt;: B](x: =&gt; BB): BB =
    toOption getOrElse x
  <span class="javadoc">/** Return the right value of this disjunction or the given default if left. Alias for `getOrElse` */</span>
  <span class="keyword">def</span> |[BB &gt;: B](x: =&gt; BB): BB = getOrElse(x)
  
  <span class="javadoc">/** Return this if it is a right, otherwise, return the given value. Alias for `|||` */</span>
  <span class="keyword">def</span> orElse[AA &gt;: A, BB &gt;: B](x: =&gt; AA \/ BB): AA \/ BB =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(_) =&gt; x
      <span class="keyword">case</span> \/-(_) =&gt; <span class="keyword">this</span>
    }
  <span class="javadoc">/** Return this if it is a right, otherwise, return the given value. Alias for `orElse` */</span>
  <span class="keyword">def</span> |||[AA &gt;: A, BB &gt;: B](x: =&gt; AA \/ BB): AA \/ BB = orElse(x)
  ...
}

<span class="keyword">private</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> -\/[+<span class="title">A</span>]<span class="params">(a: A)</span> <span class="keyword">extends</span> <span class="params">(A \/ Nothing)</span></span>
<span class="keyword">private</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> \/-[+<span class="title">B</span>]<span class="params">(b: B)</span> <span class="keyword">extends</span> <span class="params">(Nothing \/ B)</span></span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span><span class="built_in">right</span>[<span class="built_in">String</span>]
res12: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>] = \/-(<span class="number">1</span>)

scala&gt; <span class="string">"error"</span>.<span class="built_in">left</span>[<span class="built_in">Int</span>]
res13: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>] = -\/(<span class="keyword">error</span>)
</pre></td></tr></table></figure>

<p>The Either type in Scala standard library is not a monad on its own,
which means it does not implement flatMap method with or without Scalaz:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>// scala 中的Left 不是 一个 monad 没有实现 flatmap
scala&gt; Left[<span class="link_label">String, Int</span>](<span class="link_url">"boom"</span>) flatMap { x =&gt; Right[<span class="link_label">String, Int</span>](<span class="link_url">x + 1</span>) }
<span class="xml"><span class="tag">&lt;<span class="title">console</span>&gt;</span></span>:8: error: value flatMap is not a member of scala.util.Left[String,Int]
<span class="code">              Left[String, Int]("boom") flatMap { x =&gt; Right[String, Int](x + 1) }</span>
<span class="code">                                        ^</span>
// 取得右边的值进行运算
scala&gt; Left[<span class="link_label">String, Int</span>](<span class="link_url">"boom"</span>).right flatMap { x =&gt; Right[<span class="link_label">String, Int</span>](<span class="link_url">x + 1</span>)}
res15: scala.util.Either[String,Int] = Left(boom)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// 与 Either 操作相关</span>
<span class="comment">// 如果遇到left(失败), 就直接返回left</span>
scala&gt; <span class="keyword">for</span> {
         e1 &lt;- <span class="string">"event 1 ok"</span>.right
         e2 &lt;- <span class="string">"event 2 failed!"</span>.left[<span class="built_in">String</span>]
         e3 &lt;- <span class="string">"event 3 failed!"</span>.left[<span class="built_in">String</span>]
       } <span class="keyword">yield</span> (e1 |+| e2 |+| e3)
res24: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">String</span>] = -\/(event <span class="number">2</span> failed!)

<span class="comment">// getOrElse</span>
scala&gt; <span class="string">"event 1 ok"</span>.right | <span class="string">"something bad"</span>
res27: <span class="built_in">String</span> = event <span class="number">1</span> ok

scala&gt; <span class="string">"event 1 ok"</span>.right map {_ + <span class="string">"!"</span>}
res31: scalaz.\/[Nothing,<span class="built_in">String</span>] = \/-(event <span class="number">1</span> ok!)

<span class="comment">// orElse</span>
scala&gt; <span class="string">"event 1 failed!"</span>.left ||| <span class="string">"retry event 1 ok"</span>.right 
res32: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">String</span>] = \/-(retry event <span class="number">1</span> ok)
</pre></td></tr></table></figure>

<h1 id="validation">Validation</h1>
<p>Another data structure that’s compared to Either in Scalaz is Validation:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Validation</span>[+<span class="title">E</span>, +<span class="title">A</span>] {</span>
  <span class="javadoc">/** Return `true` if this validation is success. */</span>
  <span class="keyword">def</span> isSuccess: Boolean = <span class="keyword">this</span> <span class="keyword">match</span> {
    <span class="keyword">case</span> Success(_) =&gt; <span class="keyword">true</span>
    <span class="keyword">case</span> Failure(_) =&gt; <span class="keyword">false</span>
  }
  <span class="javadoc">/** Return `true` if this validation is failure. */</span>
  <span class="keyword">def</span> isFailure: Boolean = !isSuccess

  ...
}

<span class="keyword">final</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Success</span>[<span class="title">E</span>, <span class="title">A</span>]<span class="params">(a: A)</span> <span class="keyword">extends</span> <span class="title">Validation</span>[<span class="title">E</span>, <span class="title">A</span>]</span>
<span class="keyword">final</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Failure</span>[<span class="title">E</span>, <span class="title">A</span>]<span class="params">(e: E)</span> <span class="keyword">extends</span> <span class="title">Validation</span>[<span class="title">E</span>, <span class="title">A</span>]</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>scala&gt; <span class="string">"event 1 ok"</span>.success[<span class="built_in">String</span>]
res36: scalaz.Validation[<span class="built_in">String</span>,<span class="built_in">String</span>] = Success(event <span class="number">1</span> ok)

scala&gt; <span class="string">"event 1 failed!"</span>.failure[<span class="built_in">String</span>]
res38: scalaz.Validation[<span class="built_in">String</span>,<span class="built_in">String</span>] = Failure(event <span class="number">1</span> failed!)

<span class="comment">// Validation keeps going and reports back all failures. </span>
scala&gt; (<span class="string">"event 1 ok"</span>.success[<span class="built_in">String</span>] |@| <span class="string">"event 2 failed!"</span>.failure[<span class="built_in">String</span>] |@| <span class="string">"event 3 failed!"</span>.failure[<span class="built_in">String</span>]) {_ + _ + _}
res44: scalaz.Unapply[scalaz.Apply,scalaz.Validation[<span class="built_in">String</span>,<span class="built_in">String</span>]]{type M[X] = scalaz.Validation[<span class="built_in">String</span>,X]; type A = <span class="built_in">String</span>}#M[<span class="built_in">String</span>] = Failure(event <span class="number">2</span> failed!event <span class="number">3</span> failed!)
</pre></td></tr></table></figure>

<h1 id="nonemptylist-nel-">NonEmptyList(Nel)</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="javadoc">/** A singly-linked list that is guaranteed to be non-empty. */</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NonEmptyList</span>[+<span class="title">A</span>] {</span>
  <span class="keyword">val</span> head: A
  <span class="keyword">val</span> tail: List[A]
  <span class="keyword">def</span> &lt;::[AA &gt;: A](b: AA): NonEmptyList[AA] = nel(b, head :: tail)
  ...
}
</pre></td></tr></table></figure>

<p>This is a wrapper trait for plain List that’s guaranteed to be non-empty.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span>wrapNel
<span class="label">res47:</span> scalaz<span class="preprocessor">.NonEmptyList</span>[Int] = NonEmptyList(<span class="number">1</span>)

scala&gt; <span class="string">"event 1 ok"</span><span class="preprocessor">.successNel</span>[String]
<span class="label">res48:</span> scalaz<span class="preprocessor">.ValidationNEL</span>[String,String] = Success(event <span class="number">1</span> ok)

scala&gt; <span class="string">"event 1 failed!"</span><span class="preprocessor">.failureNel</span>[String]
<span class="label">res49:</span> scalaz<span class="preprocessor">.ValidationNEL</span>[String,String] = Failure(NonEmptyList(event <span class="number">1</span> failed!))

scala&gt; (<span class="string">"event 1 ok"</span><span class="preprocessor">.successNel</span>[String] |@| <span class="string">"event 2 failed!"</span><span class="preprocessor">.failureNel</span>[String] |@| <span class="string">"event 3 failed!"</span><span class="preprocessor">.failureNel</span>[String]) {_ + _ + _}
<span class="label">res50:</span> scalaz<span class="preprocessor">.Unapply</span>[scalaz<span class="preprocessor">.Apply</span>,scalaz<span class="preprocessor">.ValidationNEL</span>[String,String]]{type M[<span class="built_in">X</span>] = scalaz<span class="preprocessor">.ValidationNEL</span>[String,<span class="built_in">X</span>]<span class="comment">; type A = String}#M[String] = Failure(NonEmptyList(event 2 failed!, event 3 failed!))</span>
</pre></td></tr></table></figure>

<h1 id="some-useful-monadic-functions">Some useful monadic functions</h1>
<h2 id="join">join</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; (Some(<span class="number">9.</span>some): <span class="keyword">Option</span>[<span class="keyword">Option</span>[<span class="built_in">Int</span>]]).<span class="built_in">join</span>
res9: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">9</span>)

scala&gt; (Some(none): <span class="keyword">Option</span>[<span class="keyword">Option</span>[<span class="built_in">Int</span>]]).<span class="built_in">join</span>
res10: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = None

scala&gt; List(List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), List(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)).<span class="built_in">join</span>
res12: List[<span class="built_in">Int</span>] = List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)

scala&gt; <span class="number">9.</span><span class="built_in">right</span>[<span class="built_in">String</span>].<span class="built_in">right</span>[<span class="built_in">String</span>].<span class="built_in">join</span>
res15: scalaz.Unapply[scalaz.Bind,scalaz.\/[<span class="built_in">String</span>,scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]]]{type M[X] = scalaz.\/[<span class="built_in">String</span>,X]; type A = scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]}#M[<span class="built_in">Int</span>] = \/-(<span class="number">9</span>)

scala&gt; <span class="string">"boom"</span>.<span class="built_in">left</span>[<span class="built_in">Int</span>].<span class="built_in">right</span>[<span class="built_in">String</span>].<span class="built_in">join</span>
res16: scalaz.Unapply[scalaz.Bind,scalaz.\/[<span class="built_in">String</span>,scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]]]{type M[X] = scalaz.\/[<span class="built_in">String</span>,X]; type A = scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]}#M[<span class="built_in">Int</span>] = -\/(boom)
</pre></td></tr></table></figure>

<h2 id="filterm">filterM</h2>
<p>In Scalaz filterM is implemented in several places. For List it
seems to be there by <code>import Scalaz._</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>trait ListOps[A] extends Ops[List[A]] {
  <span class="keyword">...</span>
  final def filterM[M[_] : Monad](p: A =&gt; M[Boolean]): M[List[A]] = l.filterM(self)(p)
  <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// TODO 查源代码</span>
scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) filterM { x =&gt; <span class="keyword">List</span>(<span class="keyword">true</span>, <span class="keyword">false</span>) }
res19: <span class="keyword">List</span>[<span class="keyword">List</span>[Int]] = <span class="keyword">List</span>(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">1</span>), <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">2</span>), <span class="keyword">List</span>(<span class="number">3</span>), <span class="keyword">List</span>())

scala&gt; import syntax.std.vector._
import syntax.std.vector._

scala&gt; Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) filterM { x =&gt; Vector(<span class="keyword">true</span>, <span class="keyword">false</span>) }
res20: scala.collection.immutable.Vector[Vector[Int]] = Vector(Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Vector(<span class="number">1</span>, <span class="number">2</span>), Vector(<span class="number">1</span>, <span class="number">3</span>), Vector(<span class="number">1</span>), Vector(<span class="number">2</span>, <span class="number">3</span>), Vector(<span class="number">2</span>), Vector(<span class="number">3</span>), Vector())
</pre></td></tr></table></figure>

<h2 id="foldleftm">foldLeftM</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; def binSmalls(acc: <span class="built_in">Int</span>, x: <span class="built_in">Int</span>): <span class="keyword">Option</span>[<span class="built_in">Int</span>] = {
         <span class="keyword">if</span> (x &gt; <span class="number">9</span>) (none: <span class="keyword">Option</span>[<span class="built_in">Int</span>])
         <span class="keyword">else</span> (acc + x).some
       }
binSmalls: (acc: <span class="built_in">Int</span>, x: <span class="built_in">Int</span>)<span class="keyword">Option</span>[<span class="built_in">Int</span>]

scala&gt; List(<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>).foldLeftM(<span class="number">0</span>) {binSmalls}
res25: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">14</span>)

scala&gt; List(<span class="number">2</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">1</span>).foldLeftM(<span class="number">0</span>) {binSmalls}
res26: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = None
</pre></td></tr></table></figure>

<h1 id="making-a-safe-rpn-calculator">Making a safe RPN calculator</h1>
<p>When we were solving the problem of implementing a RPN calculator,
we noted that it worked fine as long as the input that it got made sense.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">foldingFunction</span><span class="params">(list: List[Double], next: String)</span>:</span> List[Double] = (list, next) match {
         case (x :: y :: ys, <span class="string">"*"</span>) =&gt; (y * x) :: ys
         case (x :: y :: ys, <span class="string">"+"</span>) =&gt; (y + x) :: ys
         case (x :: y :: ys, <span class="string">"-"</span>) =&gt; (y - x) :: ys
         case (xs, numString) =&gt; numString.toInt :: xs
       }
foldingFunction: (list: List[Double], next: String)List[Double]

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">solveRPN</span><span class="params">(s: String)</span>:</span> Double =
         (s.split(<span class="string">' '</span>).toList.foldLeft(Nil: List[Double]) {foldingFunction}).head
solveRPN: (s: String)Double

scala&gt; solveRPN(<span class="string">"10 4 3 + 2 * -"</span>)
res27: Double = -<span class="number">4.0</span>
</pre></td></tr></table></figure>

<p>版本2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>scala&gt; def foldingFunction(<span class="keyword">list</span>: <span class="keyword">List</span>[Double], next: String): Option[<span class="keyword">List</span>[Double]] = (<span class="keyword">list</span>, next) match {
         <span class="keyword">case</span> (x :: y :: ys, <span class="string">"*"</span>) =&gt; ((y * x) :: ys).point[Option]
         <span class="keyword">case</span> (x :: y :: ys, <span class="string">"+"</span>) =&gt; ((y + x) :: ys).point[Option]
         <span class="keyword">case</span> (x :: y :: ys, <span class="string">"-"</span>) =&gt; ((y - x) :: ys).point[Option]
         <span class="keyword">case</span> (xs, numString) =&gt; numString.parseInt.toOption map {_ :: xs}
       }
foldingFunction: (<span class="keyword">list</span>: <span class="keyword">List</span>[Double], next: String)Option[<span class="keyword">List</span>[Double]]

scala&gt; foldingFunction(<span class="keyword">List</span>(<span class="number">3</span>, <span class="number">2</span>), <span class="string">"*"</span>)
res33: Option[<span class="keyword">List</span>[Double]] = Some(<span class="keyword">List</span>(<span class="number">6.0</span>))

scala&gt; foldingFunction(Nil, <span class="string">"*"</span>)
res34: Option[<span class="keyword">List</span>[Double]] = None

<span class="comment">// 软错误</span>
scala&gt; foldingFunction(Nil, <span class="string">"wawa"</span>)
res35: Option[<span class="keyword">List</span>[Double]] = None
</pre></td></tr></table></figure>

<h1 id="composing-monadic-functions">Composing monadic functions</h1>
<h2 id="kleisli">Kleisli</h2>
<p>In Scalaz there’s a special wrapper for function
of <code>type A =&gt; M[B]</code> called Kleisli:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Kleisli</span>[<span class="title">M</span>[+<span class="title">_</span>], -<span class="title">A</span>, +<span class="title">B</span>] {</span> self =&gt;
  <span class="keyword">def</span> run(a: A): M[B]
  ...
  <span class="javadoc">/** alias for `andThen` */</span>
  <span class="keyword">def</span> &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(<span class="keyword">this</span>(a))(k(_)))
  <span class="keyword">def</span> andThen[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] = <span class="keyword">this</span> &gt;=&gt; k
  <span class="javadoc">/** alias for `compose` */</span> 
  <span class="keyword">def</span> &lt;=&lt;[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; <span class="keyword">this</span>
  <span class="keyword">def</span> compose[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; <span class="keyword">this</span>
  ...
}

<span class="class"><span class="keyword">object</span> <span class="title">Kleisli</span> <span class="keyword">extends</span> <span class="title">KleisliFunctions</span> <span class="keyword">with</span> <span class="title">KleisliInstances</span> {</span>
  <span class="keyword">def</span> apply[M[+_], A, B](f: A =&gt; M[B]): Kleisli[M, A, B] = kleisli(f)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; val f = Kleisli { (<span class="built_in">x</span>: Int) =&gt; (<span class="built_in">x</span> + <span class="number">1</span>)<span class="preprocessor">.some</span> }
<span class="label">f:</span> scalaz<span class="preprocessor">.Kleisli</span>[Option,Int,Int] = scalaz<span class="preprocessor">.KleisliFunctions</span>$$anon$18<span class="localvars">@7</span>da2734e

scala&gt; val g = Kleisli { (<span class="built_in">x</span>: Int) =&gt; (<span class="built_in">x</span> * <span class="number">100</span>)<span class="preprocessor">.some</span> }
<span class="label">g:</span> scalaz<span class="preprocessor">.Kleisli</span>[Option,Int,Int] = scalaz<span class="preprocessor">.KleisliFunctions</span>$$anon$18<span class="localvars">@49</span>e07991

scala&gt; <span class="number">4.</span>some &gt;&gt;= (f &lt;=&lt; g)
<span class="label">res59:</span> Option[Int] = Some(<span class="number">401</span>)

scala&gt; <span class="number">4.</span>some &gt;&gt;= (f &gt;=&gt; g)
<span class="label">res60:</span> Option[Int] = Some(<span class="number">500</span>)
</pre></td></tr></table></figure>

<h2 id="reader">Reader</h2>
<p>As a bonus, Scalaz defines Reader as a special case of Kleisli as follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>type ReaderT[F[+_], E, A] = Kleisli[F, E, A]
type Reader[E, A] = ReaderT[Id, E, A]
object Reader {
  def apply[<span class="link_label">E, A</span>](<span class="link_url">f: E =&gt; A</span>): Reader[<span class="link_label">E, A</span>] = Kleisli[<span class="link_label">Id, E, A</span>](<span class="link_url">f</span>)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; val addStuff: Reader[<span class="built_in">Int</span>, <span class="built_in">Int</span>] = <span class="keyword">for</span> {
         a &lt;- Reader { (_: <span class="built_in">Int</span>) * <span class="number">2</span> }
         b &lt;- Reader { (_: <span class="built_in">Int</span>) + <span class="number">10</span> }
       } yield a + b
addStuff: scalaz.Reader[<span class="built_in">Int</span>,<span class="built_in">Int</span>] = scalaz.KleisliFunctions$$anon$<span class="number">18</span>@<span class="number">343</span>bd3ae

scala&gt; addStuff(<span class="number">3</span>)
res76: scalaz.Id.Id[<span class="built_in">Int</span>] = <span class="number">19</span>
</pre></td></tr></table></figure>

<h1 id="making-monads">Making monads</h1>
<p>What if we wanted to model a non-deterministic value like <code>[3,5,9]</code>
but we wanted to express that 3 has a 50% chance of happening and 5 and 9
both have a 25% chance of happening?</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Prob</span>[<span class="title">A</span>]<span class="params">(list: List[(A, Double)</span>])</span>

<span class="comment">// the list is a functor, so this should probably be a functor as well,</span>
<span class="comment">// because we just added some stuff to the list.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">ProbInstances</span> {</span>

  <span class="keyword">def</span> flatten[B](xs: Prob[Prob[B]]): Prob[B] = {
    <span class="keyword">def</span> multall(innerxs: Prob[B], p: Double) =
      innerxs.list map { <span class="keyword">case</span> (x, r) =&gt; (x, p * r) }
    Prob((xs.list map { <span class="keyword">case</span> (innerxs, p) =&gt; multall(innerxs, p) }).flatten)
  }
  
  implicit <span class="keyword">val</span> probInstance = <span class="keyword">new</span> Functor[Prob] {
    <span class="keyword">def</span> map[A, B](fa: Prob[A])(f: A =&gt; B): Prob[B] =
      Prob(fa.list map { <span class="keyword">case</span> (x, p) =&gt; (f(x), p) })
  }
  implicit <span class="keyword">def</span> probShow[A]: Show[Prob[A]] = Show.showA
}

<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Prob</span> <span class="keyword">extends</span> <span class="title">ProbInstances</span></span>
</pre></td></tr></table></figure>

<p>The probability of having all three coins on Tails even
with a loaded coin is pretty low.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Coin</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Heads</span> <span class="keyword">extends</span> <span class="title">Coin</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Tails</span> <span class="keyword">extends</span> <span class="title">Coin</span></span>
implicit <span class="keyword">val</span> coinEqual: Equal[Coin] = Equal.equalA

<span class="keyword">def</span> coin: Prob[Coin] = Prob(Heads -&gt; <span class="number">0.5</span> :: Tails -&gt; <span class="number">0.5</span> :: Nil)
<span class="keyword">def</span> loadedCoin: Prob[Coin] = Prob(Heads -&gt; <span class="number">0.1</span> :: Tails -&gt; <span class="number">0.9</span> :: Nil)

<span class="keyword">def</span> flipThree: Prob[Boolean] = <span class="keyword">for</span> {
  a &lt;- coin
  b &lt;- coin
  c &lt;- loadedCoin
} <span class="keyword">yield</span> { List(a, b, c) all {_ === Tails} }
</pre></td></tr></table></figure>

<h1 id="tree">Tree</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Tree</span>[<span class="title">A</span>] {</span>
  <span class="javadoc">/** The label at the root of this tree. */</span>
  <span class="keyword">def</span> rootLabel: A
  <span class="javadoc">/** The child nodes of this tree. */</span>
  <span class="keyword">def</span> subForest: Stream[Tree[A]]
}

<span class="class"><span class="keyword">object</span> <span class="title">Tree</span> <span class="keyword">extends</span> <span class="title">TreeFunctions</span> <span class="keyword">with</span> <span class="title">TreeInstances</span> {</span>
  <span class="javadoc">/** Construct a tree node with no children. */</span>
  <span class="keyword">def</span> apply[A](root: =&gt; A): Tree[A] = leaf(root)

  <span class="class"><span class="keyword">object</span> <span class="title">Node</span> {</span>
    <span class="keyword">def</span> unapply[A](t: Tree[A]): Option[(A, Stream[Tree[A]])] = Some((t.rootLabel, t.subForest))
  }
}

<span class="class"><span class="keyword">trait</span> <span class="title">TreeFunctions</span> {</span>
  <span class="javadoc">/** Construct a new Tree node. */</span>
  <span class="keyword">def</span> node[A](root: =&gt; A, forest: =&gt; Stream[Tree[A]]): Tree[A] = <span class="keyword">new</span> Tree[A] {
    <span class="keyword">lazy</span> <span class="keyword">val</span> rootLabel = root
    <span class="keyword">lazy</span> <span class="keyword">val</span> subForest = forest
    <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"&lt;tree&gt;"</span>
  }
  <span class="javadoc">/** Construct a tree node with no children. */</span>
  <span class="keyword">def</span> leaf[A](root: =&gt; A): Tree[A] = node(root, Stream.empty)
  ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">TreeV</span>[<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">Ops</span>[<span class="title">A</span>] {</span>
  <span class="keyword">def</span> node(subForest: Tree[A]*): Tree[A] = Tree.node(self, subForest.toStream)

  <span class="keyword">def</span> leaf: Tree[A] = Tree.leaf(self)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>scala&gt; def freeTree: Tree[Char] =
         <span class="string">'P'</span><span class="preprocessor">.node</span>(
           <span class="string">'O'</span><span class="preprocessor">.node</span>(
             <span class="string">'L'</span><span class="preprocessor">.node</span>(<span class="string">'N'</span><span class="preprocessor">.leaf</span>, <span class="string">'T'</span><span class="preprocessor">.leaf</span>),
             <span class="string">'Y'</span><span class="preprocessor">.node</span>(<span class="string">'S'</span><span class="preprocessor">.leaf</span>, <span class="string">'A'</span><span class="preprocessor">.leaf</span>)),
           <span class="string">'L'</span><span class="preprocessor">.node</span>(
             <span class="string">'W'</span><span class="preprocessor">.node</span>(<span class="string">'C'</span><span class="preprocessor">.leaf</span>, <span class="string">'R'</span><span class="preprocessor">.leaf</span>),
             <span class="string">'A'</span><span class="preprocessor">.node</span>(<span class="string">'A'</span><span class="preprocessor">.leaf</span>, <span class="string">'C'</span><span class="preprocessor">.leaf</span>)))
<span class="label">freeTree:</span> scalaz<span class="preprocessor">.Tree</span>[Char]

scala&gt; def changeToP(tree: Tree[Char]): Tree[Char] = tree match {
         case Tree<span class="preprocessor">.Node</span>(<span class="built_in">x</span>, Stream(
           l, Tree<span class="preprocessor">.Node</span>(<span class="built_in">y</span>, Stream(
             Tree<span class="preprocessor">.Node</span>(_, Stream(m, n)), r)))) =&gt;
           <span class="built_in">x</span><span class="preprocessor">.node</span>(l, <span class="built_in">y</span><span class="preprocessor">.node</span>(<span class="string">'P'</span><span class="preprocessor">.node</span>(m, n), r))
       }
<span class="label">changeToP:</span> (tree: scalaz<span class="preprocessor">.Tree</span>[Char])scalaz<span class="preprocessor">.Tree</span>[Char]
</pre></td></tr></table></figure>

<h2 id="treeloc">TreeLoc</h2>
<p>The zipper for Tree in Scalaz is called TreeLoc:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TreeLoc</span>[<span class="title">A</span>] {</span>
  <span class="keyword">import</span> TreeLoc._
  <span class="keyword">import</span> Tree._

  <span class="javadoc">/** The currently selected node. */</span>
  <span class="keyword">val</span> tree: Tree[A]
  <span class="javadoc">/** The left siblings of the current node. */</span>
  <span class="keyword">val</span> lefts: TreeForest[A]
  <span class="javadoc">/** The right siblings of the current node. */</span>
  <span class="keyword">val</span> rights: TreeForest[A]
  <span class="javadoc">/** The parent contexts of the current node. */</span>
  <span class="keyword">val</span> parents: Parents[A]
  ...
}

<span class="class"><span class="keyword">object</span> <span class="title">TreeLoc</span> <span class="keyword">extends</span> <span class="title">TreeLocFunctions</span> <span class="keyword">with</span> <span class="title">TreeLocInstances</span> {</span>
  <span class="keyword">def</span> apply[A](t: Tree[A], l: TreeForest[A], r: TreeForest[A], p: Parents[A]): TreeLoc[A] =
    loc(t, l, r, p)
}

<span class="class"><span class="keyword">trait</span> <span class="title">TreeLocFunctions</span> {</span>
  <span class="keyword">type</span> TreeForest[A] = Stream[Tree[A]]
  <span class="keyword">type</span> Parent[A] = (TreeForest[A], A, TreeForest[A])
  <span class="keyword">type</span> Parents[A] = Stream[Parent[A]]
}

<span class="comment">// similar to DOM API:</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TreeLoc</span>[<span class="title">A</span>] {</span>
  ...
  <span class="javadoc">/** Select the parent of the current node. */</span>
  <span class="keyword">def</span> parent: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the root node of the tree. */</span>
  <span class="keyword">def</span> root: TreeLoc[A] = ...
  <span class="javadoc">/** Select the left sibling of the current node. */</span>
  <span class="keyword">def</span> left: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the right sibling of the current node. */</span>
  <span class="keyword">def</span> right: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the leftmost child of the current node. */</span>
  <span class="keyword">def</span> firstChild: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the rightmost child of the current node. */</span>
  <span class="keyword">def</span> lastChild: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the nth child of the current node. */</span>
  <span class="keyword">def</span> getChild(n: Int): Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the first immediate child of the current node that satisfies the given predicate. */</span>
  <span class="keyword">def</span> findChild(p: Tree[A] =&gt; Boolean): Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Get the label of the current node. */</span>
  <span class="keyword">def</span> getLabel: A = ...
    <span class="javadoc">/** Modify the current node with the given function. */</span>
  <span class="keyword">def</span> modifyTree(f: Tree[A] =&gt; Tree[A]): TreeLoc[A] = ...
  <span class="javadoc">/** Modify the label at the current node with the given function. */</span>
  <span class="keyword">def</span> modifyLabel(f: A =&gt; A): TreeLoc[A] = ...
  <span class="javadoc">/** Insert the given node as the last child of the current node and give it focus. */</span>
  <span class="keyword">def</span> insertDownLast(t: Tree[A]): TreeLoc[A] = ...
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; freeTree<span class="preprocessor">.loc</span><span class="preprocessor">.getChild</span>(<span class="number">2</span>) &gt;&gt;= {_<span class="preprocessor">.getChild</span>(<span class="number">1</span>)}
<span class="label">res8:</span> Option[scalaz<span class="preprocessor">.TreeLoc</span>[Char]] = Some(scalaz<span class="preprocessor">.TreeLocFunctions</span>$$anon$2<span class="localvars">@417</span>ef051)

scala&gt; freeTree<span class="preprocessor">.loc</span><span class="preprocessor">.getChild</span>(<span class="number">2</span>) &gt;&gt;= {_<span class="preprocessor">.getChild</span>(<span class="number">1</span>)} &gt;&gt;= {_<span class="preprocessor">.getLabel</span><span class="preprocessor">.some</span>}
<span class="label">res9:</span> Option[Char] = Some(W)

// modify the label to <span class="string">'P'</span>:
scala&gt; val newFocus = freeTree<span class="preprocessor">.loc</span><span class="preprocessor">.getChild</span>(<span class="number">2</span>) &gt;&gt;= {_<span class="preprocessor">.getChild</span>(<span class="number">1</span>)} &gt;&gt;= {_<span class="preprocessor">.modifyLabel</span>({_ =&gt; <span class="string">'P'</span>})<span class="preprocessor">.some</span>}
<span class="label">newFocus:</span> Option[scalaz<span class="preprocessor">.TreeLoc</span>[Char]] = Some(scalaz<span class="preprocessor">.TreeLocFunctions</span>$$anon$2<span class="localvars">@107</span>a26d0)

scala&gt; newFocus<span class="preprocessor">.get</span><span class="preprocessor">.toTree</span>
<span class="label">res19:</span> scalaz<span class="preprocessor">.Tree</span>[Char] = &lt;tree&gt;
</pre></td></tr></table></figure>

<h2 id="zipper">Zipper</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>scala&gt; for {
         <span class="built_in">z</span> &lt;- Stream(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)<span class="preprocessor">.toZipper</span>
         n1 &lt;- <span class="built_in">z</span><span class="preprocessor">.next</span>
         n2 &lt;- n1<span class="preprocessor">.next</span>
       } yield { n2<span class="preprocessor">.modify</span> {_ =&gt; <span class="number">7</span>} }
<span class="label">res33:</span> Option[scalaz<span class="preprocessor">.Zipper</span>[Int]] = Some(Zipper(&lt;lefts&gt;, <span class="number">7</span>, &lt;rights&gt;))
</pre></td></tr></table></figure>

<h2 id="id">Id</h2>
<p>The Identity monad is a monad that does not embody any computational
strategy.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>/** The strict identity type constructor. Can be thought of <span class="keyword">as</span> `Tuple1`, but <span class="keyword">with</span> no
 *  runtime representation.
 */
type Id[+X] = X

trait IdOps[A] extends Ops[A] {
  /**Returns `self` <span class="keyword">if</span> it <span class="keyword">is</span> non-null, otherwise returns `d`. */
  final <span class="function"><span class="keyword">def</span> ??<span class="params">(d: =&gt; A)</span><span class="params">(implicit ev: Null &lt;:&lt; A)</span>:</span> A =
    <span class="keyword">if</span> (self == null) d <span class="keyword">else</span> self
  /**Applies `self` to the provided function */
  final <span class="function"><span class="keyword">def</span> |&gt;[<span class="title">B</span>]<span class="params">(f: A =&gt; B)</span>:</span> B = f(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">squared</span>:</span> (A, A) = (self, self)
  <span class="function"><span class="keyword">def</span> <span class="title">left</span>[<span class="title">B</span>]:</span> (A \/ B) = \/.left(self)
  <span class="function"><span class="keyword">def</span> <span class="title">right</span>[<span class="title">B</span>]:</span> (B \/ A) = \/.right(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">wrapNel</span>:</span> NonEmptyList[A] = NonEmptyList(self)
  /** <span class="decorator">@return the result of pf(value) if defined, otherwise the the Zero element of type B. */</span>
  <span class="function"><span class="keyword">def</span> <span class="title">matchOrZero</span>[<span class="title">B</span>:</span> Monoid](pf: PartialFunction[A, B]): B = ...
  /** Repeatedly apply `f`, seeded <span class="keyword">with</span> `self`, checking after each iteration whether the predicate `p` holds. */
  final <span class="function"><span class="keyword">def</span> <span class="title">doWhile</span><span class="params">(f: A =&gt; A, p: A =&gt; Boolean)</span>:</span> A = ...
  /** Repeatedly apply `f`, seeded <span class="keyword">with</span> `self`, checking before each iteration whether the predicate `p` holds. */
  final <span class="function"><span class="keyword">def</span> <span class="title">whileDo</span><span class="params">(f: A =&gt; A, p: A =&gt; Boolean)</span>:</span> A = ...
  /** If the provided partial function <span class="keyword">is</span> defined <span class="keyword">for</span> `self` run this,
   * otherwise lift `self` into `F` <span class="keyword">with</span> the provided [[scalaz.Pointed]]. */
  <span class="function"><span class="keyword">def</span> <span class="title">visit</span>[<span class="title">F</span>[<span class="title">_</span>] :</span> Pointed](p: PartialFunction[A, F[A]]): F[A] = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">// |&gt; lets you write the function application at the end of an expression:</span>
scala&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> |&gt; {_.point[<span class="keyword">List</span>]}
res45: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">6</span>)

scala&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> |&gt; {_ * <span class="number">6</span>}
res46: Int = <span class="number">36</span>

<span class="comment">// visit is also kind of interesting:</span>
scala&gt; <span class="number">1</span> visit { <span class="keyword">case</span> x@(<span class="number">2</span>|<span class="number">3</span>) =&gt; <span class="keyword">List</span>(x * <span class="number">2</span>) }
res55: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">1</span>)

scala&gt; <span class="number">2</span> visit { <span class="keyword">case</span> x@(<span class="number">2</span>|<span class="number">3</span>) =&gt; <span class="keyword">List</span>(x * <span class="number">2</span>) }
res56: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">4</span>)
</pre></td></tr></table></figure>

<h1 id="lawless-typeclasses">Lawless typeclasses</h1>
<p>Scalaz 7.0 contains several typeclasses that are now deemed
lawless by Scalaz project: Length, Index, and Each.</p>
<h2 id="length">Length</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>trait Length[F[_]]  { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">length</span>[<span class="title">A</span>]<span class="params">(fa: F[A])</span>:</span> Int
}
</pre></td></tr></table></figure>

<h2 id="index">Index</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>trait Index[F[_]]  { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">index</span>[<span class="title">A</span>]<span class="params">(fa: F[A], i: Int)</span>:</span> Option[A]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>trait IndexOps[F[_],A] extends Ops[F[A]] {
  final <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(n: Int)</span>:</span> Option[A] = F.index(self, n)
  final <span class="function"><span class="keyword">def</span> <span class="title">indexOr</span><span class="params">(default: =&gt; A, n: Int)</span>:</span> A = F.indexOr(self, default, n)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>scala&gt; List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">3</span>)
java.lang.IndexOutOfBoundsException: <span class="number">3</span>
        <span class="keyword">...</span>

scala&gt; List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) index <span class="number">3</span>
res62: Option[Int] = None
</pre></td></tr></table></figure>

<h2 id="each">Each</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">trait</span> Each[F[_]]  { <span class="keyword">self</span> =&gt;
  def each[A](fa: F[A])(f: A =&gt; Unit)
}

sealed <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EachOps</span>[<span class="title">F</span>[<span class="title">_</span>],<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">Ops</span>[<span class="title">F</span>[<span class="title">A</span>]] {</span>
  <span class="keyword">final</span> def <span class="keyword">foreach</span>(f: A =&gt; Unit): Unit = F.each(<span class="keyword">self</span>)(f)
}
</pre></td></tr></table></figure>

<h1 id="monad-transformers">Monad transformers</h1>
<p>A monad transformer is similar to a regular monad,
but it’s not a standalone entity:
instead, it modifies the behaviour of an underlying monad.</p>
<h2 id="reader-yet-again">Reader, yet again</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">myName</span><span class="params">(step: String)</span>:</span> Reader[String, String] = Reader {step + <span class="string">", I am "</span> + _}
myName: (step: String)scalaz.Reader[String,String]

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">localExample</span>:</span> Reader[String, (String, String, String)] = <span class="keyword">for</span> {
         a &lt;- myName(<span class="string">"First"</span>)
         b &lt;- myName(<span class="string">"Second"</span>) &gt;=&gt; Reader { _ + <span class="string">"dy"</span>}
         c &lt;- myName(<span class="string">"Third"</span>)  
       } <span class="keyword">yield</span> (a, b, c)
localExample: scalaz.Reader[String,(String, String, String)]

scala&gt; localExample(<span class="string">"Fred"</span>)
res0: (String, String, String) = (First, I am Fred,Second, I am Freddy,Third, I am Fred)
</pre></td></tr></table></figure>

<h2 id="readert">ReaderT</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">type</span> ReaderTOption[A, B] = ReaderT[Option, A, B]
<span class="class"><span class="keyword">object</span> <span class="title">ReaderTOption</span> <span class="keyword">extends</span> <span class="title">KleisliFunctions</span> <span class="keyword">with</span> <span class="title">KleisliInstances</span> {</span>
  <span class="keyword">def</span> apply[A, B](f: A =&gt; Option[B]): ReaderTOption[A, B] = kleisli(f)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>scala&gt; def configure(key: <span class="keyword">String</span>) = ReaderTOption[<span class="keyword">Map</span>[<span class="keyword">String</span>, <span class="keyword">String</span>], <span class="keyword">String</span>] <span class="list">{_.get(key)}</span> 
configure: (key: <span class="keyword">String</span>)ReaderTOption[<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>],<span class="keyword">String</span>]

scala&gt; def setupConnection = for <span class="list">{
         host &lt;- configure("host")
         user &lt;- configure("user")
         password &lt;- configure("password")
     }</span> yield (host, user, password)
setupConnection: scalaz.Kleisli[Option,<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>],(<span class="keyword">String</span>, <span class="keyword">String</span>, <span class="keyword">String</span>)]

scala&gt; val goodConfig = <span class="keyword">Map</span>(
         <span class="string">"host"</span> -&gt; <span class="string">"eed3si9n.com"</span>,
         <span class="string">"user"</span> -&gt; <span class="string">"sa"</span>,
         <span class="string">"password"</span> -&gt; <span class="string">"****"</span>
       )
goodConfig: scala.collection.immutable.<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>] = <span class="keyword">Map</span>(host -&gt; eed3si9n.com, user -&gt; sa, password -&gt; ****)

scala&gt; setupConnection(goodConfig)
res2: Option[(<span class="keyword">String</span>, <span class="keyword">String</span>, <span class="keyword">String</span>)] = Some((eed3si9n.com,sa,****))

scala&gt; val badConfig = <span class="keyword">Map</span>(
         <span class="string">"host"</span> -&gt; <span class="string">"example.com"</span>,
         <span class="string">"user"</span> -&gt; <span class="string">"sa"</span>
       )
badConfig: scala.collection.immutable.<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>] = <span class="keyword">Map</span>(host -&gt; example.com, user -&gt; sa)

scala&gt; setupConnection(badConfig)
res3: Option[(<span class="keyword">String</span>, <span class="keyword">String</span>, <span class="keyword">String</span>)] = <span class="keyword">None</span>
</pre></td></tr></table></figure>

<h2 id="stacking-multiple-monad-transformers">Stacking multiple monad transformers</h2>
<p>TODO</p>
<h1 id="lens">Lens</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>scala&gt; case class Turtle(position: Point, heading: Double, color: Color) {
         def forward(dist: Double): Turtle =
           copy(position =
             position<span class="preprocessor">.copy</span>(
               <span class="built_in">x</span> = position<span class="preprocessor">.x</span> + dist * math<span class="preprocessor">.cos</span>(heading),
               <span class="built_in">y</span> = position<span class="preprocessor">.y</span> + dist * math<span class="preprocessor">.sin</span>(heading)
           ))
     }
defined class Turtle

scala&gt; Turtle(Point(<span class="number">2.0</span>, <span class="number">3.0</span>), <span class="number">0.0</span>,
         Color(<span class="number">255.</span>toByte, <span class="number">255.</span>toByte, <span class="number">255.</span>toByte))
<span class="label">res10:</span> Turtle = Turtle(Point(<span class="number">2.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

scala&gt; res10<span class="preprocessor">.forward</span>(<span class="number">10</span>)
<span class="label">res11:</span> Turtle = Turtle(Point(<span class="number">12.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

// To update the child data structure, we need to nest copy <span class="keyword">call</span>.
// To quote from Seth’s example again:

// imperative
a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.d</span><span class="preprocessor">.e</span> += <span class="number">1</span>

// functional
a<span class="preprocessor">.copy</span>(
  b = a<span class="preprocessor">.b</span><span class="preprocessor">.copy</span>(
    c = a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.copy</span>(
      d = a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.d</span><span class="preprocessor">.copy</span>(
        e = a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.d</span><span class="preprocessor">.e</span> + <span class="number">1</span>
))))
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="keyword">type</span> Lens[A, B] = LensT[Id, A, B]

<span class="class"><span class="keyword">object</span> <span class="title">Lens</span> <span class="keyword">extends</span> <span class="title">LensTFunctions</span> <span class="keyword">with</span> <span class="title">LensTInstances</span> {</span>
  <span class="keyword">def</span> apply[A, B](r: A =&gt; Store[B, A]): Lens[A, B] =
    lens(r)
}

<span class="keyword">import</span> StoreT._
<span class="keyword">import</span> Id._

<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">LensT</span>[<span class="title">F</span>[+<span class="title">_</span>], <span class="title">A</span>, <span class="title">B</span>] {</span>
  <span class="keyword">def</span> run(a: A): F[Store[B, A]]
  <span class="keyword">def</span> apply(a: A): F[Store[B, A]] = run(a)
  ...
}

<span class="class"><span class="keyword">object</span> <span class="title">LensT</span> <span class="keyword">extends</span> <span class="title">LensTFunctions</span> <span class="keyword">with</span> <span class="title">LensTInstances</span> {</span>
  <span class="keyword">def</span> apply[F[+_], A, B](r: A =&gt; F[Store[B, A]]): LensT[F, A, B] =
    lensT(r)
}

<span class="class"><span class="keyword">trait</span> <span class="title">LensTFunctions</span> {</span>
  <span class="keyword">import</span> StoreT._

  <span class="keyword">def</span> lensT[F[+_], A, B](r: A =&gt; F[Store[B, A]]): LensT[F, A, B] = <span class="keyword">new</span> LensT[F, A, B] {
    <span class="keyword">def</span> run(a: A): F[Store[B, A]] = r(a)
  }

  <span class="keyword">def</span> lensgT[F[+_], A, B](set: A =&gt; F[B =&gt; A], get: A =&gt; F[B])(implicit M: Bind[F]): LensT[F, A, B] =
    lensT(a =&gt; M(set(a), get(a))(Store(_, _)))
  <span class="keyword">def</span> lensg[A, B](set: A =&gt; B =&gt; A, get: A =&gt; B): Lens[A, B] =
    lensgT[Id, A, B](set, get)
  <span class="keyword">def</span> lensu[A, B](set: (A, B) =&gt; A, get: A =&gt; B): Lens[A, B] =
    lensg(set.curried, get)
  ...
}

<span class="keyword">type</span> Store[A, B] = StoreT[Id, A, B]
  <span class="comment">// flipped</span>
  <span class="keyword">type</span> |--&gt;[A, B] = Store[B, A]
  <span class="class"><span class="keyword">object</span> <span class="title">Store</span> {</span>
    <span class="keyword">def</span> apply[A, B](f: A =&gt; B, a: A): Store[A, B] = StoreT.store(a)(f)
}
</pre></td></tr></table></figure>

<h2 id="using-lens">Using Lens</h2>
<p>类似给类设置 get 和 set 方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>scala&gt; val turtlePosition = Lens<span class="preprocessor">.lensu</span>[Turtle, Point] (
         (a, value) =&gt; a<span class="preprocessor">.copy</span>(position = value),
         _<span class="preprocessor">.position</span>
       )
<span class="label">turtlePosition:</span> scalaz<span class="preprocessor">.Lens</span>[Turtle,Point] = scalaz<span class="preprocessor">.LensTFunctions</span>$$anon$5<span class="localvars">@421</span>dc8c8

scala&gt; val pointX = Lens<span class="preprocessor">.lensu</span>[Point, Double] (
         (a, value) =&gt; a<span class="preprocessor">.copy</span>(<span class="built_in">x</span> = value),
         _<span class="preprocessor">.x</span>
       )
<span class="label">pointX:</span> scalaz<span class="preprocessor">.Lens</span>[Point,Double] = scalaz<span class="preprocessor">.LensTFunctions</span>$$anon$5<span class="localvars">@30</span>d31cf9

scala&gt; val turtleX = turtlePosition &gt;=&gt; pointX
<span class="label">turtleX:</span> scalaz<span class="preprocessor">.LensT</span>[scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>,Turtle,Double] = scalaz<span class="preprocessor">.LensTFunctions</span>$$anon$5<span class="localvars">@11</span>b3536

scala&gt; val t0 = Turtle(Point(<span class="number">2.0</span>, <span class="number">3.0</span>), <span class="number">0.0</span>,
                  Color(<span class="number">255.</span>toByte, <span class="number">255.</span>toByte, <span class="number">255.</span>toByte))
<span class="label">t0:</span> Turtle = Turtle(Point(<span class="number">2.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

scala&gt; turtleX<span class="preprocessor">.get</span>(t0)
<span class="label">res16:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Double] = <span class="number">2.0</span>

scala&gt; turtleX<span class="preprocessor">.set</span>(t0, <span class="number">5.0</span>)
<span class="label">res17:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">5.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

scala&gt; turtleX<span class="preprocessor">.mod</span>(_ + <span class="number">1.0</span>, t0)
<span class="label">res19:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">3.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

// 柯里化
scala&gt; val incX = turtleX =&gt;= {_ + <span class="number">1.0</span>}
<span class="label">incX:</span> Turtle =&gt; scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = &lt;function1&gt;

scala&gt; incX(t0)
<span class="label">res26:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">3.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))
</pre></td></tr></table></figure>

<h2 id="lens-as-a-state-monad">Lens as a State monad</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>// %= method takes a function Double =&gt; Double
// <span class="keyword">and</span> returns a State monad that expresses the change.
scala&gt; val incX = for {
         <span class="built_in">x</span> &lt;- turtleX %= {_ + <span class="number">1.0</span>}
       } yield <span class="built_in">x</span>
<span class="label">incX:</span> scalaz<span class="preprocessor">.StateT</span>[scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>,Turtle,Double] = scalaz<span class="preprocessor">.StateT</span>$$anon$7<span class="localvars">@38</span>e61ffa

scala&gt; incX(t0)
<span class="label">res28:</span> (Turtle, Double) = (Turtle(Point(<span class="number">3.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>)),<span class="number">3.0</span>)

//  Instead of general %=, Scalaz even provides sugars like += for Numeric lenses
scala&gt; def forward(dist: Double) = for {
         heading &lt;- turtleHeading
         <span class="built_in">x</span> &lt;- turtleX += dist * math<span class="preprocessor">.cos</span>(heading)
         <span class="built_in">y</span> &lt;- turtleY += dist * math<span class="preprocessor">.sin</span>(heading)
       } yield (<span class="built_in">x</span>, <span class="built_in">y</span>)
<span class="label">forward:</span> (dist: Double)scalaz<span class="preprocessor">.StateT</span>[scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>,Turtle,(Double, Double)]

scala&gt; forward(<span class="number">10.0</span>)(t0)
<span class="label">res31:</span> (Turtle, (Double, Double)) = (Turtle(Point(<span class="number">12.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>)),(<span class="number">12.0</span>,<span class="number">3.0</span>))

scala&gt; forward(<span class="number">10.0</span>) exec (t0)
<span class="label">res32:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">12.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))
</pre></td></tr></table></figure>

<p>Lens 的一些其他方法的定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">LensT</span>[<span class="title">F</span>[+<span class="title">_</span>], <span class="title">A</span>, <span class="title">B</span>] {</span>
  <span class="keyword">def</span> get(a: A)(implicit F: Functor[F]): F[B] =
    F.map(run(a))(_.pos)
  <span class="keyword">def</span> set(a: A, b: B)(implicit F: Functor[F]): F[A] =
    F.map(run(a))(_.put(b))
  <span class="javadoc">/** Modify the value viewed through the lens */</span>
  <span class="keyword">def</span> mod(f: B =&gt; B, a: A)(implicit F: Functor[F]): F[A] = ...
  <span class="keyword">def</span> =&gt;=(f: B =&gt; B)(implicit F: Functor[F]): A =&gt; F[A] =
    mod(f, _)
  <span class="javadoc">/** Modify the portion of the state viewed through the lens and return its new value. */</span>
  <span class="keyword">def</span> %=(f: B =&gt; B)(implicit F: Functor[F]): StateT[F, A, B] =
    mods(f)
  <span class="javadoc">/** Lenses can be composed */</span>
  <span class="keyword">def</span> compose[C](that: LensT[F, C, A])(implicit F: Bind[F]): LensT[F, C, B] = ...
  <span class="javadoc">/** alias for `compose` */</span>
  <span class="keyword">def</span> &lt;=&lt;[C](that: LensT[F, C, A])(implicit F: Bind[F]): LensT[F, C, B] = compose(that)
  <span class="keyword">def</span> andThen[C](that: LensT[F, B, C])(implicit F: Bind[F]): LensT[F, A, C] =
    that compose <span class="keyword">this</span>
  <span class="javadoc">/** alias for `andThen` */</span>
  <span class="keyword">def</span> &gt;=&gt;[C](that: LensT[F, B, C])(implicit F: Bind[F]): LensT[F, A, C] = andThen(that)
}
</pre></td></tr></table></figure>

<h2 id="lens-laws">Lens laws</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>trait LensLaw {
  def identity(a: A)(implicit A: Equal[A], ev: F[Store[B, A]] =:= Id[Store[B, A]]): Boolean = {
    val c = <span class="command">run</span>(a)
    A.<span class="keyword">equal</span>(c.<span class="keyword">put</span>(c.pos), a)
  }
  def retention(a: A, b: B)(implicit B: Equal[B], ev: F[Store[B, A]] =:= Id[Store[B, A]]): Boolean =
    B.<span class="keyword">equal</span>(<span class="command">run</span>(<span class="command">run</span>(a) <span class="keyword">put</span> b).pos, b)
  def doubleSet(a: A, b1: B, b2: B)(implicit A: Equal[A], ev: F[Store[B, A]] =:= Id[Store[B, A]]) = {
    val r = <span class="command">run</span>(a)
    A.<span class="keyword">equal</span>(<span class="command">run</span>(r <span class="keyword">put</span> b1) <span class="keyword">put</span> b2, r <span class="keyword">put</span> b2)
  }
}
</pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/scala/">scala</a><a href="/tags/scalaz/">scalaz</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://zhpooer.github.io/2014/07/30/learning-scalaz-进阶2/" data-title="learning scalaz 进阶2 | Poe&#39;s World" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/07/30/learning-scalaz-进阶3/" title="learning scalaz 进阶3">
  <strong>PREVIOUS:</strong><br/>
  <span>
  learning scalaz 进阶3</span>
</a>
</div>


<div class="next">
<a href="/2014/07/29/learning-scalaz-进阶/"  title="learning scalaz 进阶">
 <strong>NEXT:</strong><br/> 
 <span>learning scalaz 进阶
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#applicative-builder"><span class="toc-number">1.</span> <span class="toc-text">Applicative Builder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#state-and-statet"><span class="toc-number">2.</span> <span class="toc-text">State and StateT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#either"><span class="toc-number">3.</span> <span class="toc-text">Either</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#validation"><span class="toc-number">4.</span> <span class="toc-text">Validation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nonemptylist-nel-"><span class="toc-number">5.</span> <span class="toc-text">NonEmptyList(Nel)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#some-useful-monadic-functions"><span class="toc-number">6.</span> <span class="toc-text">Some useful monadic functions</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#join"><span class="toc-number">6.1.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filterm"><span class="toc-number">6.2.</span> <span class="toc-text">filterM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foldleftm"><span class="toc-number">6.3.</span> <span class="toc-text">foldLeftM</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#making-a-safe-rpn-calculator"><span class="toc-number">7.</span> <span class="toc-text">Making a safe RPN calculator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#composing-monadic-functions"><span class="toc-number">8.</span> <span class="toc-text">Composing monadic functions</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#kleisli"><span class="toc-number">8.1.</span> <span class="toc-text">Kleisli</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reader"><span class="toc-number">8.2.</span> <span class="toc-text">Reader</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#making-monads"><span class="toc-number">9.</span> <span class="toc-text">Making monads</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tree"><span class="toc-number">10.</span> <span class="toc-text">Tree</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#treeloc"><span class="toc-number">10.1.</span> <span class="toc-text">TreeLoc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zipper"><span class="toc-number">10.2.</span> <span class="toc-text">Zipper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#id"><span class="toc-number">10.3.</span> <span class="toc-text">Id</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#lawless-typeclasses"><span class="toc-number">11.</span> <span class="toc-text">Lawless typeclasses</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#length"><span class="toc-number">11.1.</span> <span class="toc-text">Length</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#index"><span class="toc-number">11.2.</span> <span class="toc-text">Index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#each"><span class="toc-number">11.3.</span> <span class="toc-text">Each</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#monad-transformers"><span class="toc-number">12.</span> <span class="toc-text">Monad transformers</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reader-yet-again"><span class="toc-number">12.1.</span> <span class="toc-text">Reader, yet again</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#readert"><span class="toc-number">12.2.</span> <span class="toc-text">ReaderT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stacking-multiple-monad-transformers"><span class="toc-number">12.3.</span> <span class="toc-text">Stacking multiple monad transformers</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#lens"><span class="toc-number">13.</span> <span class="toc-text">Lens</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#using-lens"><span class="toc-number">13.1.</span> <span class="toc-text">Using Lens</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lens-as-a-state-monad"><span class="toc-number">13.2.</span> <span class="toc-text">Lens as a State monad</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lens-laws"><span class="toc-number">13.3.</span> <span class="toc-text">Lens laws</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AJAX/" title="AJAX">AJAX<sup>1</sup></a></li>
		
			<li><a href="/tags/Akka/" title="Akka">Akka<sup>1</sup></a></li>
		
			<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
		
			<li><a href="/tags/EL表达式/" title="EL表达式">EL表达式<sup>1</sup></a></li>
		
			<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>1</sup></a></li>
		
			<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>2</sup></a></li>
		
			<li><a href="/tags/HttpSession/" title="HttpSession">HttpSession<sup>1</sup></a></li>
		
			<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
		
			<li><a href="/tags/JSP/" title="JSP">JSP<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaBean/" title="JavaBean">JavaBean<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/tags/Mybatis/" title="Mybatis">Mybatis<sup>1</sup></a></li>
		
			<li><a href="/tags/NoSql/" title="NoSql">NoSql<sup>1</sup></a></li>
		
			<li><a href="/tags/SAX/" title="SAX">SAX<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletRequest/" title="ServletRequest">ServletRequest<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletResponse/" title="ServletResponse">ServletResponse<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring MVC/" title="Spring MVC">Spring MVC<sup>1</sup></a></li>
		
			<li><a href="/tags/String/" title="String">String<sup>1</sup></a></li>
		
			<li><a href="/tags/StringBuffer/" title="StringBuffer">StringBuffer<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://zhpooer.github.io" target="_blank" title="zhpooer">zhpooer</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhpoooer"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
