
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Play for Scala-the persistence layer | Poe&#39;s World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhpooer">
    
    <meta name="description" content="What are Anorm and Squeryl?
In order to talk to the database, you’ll have to create SQL at some point.
A modern object-relation mapper (ORM) like Hibe">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Poe&#39;s World" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Poe&#39;s World" title="Poe&#39;s World"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Poe&#39;s World">Poe&#39;s World</a></h1>
				<h2 class="blog-motto">竹杖芒鞋轻胜马，一蓑烟雨任平生</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/english-monthly">英语角</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zhpooer.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/11/play-for-scala-the-persistence-layer/" title="Play for Scala-the persistence layer" itemprop="url">Play for Scala-the persistence layer</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://zhpooer.github.io" title="zhpooer">zhpooer</a>
    </p>
  <p class="article-time">
    <time datetime="2014-08-11T00:00:25.000Z" itemprop="datePublished">8月 11 2014</time>
    更新日期:<time datetime="2014-08-12T03:33:03.766Z" itemprop="dateModified">8月 12 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#what-are-anorm-and-squeryl-"><span class="toc-number">1.</span> <span class="toc-text">What are Anorm and Squeryl?</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#configuring-your-database"><span class="toc-number">1.1.</span> <span class="toc-text">Configuring your database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#creating-the-schema"><span class="toc-number">1.2.</span> <span class="toc-text">Creating the schema</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#using-anorm"><span class="toc-number">2.</span> <span class="toc-text">Using Anorm</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-your-model"><span class="toc-number">2.1.</span> <span class="toc-text">Defining your model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-anorm-s-stream-api"><span class="toc-number">2.2.</span> <span class="toc-text">Using Anorm’s stream API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pattern-matching-results"><span class="toc-number">2.3.</span> <span class="toc-text">Pattern matching results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parsing-results"><span class="toc-number">2.4.</span> <span class="toc-text">Parsing results</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#building-a-single-record-parser"><span class="toc-number">2.4.1.</span> <span class="toc-text">BUILDING A SINGLE-RECORD PARSER</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#building-a-multirecord-parser"><span class="toc-number">2.5.</span> <span class="toc-text">BUILDING A MULTIRECORD PARSER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inserting-updating-and-deleting-data"><span class="toc-number">2.6.</span> <span class="toc-text">Inserting, updating, and deleting data</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#using-squeryl"><span class="toc-number">3.</span> <span class="toc-text">Using Squeryl</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#plugging-squeryl-in"><span class="toc-number">3.1.</span> <span class="toc-text">Plugging Squeryl in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-your-model"><span class="toc-number">3.2.</span> <span class="toc-text">Defining your model</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#immutability-and-threads"><span class="toc-number">3.2.1.</span> <span class="toc-text">IMMUTABILITY AND THREADS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defining-the-schema"><span class="toc-number">3.2.2.</span> <span class="toc-text">DEFINING THE SCHEMA</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#extracting-data-queries"><span class="toc-number">3.3.</span> <span class="toc-text">Extracting data—queries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#saving-records"><span class="toc-number">3.4.</span> <span class="toc-text">Saving records</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handling-transactions"><span class="toc-number">3.5.</span> <span class="toc-text">Handling transactions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#entity-relations"><span class="toc-number">3.6.</span> <span class="toc-text">Entity relations</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stateful-relations"><span class="toc-number">3.6.1.</span> <span class="toc-text">STATEFUL RELATIONS</span></a></li></ol></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#caching-data"><span class="toc-number">4.</span> <span class="toc-text">Caching data</span></a></li></ol>
		</div>
		
		<h1 id="what-are-anorm-and-squeryl-">What are Anorm and Squeryl?</h1>
<p>In order to talk to the database, you’ll have to create SQL at some point.
A modern object-relation mapper (ORM) like Hibernate or the Java Persistence API (JPA)
provides its own query language (HQL and JPQL, respectively), which is then translated
into the target database’s SQL dialect.</p>
<p>Anorm and Squeryl are at opposite ends of the SQL-generation/translation spectrum.</p>
<p>Squeryl generates SQL by providing a Scala domain-specific language ( DSL)
that’s similar to actual SQL. Anorm doesn’t generate any SQL, and instead
relies on the developer to write SQL. </p>
<ul>
<li>Anorm allows you to write any SQL that you can come up with, even using
proprietary extensions of the particular database that you’re using.</li>
<li>Squeryl’s DSL allows the compiler to check that your queries are correct, which
meshes well with Play’s emphasis on type safety.</li>
</ul>
<h2 id="configuring-your-database">Configuring your database</h2>
<p>Play comes with support for an H2 in-memory database out of the box, but there’s no
database configured by default. </p>
<p><code>conf/application.conf</code>, 要配置其他的数据库, 可以注释掉</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span>=org<span class="preprocessor">.h</span>2<span class="preprocessor">.Driver</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=<span class="string">"jdbc:h2:mem:play"</span>
</pre></td></tr></table></figure>

<p>An in-memory database is fine for development and testing but doesn’t cut it
for most production environments.</p>
<p><code>Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val appDependencies = Se<span class="string">q(
  jdbc,
  anorm,
  "postgresql" % "postgresql" % "9.1-901.jdbc4"
)</span>
</pre></td></tr></table></figure>

<p><code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db<span class="preprocessor">.default</span><span class="preprocessor">.user</span>=user
db<span class="preprocessor">.default</span><span class="preprocessor">.password</span>=qwerty
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=<span class="string">"jdbc:postgresql://localhost:5432/paperclips"</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span>=org<span class="preprocessor">.postgresql</span><span class="preprocessor">.Driver</span>
</pre></td></tr></table></figure>

<h2 id="creating-the-schema">Creating the schema</h2>
<p>Anorm can’t create your schema for you because it doesn’t know anything about your model.
Squeryl can create your schema for you, but it’s unable to update it. This means
you’ll have to write the SQL commands to create (and later update) your schema yourself.</p>
<p>Play does offer some help in the form of evolutions. To use evolutions, you write an
SQL script for each revision of your database; Play will then automatically detect that a
database needs to be upgraded and will do so after asking for your permission.</p>
<p>Evolutions scripts should be placed in the <code>conf/evolutions/default</code> directory
and be named <code>1.sql</code> for the first revision, <code>2.sql</code> for the second, and so on.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre># <span class="comment">--- !Ups</span>
<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (
  id long,
  ean long,
  name <span class="keyword">varchar</span>,
  description <span class="keyword">varchar</span>);</span>
  
<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> warehouses (
  id long,
  name <span class="keyword">varchar</span>);</span>

<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_items (
  id long,
  product_id long,
  warehouse_id long,
  quantity long);</span>

# <span class="comment">--- !Downs</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> products;</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> warehouses;</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> stock_items;</span>
</pre></td></tr></table></figure>

<p>Just click the red button labeled “Apply this script now!”</p>
<h1 id="using-anorm">Using Anorm</h1>
<p>Anorm lets you write SQL queries and provides an API to parse result sets. </p>
<p>When you retrieve data with Anorm, there are three ways to
process the results: the Stream API, pattern matching, and parser combinators. </p>
<h2 id="defining-your-model">Defining your model</h2>
<p>Therefore, your model is simply a bunch of classes that represent the entities
that you want to use in your application and store in the database.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="keyword">class</span> Product(
  id: <span class="built_in">Long</span>,
  ean: <span class="built_in">Long</span>,
  name: <span class="built_in">String</span>,
  description: <span class="built_in">String</span>)
<span class="keyword">case</span> <span class="keyword">class</span> Warehouse(id: <span class="built_in">Long</span>, name: <span class="built_in">String</span>)

<span class="keyword">case</span> <span class="keyword">class</span> StockItem(
  id: <span class="built_in">Long</span>,
  productId: <span class="built_in">Long</span>,
  warehouseId: <span class="built_in">Long</span>,
  quantity: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h2 id="using-anorm-s-stream-api">Using Anorm’s stream API</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">import</span> anorm.SQL
<span class="keyword">import</span> anorm.SqlQuery

// The apply method has an implicit parameter
// block that takes a java.sql.Connection
// which Play provides <span class="keyword">in</span> the form of DB.withConnection.
val sql: SqlQuery = SQL(<span class="string">"select * from products order by name asc"</span>)

<span class="keyword">import</span> play.api.Play.current
<span class="keyword">import</span> play.api.db.DB

<span class="function"><span class="keyword">def</span> <span class="title">getAll</span>:</span>List[Product] = DB.withConnection{
    implicity connection =&gt;
    sql().map(row =&gt;
        Product(row[Long](<span class="string">"id"</span>), row[Long](<span class="string">"ean"</span>),
                row[String](<span class="string">"name"</span>), row[String](<span class="string">"description"</span>))
    ).toList
}
</pre></td></tr></table></figure>

<p>The <code>row</code> variable in the function body passed to map is an <code>SqlRow</code> ,
which has an apply method that retrieves the requested field by name.</p>
<h2 id="pattern-matching-results">Pattern matching results</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">getAllWithPatterns</span>:</span> List[Product] = DB.withConnection {
  implicit connection =&gt;
  <span class="keyword">import</span> anorm.Row
  sql().collect {
    case Row(Some(id: Long), Some(ean: Long),
             Some(name: String), Some(description: String)) =&gt;
      Product(id, ean, name, description)
  }.toList
}
</pre></td></tr></table></figure>

<p>We’ve said before that the query’s apply method returns a standard Scala <code>Stream</code>.</p>
<p>Streams are simply lists that haven’t computed—or in this case retrieved—their
contents yet. This is why we had to convert
them to Lists with toList to actually retrieve the contents.</p>
<h2 id="parsing-results">Parsing results</h2>
<p>You can also parse results with parser combinators,1 a functional programming
technique for building parsers by combining other parsers,</p>
<h3 id="building-a-single-record-parser">BUILDING A SINGLE-RECORD PARSER</h3>
<p>We’ll need to retrieve (and therefore parse) our entities many times, so it’s a good
idea to build parsers for each of our entities.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">import</span> anorm.RowParser
val productParser: RowParser[Product] = {
  <span class="keyword">import</span> anorm.~
  <span class="keyword">import</span> anorm.SqlParser._
  long(<span class="string">"id"</span>) ~
  long(<span class="string">"ean"</span>) ~
  str(<span class="string">"name"</span>) ~
  str(<span class="string">"description"</span>) map {
    case id ~ ean ~ name ~ description =&gt;
      Product(id, ean, name, description)
  }
}

<span class="keyword">import</span> anorm.ResultSetParser
// Anorm needs a ResultSetParser 
val productsParser: ResultSetParser[List[Product]] = {
  productParser *
}

// 查询结果
<span class="function"><span class="keyword">def</span> <span class="title">getAllWithParser</span>:</span> List[Product] = DB.withConnection {
  implicit connection =&gt;
  sql.<span class="keyword">as</span>(productsParser)
}
</pre></td></tr></table></figure>

<h2 id="building-a-multirecord-parser">BUILDING A MULTIRECORD PARSER</h2>
<p>To fetch stock item data, we’ll use SQL to query the <code>products</code> and
<code>stock_items</code> database tables.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>val stockItemParser: RowParser[StockItem] = {
  <span class="keyword">import</span> anorm.SqlParser._
  <span class="keyword">import</span> anorm.~
  long(<span class="string">"id"</span>) ~ long(<span class="string">"product_id"</span>) ~
  long(<span class="string">"warehouse_id"</span>) ~ long(<span class="string">"quantity"</span>) map {
    case id ~ productId ~ warehouseId ~ quantity =&gt;
      StockItem(id, productId, warehouseId, quantity)
  }
}

<span class="function"><span class="keyword">def</span> <span class="title">productStockItemParser</span>:</span> RowParser[(Product, StockItem)] = {
  <span class="keyword">import</span> anorm.SqlParser._
  <span class="keyword">import</span> anorm.~
  // flatten (<span class="keyword">in</span> map (flatten) ) turns the given ~[Product, StockItem] into a standard tuple.
  productParser ~ StockItem.stockItemParser map (flatten)
}

<span class="function"><span class="keyword">def</span> <span class="title">getAllProductsWithStockItems</span>:</span> Map[Product, List[StockItem]] = {
  DB.withConnection { implicit connection =&gt;
    val sql = SQL(<span class="string">"select p.*, s.* "</span> +
                  <span class="string">"from products p "</span> +
                  <span class="string">"inner join stock_items s on (p.id = s.product_id)"</span>)
    val results: List[(Product, StockItem)] =
    sql.<span class="keyword">as</span>(productStockItemParser *)
    //  Map[Product, StockItem] =&gt;
    //  Map[Product, List[(Product, StockItem)]] =&gt; 
    //  Map[Product, List[StockItem]]
    results.groupBy { _._1 }.mapValues { _.map { _._2 } }
  }
}
</pre></td></tr></table></figure>

<h2 id="inserting-updating-and-deleting-data">Inserting, updating, and deleting data</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="keyword">def</span> insert(product: Product): Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> addedRows =
      SQL(<span class="string">"""insert
             into products
             values ({id}, {ean}, {name}, {description})"""</span>).on(
               <span class="string">"id"</span> -&gt; product.id,
               <span class="string">"ean"</span> -&gt; product.ean,
               <span class="string">"name"</span> -&gt; product.name,
               <span class="string">"description"</span> -&gt; product.description
      ).executeUpdate()
  addedRows == <span class="number">1</span>
}

<span class="keyword">def</span> update(product: Product):Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> updateRows =
      SQL(<span class="string">"""update products
             set name = {name},
             ean = {ean},
             description = {description},
             where id = {id}
      """</span>).on (
        <span class="string">"id"</span> -&gt; product.id,
        <span class="string">"name"</span> -&gt; product.name,
        <span class="string">"ean"</span> -&gt; product.ean,
        <span class="string">"description"</span> -&gt; product.description
      ).executeUpdate()
    updatedRows == <span class="number">1</span>
  }

<span class="keyword">def</span> delete(product: Product): Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> updatedRows = SQL(<span class="string">"delete from products where id = {id}"</span>).
    on(<span class="string">"id"</span> -&gt; product.id).executeUpdate()
    updatedRows == <span class="number">0</span>
  }
</pre></td></tr></table></figure>

<h1 id="using-squeryl">Using Squeryl</h1>
<p>This means that Squeryl is an ORM that gives you a feature that other
ORMs don’t: a type-safe query language.</p>
<p>You can write queries in a language that the Scala compiler understands,
and you’ll find out whether there are errors in your queries at compile time.</p>
<p>Contrast this with other ORMs (or Anorm—Anorm is not an ORM) that rely
on the database to tell you that there are errors in your query,
and don’t complain until the queries are actually run.</p>
<h2 id="plugging-squeryl-in">Plugging Squeryl in</h2>
<p><code>project/Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>val appDependencies = <span class="constant">Seq</span>(
  jdbc,
  <span class="string">"org.squeryl"</span> <span class="string">%% "squeryl" %</span> <span class="string">"0.9.5-6"</span>
)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.adapters.H2Adapter
<span class="keyword">import</span> org.squeryl.{Session, SessionFactory}
<span class="keyword">import</span> play.api.db.DB
<span class="keyword">import</span> play.api.{Application, GlobalSettings}

<span class="class"><span class="keyword">object</span> <span class="title">Global</span> <span class="keyword">extends</span> <span class="title">GlobalSettings</span> {</span>
  <span class="keyword">override</span> <span class="keyword">def</span> onStart(app: Application) {
    SessionFactory.concreteFactory = Some(() =&gt;
      Session.create(DB.getConnection()(app), <span class="keyword">new</span> H2Adapter) )
  }
}
<span class="comment">// DB.getConnection is intended to be used in an environment where an</span>
<span class="comment">// Application is available as an</span>
<span class="comment">// implicit, and you can call it without the second parameter list.</span>
implicit <span class="keyword">val</span> implicitApp = app
DB.getConnection()
</pre></td></tr></table></figure>

<h2 id="defining-your-model">Defining your model</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.KeyedEntity

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(
  id: Long,
  ean: Long,
  name: String,
  description: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>
  
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Warehouse</span><span class="params">(
  id: Long,
  name: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StockItem</span><span class="params">(
  id: Long,
  product: Long,
  location: Long,
  quantity: Long)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>
</pre></td></tr></table></figure>

<p>The only thing that’s different from vanilla case classes here is that
we’re extending <code>KeyedEntity</code>. This tells Squeryl that it can use the
id for updates and deletes.</p>
<h3 id="immutability-and-threads">IMMUTABILITY AND THREADS</h3>
<p>When an object is immutable, you can only change it by making a copy.
This ensures that other threads that have a
reference to the same object won’t be affected by the changes.</p>
<h3 id="defining-the-schema">DEFINING THE SCHEMA</h3>
<p><code>org.squeryl.Schema</code> contains some utility methods and will allow
us to group our entity classes in such a way that Squeryl can make sense of them.</p>
<p>We’ve defined three classes to contain records, and we’ve
told Squeryl which tables we want it to create and how to map them to our model.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.Schema
<span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._

<span class="class"><span class="keyword">object</span> <span class="title">Database</span> <span class="keyword">extends</span> <span class="title">Schema</span> {</span>
  <span class="comment">// The table method returns a table for the</span>
  <span class="comment">// class specified as the type parameter</span>
  <span class="keyword">val</span> productsTable: Table[Product] =
    table[Product](<span class="string">"products"</span>)
  <span class="keyword">val</span> stockItemsTable: Table[StockItem] =
    table[StockItem](<span class="string">"stock_items"</span>)
  <span class="keyword">val</span> warehousesTable: Table[Warehouse] =
    table[Warehouse](<span class="string">"warehouses"</span>)
    
  on(productsTable) { p =&gt; declare {
    p.id is(autoIncremented)
  }}
  
  on(stockItemsTable) { s =&gt; declare {
    s.id is(autoIncremented)
  }}
  
  on(warehousesTable) { w =&gt; declare {
    w.id is(autoIncremented)
  }}
}
</pre></td></tr></table></figure>

<p>Squeryl does define a create method that creates the schema when
called from the Database object.</p>
<h2 id="extracting-data-queries">Extracting data—queries</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._
<span class="keyword">import</span> org.squeryl.Table
<span class="keyword">import</span> org.squeryl.Query
<span class="keyword">import</span> collection.Iterable
object Product {
  <span class="keyword">import</span> Database.{productsTable, stockItemsTable}
  // product: Query result row name
  <span class="function"><span class="keyword">def</span> <span class="title">allQ</span>:</span> Query[Product] = <span class="keyword">from</span>(productsTable) {
    product =&gt; select(product) orderBy(product.name desc)
  }
}

// it also extends Iterable
<span class="function"><span class="keyword">def</span> <span class="title">findAll</span>:</span> Iterable[Product] = inTransaction {
  allQ.toList
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def productsInWarehouse(<span class="attribute">warehouse</span>: Warehouse) = {
  join<span class="function"><span class="params">(productsTable, stockItemsTable)((product, stockItem) =&gt;
    where(stockItem.location === warehouse.id).
    select(product).
    <span class="literal">on</span>(stockItem.product === product.id)
  )</span>
}
<span class="title">def</span> <span class="title">productsInWarehouseByName</span><span class="params">(name: String, warehouse: Warehouse)</span>: <span class="title">Query</span>[<span class="title">Product</span>]= {
  <span class="title">from</span><span class="params">(productsInWarehouse(warehouse))</span>{ <span class="title">product</span> =&gt;</span>
    where(product.name like name).select(product)
  }
}
</pre></td></tr></table></figure>

<h2 id="saving-records">Saving records</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>def insert(product: <span class="keyword">Product</span>): <span class="keyword">Product</span> = inTransaction <span class="list">{
  productsTable.insert(product)
}</span>

def update(product: <span class="keyword">Product</span>) <span class="list">{
  inTransaction { productsTable.update(product) }</span>
}
</pre></td></tr></table></figure>

<p>如果不这样, 那么插入时会产生 原先的 id 会变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(product: Product)</span>:</span> Product = inTransaction {
  val defensiveCopy = product.copy
  productsTable.insert(defensiveCopy)
}

val myImmutableObject = Product(<span class="number">0</span>, <span class="number">5010255079763l</span>,
  <span class="string">"plastic coated blue"</span>,
  <span class="string">"standard paperclip, coated with blue plastic"</span>)
Database.productsTable.insert(myImmutableObject)
// id 会变成 xxx
println(myImmutableObject)
</pre></td></tr></table></figure>

<h2 id="handling-transactions">Handling transactions</h2>
<p>In order to ensure your database’s data integrity, you’ll want to use transactions.
Databases that provide transactions guarantee that all write operations
in the same transaction will either succeed together or fail together.</p>
<p>Squeryl provides two methods for working with transactions: <code>transaction</code> and
<code>inTransaction</code>.</p>
<p>The difference is that transaction always makes its own transaction and
inTransaction only makes a transaction (and eventually commits) if it’s not already
in a transaction.</p>
<p>This means that because our DAO methods wrap everything in an
inTransaction, they themselves can be wrapped in a transaction and succeed or fail
together and never separately.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>import models.{ Database, Product, StockItem }
import org<span class="preprocessor">.squeryl</span><span class="preprocessor">.PrimitiveTypeMode</span><span class="preprocessor">.transaction</span>
import Database.{productsTable, stockItemsTable}

def addNewProductGood(product: Product, stockItem: StockItem) {
  transaction {
    productsTable<span class="preprocessor">.insert</span>(product)
    stockItemsTable<span class="preprocessor">.insert</span>(stockItem)
  }
}

// 不推荐
def addNewProductBad(product: Product, stockItem: StockItem) {
  productsTable<span class="preprocessor">.insert</span>(product)
  stockItemsTable<span class="preprocessor">.insert</span>(stockItem)
}
</pre></td></tr></table></figure>

<h2 id="entity-relations">Entity relations</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._
<span class="keyword">import</span> org.squeryl.dsl.{OneToMany, ManyToOne}
<span class="keyword">import</span> org.squeryl.{Query, Schema, KeyedEntity, Table}

<span class="class"><span class="keyword">object</span> <span class="title">Database</span> <span class="keyword">extends</span> <span class="title">Schema</span> {</span>
  <span class="keyword">val</span> productsTable = table[Product](<span class="string">"products"</span>)
  <span class="keyword">val</span> warehousesTable = table[Warehouse](<span class="string">"warehouses"</span>)
  <span class="keyword">val</span> stockItemsTable = table[StockItem](<span class="string">"stockItems"</span>)

  <span class="keyword">val</span> productToStockItems =
    oneToManyRelation(productsTable, stockItemsTable).
      via((p,s) =&gt; p.id === s.productId)

  <span class="keyword">val</span> warehouseToStockItems =
    oneToManyRelation(warehousesTable, stockItemsTable).
      via((w,s) =&gt; w.id === s.warehouseId)
}


<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(
  id: Long,
  ean: Long,
  name: String,
  description: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> stockItems: OneToMany[StockItem] =
    Database.productToStockItems.left(<span class="keyword">this</span>)
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Warehouse</span><span class="params">(
  id: Long,
  name: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> stockItems: OneToMany[StockItem] =
    Database.warehouseToStockItems.left(<span class="keyword">this</span>)
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StockItem</span><span class="params">(
  id: Long,
  productId: Long,
  warehouseId: Long,
  quantity: Long)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> product: ManyToOne[Product] =
    Database.productToStockItems.right(<span class="keyword">this</span>)
  <span class="keyword">lazy</span> <span class="keyword">val</span> warehouse: ManyToOne[Warehouse] =
    Database.warehouseToStockItems.right(<span class="keyword">this</span>)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>def getStockItems(product: Product) =
  inTransaction {
    product<span class="preprocessor">.stockItems</span><span class="preprocessor">.toList</span>
  }

def getLargeStockQ(product: Product, quantity: Long) =
  from(product<span class="preprocessor">.stockItems</span>) ( s =&gt;
    where(s<span class="preprocessor">.quantity</span> gt quantity)
      select(s)
  )
</pre></td></tr></table></figure>

<p>Obviously, you need to be able to add stock items to products and warehouses. You
could set the foreign keys in each stock item by hand, which is simple enough, but
Squeryl offers some help here.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// 建立外键联系
product<span class="preprocessor">.stockItems</span><span class="preprocessor">.assign</span>(stockItem)
warehouse<span class="preprocessor">.stockItems</span><span class="preprocessor">.assign</span>(stockItem)
transaction { Database<span class="preprocessor">.stockItemsTable</span><span class="preprocessor">.insert</span>(stockItem) }

// The difference between assign <span class="keyword">and</span> associate is
// that associate also saves the stock item
transaction {
  product<span class="preprocessor">.stockItems</span><span class="preprocessor">.associate</span>(stockItem)
  warehouse<span class="preprocessor">.stockItems</span><span class="preprocessor">.associate</span>(stockItem)
}
</pre></td></tr></table></figure>

<h3 id="stateful-relations">STATEFUL RELATIONS</h3>
<p>Instead of providing queries, Squeryl’s stateful relations
provide collections of related entities that you can access directly.</p>
<p>You only need to change the call to
left to leftStateful and similarly right to rightStateful:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">lazy</span> <span class="keyword">val</span> stockItems =
  Database.productToStockItems.leftStateful(<span class="keyword">this</span>)
</pre></td></tr></table></figure>

<p>You’ll have problems instantiating entities out-
side of a transaction.</p>
<p><code>StatefulOneToMany</code> has an associate method that does the same thing as its non-
stateful counterpart, but it doesn’t have an assign method.</p>
<p>Apart from that, there’s a refresh method that refreshes the list from the database. </p>
<h1 id="caching-data">Caching data</h1>
<p>Any database worth its salt will cache results for queries it encounters often. But
you’re still dealing with the overhead of talking to the database, and there are usually
more queries hitting the database, which may push these results out of the cache or
invalidate them eagerly. </p>
<p>An application cache can be more useful than a database cache, because it knows
what it’s doing with the data and can make informed decisions about when to invali-
date what.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>def insert(product: Product) {
  val insertedProduct = Product.insert(product)
  Cache.set("product-" + product.id, product)
}

def show(productId: Long) {
  Cache.getAs[<span class="link_label">Product</span>](<span class="link_url">"product-" + productId</span>) match {
<span class="code">    case Some(product) =&gt; Ok(product)</span>
<span class="code">    case None =&gt; Ok(Product.findById(productId))</span>
  }
}
</pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/scala/">scala</a><a href="/tags/play/">play</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://zhpooer.github.io/2014/08/11/play-for-scala-the-persistence-layer/" data-title="Play for Scala-the persistence layer | Poe&#39;s World" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/08/11/传智播客day66-hadoop-hdfs/" title="传智播客day66-Hadoop HDFS">
  <strong>PREVIOUS:</strong><br/>
  <span>
  传智播客day66-Hadoop HDFS</span>
</a>
</div>


<div class="next">
<a href="/2014/08/10/传智播客day65-hadoop入门/"  title="传智播客day65-Hadoop入门">
 <strong>NEXT:</strong><br/> 
 <span>传智播客day65-Hadoop入门
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#what-are-anorm-and-squeryl-"><span class="toc-number">1.</span> <span class="toc-text">What are Anorm and Squeryl?</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#configuring-your-database"><span class="toc-number">1.1.</span> <span class="toc-text">Configuring your database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#creating-the-schema"><span class="toc-number">1.2.</span> <span class="toc-text">Creating the schema</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#using-anorm"><span class="toc-number">2.</span> <span class="toc-text">Using Anorm</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-your-model"><span class="toc-number">2.1.</span> <span class="toc-text">Defining your model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-anorm-s-stream-api"><span class="toc-number">2.2.</span> <span class="toc-text">Using Anorm’s stream API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pattern-matching-results"><span class="toc-number">2.3.</span> <span class="toc-text">Pattern matching results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parsing-results"><span class="toc-number">2.4.</span> <span class="toc-text">Parsing results</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#building-a-single-record-parser"><span class="toc-number">2.4.1.</span> <span class="toc-text">BUILDING A SINGLE-RECORD PARSER</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#building-a-multirecord-parser"><span class="toc-number">2.5.</span> <span class="toc-text">BUILDING A MULTIRECORD PARSER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inserting-updating-and-deleting-data"><span class="toc-number">2.6.</span> <span class="toc-text">Inserting, updating, and deleting data</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#using-squeryl"><span class="toc-number">3.</span> <span class="toc-text">Using Squeryl</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#plugging-squeryl-in"><span class="toc-number">3.1.</span> <span class="toc-text">Plugging Squeryl in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defining-your-model"><span class="toc-number">3.2.</span> <span class="toc-text">Defining your model</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#immutability-and-threads"><span class="toc-number">3.2.1.</span> <span class="toc-text">IMMUTABILITY AND THREADS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defining-the-schema"><span class="toc-number">3.2.2.</span> <span class="toc-text">DEFINING THE SCHEMA</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#extracting-data-queries"><span class="toc-number">3.3.</span> <span class="toc-text">Extracting data—queries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#saving-records"><span class="toc-number">3.4.</span> <span class="toc-text">Saving records</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handling-transactions"><span class="toc-number">3.5.</span> <span class="toc-text">Handling transactions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#entity-relations"><span class="toc-number">3.6.</span> <span class="toc-text">Entity relations</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stateful-relations"><span class="toc-number">3.6.1.</span> <span class="toc-text">STATEFUL RELATIONS</span></a></li></ol></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#caching-data"><span class="toc-number">4.</span> <span class="toc-text">Caching data</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AJAX/" title="AJAX">AJAX<sup>1</sup></a></li>
		
			<li><a href="/tags/Akka/" title="Akka">Akka<sup>1</sup></a></li>
		
			<li><a href="/tags/Android/" title="Android">Android<sup>1</sup></a></li>
		
			<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
		
			<li><a href="/tags/EL表达式/" title="EL表达式">EL表达式<sup>1</sup></a></li>
		
			<li><a href="/tags/HBase/" title="HBase">HBase<sup>1</sup></a></li>
		
			<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>1</sup></a></li>
		
			<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>2</sup></a></li>
		
			<li><a href="/tags/HttpSession/" title="HttpSession">HttpSession<sup>1</sup></a></li>
		
			<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
		
			<li><a href="/tags/Illustrator/" title="Illustrator">Illustrator<sup>3</sup></a></li>
		
			<li><a href="/tags/JSP/" title="JSP">JSP<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaBean/" title="JavaBean">JavaBean<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/tags/Mybatis/" title="Mybatis">Mybatis<sup>1</sup></a></li>
		
			<li><a href="/tags/NoSql/" title="NoSql">NoSql<sup>1</sup></a></li>
		
			<li><a href="/tags/SASS/" title="SASS">SASS<sup>1</sup></a></li>
		
			<li><a href="/tags/SAX/" title="SAX">SAX<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletRequest/" title="ServletRequest">ServletRequest<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletResponse/" title="ServletResponse">ServletResponse<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://zhpooer.github.io" target="_blank" title="zhpooer">zhpooer</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhpoooer"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
