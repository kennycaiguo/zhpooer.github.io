
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Akka in Action-Message Channels &amp; Finite State Machines | Poe&#39;s World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhpooer">
    
    <meta name="description" content="Chinnel types
Other names which are often used for these kind of channels are EventQueue or
EventBus. Akka has an EventStream which implements a publi">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Poe&#39;s World" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Poe&#39;s World" title="Poe&#39;s World"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Poe&#39;s World">Poe&#39;s World</a></h1>
				<h2 class="blog-motto">竹杖芒鞋轻胜马，一蓑烟雨任平生</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/english-monthly">英语角</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zhpooer.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/05/akka-in-action-message-channels/" title="Akka in Action-Message Channels &amp; Finite State Machines" itemprop="url">Akka in Action-Message Channels &amp; Finite State Machines</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://zhpooer.github.io" title="zhpooer">zhpooer</a>
    </p>
  <p class="article-time">
    <time datetime="2014-08-05T03:11:47.000Z" itemprop="datePublished">8月 5 2014</time>
    更新日期:<time datetime="2014-08-05T14:26:35.000Z" itemprop="dateModified">8月 5 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chinnel-types"><span class="toc-number">1.</span> <span class="toc-text">Chinnel types</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#point-to-point"><span class="toc-number">1.1.</span> <span class="toc-text">Point to Point</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#publish-subscribe"><span class="toc-number">1.2.</span> <span class="toc-text">Publish subscribe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#custom-eventbus"><span class="toc-number">1.3.</span> <span class="toc-text">CUSTOM EVENTBUS</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#specialize-channel"><span class="toc-number">2.</span> <span class="toc-text">Specialize Channel</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dead-letter"><span class="toc-number">2.1.</span> <span class="toc-text">Dead letter</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#guaranteed-delivery"><span class="toc-number">3.</span> <span class="toc-text">Guaranteed delivery</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#using-a-finite-state-machine"><span class="toc-number">4.</span> <span class="toc-text">Using a Finite State Machine</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#creating-an-fsm-model"><span class="toc-number">4.1.</span> <span class="toc-text">Creating an FSM Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#testing-the-fsm"><span class="toc-number">4.2.</span> <span class="toc-text">TESTING THE FSM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#timers-within-fsm"><span class="toc-number">4.3.</span> <span class="toc-text">Timers within FSM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#termination-of-fsm"><span class="toc-number">4.4.</span> <span class="toc-text">Termination of FSM</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#implement-shared-state-using-agents"><span class="toc-number">5.</span> <span class="toc-text">Implement Shared state using agents</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#waiting-for-the-state-update"><span class="toc-number">5.1.</span> <span class="toc-text">Waiting for the state update</span></a></li></ol>
		</div>
		
		<h1 id="chinnel-types">Chinnel types</h1>
<p>Other names which are often used for these kind of channels are EventQueue or
EventBus. Akka has an EventStream which implements a publish-subscribe
channel. But when this implementation isn&#39;t sufficient, then Akka has a collection
of traits which helps to implement an custom publish subscribe channel.</p>
<p>Next we describe two special channels. The first is the Dead Letter channel,
which contain message that couldn&#39;t be delivered.
This channel can help when debugging, why some messages
aren&#39;t processed or to monitor where there are problems.</p>
<h2 id="point-to-point">Point to Point</h2>
<p>The point-to-point channel sends the message to one receiver.</p>
<p><img src="/img/akka_point2point.png" alt="point 2 point img"></p>
<p>The round-robin
Router in section 7.3.1 is an example of the channel having multiple receivers. The
processing of the messages can be done concurrently by different Receivers, but
only one Receiver consumes any one message.</p>
<p>Because in Akka the ActorRef is the implementation of a point-to-point channel.
Because all the messages send will be delivered to one Actor.</p>
<h2 id="publish-subscribe">Publish subscribe</h2>
<p>The channel can also deliver the same message to multiple receivers.</p>
<p>To solve this problem we can use
the Publish-subscribe channel. The channel is able to send the same message to
multiple receivers, without the sender knows which receiver.</p>
<p>When a receiver is interested in a message of the publisher, it subscribes itself
to the channel.</p>
<p>The most easiest when needed a publish-subscribe channel,
is to use the EventStream.The EventStream can be seen as a
manager of multiple Publish-Subscribe channels.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// subscirbe <span class="built_in">to</span> <span class="operator">the</span> EventStream <span class="built_in">to</span> receive Order messages
<span class="keyword">system</span>.eventStream.subscribe(giftModule, classOf[Order])<span class="comment">
// unsubscribe</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule, classOf[Order])
<span class="comment">
// 取消订阅所有消息</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule.ref)<span class="comment">
// 发布消息</span>
<span class="keyword">system</span>.eventStream.publish(msg)
</pre></td></tr></table></figure>

<h2 id="custom-eventbus">CUSTOM EVENTBUS</h2>
<p>Let assume that we only want to send a gift when someone ordered more than one
book.</p>
<p> An EventBus is generalized so
that it can be used for all implementations of a publish-subscribe channel. In the
generalized form there are three entities.</p>
<ul>
<li>Event, This is the type of all events published on that bus. In the Akka EventStream all uses
AnyRef as event and therefor supports all type of messages</li>
<li>Subscriber, This is the type of subscribers allowed to register on that event bus. In the Akka
EventStream the subscribers are ActorRef&#39;s</li>
<li>Classifier, This defines the classifier to be used in selecting subscribers
for dispatching events. </li>
</ul>
<p>EventBus Interface</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>package akka.event
trait EventBus {
  type Event
  type Classifier
  type Subscriber
  /**
  * Attempts to register the subscriber to the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it was</span>
  * already subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(subscriber: Subscriber, to: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it wasn't</span>
  * subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber, from: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> all Classifiers it may
  * be subscribed to
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber)</span>:</span> Unit
  /**
  * Publishes the specified Event to this bus
  */
  <span class="function"><span class="keyword">def</span> <span class="title">publish</span><span class="params">(event: Event)</span>:</span> Unit
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> {</span>
  <span class="keyword">type</span> Event = Order
  <span class="comment">// chosen to classify the Order messages on the criteria "is Multiple</span>
  <span class="comment">// Book Order" and use a Boolean as classifier </span>
  <span class="keyword">type</span> Classifier = Boolean

}
</pre></td></tr></table></figure>

<p>Akka has three composable traits which can help in keeping
track of the subscribers.</p>
<ul>
<li>LookupClassification,  It maintain a set of subscribers for each
possible classifier and extract a classifier from each event.</li>
<li>SubchannelClassification, This trait is used when classifiers form a hierarchy
and it is desired that subscription can be possible not only at the leaf nodes,
but also to the higher nodes.</li>
<li>ScanningClassification,  it can be used when classifiers have an overlap. This
means that one Event can be part of more classifiers, for example if we give more gifts
when ordering more books.</li>
</ul>
<p>API of LookupClassification</p>
<ul>
<li>classify(event: Event): Classifier
This is used for extracting the classifier from the incoming events.</li>
<li>compareSubscribers(a: Subscriber, b: Subscriber): Int
This method must define a order over the subscribers, to be able to compare them just as
the java.lang.Comparable.compare method.</li>
<li>publish(event: Event, subscriber: Subscriber),
This method will be invoked for each event for all subscribers which registered
themselves for the events classifier.</li>
<li>mapSize: Int, This returns the expected number of the different classifiers.
This is used for the initial size of an internal data structure.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.event.ActorEventBus
<span class="keyword">import</span> akka.event.{ LookupClassification, EventBus }

<span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> <span class="keyword">with</span> <span class="title">LookupClassification</span></span>
    <span class="keyword">with</span> ActorEventBus {  <span class="comment">//  defines that the subscriber is an ActorRef.</span>
  <span class="keyword">type</span> Event = Order
  <span class="keyword">type</span> Classifier = Boolean
  <span class="keyword">def</span> mapSize = <span class="number">2</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> classify(event: StateEventBus#Event) = {
    event.number &gt; <span class="number">1</span>
  }
  
  <span class="comment">// publish method by sending the event to the subscriber</span>
  <span class="keyword">protected</span> <span class="keyword">def</span> publish(event: OrderMessageBus#Event,
      subscriber: OrderMessageBus#Subscriber) {
    subscriber ! event
  }

}


<span class="comment">// Test for event bus</span>
<span class="keyword">val</span> bus = <span class="keyword">new</span> OrderMessageBus
<span class="keyword">val</span> singleBooks = TestProbe()
bus.subscribe(singleBooks.ref, <span class="keyword">false</span>)

<span class="keyword">val</span> multiBooks = TestProbe()
bus.subscribe(multiBooks.ref, <span class="keyword">true</span>)

<span class="keyword">val</span> msg = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)
bus.publish(msg)

singleBooks.expectMsg(msg)
multiBooks.expectNoMsg(<span class="number">3</span> seconds)

<span class="keyword">val</span> msg2 = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">3</span>)
bus.publish(msg2)
singleBooks.expectNoMsg(<span class="number">3</span> seconds)
multiBooks.expectMsg(msg2)
</pre></td></tr></table></figure>

<h1 id="specialize-channel">Specialize Channel</h1>
<p>DeadLetter channel,  Only failed message are put on this channel. Listening on this
channel can help to find problems in your system.</p>
<p>Guaranteed deliver channel, his channel guaranties
all messages which are send are also delivered</p>
<h2 id="dead-letter">Dead letter</h2>
<p>By monitoring this channel you know which messages aren&#39;t processed and can
take corrective actions.</p>
<p> To get these dead letter messages you
only need to subscribe your actor to the EventStream with the DeadLetter class as
the Classifier.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>val deadLetterMonitor: ActorRef

system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
  deadLetterMonitor,
  classOf[DeadLetter])

// 测试代码
val deadLetterMonitor = TestProbe()
system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
    deadLetterMonitor<span class="preprocessor">.ref</span>,
    classOf[DeadLetter])
    
val actor = system<span class="preprocessor">.actorOf</span>(Props[EchoActor], <span class="string">"echo"</span>)
actor ! PoisonPill
val msg = new Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)

actor ! msg

//  wrapped also into a DeadLetter object
val dead = deadLetterMonitor<span class="preprocessor">.expectMsgType</span>[DeadLetter]
dead<span class="preprocessor">.message</span> must be(msg)
dead<span class="preprocessor">.sender</span> must be(testActor)
dead<span class="preprocessor">.recipient</span> must be(actor)
</pre></td></tr></table></figure>

<h1 id="guaranteed-delivery">Guaranteed delivery</h1>
<p>The guaranteed delivery channel is point-to-point channel with the guaranty that
the message is always delivered to the receiver.</p>
<p>This means that the channel must have
all kind of mechanism and checks to be able to guaranty the delivery, for example
the message has to be saved on disk in case the process crashes.</p>
<p>The general rule of message delivery is that messages are delivered
at-most-once. This means that Akka promise that messages are delivered once or
fails to deliver, Which means that the message is lost.</p>
<p>Sending local messages will not likely fails, because it is like a normal method
call. This fails only when there are catastrophic VM errors, like
StackOverflowError, OutOfMemoryError or a memory access violation.
So the guaranties when sending a message to a local actor, are pretty good
and reliable.</p>
<p>The problem of losing the messages is when using remote actors. When using
remote actors, it is a lot more likely for a message delivery failure to occur.</p>
<p>The Egress is an Actor which is started by the
ReliableProxy and both Actors implements the checks and resend functionality to
be able to keep track of which of the messages are delivered to the remote receiver.</p>
<p> One restriction of using the ReliableProxy is that the tunnel is only one-way
and for one receiver. This means that when the receiver replies to the sender the
tunnel is NOT used.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.contrib.pattern.ReliableProxy
<span class="keyword">val</span> echo = system.actorFor(node(server) / <span class="string">"user"</span> / <span class="string">"echo"</span>)
<span class="comment">// In the example we create a proxy using the echo reference.</span>
<span class="comment">// When failing to send a message it is retried after 500 milliseconds.</span>
<span class="keyword">val</span> proxy = system.actorOf(Props(<span class="keyword">new</span> ReliableProxy(echo, <span class="number">500.</span>millis)), <span class="string">"proxy"</span>)
</pre></td></tr></table></figure>

<p>We create a Multi-node test with two nodes, the client and server
node. On the server Node we create a EchoActor as receiver and on the client node
we run our actual test.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.remote.testkit.MultiNodeSpecCallbacks
<span class="keyword">import</span> akka.remote.testkit.MultiNodeConfig
<span class="keyword">import</span> akka.remote.testkit.MultiNodeSpec

<span class="class"><span class="keyword">trait</span> <span class="title">STMultiNodeSpec</span></span>
    <span class="keyword">extends</span> MultiNodeSpecCallbacks
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> BeforeAndAfterAll {
  <span class="keyword">override</span> <span class="keyword">def</span> beforeAll() = multiNodeSpecBeforeAll()
  <span class="keyword">override</span> <span class="keyword">def</span> afterAll() = multiNodeSpecAfterAll()
}

<span class="class"><span class="keyword">object</span> <span class="title">ReliableProxySampleConfig</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> {</span>
  <span class="keyword">val</span> client = role(<span class="string">"Client"</span>)
  <span class="keyword">val</span> server = role(<span class="string">"Server"</span>)
  testTransport(on = <span class="keyword">true</span>)
}

<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode1</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode2</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
</pre></td></tr></table></figure>

<p>TODO P257</p>
<h1 id="using-a-finite-state-machine">Using a Finite State Machine</h1>
<p>Finite-state machine (FSM), also called a state machine, is a common,
language-independent modeling technique.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p><img src="/img/akka_FSM.png" alt="fsm"></p>
<h2 id="creating-an-fsm-model">Creating an FSM Model</h2>
<p>The inventory Service gets requests for
specific books and sends a reply. When the book is in inventory, the order system
gets a reply that a book has been reserved. But it is possible that there aren&#39;t any
books left and that the inventory will have to ask the publisher for more books,
before it can service the order.</p>
<p><img src="/img/akka_FMS.png" alt="fms"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td class="code"><pre>
<span class="comment">// State, The super type of all state names</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForRequests</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessRequest</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForPublisher</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessSoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>

<span class="comment">// StateData, The type of the state data which are tracked by the FSM.</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateData</span><span class="params">(nrBooksInStore:Int,pendingRequests:Seq[BookRequest])</span></span>


<span class="keyword">import</span> akka.actor.{Actor, FSM}
<span class="class"><span class="keyword">class</span> <span class="title">Inventory</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">FSM</span>[<span class="title">State</span>, <span class="title">StateData</span>] {</span>
  <span class="comment">// define the initial state and the initial StateData.</span>
  startWith(WaitForRequests, <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq()))

  <span class="comment">// Declare the transitions for state WaitForRequests</span>
  when(WaitForRequests) {
    <span class="comment">// Declare the possible Event when a BookRequest messages occur</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; 
      <span class="keyword">val</span> newStateData = data.copy(pendingRequests = data.pendingRequests :+ request)
      
      <span class="keyword">if</span> (newStateData.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest) using newStateData
      } <span class="keyword">else</span> {
        goto(WaitForPublisher) using newStateData
      }
    <span class="keyword">case</span> Event(PendingRequests, data:StateData) =&gt; 
      <span class="keyword">if</span> (data.pendingRequests.isEmpty) {
        stay
      } <span class="keyword">else</span> <span class="keyword">if</span>(data.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest)
      } <span class="keyword">else</span> {
        goto(WaitForPublisher)
      }
  }

  when(WaitForPublisher) {
    <span class="keyword">case</span> Event(supply:BookSupply, data:StateData) =&gt; {
      goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
    }
    <span class="keyword">case</span> Event(BookSupplySoldOut, _) =&gt; {
      goto(ProcessSoldOut)
    }
  }

  when(ProcessRequest) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(WaitForRequests) using data.copy(
          nrBooksInStore = data.nrBooksInStore - <span class="number">1</span>,
          pendingRequests = data.pendingRequests.tail)
    }
  }

  when(SoldOut) {
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      goto(ProcessSoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq(request))
    }
  }

  when(ProcessSoldOut) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(SoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq())
    }
  }

  whenUnhandled {
    <span class="comment">// common code for all states</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      <span class="comment">// Only update the stateData</span>
      stay using data.copy(pendingRequests = data.pendingRequests :+ request)
    }
    <span class="comment">// Log when the event isn't handled</span>
    <span class="keyword">case</span> Event(e, s) =&gt; {
      log.warning(<span class="string">"received unhandled request {} in state {}/{}"</span>, e, stateName, s)
      stay
    }
  }

  <span class="comment">// entry Action of the WaitForRequests state</span>
  onTransition {
    <span class="keyword">case</span> _ -&gt; WaitForRequests =&gt; {
      <span class="keyword">if</span> (!nextStateData.pendingRequests.isEmpty) {
        <span class="comment">// go to next state</span>
        self ! PendingRequests
      }
    }
    
    <span class="keyword">case</span> _ -&gt; WaitForPublisher =&gt; {
      publisher ! PublisherRequest
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessRequest =&gt; {
      <span class="keyword">val</span> request = nextStateData.pendingRequests.head
      reserveId += <span class="number">1</span>
      request.target ! <span class="keyword">new</span> BookReply(request.context, Right(reserveId))
      self ! Done
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessSoldOut =&gt; {
      nextStateData.pendingRequests.foreach(request =&gt; {
        request.target ! <span class="keyword">new</span> BookReply(request.context, Left(<span class="string">"SoldOut"</span>))
      })
      self ! Done
    }
  }

}
</pre></td></tr></table></figure>

<h2 id="testing-the-fsm">TESTING THE FSM</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(totalNrBooks: Int, nrBooksPerRequest: Int)</span></span>
    <span class="keyword">extends</span> Actor {
  <span class="keyword">var</span> nrLeft = totalNrBooks
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> PublisherRequest =&gt; {
      <span class="keyword">if</span> (nrLeft == <span class="number">0</span>)
      sender ! BookSupplySoldOut
      <span class="keyword">else</span> {
        <span class="keyword">val</span> supply = min(nrBooksPerRequest, nrLeft)
        nrLeft -= supply
        sender ! <span class="keyword">new</span> BookSupply(supply)
      }
    }
  }
}

<span class="keyword">val</span> publisher = system.actorOf(Props(<span class="keyword">new</span> Publisher(<span class="number">2</span>,<span class="number">2</span>)))
<span class="keyword">val</span> inventory = system.actorOf(Props(<span class="keyword">new</span> Inventory(publisher)))
<span class="keyword">val</span> stateProbe = TestProbe()

<span class="comment">// 订阅状态变化信息</span>
inventory ! <span class="keyword">new</span> SubscribeTransitionCallBack(stateProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> CurrentState(inventory, WaitForRequests))

inventory ! <span class="keyword">new</span> BookRequest(<span class="string">"context1"</span>, replyProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForRequests, WaitForPublisher))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForPublisher, ProcessRequest))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, ProcessRequest, WaitForRequests))
replyProbe.expectMsg(<span class="keyword">new</span> BookReply(<span class="string">"context1"</span>, Right(<span class="number">1</span>)))
</pre></td></tr></table></figure>

<h2 id="timers-within-fsm">Timers within FSM</h2>
<p>When it is in the state &#39;WaitingForPublisher,&#39;
we don&#39;t wait forever for the publisher to reply.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">when</span>(WaitForPublisher, stateTimeout = <span class="number">5</span> seconds) {
  <span class="reserved">case</span> Event<span class="function"><span class="params">(supply:BookSupply, data:StateData)</span> =&gt;</span> {
    goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
  }
  <span class="reserved">case</span> Event<span class="function"><span class="params">(BookSupplySoldOut, _)</span> =&gt;</span> {
    goto(ProcessSoldOut)
  }
  <span class="regexp">//</span> Define the timeout transition
  <span class="reserved">case</span> Event<span class="function"><span class="params">(StateTimeout,_)</span> =&gt;</span> goto(WaitForRequests)
}

<span class="regexp">//</span> 当测试时
<span class="regexp">//</span> stateProbe.expectMsg(<span class="number">6</span> seconds,<span class="keyword">new</span> Transition(inventory, WaitForPublisher, WaitForRequests))
</pre></td></tr></table></figure>

<p>The timer can also be set by specifying the next state using the
method forMax.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">goto</span><span class="params">(<span class="variable">WaitForPublisher</span>)</span> <span class="title">using</span> <span class="params">(new<span class="variable">Data</span>)</span> <span class="title">forMax</span> <span class="params">(<span class="number">5</span> seconds)</span></span>
</pre></td></tr></table></figure>

<h2 id="termination-of-fsm">Termination of FSM</h2>
<p>The FSM has an
specific handler for these cases: onTermination. This handler is also a partial
function and takes a StopEvent as an argument.</p>
<p>There are three possible reasons this can be received.</p>
<ul>
<li>Normal. This is received when there is a normal termination.</li>
<li>Shutdown. This is received when the FSM is stopped due to a shutdown.</li>
<li>Failure(cause: Any), This reason is received when the termination was caused by a failure</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="title">onTermination</span> {
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Normal</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Shutdown</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Failure</span>(cause), state, <span class="typedef"><span class="keyword">data</span>)</span>
}
</pre></td></tr></table></figure>

<h1 id="implement-shared-state-using-agents">Implement Shared state using agents</h1>
<p>Akka accomplishes this by sending
actions to the agent for each operation, where the messaging infrastructure will
preclude a race condition.</p>
<p>For our example, we need to share the number
of copies sold for each book, so we will create an Agent that contains this value.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">BookStatics</span><span class="params">(val nameBook: String, nrSold: Int)</span></span>
<span class="comment">// a BookStatics instance is created which is put into a map using the title as the key</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateBookStatics</span><span class="params">(val sequence: Long, books: Map[String, BookStatics])</span></span>
</pre></td></tr></table></figure>

<p>The state object contained by the agent must be immutable.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.global
<span class="keyword">import</span> akka.agent.Agent
<span class="keyword">val</span> stateAgent = <span class="keyword">new</span> Agent(<span class="keyword">new</span> StateBookStatics(<span class="number">0</span>,Map()))

<span class="keyword">val</span> currentBookStatics = stateAgent.get <span class="comment">// 使用 stateAgent() 效果一样</span>

<span class="comment">// 如果 agent 的值是依赖前一个状态的呢?</span>
<span class="keyword">val</span> newState = StateBookStatics(<span class="number">1</span>, Map(book -&gt; bookStat ))
stateAgent send newState

<span class="comment">// 可以这样</span>
<span class="keyword">val</span> book = <span class="string">"Akka in Action"</span>
<span class="keyword">val</span> nrSold = <span class="number">1</span>
stateAgent send( oldState =&gt; {
  <span class="keyword">val</span> bookStat = oldState.books.get(book) <span class="keyword">match</span> {
    <span class="keyword">case</span> Some(bookState) =&gt;
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="keyword">case</span> None =&gt; <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>, oldState.books + (book -&gt; bookStat ))
})
</pre></td></tr></table></figure>

<h2 id="waiting-for-the-state-update">Waiting for the state update</h2>
<p>In some cases, we need to update shared state and use the new state. For example,
we need to know which book is selling the most, and when a book becomes
popular, we want to notify the authors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>implicit val timeout = Timeout(<span class="number">1000</span>)

<span class="regexp">//</span> It works exactly as the send method only it returns a Future,
<span class="regexp">//</span> which can be used to wait <span class="keyword">for</span> the <span class="keyword">new</span> state.
val future = stateAgent alter( oldState<span class="function"> =&gt;</span> {
  val bookStat = oldState.books.get(book) match {
    <span class="reserved">case</span> Some<span class="function"><span class="params">(bookState)</span> =&gt;</span>
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="reserved">case</span> None<span class="function"> =&gt;</span>
      <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>,oldState.books + (book<span class="function"> -&gt;</span> bookStat ))
})

val newState = Await.result(future, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<p> It is possible that there are multiple changes at
nearly the same time and we want the final state or another thread needs the final
state and only knows that the process before it may have updated the state. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>val <span class="keyword">future</span> = stateAgent.<span class="keyword">future</span>
val newState = <span class="keyword">Await</span>.<span class="keyword">result</span>(<span class="keyword">future</span>, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.<span class="keyword">global</span>
val agent1 = Agent(<span class="number">3</span>)
// When using this notation, agent2 <span class="keyword">is</span> a newly created Agent that contains the
// value <span class="number">4</span> <span class="keyword">and</span> agent1 <span class="keyword">is</span> just the same <span class="keyword">as</span> before (it still contains the value <span class="number">3</span>).
val agent2 = agent1 map (_ + <span class="number">1</span>)
</pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/akka/">akka</a><a href="/tags/scala/">scala</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://zhpooer.github.io/2014/08/05/akka-in-action-message-channels/" data-title="Akka in Action-Message Channels &amp; Finite State Machines | Poe&#39;s World" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/08/06/akka-in-action-working-with-transactions/" title="Akka in Action-Working with Transactions">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Akka in Action-Working with Transactions</span>
</a>
</div>


<div class="next">
<a href="/2014/08/04/akka-in-action-system-structure/"  title="Akka in Action-System Structure &amp; Routing Messages">
 <strong>NEXT:</strong><br/> 
 <span>Akka in Action-System Structure &amp; Routing Messages
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chinnel-types"><span class="toc-number">1.</span> <span class="toc-text">Chinnel types</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#point-to-point"><span class="toc-number">1.1.</span> <span class="toc-text">Point to Point</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#publish-subscribe"><span class="toc-number">1.2.</span> <span class="toc-text">Publish subscribe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#custom-eventbus"><span class="toc-number">1.3.</span> <span class="toc-text">CUSTOM EVENTBUS</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#specialize-channel"><span class="toc-number">2.</span> <span class="toc-text">Specialize Channel</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dead-letter"><span class="toc-number">2.1.</span> <span class="toc-text">Dead letter</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#guaranteed-delivery"><span class="toc-number">3.</span> <span class="toc-text">Guaranteed delivery</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#using-a-finite-state-machine"><span class="toc-number">4.</span> <span class="toc-text">Using a Finite State Machine</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#creating-an-fsm-model"><span class="toc-number">4.1.</span> <span class="toc-text">Creating an FSM Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#testing-the-fsm"><span class="toc-number">4.2.</span> <span class="toc-text">TESTING THE FSM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#timers-within-fsm"><span class="toc-number">4.3.</span> <span class="toc-text">Timers within FSM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#termination-of-fsm"><span class="toc-number">4.4.</span> <span class="toc-text">Termination of FSM</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#implement-shared-state-using-agents"><span class="toc-number">5.</span> <span class="toc-text">Implement Shared state using agents</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#waiting-for-the-state-update"><span class="toc-number">5.1.</span> <span class="toc-text">Waiting for the state update</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AJAX/" title="AJAX">AJAX<sup>1</sup></a></li>
		
			<li><a href="/tags/Akka/" title="Akka">Akka<sup>1</sup></a></li>
		
			<li><a href="/tags/Android/" title="Android">Android<sup>1</sup></a></li>
		
			<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
		
			<li><a href="/tags/EL表达式/" title="EL表达式">EL表达式<sup>1</sup></a></li>
		
			<li><a href="/tags/HBase/" title="HBase">HBase<sup>1</sup></a></li>
		
			<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>1</sup></a></li>
		
			<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>2</sup></a></li>
		
			<li><a href="/tags/HttpSession/" title="HttpSession">HttpSession<sup>1</sup></a></li>
		
			<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
		
			<li><a href="/tags/Illustrator/" title="Illustrator">Illustrator<sup>3</sup></a></li>
		
			<li><a href="/tags/JSP/" title="JSP">JSP<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaBean/" title="JavaBean">JavaBean<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/tags/Mybatis/" title="Mybatis">Mybatis<sup>1</sup></a></li>
		
			<li><a href="/tags/NoSql/" title="NoSql">NoSql<sup>1</sup></a></li>
		
			<li><a href="/tags/SASS/" title="SASS">SASS<sup>1</sup></a></li>
		
			<li><a href="/tags/SAX/" title="SAX">SAX<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletRequest/" title="ServletRequest">ServletRequest<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletResponse/" title="ServletResponse">ServletResponse<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://zhpooer.github.io" target="_blank" title="zhpooer">zhpooer</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhpoooer"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
