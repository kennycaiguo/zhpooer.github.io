
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Play for Scala-Web services &amp; iteratees &amp; WebSockets | Poe&#39;s World</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="zhpooer">
    
    <meta name="description" content="Accessing web services
In this section, we’ll look at how to use Play’s Web Service API to
connect our application to remote web services.
Basic reque">
    
    
    
    
    <link rel="alternative" href="/atom.xml" title="Poe&#39;s World" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Poe&#39;s World" title="Poe&#39;s World"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Poe&#39;s World">Poe&#39;s World</a></h1>
				<h2 class="blog-motto">竹杖芒鞋轻胜马，一蓑烟雨任平生</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/english-monthly">英语角</a></li>
					
						<li><a href="/about">关于</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zhpooer.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/20/play-for-scala-web-services-&-iteratees-&-websockets/" title="Play for Scala-Web services &amp; iteratees &amp; WebSockets" itemprop="url">Play for Scala-Web services &amp; iteratees &amp; WebSockets</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://zhpooer.github.io" title="zhpooer">zhpooer</a>
    </p>
  <p class="article-time">
    <time datetime="2014-08-20T03:22:40.000Z" itemprop="datePublished">8月 20 2014</time>
    更新日期:<time datetime="2014-08-21T02:37:30.000Z" itemprop="dateModified">8月 21 2014</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#accessing-web-services"><span class="toc-number">1.</span> <span class="toc-text">Accessing web services</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#basic-requests"><span class="toc-number">1.1.</span> <span class="toc-text">Basic requests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handling-responses-asynchronously"><span class="toc-number">1.2.</span> <span class="toc-text">Handling responses asynchronously</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-the-cache"><span class="toc-number">1.3.</span> <span class="toc-text">Using the cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#other-request-methods-and-headers"><span class="toc-number">1.4.</span> <span class="toc-text">Other request methods and headers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#authentication-mechanisms"><span class="toc-number">1.5.</span> <span class="toc-text">Authentication mechanisms</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#dealing-with-streams-using-the-iteratee-library"><span class="toc-number">2.</span> <span class="toc-text">Dealing with streams using the iteratee library</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#processing-large-web-services-responses-with-an-iteratee"><span class="toc-number">2.1.</span> <span class="toc-text">Processing large web services responses with an iteratee</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#creating-other-iteratees-and-feeding-them-data"><span class="toc-number">2.2.</span> <span class="toc-text">Creating other iteratees and feeding them data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iteratees-and-immutability"><span class="toc-number">2.3.</span> <span class="toc-text">Iteratees and immutability</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#websockets-bidirectional-communication-with-the-browser"><span class="toc-number">3.</span> <span class="toc-text">WebSockets: Bidirectional communication with the browser</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#a-real-time-status-page-using-websockets"><span class="toc-number">3.1.</span> <span class="toc-text">A real-time status page using WebSockets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-simple-chat-application"><span class="toc-number">3.2.</span> <span class="toc-text">A simple chat application</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#using-body-parsers-to-deal-with-http-request-bodies"><span class="toc-number">4.</span> <span class="toc-text">Using body parsers to deal with HTTP request bodies</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#structure-of-a-body-parser"><span class="toc-number">4.1.</span> <span class="toc-text">Structure of a body parser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-built-in-body-parsers"><span class="toc-number">4.2.</span> <span class="toc-text">Using built-in body parsers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#composing-body-parsers"><span class="toc-number">4.3.</span> <span class="toc-text">Composing body parsers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#building-a-new-body-parser"><span class="toc-number">4.4.</span> <span class="toc-text">Building a new body parser</span></a></li></ol>
		</div>
		
		<h1 id="accessing-web-services">Accessing web services</h1>
<p>In this section, we’ll look at how to use Play’s Web Service API to
connect our application to remote web services.</p>
<h2 id="basic-requests">Basic requests</h2>
<p>Twitter exposes a REST API that allows you to search for tweets. This search API lives at
<a href="http://search.twitter.com/search.json" target="_blank">http://search.twitter.com/search.json</a> and returns a JSON data structure containing
tweets.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>case class Tweet(from: String, text: String)

implicit val tweetReads = (
  (JsPath \ <span class="string">"from_user_name"</span>)<span class="preprocessor">.read</span>[String] ~
  (JsPath \ <span class="string">"text"</span>)<span class="preprocessor">.read</span>[String])(Tweet<span class="preprocessor">.apply</span> _)

def tweetList() = Action {
  val results = <span class="number">3</span>
  val query = <span class="string">""</span><span class="string">"paperclip OR "</span>paper clip<span class="string">""</span><span class="string">""</span>
  val responseFuture =
    WS<span class="preprocessor">.url</span>(<span class="string">"http://search.twitter.com/search.json"</span>)
      <span class="preprocessor">.withQueryString</span>(<span class="string">"q"</span> -&gt; query, <span class="string">"rpp"</span> -&gt; results<span class="preprocessor">.toString</span>)
      <span class="preprocessor">.get</span>
  val response = Await<span class="preprocessor">.result</span>(responseFuture, <span class="number">10</span> seconds)
  val tweets = (Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>) \ <span class="string">"result"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
}
</pre></td></tr></table></figure>

<p>Tweetlist template</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>@(tweets: Seq[Tweet])

@main("Tweets") {
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Tweets<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  @tweets.map { tweet =&gt;
    <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
      <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>@tweet.from<span class="tag">&lt;/<span class="title">span</span>&gt;</span>: @tweet.text<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="handling-responses-asynchronously">Handling responses asynchronously</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>val resultFuture: Future[Result] = responseFuture<span class="preprocessor">.map</span> { response =&gt;
  val tweets = Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>).\(<span class="string">"results"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
}

def tweetList() = Action {
  Async {
    val results = <span class="number">3</span>
    val query = <span class="string">""</span><span class="string">"paperclip OR "</span>paper clip<span class="string">""</span><span class="string">""</span>
    val responseFuture =
    WS<span class="preprocessor">.url</span>(<span class="string">"http://search.twitter.com/search.json"</span>)
      <span class="preprocessor">.withQueryString</span>(<span class="string">"q"</span> -&gt; query, <span class="string">"rpp"</span> -&gt; results<span class="preprocessor">.toString</span>)<span class="preprocessor">.get</span>
    responseFuture<span class="preprocessor">.map</span> { response =&gt;
      val tweets = Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>).\(<span class="string">"results"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
      Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="using-the-cache">Using the cache</h2>
<p>For all cache methods, you need an <code>implicit play.api.Application</code> in scope. You
can get one by importing <code>play.api.Play.current</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>//  it’ll compute Product.getBestSeller() <span class="keyword">and</span>
// cache it <span class="keyword">for</span> <span class="number">1800</span> seconds <span class="keyword">as</span> well <span class="keyword">as</span> <span class="keyword">return</span> it
val bestSellerProduct: Product =
  Cache.getOrElse(<span class="string">"product-bestseller"</span>, <span class="number">1800</span>){
    Product.getBestSeller()
  }
</pre></td></tr></table></figure>

<p>Caching an entire action</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>def tweetList() = Cached(<span class="string">"action-tweets"</span>, <span class="number">120</span>) {
  Action {
    Async {
      val results = <span class="number">3</span>
      val query = <span class="string">""</span><span class="string">"paperclip OR "</span>paper clip<span class="string">""</span><span class="string">""</span>
      val responseFuture =
        WS<span class="preprocessor">.url</span>(<span class="string">"http://search.twitter.com/search.json"</span>)
          <span class="preprocessor">.withQueryString</span>(<span class="string">"q"</span> -&gt; query, <span class="string">"rpp"</span> -&gt; results<span class="preprocessor">.toString</span>)<span class="preprocessor">.get</span>
      responseFuture<span class="preprocessor">.map</span> { response =&gt;
        val tweets =
        Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>).\(<span class="string">"results"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
        Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
      }
    }
  }
}
</pre></td></tr></table></figure>

<p>You can use this to cache a recommendations page for each user ID:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>def userIdCacheKey(prefix: String) = { (header: RequestHeader) =&gt;
  prefix + header<span class="preprocessor">.session</span><span class="preprocessor">.get</span>(<span class="string">"userId"</span>)<span class="preprocessor">.getOrElse</span>(<span class="string">"anonymous"</span>)
}
def recommendations() = Cached(userIdCacheKey(<span class="string">"recommendations-"</span>), <span class="number">120</span>) {
  Action { request =&gt;
    val recommendedProducts =
      RecommendationsEngine<span class="preprocessor">.recommendedProductsForUser</span>(request<span class="preprocessor">.session</span><span class="preprocessor">.get</span>(<span class="string">"userId"</span>))
    Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.recommendations</span>(recommendedProducts))
  }
}
</pre></td></tr></table></figure>

<h2 id="other-request-methods-and-headers">Other request methods and headers</h2>
<p>As well as GET requests, you can of course use the WS library to send PUT , POST , DELETE,
and HEAD requests.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val newUser = Json<span class="preprocessor">.toJson</span>(Map(
  <span class="string">"name"</span> -&gt; <span class="string">"John Doe"</span>,
  <span class="string">"email"</span> -&gt; <span class="string">"j.doe@example.com"</span>))
val responseFuture =
  WS<span class="preprocessor">.url</span>(<span class="string">"http://api.example.com/users"</span>)<span class="preprocessor">.post</span>(newUser)

WS<span class="preprocessor">.url</span>(<span class="string">"http://example.com"</span>)<span class="preprocessor">.withHeaders</span>(HeaderNames<span class="preprocessor">.ACCEPT</span> -&gt; <span class="string">"application/json"</span>)
</pre></td></tr></table></figure>

<h2 id="authentication-mechanisms">Authentication mechanisms</h2>
<p>OAuth requests are authenticated using a signature that’s added to each request,
and this signature is calculated using secret keys that are shared between the
server that offers OAuth protected resources and a third party that OAuth calls
the consumer. Also, OAuth defines a standard to acquire some of the required keys
and the flow that allows end users to grant access to protected resources.</p>
<p>The OAuthCalculator can calculate signatures given a consumer key,
a consumer secret wrapped in a ConsumerKey , and an access token and
token secret wrapped in a RequestToken.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>val consumerKey = ConsumerKey(
  <span class="string">"52xEY4sGbPlO1FCQRaiAg"</span>,
  <span class="string">"KpnmEeDM6XDwS59FDcAmVMQbui8mcceNASj7xFJc5WY"</span>)

val accessToken = RequestToken(
  <span class="string">"16905598-cIPuAsWUI47Fk78guCRTa7QX49G0nOQdwv2SA6Rjz"</span>,
  <span class="string">"yEKoKqqOjo4gtSQ6FSsQ9tbxQqQZNq7LB5NGsbyKU"</span>)

def postTweet() = Action {
  val message = <span class="string">"Hi! This is an automated tweet!"</span>
  val data = Map(
    <span class="string">"status"</span> -&gt; Se<span class="string">q(message)</span>)
  val responseFuture =
    WS.url(<span class="string">"http://api.twitter.com/1/statuses/update.json"</span>)
      .sign(OAuthCalculator(consumerKey, accessToken)).post(data)
  Async(responseFuture.<span class="keyword">map</span>(<span class="string">response =&gt;</span> Ok(response.body)))
}
</pre></td></tr></table></figure>

<h1 id="dealing-with-streams-using-the-iteratee-library">Dealing with streams using the iteratee library</h1>
<p>Play’s iteratee library is in the <code>play.api.libs.iteratee</code> package.
This library is considered a cornerstone of Play’s reactive programming model.
It contains an abstraction for performing IO operations, called an iteratee.</p>
<p>Twitter not only offers the REST API that we saw in the previous section,
but also a streaming API.</p>
<p>You start out using this API much like the regular API:
you construct an HTTP request with some parameters that
specify which tweets you want to retrieve. Twitter will then
start returning tweets. But unlike the REST API, this streaming API will
never stop serving the response. It’ll keep
the HTTP connection open and will continue sending new tweets over it.</p>
<h2 id="processing-large-web-services-responses-with-an-iteratee">Processing large web services responses with an iteratee</h2>
<p>If the web service sends the response in chunks, the WS library buffers these
chunks until it has the complete HTTP response. 
The buffering strategy breaks down when trying to use the Twitter API. </p>
<p>We need another approach, where we can start using parts of the response as soon
as they arrive in our application, without needing to wait for the entire response.
And this is exactly what an iteratee can do. An iteratee is an object that receives
each individual chunk of data and can do something with that data.</p>
<p>When dealing with the Twitter streaming API, we’d want to use an iteratee that
converts the HTTP response chunks into tweet objects, and send them to another
part of our application, perhaps to be stored in a database.</p>
<p>Iteratees are instances of the Iteratee class, and they can most easily be con-
structed using methods on the Iteratee object.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="regexp">//</span> The foreach[A] method <span class="literal">on</span> the Iteratee object takes a single parameter, a <span class="reserved">function</span>
<span class="regexp">//</span> that takes a chunk <span class="keyword">of</span> type A <span class="keyword">and</span> returns an Iteratee[A, Unit]
<span class="regexp">//</span> For each chunk that’s received, a string <span class="keyword">is</span> constructed <span class="keyword">and</span> printed.
<span class="regexp">//</span>  The first indicates the Scala type <span class="keyword">for</span> the chunks that the iteratee accepts. 
val loggingIteratee = Iteratee.foreach[Array[Byte]] { chunk<span class="function"> =&gt;</span>
  val chunkString = <span class="keyword">new</span> String(chunk, <span class="string">"UTF-8"</span>)
  println(chunkString)
}

WS.url(<span class="string">"https://stream.twitter.com/1/statuses/sample.json"</span>)
  .sign(OAuthCalculator(consumerKey, accessToken))
  .get(_<span class="function"> =&gt;</span> loggingIteratee)
</pre></td></tr></table></figure>

<h2 id="creating-other-iteratees-and-feeding-them-data">Creating other iteratees and feeding them data</h2>
<p>The Iteratee object exposes more methods that we can use to create iteratees.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="regexp">//</span> accepts Int chunks, <span class="keyword">and</span> sums these chunks.
val summingIteratee = Iteratee.fold<span class="function"><span class="params">(<span class="number">0</span>)</span>{ <span class="params">(sum: Int, chunk: Int)</span> =&gt;</span>
  sum + chunk
}
</pre></td></tr></table></figure>

<p>It turns out that the Iteratee class has a counterpart: Enumerator .
An enumerator is a producer of chunks.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val intEnumerator = Enumerator(<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>)
// it’ll <span class="keyword">return</span> <span class="literal">a</span> future of <span class="literal">a</span> new iteratee
<span class="label">val newIterateeFuture:</span> Future[Iteratee[Int, Int]] =
  intEnumerator(summingIteratee)
// With <span class="literal">a</span> regular map , we’d get <span class="literal">a</span> Future[Future[Int]], but with flatMap, we get <span class="literal">a</span> Future[Int]  
<span class="label">val resultFuture:</span> Future[Int] = newIterateeFuture.flatMap(_.run)
resultFuture.onComplete(sum =&gt; println(<span class="string">"The sum is %d"</span> format sum))
</pre></td></tr></table></figure>

<h2 id="iteratees-and-immutability">Iteratees and immutability</h2>
<p>As mentioned before, the iteratee library is designed to be immutable: operations
don’t change the iteratee that you perform it on, but they return a new iteratee. </p>
<p>You can apply it to different enumerators as often as you like without problems.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>//  here are both an immutable and a mutable iteratee that do the same thing: sum integers:

val immutableSumIteratee = Iteratee.fold(0){ (sum: Int, chunk: Int) =&gt;
  sum + chunk
}
val mutableSumIteratee = {
  var sum = 0
  Iteratee.foreach[<span class="link_label">Int</span>](<span class="link_url">sum += _</span>).mapDone(_ =&gt; sum)
}
</pre></td></tr></table></figure>

<h1 id="websockets-bidirectional-communication-with-the-browser">WebSockets: Bidirectional communication with the browser</h1>
<p>The most basic approach is polling:
the browser sends a request to the server to ask for new data every second or so.</p>
<p>When polling, the browser sends a request to the server at a regular interval
requesting new messages. Often, the server will have nothing.</p>
<p>A more advanced workaround is Comet, which is a technique to allow the server to
push data to a client. With Comet, the browser starts a request and the server keeps
the connection open until it has something to send.</p>
<h2 id="a-real-time-status-page-using-websockets">A real-time status page using WebSockets</h2>
<p>From the application’s perspective, a WebSocket connection is essentially two
independent streams of data: one stream of data incoming from the client
and a second stream of data to be sent to the client.</p>
<p>To handle the incoming stream of data, you need to provide an iteratee. You also
provide an enumerator that’s used to send data to the client. With an iteratee and an
enumerator, you can construct a WebSocket, which comes in the place of an Action.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>@(implicit request: RequestHeader)
@main("Server Status") {
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    $(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"@route.WebSockets.statusFeed.webSocketUrL()"</span>)
      ws.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
        $(<span class="string">'#load-average'</span>).text(msg.data)
      }
    });
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>System load average: <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"load-average"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def statusFeed() = WebSocket<span class="preprocessor">.using</span>[String] { implicit request =&gt;
  // iterratee ignoring incoming message
  val <span class="keyword">in</span> = Iteratee<span class="preprocessor">.ignore</span>[String]
  val <span class="keyword">out</span> = Enumerator<span class="preprocessor">.repeatM</span> {
    Promise<span class="preprocessor">.timeout</span>(getLoadAverage), <span class="number">3</span> seconds)
  }
  (<span class="keyword">in</span>, <span class="keyword">out</span>)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>GET /WebSockets/statusFeed controllers<span class="preprocessor">.WebSockets</span><span class="preprocessor">.statusFeed</span>()
</pre></td></tr></table></figure>

<h2 id="a-simple-chat-application">A simple chat application</h2>
<p>Play allows you to make such an enumerator with <code>Concurrent.broadcast</code> .
This method returns a tuple with an enumerator and a Channel.
This channel is tied to the enumerator and allows you to
push chunks into the enumerator:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="title">val</span> <span class="params">(enumerator, channel)</span> = C<span class="title">oncurrent</span>.<span class="title">broadcast</span>[S<span class="title">tring</span>]
<span class="title">channel</span>.<span class="title">push</span><span class="params">(<span class="string">"Hello"</span>)</span>
<span class="title">channel</span>.<span class="title">push</span><span class="params">(<span class="string">"World"</span>)</span></span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Join</span><span class="params">(nick: String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leave</span><span class="params">(nick: String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Broadcast</span><span class="params">(message: String)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">var</span> users = Set[String]()
  <span class="keyword">var</span> (enumerator, channle) = Concurrent.broadcast[String]
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> Join(nick) =&gt; {
      <span class="keyword">if</span>(!users.contains(nick)) {
        <span class="keyword">val</span> iteratee = Iteratee.foreach[String] { message =&gt;
          self ! broadcast(<span class="string">"%s: %s"</span> format (nick, message))
        }.mapDone { _ =&gt;
          self ! Leave(nick)
        }
        users += nick
        channel.push(<span class="string">"User %s has joined the room, now %s users"</span>
          format(nick, users.size))
        sender ! (iteratee, enumerator)
      } <span class="keyword">else</span> {
        <span class="keyword">val</span> enumerator = Enumerator(<span class="string">"Nickname %s is already in use."</span> format nick)
        <span class="keyword">val</span> iteratee = Iteratee.ignore
        sender ! (iteratee, enumerator)
      }
    }
    <span class="keyword">case</span> Leave(nick) =&gt; {
      users -= nick
      channel.push(<span class="string">"User %s has left the room, %s users left"</span> format(nick, users.size))
    }
    <span class="keyword">case</span> Broadcast(msg: String) =&gt; channel.push(msg)
  }
}

<span class="comment">// Chat controller</span>
<span class="class"><span class="keyword">object</span> <span class="title">Chat</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  impplicit <span class="keyword">val</span> timeout = Timeout(<span class="number">1</span> seconds)
  <span class="keyword">val</span> room = Akka.system.actorOf(Props[ChatRoom])

  <span class="keyword">def</span> showRoom(nick: String) = Action {implicit request =&gt;
    Ok(views.html.chat.showRoom(nick))
  }
  
  <span class="keyword">def</span> chatSocket(nick: String) = WebSocket.async { request =&gt;
    <span class="keyword">val</span> channelsFuture = room ? Join(nick)
    channlesFuture.mapTo[(Iteratee[String, _], Enumerator[String])]
  }
 
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>GET /room/:nick controllers<span class="preprocessor">.Chat</span><span class="preprocessor">.room</span>(nick)
GET /room/socket/:nick controllers<span class="preprocessor">.Chat</span><span class="preprocessor">.chatSocket</span>(nick)
</pre></td></tr></table></figure>

<h1 id="using-body-parsers-to-deal-with-http-request-bodies">Using body parsers to deal with HTTP request bodies</h1>
<p>HTTP requests are normally processed when they’ve been fully received by the server.
An action is only invoked when the request is complete, and when the body parser is
done parsing the body of the request.</p>
<p>In this section, we’ll show how body
parsers work, how you can use and compose existing body parsers, and finally how you
can build your own body parsers from scratch.</p>
<h2 id="structure-of-a-body-parser">Structure of a body parser</h2>
<p>A body parser is an object that knows what to make of an HTTP request body. A JSON
body parser, for example, knows how to construct a JsValue from the body of an
HTTP request that contains JSON data.</p>
<p>A body parser can also choose to return an error Result; for example, when the
user exceeds the storage quota, or when the HTTP request body doesn’t conform to
what the body parser expects, like a non-JSON body for a JSON body parser.</p>
<p>A BodyParser is a function with a RequestHeader parameter
returning an iteratee. The iteratee consumes chunks of type Array[Byte] and
eventually produces either a play.api.mvc.Result or an A, which can be anything.</p>
<p>An Action in Play not only defines the method that constructs a Result from a
<code>Request[A]</code>, but it also contains the body parser that must be used for requests that
are routed to this action. </p>
<p>the following two Action definitions construct the same Action:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Action { <span class="comment">// block }</span>
<span class="comment">//  The anyContent body parser is of type BodyParser[AnyContent],</span>
<span class="comment">// so your action will receive a Request[AnyContent]</span>
<span class="comment">//  AnyContent is a convenient one; it has the methods asJson, asText, asXml, and so on,</span>
<span class="function">Action(BodyParsers.parse.anyContent)</span> { <span class="comment">// block }</span>
</pre></td></tr></table></figure>

<p>the BodyParsers.parse.json body parser will result in a <code>Request[JsValue]</code>,
and then the body field of the Request is of type JsValue.
With the json body parser, a BadRequest response is sent back to the client
automatically when the body doesn’t contain valid JSON.</p>
<p><img src="/img/play_body_parse.png" alt="Body parser in the request lifecycle"></p>
<h2 id="using-built-in-body-parsers">Using built-in body parsers</h2>
<p>Play has many more body parsers, all available on the <code>Bodyparsers.parse</code> object.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>// This action will <span class="constant">return</span> <span class="operator">an</span> EntityTooLarge HTTP response<span class="comment">
// when the body is larger than 10,000 bytes.</span>
def myAction = Action(parse.json(<span class="number">10000</span>)) {
 <span class="comment"> // foo</span>
}
</pre></td></tr></table></figure>

<p>If you don’t specify a maximum length, the text, JSON, XML, and
URL-encoded body parsers default to a limit of 512 kilobytes. This can be changed in
<code>application.conf</code>: <code>parsers.text.maxLength = 1m</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// To store uploaded file, you can use the temporaryFile body parser.
def upload = Action(parse<span class="preprocessor">.temporaryFile</span>) { request =&gt;
  val destinationFile = Play<span class="preprocessor">.getFile</span>(<span class="string">"uploads/myfile"</span>)
  request<span class="preprocessor">.body</span><span class="preprocessor">.moveTo</span>(destinationFile)
  Ok(<span class="string">"File successfully uploaded!"</span>)
}
</pre></td></tr></table></figure>

<h2 id="composing-body-parsers">Composing body parsers</h2>
<p>The built-in body parsers are fairly basic. It’s possible to compose these basic
body parsers into more complex ones that have more complex behavior if you need that.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>// Play also has <span class="operator">a</span> <span class="built_in">file</span> body parser that takes <span class="operator">a</span> java.io.File <span class="keyword">as</span> <span class="operator">a</span> parameter:
def store(filename: String) = Action(parse.<span class="built_in">file</span>(Play.getFile(filename))) { request =&gt;
  Ok(<span class="string">"Your file is saved!"</span>)
}
</pre></td></tr></table></figure>

<p>Suppose we want to make a body parser that works like the file body parser, but
only saves the file if the content type is some given value.</p>
<p>We can use the <code>BodyParsers.parse.when</code> method to construct a
new body parser from a predicate, an existing body parser,
and a function constructing a failure result:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def fileWithContentType(filname:<span class="built_in">String</span>, contentType: <span class="built_in">String</span>) =
  parse.when(
    requestHeader =&gt; requestHeader.contentType == contentType,
    parse.file(Play.getFile(filename)),
    requestHeader =&gt; BadRequest(  <span class="comment">// Existing body parser</span>
      <span class="string">"Expected a '%s' content type, but found %s"</span>.
        format(contentType, requestHeader.contentType)))

<span class="comment">// We can use this body parser as follows:</span>
def savePdf(filename: <span class="built_in">String</span>) = Action(fileWithContentType(filename, <span class="string">"application/pdf"</span>)) { request =&gt;
  Ok(<span class="string">"Your file is saved!"</span>)
}
</pre></td></tr></table></figure>

<p>We can start with the temporaryFile body parser to store the file on
disk and then upload it to MongoDB.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def mongoDbStorageBodyParser(dbName: String) =
  parse<span class="preprocessor">.temporaryFile</span><span class="preprocessor">.map</span> { temporaryFile =&gt;
  // Here some code to store the file <span class="keyword">in</span> MongoDB
  // <span class="keyword">and</span> get an objectId
  objectId
}
val dbName = Play<span class="preprocessor">.configuration</span><span class="preprocessor">.getString</span>(<span class="string">"mongoDbName"</span>)<span class="preprocessor">.getOrElse</span>(<span class="string">"mydb"</span>)

def saveInMongo = Action(mongoDbStorageBodyParser(dbName)) {
  request =&gt;
    Ok(<span class="string">"Your file was saved with id %s"</span> format request<span class="preprocessor">.body</span>)
}
</pre></td></tr></table></figure>

<h2 id="building-a-new-body-parser">Building a new body parser</h2>
<p>In this section, we’ll build another body parser that allows a user to upload a file.
This time, though, it won’t be stored on disk or in MongoDB, but on Amazon’s Simple
Storage Service, better known as S3.</p>
<p>The underlying library that Play uses, Async HTTP Client (AHC), does support
pushing chunks of data into a request body</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre>private lazy val client = {
  val playConfig = WS<span class="preprocessor">.client</span><span class="preprocessor">.getConfig</span>
  new AsyncHttpClient(new GrizzlyAsyncHttpProvider(playConfig), playConfig)
}

// Amazon requires requests to be signed. 
def sign(method: String, path: String,
         secretKey: String,
         date: String,
         contentType: Option[String] = None,
         aclHeader: Option[String] = None) = {
  val message = List(method, <span class="string">""</span>,
    contentType<span class="preprocessor">.getOrElse</span>(<span class="string">""</span>),
    date, aclHeader<span class="preprocessor">.map</span>(<span class="string">"x-amz-acl:"</span> + _)<span class="preprocessor">.getOrElse</span>(<span class="string">""</span>), path)<span class="preprocessor">.mkString</span>(<span class="string">"\n"</span>)
  // Play’s Crypto<span class="preprocessor">.sign</span> method returns a Hex string,
  // instead of Base64, so we do hashing ourselves.
  val mac = Mac<span class="preprocessor">.getInstance</span>(<span class="string">"HmacSHA1"</span>)
  mac<span class="preprocessor">.init</span>(new SecretKeySpec(secretKey<span class="preprocessor">.getBytes</span>(<span class="string">"UTF-8"</span>), <span class="string">"HmacSHA1"</span>))
  val codec = new Base64()
  new String(codec<span class="preprocessor">.encode</span>(mac<span class="preprocessor">.doFinal</span>(message<span class="preprocessor">.getBytes</span>(<span class="string">"UTF-8"</span>))))
}

def buildRequest(bucket: String, objectId: String, key: String,
    secret: String, requestHeader: RequestHeader): (Request, FeedableBodyGenerator) = {
  val expires = dateFormat<span class="preprocessor">.format</span>(new Date())
  val path = <span class="string">"/%s/%s"</span> format (bucket, objectId)
  val acl = <span class="string">"public-read"</span>
  val contentType = requestHeader<span class="preprocessor">.headers</span><span class="preprocessor">.get</span>(HeaderNames<span class="preprocessor">.CONTENT</span>_TYPE)
                                         <span class="preprocessor">.getOrElse</span>(<span class="string">"binary/octet-stream"</span>)
  val auth = <span class="string">"AWS %s:%s"</span> format (key, sign(<span class="string">"PUT"</span>, path, secret,
    expires, Some(contentType), Some(acl)))
  val url = <span class="string">"https://%s.s3.amazonaws.com/%s"</span> format (bucket, objectId)
  val bodyGenerator = new FeedableBodyGenerator()
  val request = new RequestBuilder(<span class="string">"PUT"</span>)
    <span class="preprocessor">.setUrl</span>(url)
    <span class="preprocessor">.setHeader</span>(<span class="string">"Date"</span>, expires)
    <span class="preprocessor">.setHeader</span>(<span class="string">"x-amz-acl"</span>, acl)
    <span class="preprocessor">.setHeader</span>(<span class="string">"Content-Type"</span>, contentType)
    <span class="preprocessor">.setHeader</span>(<span class="string">"Authorization"</span>, auth)
    <span class="preprocessor">.setContentLength</span>(requestHeader<span class="preprocessor">.headers</span>
    <span class="preprocessor">.get</span>(HeaderNames<span class="preprocessor">.CONTENT</span>_LENGTH)<span class="preprocessor">.get</span><span class="preprocessor">.toInt</span>)
    <span class="preprocessor">.setBody</span>(bodyGenerator)
    <span class="preprocessor">.build</span>()
  (request, bodyGenerator)
}
</pre></td></tr></table></figure>

<p>Amazon S3 body parser</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">def</span> S3Upload(bucket: String, objectId: String) = BodyParser {
    requestHeader =&gt;
  <span class="keyword">val</span> awsSecret = Play.configuration.getString(<span class="string">"aws.secret"</span>).get
  <span class="keyword">val</span> awsKey = Play.configuration.getString(<span class="string">"aws.key"</span>).get
  <span class="keyword">val</span> (request, bodyGenerator) =
    buildRequest(bucket, objectId, awsKey, awsSecret, requestHeader)
  S3Writer(objectId, request, bodyGenerator)
}

<span class="keyword">def</span> S3Writer(objectId: String, request: Request,
    bodyGenerator: FeedableBodyGenerator):Iteratee[Array[Byte], Either[Result, String]] = {
  <span class="comment">// We execute the request, but we can send body chunks afterwards.</span>
  <span class="keyword">val</span> responseFuture = client.executeRequest(request)
  Iteratee.fold[Array[Byte], FeedableBodyGenerator](bodyGenerator) {
  (generator, bytes) =&gt;
    <span class="keyword">val</span> isLast = <span class="keyword">false</span>
    generator.feed(<span class="keyword">new</span> ByteBufferWrapper(ByteBuffer.wrap(bytes)), isLast)
    generator
  } mapDone { generator =&gt;
    <span class="keyword">val</span> isLast = <span class="keyword">true</span>
    <span class="keyword">val</span> emptyBuffer = <span class="keyword">new</span> ByteBufferWrapper(ByteBuffer.wrap(Array[Byte]()))
    generator.feed(emptyBuffer, isLast)
    <span class="keyword">val</span> response = responseFuture.get
    response.getStatusCode <span class="keyword">match</span> {
      <span class="keyword">case</span> <span class="number">200</span> =&gt; Right(objectId)
      <span class="keyword">case</span> _ =&gt; Left(Forbidden(response.getResponseBody))
    }
  }
}
</pre></td></tr></table></figure>

<p>Enumeratees can sit between enumerators and iteratees
and modify the stream. Elements of the stream can be removed, changed, or grouped.</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/play/">play</a><a href="/tags/scala/">scala</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://zhpooer.github.io/2014/08/20/play-for-scala-web-services-&-iteratees-&-websockets/" data-title="Play for Scala-Web services &amp; iteratees &amp; WebSockets | Poe&#39;s World" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2014/08/18/play-for-scala-modules-&-plugins/"  title="Play for Scala-Modules &amp; Plugins">
 <strong>NEXT:</strong><br/> 
 <span>Play for Scala-Modules &amp; Plugins
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#accessing-web-services"><span class="toc-number">1.</span> <span class="toc-text">Accessing web services</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#basic-requests"><span class="toc-number">1.1.</span> <span class="toc-text">Basic requests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handling-responses-asynchronously"><span class="toc-number">1.2.</span> <span class="toc-text">Handling responses asynchronously</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-the-cache"><span class="toc-number">1.3.</span> <span class="toc-text">Using the cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#other-request-methods-and-headers"><span class="toc-number">1.4.</span> <span class="toc-text">Other request methods and headers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#authentication-mechanisms"><span class="toc-number">1.5.</span> <span class="toc-text">Authentication mechanisms</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#dealing-with-streams-using-the-iteratee-library"><span class="toc-number">2.</span> <span class="toc-text">Dealing with streams using the iteratee library</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#processing-large-web-services-responses-with-an-iteratee"><span class="toc-number">2.1.</span> <span class="toc-text">Processing large web services responses with an iteratee</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#creating-other-iteratees-and-feeding-them-data"><span class="toc-number">2.2.</span> <span class="toc-text">Creating other iteratees and feeding them data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iteratees-and-immutability"><span class="toc-number">2.3.</span> <span class="toc-text">Iteratees and immutability</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#websockets-bidirectional-communication-with-the-browser"><span class="toc-number">3.</span> <span class="toc-text">WebSockets: Bidirectional communication with the browser</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#a-real-time-status-page-using-websockets"><span class="toc-number">3.1.</span> <span class="toc-text">A real-time status page using WebSockets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-simple-chat-application"><span class="toc-number">3.2.</span> <span class="toc-text">A simple chat application</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#using-body-parsers-to-deal-with-http-request-bodies"><span class="toc-number">4.</span> <span class="toc-text">Using body parsers to deal with HTTP request bodies</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#structure-of-a-body-parser"><span class="toc-number">4.1.</span> <span class="toc-text">Structure of a body parser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-built-in-body-parsers"><span class="toc-number">4.2.</span> <span class="toc-text">Using built-in body parsers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#composing-body-parsers"><span class="toc-number">4.3.</span> <span class="toc-text">Composing body parsers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#building-a-new-body-parser"><span class="toc-number">4.4.</span> <span class="toc-text">Building a new body parser</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/AJAX/" title="AJAX">AJAX<sup>1</sup></a></li>
		
			<li><a href="/tags/Akka/" title="Akka">Akka<sup>1</sup></a></li>
		
			<li><a href="/tags/DOM/" title="DOM">DOM<sup>2</sup></a></li>
		
			<li><a href="/tags/EL表达式/" title="EL表达式">EL表达式<sup>1</sup></a></li>
		
			<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>1</sup></a></li>
		
			<li><a href="/tags/Hibernate/" title="Hibernate">Hibernate<sup>2</sup></a></li>
		
			<li><a href="/tags/HttpSession/" title="HttpSession">HttpSession<sup>1</sup></a></li>
		
			<li><a href="/tags/IO/" title="IO">IO<sup>1</sup></a></li>
		
			<li><a href="/tags/JSP/" title="JSP">JSP<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaBean/" title="JavaBean">JavaBean<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>1</sup></a></li>
		
			<li><a href="/tags/Mybatis/" title="Mybatis">Mybatis<sup>1</sup></a></li>
		
			<li><a href="/tags/NoSql/" title="NoSql">NoSql<sup>1</sup></a></li>
		
			<li><a href="/tags/SAX/" title="SAX">SAX<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletRequest/" title="ServletRequest">ServletRequest<sup>1</sup></a></li>
		
			<li><a href="/tags/ServletResponse/" title="ServletResponse">ServletResponse<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
		
			<li><a href="/tags/Spring MVC/" title="Spring MVC">Spring MVC<sup>1</sup></a></li>
		
			<li><a href="/tags/String/" title="String">String<sup>1</sup></a></li>
		
			<li><a href="/tags/StringBuffer/" title="StringBuffer">StringBuffer<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2014 
		
		<a href="http://zhpooer.github.io" target="_blank" title="zhpooer">zhpooer</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhpoooer"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
