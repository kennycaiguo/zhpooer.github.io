<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Poe's World]]></title>
  <subtitle><![CDATA[竹杖芒鞋轻胜马，一蓑烟雨任平生]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhpooer.github.io/"/>
  <updated>2014-08-21T06:05:42.792Z</updated>
  <id>http://zhpooer.github.io/</id>
  
  <author>
    <name><![CDATA[zhpooer]]></name>
    <email><![CDATA[zhpooer@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Play for Scala-Web services & iteratees & WebSockets]]></title>
    <link href="http://zhpooer.github.io/2014/08/20/play-for-scala-web-services-&-iteratees-&-websockets/"/>
    <id>http://zhpooer.github.io/2014/08/20/play-for-scala-web-services-&-iteratees-&-websockets/</id>
    <published>2014-08-20T03:22:40.000Z</published>
    <updated>2014-08-21T02:37:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="accessing-web-services">Accessing web services</h1>
<p>In this section, we’ll look at how to use Play’s Web Service API to
connect our application to remote web services.</p>
<h2 id="basic-requests">Basic requests</h2>
<p>Twitter exposes a REST API that allows you to search for tweets. This search API lives at
<a href="http://search.twitter.com/search.json" target="_blank">http://search.twitter.com/search.json</a> and returns a JSON data structure containing
tweets.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>case class Tweet(from: String, text: String)

implicit val tweetReads = (
  (JsPath \ <span class="string">"from_user_name"</span>)<span class="preprocessor">.read</span>[String] ~
  (JsPath \ <span class="string">"text"</span>)<span class="preprocessor">.read</span>[String])(Tweet<span class="preprocessor">.apply</span> _)

def tweetList() = Action {
  val results = <span class="number">3</span>
  val query = <span class="string">""</span><span class="string">"paperclip OR "</span>paper clip<span class="string">""</span><span class="string">""</span>
  val responseFuture =
    WS<span class="preprocessor">.url</span>(<span class="string">"http://search.twitter.com/search.json"</span>)
      <span class="preprocessor">.withQueryString</span>(<span class="string">"q"</span> -&gt; query, <span class="string">"rpp"</span> -&gt; results<span class="preprocessor">.toString</span>)
      <span class="preprocessor">.get</span>
  val response = Await<span class="preprocessor">.result</span>(responseFuture, <span class="number">10</span> seconds)
  val tweets = (Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>) \ <span class="string">"result"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
}
</pre></td></tr></table></figure>

<p>Tweetlist template</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>@(tweets: Seq[Tweet])

@main("Tweets") {
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Tweets<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  @tweets.map { tweet =&gt;
    <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
      <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">span</span>&gt;</span>@tweet.from<span class="tag">&lt;/<span class="title">span</span>&gt;</span>: @tweet.text<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="handling-responses-asynchronously">Handling responses asynchronously</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>val resultFuture: Future[Result] = responseFuture<span class="preprocessor">.map</span> { response =&gt;
  val tweets = Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>).\(<span class="string">"results"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
}

def tweetList() = Action {
  Async {
    val results = <span class="number">3</span>
    val query = <span class="string">""</span><span class="string">"paperclip OR "</span>paper clip<span class="string">""</span><span class="string">""</span>
    val responseFuture =
    WS<span class="preprocessor">.url</span>(<span class="string">"http://search.twitter.com/search.json"</span>)
      <span class="preprocessor">.withQueryString</span>(<span class="string">"q"</span> -&gt; query, <span class="string">"rpp"</span> -&gt; results<span class="preprocessor">.toString</span>)<span class="preprocessor">.get</span>
    responseFuture<span class="preprocessor">.map</span> { response =&gt;
      val tweets = Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>).\(<span class="string">"results"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
      Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="using-the-cache">Using the cache</h2>
<p>For all cache methods, you need an <code>implicit play.api.Application</code> in scope. You
can get one by importing <code>play.api.Play.current</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>//  it’ll compute Product.getBestSeller() <span class="keyword">and</span>
// cache it <span class="keyword">for</span> <span class="number">1800</span> seconds <span class="keyword">as</span> well <span class="keyword">as</span> <span class="keyword">return</span> it
val bestSellerProduct: Product =
  Cache.getOrElse(<span class="string">"product-bestseller"</span>, <span class="number">1800</span>){
    Product.getBestSeller()
  }
</pre></td></tr></table></figure>

<p>Caching an entire action</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>def tweetList() = Cached(<span class="string">"action-tweets"</span>, <span class="number">120</span>) {
  Action {
    Async {
      val results = <span class="number">3</span>
      val query = <span class="string">""</span><span class="string">"paperclip OR "</span>paper clip<span class="string">""</span><span class="string">""</span>
      val responseFuture =
        WS<span class="preprocessor">.url</span>(<span class="string">"http://search.twitter.com/search.json"</span>)
          <span class="preprocessor">.withQueryString</span>(<span class="string">"q"</span> -&gt; query, <span class="string">"rpp"</span> -&gt; results<span class="preprocessor">.toString</span>)<span class="preprocessor">.get</span>
      responseFuture<span class="preprocessor">.map</span> { response =&gt;
        val tweets =
        Json<span class="preprocessor">.parse</span>(response<span class="preprocessor">.body</span>).\(<span class="string">"results"</span>)<span class="preprocessor">.as</span>[Seq[Tweet]]
        Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.twitterrest</span><span class="preprocessor">.tweetlist</span>(tweets))
      }
    }
  }
}
</pre></td></tr></table></figure>

<p>You can use this to cache a recommendations page for each user ID:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>def userIdCacheKey(prefix: String) = { (header: RequestHeader) =&gt;
  prefix + header<span class="preprocessor">.session</span><span class="preprocessor">.get</span>(<span class="string">"userId"</span>)<span class="preprocessor">.getOrElse</span>(<span class="string">"anonymous"</span>)
}
def recommendations() = Cached(userIdCacheKey(<span class="string">"recommendations-"</span>), <span class="number">120</span>) {
  Action { request =&gt;
    val recommendedProducts =
      RecommendationsEngine<span class="preprocessor">.recommendedProductsForUser</span>(request<span class="preprocessor">.session</span><span class="preprocessor">.get</span>(<span class="string">"userId"</span>))
    Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.recommendations</span>(recommendedProducts))
  }
}
</pre></td></tr></table></figure>

<h2 id="other-request-methods-and-headers">Other request methods and headers</h2>
<p>As well as GET requests, you can of course use the WS library to send PUT , POST , DELETE,
and HEAD requests.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val newUser = Json<span class="preprocessor">.toJson</span>(Map(
  <span class="string">"name"</span> -&gt; <span class="string">"John Doe"</span>,
  <span class="string">"email"</span> -&gt; <span class="string">"j.doe@example.com"</span>))
val responseFuture =
  WS<span class="preprocessor">.url</span>(<span class="string">"http://api.example.com/users"</span>)<span class="preprocessor">.post</span>(newUser)

WS<span class="preprocessor">.url</span>(<span class="string">"http://example.com"</span>)<span class="preprocessor">.withHeaders</span>(HeaderNames<span class="preprocessor">.ACCEPT</span> -&gt; <span class="string">"application/json"</span>)
</pre></td></tr></table></figure>

<h2 id="authentication-mechanisms">Authentication mechanisms</h2>
<p>OAuth requests are authenticated using a signature that’s added to each request,
and this signature is calculated using secret keys that are shared between the
server that offers OAuth protected resources and a third party that OAuth calls
the consumer. Also, OAuth defines a standard to acquire some of the required keys
and the flow that allows end users to grant access to protected resources.</p>
<p>The OAuthCalculator can calculate signatures given a consumer key,
a consumer secret wrapped in a ConsumerKey , and an access token and
token secret wrapped in a RequestToken.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>val consumerKey = ConsumerKey(
  <span class="string">"52xEY4sGbPlO1FCQRaiAg"</span>,
  <span class="string">"KpnmEeDM6XDwS59FDcAmVMQbui8mcceNASj7xFJc5WY"</span>)

val accessToken = RequestToken(
  <span class="string">"16905598-cIPuAsWUI47Fk78guCRTa7QX49G0nOQdwv2SA6Rjz"</span>,
  <span class="string">"yEKoKqqOjo4gtSQ6FSsQ9tbxQqQZNq7LB5NGsbyKU"</span>)

def postTweet() = Action {
  val message = <span class="string">"Hi! This is an automated tweet!"</span>
  val data = Map(
    <span class="string">"status"</span> -&gt; Se<span class="string">q(message)</span>)
  val responseFuture =
    WS.url(<span class="string">"http://api.twitter.com/1/statuses/update.json"</span>)
      .sign(OAuthCalculator(consumerKey, accessToken)).post(data)
  Async(responseFuture.<span class="keyword">map</span>(<span class="string">response =&gt;</span> Ok(response.body)))
}
</pre></td></tr></table></figure>

<h1 id="dealing-with-streams-using-the-iteratee-library">Dealing with streams using the iteratee library</h1>
<p>Play’s iteratee library is in the <code>play.api.libs.iteratee</code> package.
This library is considered a cornerstone of Play’s reactive programming model.
It contains an abstraction for performing IO operations, called an iteratee.</p>
<p>Twitter not only offers the REST API that we saw in the previous section,
but also a streaming API.</p>
<p>You start out using this API much like the regular API:
you construct an HTTP request with some parameters that
specify which tweets you want to retrieve. Twitter will then
start returning tweets. But unlike the REST API, this streaming API will
never stop serving the response. It’ll keep
the HTTP connection open and will continue sending new tweets over it.</p>
<h2 id="processing-large-web-services-responses-with-an-iteratee">Processing large web services responses with an iteratee</h2>
<p>If the web service sends the response in chunks, the WS library buffers these
chunks until it has the complete HTTP response. 
The buffering strategy breaks down when trying to use the Twitter API. </p>
<p>We need another approach, where we can start using parts of the response as soon
as they arrive in our application, without needing to wait for the entire response.
And this is exactly what an iteratee can do. An iteratee is an object that receives
each individual chunk of data and can do something with that data.</p>
<p>When dealing with the Twitter streaming API, we’d want to use an iteratee that
converts the HTTP response chunks into tweet objects, and send them to another
part of our application, perhaps to be stored in a database.</p>
<p>Iteratees are instances of the Iteratee class, and they can most easily be con-
structed using methods on the Iteratee object.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="regexp">//</span> The foreach[A] method <span class="literal">on</span> the Iteratee object takes a single parameter, a <span class="reserved">function</span>
<span class="regexp">//</span> that takes a chunk <span class="keyword">of</span> type A <span class="keyword">and</span> returns an Iteratee[A, Unit]
<span class="regexp">//</span> For each chunk that’s received, a string <span class="keyword">is</span> constructed <span class="keyword">and</span> printed.
<span class="regexp">//</span>  The first indicates the Scala type <span class="keyword">for</span> the chunks that the iteratee accepts. 
val loggingIteratee = Iteratee.foreach[Array[Byte]] { chunk<span class="function"> =&gt;</span>
  val chunkString = <span class="keyword">new</span> String(chunk, <span class="string">"UTF-8"</span>)
  println(chunkString)
}

WS.url(<span class="string">"https://stream.twitter.com/1/statuses/sample.json"</span>)
  .sign(OAuthCalculator(consumerKey, accessToken))
  .get(_<span class="function"> =&gt;</span> loggingIteratee)
</pre></td></tr></table></figure>

<h2 id="creating-other-iteratees-and-feeding-them-data">Creating other iteratees and feeding them data</h2>
<p>The Iteratee object exposes more methods that we can use to create iteratees.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="regexp">//</span> accepts Int chunks, <span class="keyword">and</span> sums these chunks.
val summingIteratee = Iteratee.fold<span class="function"><span class="params">(<span class="number">0</span>)</span>{ <span class="params">(sum: Int, chunk: Int)</span> =&gt;</span>
  sum + chunk
}
</pre></td></tr></table></figure>

<p>It turns out that the Iteratee class has a counterpart: Enumerator .
An enumerator is a producer of chunks.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val intEnumerator = Enumerator(<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>)
// it’ll <span class="keyword">return</span> <span class="literal">a</span> future of <span class="literal">a</span> new iteratee
<span class="label">val newIterateeFuture:</span> Future[Iteratee[Int, Int]] =
  intEnumerator(summingIteratee)
// With <span class="literal">a</span> regular map , we’d get <span class="literal">a</span> Future[Future[Int]], but with flatMap, we get <span class="literal">a</span> Future[Int]  
<span class="label">val resultFuture:</span> Future[Int] = newIterateeFuture.flatMap(_.run)
resultFuture.onComplete(sum =&gt; println(<span class="string">"The sum is %d"</span> format sum))
</pre></td></tr></table></figure>

<h2 id="iteratees-and-immutability">Iteratees and immutability</h2>
<p>As mentioned before, the iteratee library is designed to be immutable: operations
don’t change the iteratee that you perform it on, but they return a new iteratee. </p>
<p>You can apply it to different enumerators as often as you like without problems.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>//  here are both an immutable and a mutable iteratee that do the same thing: sum integers:

val immutableSumIteratee = Iteratee.fold(0){ (sum: Int, chunk: Int) =&gt;
  sum + chunk
}
val mutableSumIteratee = {
  var sum = 0
  Iteratee.foreach[<span class="link_label">Int</span>](<span class="link_url">sum += _</span>).mapDone(_ =&gt; sum)
}
</pre></td></tr></table></figure>

<h1 id="websockets-bidirectional-communication-with-the-browser">WebSockets: Bidirectional communication with the browser</h1>
<p>The most basic approach is polling:
the browser sends a request to the server to ask for new data every second or so.</p>
<p>When polling, the browser sends a request to the server at a regular interval
requesting new messages. Often, the server will have nothing.</p>
<p>A more advanced workaround is Comet, which is a technique to allow the server to
push data to a client. With Comet, the browser starts a request and the server keeps
the connection open until it has something to send.</p>
<h2 id="a-real-time-status-page-using-websockets">A real-time status page using WebSockets</h2>
<p>From the application’s perspective, a WebSocket connection is essentially two
independent streams of data: one stream of data incoming from the client
and a second stream of data to be sent to the client.</p>
<p>To handle the incoming stream of data, you need to provide an iteratee. You also
provide an enumerator that’s used to send data to the client. With an iteratee and an
enumerator, you can construct a WebSocket, which comes in the place of an Action.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>@(implicit request: RequestHeader)
@main("Server Status") {
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    $(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"@route.WebSockets.statusFeed.webSocketUrL()"</span>)
      ws.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
        $(<span class="string">'#load-average'</span>).text(msg.data)
      }
    });
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>System load average: <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"load-average"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def statusFeed() = WebSocket<span class="preprocessor">.using</span>[String] { implicit request =&gt;
  // iterratee ignoring incoming message
  val <span class="keyword">in</span> = Iteratee<span class="preprocessor">.ignore</span>[String]
  val <span class="keyword">out</span> = Enumerator<span class="preprocessor">.repeatM</span> {
    Promise<span class="preprocessor">.timeout</span>(getLoadAverage), <span class="number">3</span> seconds)
  }
  (<span class="keyword">in</span>, <span class="keyword">out</span>)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>GET /WebSockets/statusFeed controllers<span class="preprocessor">.WebSockets</span><span class="preprocessor">.statusFeed</span>()
</pre></td></tr></table></figure>

<h2 id="a-simple-chat-application">A simple chat application</h2>
<p>Play allows you to make such an enumerator with <code>Concurrent.broadcast</code> .
This method returns a tuple with an enumerator and a Channel.
This channel is tied to the enumerator and allows you to
push chunks into the enumerator:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="title">val</span> <span class="params">(enumerator, channel)</span> = C<span class="title">oncurrent</span>.<span class="title">broadcast</span>[S<span class="title">tring</span>]
<span class="title">channel</span>.<span class="title">push</span><span class="params">(<span class="string">"Hello"</span>)</span>
<span class="title">channel</span>.<span class="title">push</span><span class="params">(<span class="string">"World"</span>)</span></span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Join</span><span class="params">(nick: String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leave</span><span class="params">(nick: String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Broadcast</span><span class="params">(message: String)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">var</span> users = Set[String]()
  <span class="keyword">var</span> (enumerator, channle) = Concurrent.broadcast[String]
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> Join(nick) =&gt; {
      <span class="keyword">if</span>(!users.contains(nick)) {
        <span class="keyword">val</span> iteratee = Iteratee.foreach[String] { message =&gt;
          self ! broadcast(<span class="string">"%s: %s"</span> format (nick, message))
        }.mapDone { _ =&gt;
          self ! Leave(nick)
        }
        users += nick
        channel.push(<span class="string">"User %s has joined the room, now %s users"</span>
          format(nick, users.size))
        sender ! (iteratee, enumerator)
      } <span class="keyword">else</span> {
        <span class="keyword">val</span> enumerator = Enumerator(<span class="string">"Nickname %s is already in use."</span> format nick)
        <span class="keyword">val</span> iteratee = Iteratee.ignore
        sender ! (iteratee, enumerator)
      }
    }
    <span class="keyword">case</span> Leave(nick) =&gt; {
      users -= nick
      channel.push(<span class="string">"User %s has left the room, %s users left"</span> format(nick, users.size))
    }
    <span class="keyword">case</span> Broadcast(msg: String) =&gt; channel.push(msg)
  }
}

<span class="comment">// Chat controller</span>
<span class="class"><span class="keyword">object</span> <span class="title">Chat</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  impplicit <span class="keyword">val</span> timeout = Timeout(<span class="number">1</span> seconds)
  <span class="keyword">val</span> room = Akka.system.actorOf(Props[ChatRoom])

  <span class="keyword">def</span> showRoom(nick: String) = Action {implicit request =&gt;
    Ok(views.html.chat.showRoom(nick))
  }
  
  <span class="keyword">def</span> chatSocket(nick: String) = WebSocket.async { request =&gt;
    <span class="keyword">val</span> channelsFuture = room ? Join(nick)
    channlesFuture.mapTo[(Iteratee[String, _], Enumerator[String])]
  }
 
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>GET /room/:nick controllers<span class="preprocessor">.Chat</span><span class="preprocessor">.room</span>(nick)
GET /room/socket/:nick controllers<span class="preprocessor">.Chat</span><span class="preprocessor">.chatSocket</span>(nick)
</pre></td></tr></table></figure>

<h1 id="using-body-parsers-to-deal-with-http-request-bodies">Using body parsers to deal with HTTP request bodies</h1>
<p>HTTP requests are normally processed when they’ve been fully received by the server.
An action is only invoked when the request is complete, and when the body parser is
done parsing the body of the request.</p>
<p>In this section, we’ll show how body
parsers work, how you can use and compose existing body parsers, and finally how you
can build your own body parsers from scratch.</p>
<h2 id="structure-of-a-body-parser">Structure of a body parser</h2>
<p>A body parser is an object that knows what to make of an HTTP request body. A JSON
body parser, for example, knows how to construct a JsValue from the body of an
HTTP request that contains JSON data.</p>
<p>A body parser can also choose to return an error Result; for example, when the
user exceeds the storage quota, or when the HTTP request body doesn’t conform to
what the body parser expects, like a non-JSON body for a JSON body parser.</p>
<p>A BodyParser is a function with a RequestHeader parameter
returning an iteratee. The iteratee consumes chunks of type Array[Byte] and
eventually produces either a play.api.mvc.Result or an A, which can be anything.</p>
<p>An Action in Play not only defines the method that constructs a Result from a
<code>Request[A]</code>, but it also contains the body parser that must be used for requests that
are routed to this action. </p>
<p>the following two Action definitions construct the same Action:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Action { <span class="comment">// block }</span>
<span class="comment">//  The anyContent body parser is of type BodyParser[AnyContent],</span>
<span class="comment">// so your action will receive a Request[AnyContent]</span>
<span class="comment">//  AnyContent is a convenient one; it has the methods asJson, asText, asXml, and so on,</span>
<span class="function">Action(BodyParsers.parse.anyContent)</span> { <span class="comment">// block }</span>
</pre></td></tr></table></figure>

<p>the BodyParsers.parse.json body parser will result in a <code>Request[JsValue]</code>,
and then the body field of the Request is of type JsValue.
With the json body parser, a BadRequest response is sent back to the client
automatically when the body doesn’t contain valid JSON.</p>
<p><img src="/img/play_body_parse.png" alt="Body parser in the request lifecycle"></p>
<h2 id="using-built-in-body-parsers">Using built-in body parsers</h2>
<p>Play has many more body parsers, all available on the <code>Bodyparsers.parse</code> object.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>// This action will <span class="constant">return</span> <span class="operator">an</span> EntityTooLarge HTTP response<span class="comment">
// when the body is larger than 10,000 bytes.</span>
def myAction = Action(parse.json(<span class="number">10000</span>)) {
 <span class="comment"> // foo</span>
}
</pre></td></tr></table></figure>

<p>If you don’t specify a maximum length, the text, JSON, XML, and
URL-encoded body parsers default to a limit of 512 kilobytes. This can be changed in
<code>application.conf</code>: <code>parsers.text.maxLength = 1m</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// To store uploaded file, you can use the temporaryFile body parser.
def upload = Action(parse<span class="preprocessor">.temporaryFile</span>) { request =&gt;
  val destinationFile = Play<span class="preprocessor">.getFile</span>(<span class="string">"uploads/myfile"</span>)
  request<span class="preprocessor">.body</span><span class="preprocessor">.moveTo</span>(destinationFile)
  Ok(<span class="string">"File successfully uploaded!"</span>)
}
</pre></td></tr></table></figure>

<h2 id="composing-body-parsers">Composing body parsers</h2>
<p>The built-in body parsers are fairly basic. It’s possible to compose these basic
body parsers into more complex ones that have more complex behavior if you need that.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>// Play also has <span class="operator">a</span> <span class="built_in">file</span> body parser that takes <span class="operator">a</span> java.io.File <span class="keyword">as</span> <span class="operator">a</span> parameter:
def store(filename: String) = Action(parse.<span class="built_in">file</span>(Play.getFile(filename))) { request =&gt;
  Ok(<span class="string">"Your file is saved!"</span>)
}
</pre></td></tr></table></figure>

<p>Suppose we want to make a body parser that works like the file body parser, but
only saves the file if the content type is some given value.</p>
<p>We can use the <code>BodyParsers.parse.when</code> method to construct a
new body parser from a predicate, an existing body parser,
and a function constructing a failure result:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def fileWithContentType(filname:<span class="built_in">String</span>, contentType: <span class="built_in">String</span>) =
  parse.when(
    requestHeader =&gt; requestHeader.contentType == contentType,
    parse.file(Play.getFile(filename)),
    requestHeader =&gt; BadRequest(  <span class="comment">// Existing body parser</span>
      <span class="string">"Expected a '%s' content type, but found %s"</span>.
        format(contentType, requestHeader.contentType)))

<span class="comment">// We can use this body parser as follows:</span>
def savePdf(filename: <span class="built_in">String</span>) = Action(fileWithContentType(filename, <span class="string">"application/pdf"</span>)) { request =&gt;
  Ok(<span class="string">"Your file is saved!"</span>)
}
</pre></td></tr></table></figure>

<p>We can start with the temporaryFile body parser to store the file on
disk and then upload it to MongoDB.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def mongoDbStorageBodyParser(dbName: String) =
  parse<span class="preprocessor">.temporaryFile</span><span class="preprocessor">.map</span> { temporaryFile =&gt;
  // Here some code to store the file <span class="keyword">in</span> MongoDB
  // <span class="keyword">and</span> get an objectId
  objectId
}
val dbName = Play<span class="preprocessor">.configuration</span><span class="preprocessor">.getString</span>(<span class="string">"mongoDbName"</span>)<span class="preprocessor">.getOrElse</span>(<span class="string">"mydb"</span>)

def saveInMongo = Action(mongoDbStorageBodyParser(dbName)) {
  request =&gt;
    Ok(<span class="string">"Your file was saved with id %s"</span> format request<span class="preprocessor">.body</span>)
}
</pre></td></tr></table></figure>

<h2 id="building-a-new-body-parser">Building a new body parser</h2>
<p>In this section, we’ll build another body parser that allows a user to upload a file.
This time, though, it won’t be stored on disk or in MongoDB, but on Amazon’s Simple
Storage Service, better known as S3.</p>
<p>The underlying library that Play uses, Async HTTP Client (AHC), does support
pushing chunks of data into a request body</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre>private lazy val client = {
  val playConfig = WS<span class="preprocessor">.client</span><span class="preprocessor">.getConfig</span>
  new AsyncHttpClient(new GrizzlyAsyncHttpProvider(playConfig), playConfig)
}

// Amazon requires requests to be signed. 
def sign(method: String, path: String,
         secretKey: String,
         date: String,
         contentType: Option[String] = None,
         aclHeader: Option[String] = None) = {
  val message = List(method, <span class="string">""</span>,
    contentType<span class="preprocessor">.getOrElse</span>(<span class="string">""</span>),
    date, aclHeader<span class="preprocessor">.map</span>(<span class="string">"x-amz-acl:"</span> + _)<span class="preprocessor">.getOrElse</span>(<span class="string">""</span>), path)<span class="preprocessor">.mkString</span>(<span class="string">"\n"</span>)
  // Play’s Crypto<span class="preprocessor">.sign</span> method returns a Hex string,
  // instead of Base64, so we do hashing ourselves.
  val mac = Mac<span class="preprocessor">.getInstance</span>(<span class="string">"HmacSHA1"</span>)
  mac<span class="preprocessor">.init</span>(new SecretKeySpec(secretKey<span class="preprocessor">.getBytes</span>(<span class="string">"UTF-8"</span>), <span class="string">"HmacSHA1"</span>))
  val codec = new Base64()
  new String(codec<span class="preprocessor">.encode</span>(mac<span class="preprocessor">.doFinal</span>(message<span class="preprocessor">.getBytes</span>(<span class="string">"UTF-8"</span>))))
}

def buildRequest(bucket: String, objectId: String, key: String,
    secret: String, requestHeader: RequestHeader): (Request, FeedableBodyGenerator) = {
  val expires = dateFormat<span class="preprocessor">.format</span>(new Date())
  val path = <span class="string">"/%s/%s"</span> format (bucket, objectId)
  val acl = <span class="string">"public-read"</span>
  val contentType = requestHeader<span class="preprocessor">.headers</span><span class="preprocessor">.get</span>(HeaderNames<span class="preprocessor">.CONTENT</span>_TYPE)
                                         <span class="preprocessor">.getOrElse</span>(<span class="string">"binary/octet-stream"</span>)
  val auth = <span class="string">"AWS %s:%s"</span> format (key, sign(<span class="string">"PUT"</span>, path, secret,
    expires, Some(contentType), Some(acl)))
  val url = <span class="string">"https://%s.s3.amazonaws.com/%s"</span> format (bucket, objectId)
  val bodyGenerator = new FeedableBodyGenerator()
  val request = new RequestBuilder(<span class="string">"PUT"</span>)
    <span class="preprocessor">.setUrl</span>(url)
    <span class="preprocessor">.setHeader</span>(<span class="string">"Date"</span>, expires)
    <span class="preprocessor">.setHeader</span>(<span class="string">"x-amz-acl"</span>, acl)
    <span class="preprocessor">.setHeader</span>(<span class="string">"Content-Type"</span>, contentType)
    <span class="preprocessor">.setHeader</span>(<span class="string">"Authorization"</span>, auth)
    <span class="preprocessor">.setContentLength</span>(requestHeader<span class="preprocessor">.headers</span>
    <span class="preprocessor">.get</span>(HeaderNames<span class="preprocessor">.CONTENT</span>_LENGTH)<span class="preprocessor">.get</span><span class="preprocessor">.toInt</span>)
    <span class="preprocessor">.setBody</span>(bodyGenerator)
    <span class="preprocessor">.build</span>()
  (request, bodyGenerator)
}
</pre></td></tr></table></figure>

<p>Amazon S3 body parser</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">def</span> S3Upload(bucket: String, objectId: String) = BodyParser {
    requestHeader =&gt;
  <span class="keyword">val</span> awsSecret = Play.configuration.getString(<span class="string">"aws.secret"</span>).get
  <span class="keyword">val</span> awsKey = Play.configuration.getString(<span class="string">"aws.key"</span>).get
  <span class="keyword">val</span> (request, bodyGenerator) =
    buildRequest(bucket, objectId, awsKey, awsSecret, requestHeader)
  S3Writer(objectId, request, bodyGenerator)
}

<span class="keyword">def</span> S3Writer(objectId: String, request: Request,
    bodyGenerator: FeedableBodyGenerator):Iteratee[Array[Byte], Either[Result, String]] = {
  <span class="comment">// We execute the request, but we can send body chunks afterwards.</span>
  <span class="keyword">val</span> responseFuture = client.executeRequest(request)
  Iteratee.fold[Array[Byte], FeedableBodyGenerator](bodyGenerator) {
  (generator, bytes) =&gt;
    <span class="keyword">val</span> isLast = <span class="keyword">false</span>
    generator.feed(<span class="keyword">new</span> ByteBufferWrapper(ByteBuffer.wrap(bytes)), isLast)
    generator
  } mapDone { generator =&gt;
    <span class="keyword">val</span> isLast = <span class="keyword">true</span>
    <span class="keyword">val</span> emptyBuffer = <span class="keyword">new</span> ByteBufferWrapper(ByteBuffer.wrap(Array[Byte]()))
    generator.feed(emptyBuffer, isLast)
    <span class="keyword">val</span> response = responseFuture.get
    response.getStatusCode <span class="keyword">match</span> {
      <span class="keyword">case</span> <span class="number">200</span> =&gt; Right(objectId)
      <span class="keyword">case</span> _ =&gt; Left(Forbidden(response.getResponseBody))
    }
  }
}
</pre></td></tr></table></figure>

<p>Enumeratees can sit between enumerators and iteratees
and modify the stream. Elements of the stream can be removed, changed, or grouped.</p>
]]></content>
    
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Modules & Plugins]]></title>
    <link href="http://zhpooer.github.io/2014/08/18/play-for-scala-modules-&-plugins/"/>
    <id>http://zhpooer.github.io/2014/08/18/play-for-scala-modules-&-plugins/</id>
    <published>2014-08-18T12:56:34.000Z</published>
    <updated>2014-08-20T03:21:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="modules">Modules</h1>
<p>Currently available modules for Play 2 provide anything from alternate template
engines to NoSQL database layers.
This section will explain how to use a common module and, later on, how
to build a module yourself.</p>
<h2 id="using-modules">Using Modules</h2>
<p>Play modules are, like any other library, a collection of files in a JAR. This means that
you add a module to your project the same way you add any other library: you add it to
appDependencies in <code>project/Build.scala</code> .</p>
<p>www.playframework.com/documentation/2.1.x/Modules</p>
<p>Let’s get started: make a copy of the sample project in chapter 2, and add the
dependency and resolver.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">import</span> sbt._
<span class="keyword">import</span> Keys._
<span class="keyword">import</span> PlayProject._

<span class="class"><span class="keyword">object</span> <span class="title">ApplicationBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> {</span>
  <span class="keyword">val</span> appName = <span class="string">"product-details"</span>
  <span class="keyword">val</span> appVersion = <span class="string">"1.0-SNAPSHOT"</span>
  <span class="keyword">val</span> appDependencies = Seq(
    <span class="string">"net.sf.barcode4j"</span> % <span class="string">"barcode4j"</span> % <span class="string">"2.0"</span>,
    <span class="string">"securesocial"</span> %% <span class="string">"securesocial"</span> % <span class="string">"2.1.0"</span>
  )

  <span class="keyword">val</span> main = PlayProject(appName, appVersion,
    appDependencies, mainLang = SCALA ).settings(
      resolvers +=
        Resolver.url(
          <span class="string">"SecureSocial Repository"</span>, url(<span class="string">"http://repo.scala-sbt.org/scalasbt/sbt-plugin-releases/"</span>)
        )(Resolver.ivyStylePatterns)
    )
}
</pre></td></tr></table></figure>

<p>According to the documentation, SecureSocial provides a replacement
for Action called SecuredAction. This method acts the same way as Action,
except that it first checks whether the user is
logged in and redirects to a login page if necessary.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="keyword">def</span> list = SecuredAction { implicit request =&gt;
  <span class="keyword">val</span> products = Product.findAll
  Ok(views.html.products.list(products))
}

<span class="class"><span class="keyword">class</span> <span class="title">SimpleUserService</span><span class="params">(val app: Application)</span> <span class="keyword">extends</span> <span class="title">UserService</span></span>
    <span class="keyword">with</span> Plugin {
    
  <span class="keyword">var</span> users: Map[UserId, SocialUser] = Map()
  <span class="comment">// stores login tokens</span>
  <span class="keyword">var</span> tokens: Map[String, Token] = Map()

  <span class="keyword">def</span> find(id: UserId): Option[SocialUser] = {
    users.get(id)
  }

  <span class="keyword">def</span> findByEmailAndProvider(email: String, providerId: String) = {
    users.values.find { user =&gt;
      user.id.providerId == providerId &&
      user.email == Some(email)
    }
  }

  <span class="keyword">def</span> save(user: Identity): Identity = {
    <span class="keyword">val</span> socialUser: SocialUser = SocialUser(user)
    users = users + (user.id -&gt; socialUser)
    socialUser
  }
  <span class="comment">// savetoken</span>
  <span class="keyword">def</span> save(token: Token) {
    tokens = tokens + (token.uuid -&gt; token)
  }

  <span class="keyword">def</span> findToken(token: String) = {
   <span class="comment">// Looks up a token</span>
    tokens.get(token)
  }

  <span class="keyword">def</span> deleteToken(uuid: String) {
    tokens = tokens - uuid
  }

  <span class="keyword">def</span> deleteExpiredTokens() {
    tokens = tokens.filter{ !_._2.isExpired }
  }
}
</pre></td></tr></table></figure>

<p><code>conf/securesocial.conf</code>, If you prefer to keep it in
<code>conf/application.conf</code>, that’s fine too.
<code>conf/application.conf</code> should contains <code>include &quot;securesocial.conf&quot;</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>userpass {
  withUserNameSupport=<span class="literal">false</span>
  sendWelcomeEmail=<span class="literal">false</span>
  enableGravatarSupport=<span class="literal">false</span>
  tokenDuration=<span class="number">60</span>
  tokenDeleteInterval=<span class="number">5</span>
  minimumPasswordLength=<span class="number">8</span>
  enableTokenJob=<span class="literal">true</span>
  hasher=bcrypt
}
securesocial {
  onLoginGoTo=/
  onLogoutGoTo=/login
  ssl=<span class="literal">false</span>
  sessionTimeOut=<span class="number">60</span>
  assetsController=controllers.ReverseMyCustomAssetsController
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>GET /login securesocial<span class="preprocessor">.controllers</span><span class="preprocessor">.LoginPage</span><span class="preprocessor">.login</span>
GET /logout securesocial<span class="preprocessor">.controllers</span><span class="preprocessor">.LoginPage</span><span class="preprocessor">.logout</span>
</pre></td></tr></table></figure>

<h2 id="creating-modules">Creating modules</h2>
<p>Creating a Play module is as easy as making a Play application. In fact, that’s how you
start with a new module—you create a new Play application as the starting point.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>play <span class="keyword">new</span> ean
rm app<span class="regexp">/public/</span>*
rm app<span class="regexp">/views/</span>*
rm conf/application.conf
</pre></td></tr></table></figure>

<p><code>app/controller/Barcodes.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">package</span> com.github.playforscala.barcodes
<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="keyword">import</span> org.krysalis.barcode4j.output.bitmap.BitmapCanvasProvider
<span class="keyword">import</span> org.krysalis.barcode4j.impl.upcean.EAN13Bean
<span class="keyword">import</span> util.{Failure, Success, Try}

<span class="class"><span class="keyword">object</span> <span class="title">Barcodes</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">val</span> ImageResolution = <span class="number">144</span>
  
  <span class="keyword">def</span> barcode(ean: Long) = Action {
    <span class="keyword">val</span> MimeType = <span class="string">"image/png"</span>
    Try(ean13BarCode(ean, MimeType)) <span class="keyword">match</span> {
      <span class="keyword">case</span> Success(imageData) =&gt; Ok(imageData).as(MimeType)
      <span class="keyword">case</span> Failure(e) =&gt;
        BadRequest(<span class="string">"Couldn’t generate bar code. Error: "</span> +e.getMessage)
    }
  }

  <span class="keyword">def</span> ean13BarCode(ean: Long, mimeType: String): Array[Byte] = {
    <span class="keyword">import</span> java.io.ByteArrayOutputStream
    <span class="keyword">import</span> java.awt.image.BufferedImage
    <span class="keyword">val</span> output = <span class="keyword">new</span> ByteArrayOutputStream
    <span class="keyword">val</span> canvas =
      <span class="keyword">new</span> BitmapCanvasProvider(output, mimeType, ImageResolution,
        BufferedImage.TYPE_BYTE_BINARY, <span class="keyword">false</span>, <span class="number">0</span>)

    <span class="keyword">val</span> barCode = <span class="keyword">new</span> EAN13Bean
    barCode.generateBarcode(canvas, String valueOf ean)
    canvas.finish()
    output.toByteArray
  }
}
</pre></td></tr></table></figure>

<p>We’ll explain that in the “Testing your module” section. The
route will therefore look like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>GET /:ean <span class="keyword">com</span><span class="preprocessor">.github</span><span class="preprocessor">.playforscala</span><span class="preprocessor">.barcodes</span><span class="preprocessor">.Barcodes</span><span class="preprocessor">.barcode</span>(ean: Long)
</pre></td></tr></table></figure>

<h3 id="publish">Publish</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
val main = play<span class="preprocessor">.Project</span>(appName, appVersion, appDependencies)<span class="preprocessor">.settings</span>(
  publishTo := Some(<span class="string">"My Maven repository"</span> at <span class="string">"http://maven.example.com/releases"</span>),
  credentials += Credentials(Path<span class="preprocessor">.userHome</span> / <span class="string">".repo-credentials"</span>)
)
</pre></td></tr></table></figure>

<h3 id="testing-your-module">TESTING YOUR MODULE</h3>
<p><code>play new module-test</code></p>
<p><code>project/Build.scala</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">...</span>
val appDependencies = Seq(
  <span class="string">"playforscala"</span> %% <span class="string">"ean-module"</span> % <span class="string">"1.0-SNAPSHOT"</span>
)
<span class="keyword">...</span>
</pre></td></tr></table></figure>

<p><code>app/views/index.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">(message:</span> String)
@<span class="function">main(<span class="string">"Welcome to Play 2.0"</span>)</span> </span>{
  <span class="at_rule">@<span class="keyword">tags.barcode(1234567890128l)</span>
}</span>
</pre></td></tr></table></figure>

<h1 id="plugins">Plugins</h1>
<p>Play provides a <code>play.api.Plugin trait</code>, specifically
for modules to initialize themselves.</p>
<p>Note that Plugin is only really useful for modules, because a <code>Global</code> object in
a Play application can do anything a <code>Plugin</code> can do.</p>
<p>The Plugin trait has three methods: onStart, onStop, and enabled. The first two are
called on application startup and shutdown, respectively, but only if the plugin is
enabled.</p>
<p>You can “enable” your plugin in your module’s play.plugins file and
provide the user with a more convenient way to really enable the plugin,
in application.conf, for instance.</p>
<p>Let’s say we want to cache our generated bar
codes, and for some reason we don’t want to use Play’s built-in cache.</p>
<ul>
<li>Concurrent calls should be handled concurrently</li>
<li>Multiple calls for the same bar code should cause no more than one cache miss</li>
</ul>
<p>In order to satisfy those requirements, we’ll use an actor.
It would only be able to render one bar code at a time if we did that.
The easiest solution is to have the future’s onComplete send the
rendered image to the client.</p>
<p><code>app/com/github/playforscala/barcodes/BarcodeCache.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">package</span> com.github.playforscala.barcodes

<span class="keyword">import</span> akka.actor.Actor
<span class="keyword">import</span> concurrent._
<span class="keyword">import</span> org.krysalis.barcode4j.output.bitmap.BitmapCanvasProvider
<span class="keyword">import</span> org.krysalis.barcode4j.impl.upcean.EAN13Bean
<span class="keyword">import</span> scala.util.Try
<span class="keyword">import</span> play.api.libs.concurrent.Execution.Implicits._

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RenderImage</span><span class="params">(ean: Long)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">RenderResult</span><span class="params">(image: Try[Array[Byte]])</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">BarcodeCache</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">var</span> imageCache = Map[Long, Future[Array[Byte]]]()
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> RenderImage(ean) =&gt; {
      <span class="keyword">val</span> futureImage = imageCache.get(ean) <span class="keyword">match</span> {
        <span class="keyword">case</span> Some(futureImage) =&gt; futureImage
        <span class="keyword">case</span> None =&gt;
          <span class="keyword">val</span> futureImage = future { ean13BarCode(ean, <span class="string">"image/png"</span>) }
          imageCache += (ean -&gt; futureImage)
          futureImage
      }
      <span class="keyword">val</span> client = sender
      futureImage.onComplete {
        client ! RenderResult(_)
      }
    }
  }

  <span class="keyword">def</span> ean13BarCode(ean: Long, mimeType: String): Array[Byte] = {
    <span class="keyword">import</span> java.io.ByteArrayOutputStream
    <span class="keyword">import</span> java.awt.imageBufferedImage
    <span class="keyword">val</span> output = <span class="keyword">new</span> ByteArrayOutputStream
    <span class="keyword">val</span> canvas = <span class="keyword">new</span> BitmapCanvasProvider(output, mimeType,
      Barcodes.imageResolution, BufferedImage.TYPE_BYTE_BINARY,
      <span class="keyword">false</span>, <span class="number">0</span>)
    <span class="keyword">val</span> barCode = <span class="keyword">new</span> EAN13Bean
    barCode.generateBarcode(canvas, String valueOf ean)
    canvas.finish()

    output.toByteArray
  }
}
</pre></td></tr></table></figure>

<p><code>app/com/github/playforscala/barcodes/Barcodes.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>package <span class="keyword">com</span><span class="preprocessor">.github</span><span class="preprocessor">.playforscala</span><span class="preprocessor">.barcodes</span>

import akka<span class="preprocessor">.actor</span><span class="preprocessor">.ActorRef</span>
import akka<span class="preprocessor">.pattern</span><span class="preprocessor">.ask</span>
import util<span class="preprocessor">.Try</span>
import scala<span class="preprocessor">.concurrent</span><span class="preprocessor">.Future</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.concurrent</span><span class="preprocessor">.Execution</span><span class="preprocessor">.Implicits</span>._
import scala<span class="preprocessor">.concurrent</span><span class="preprocessor">.duration</span>._
import akka<span class="preprocessor">.util</span><span class="preprocessor">.Timeout</span>

object Barcodes {
  var barcodeCache: ActorRef = _
  val mimeType = <span class="string">"image/png"</span>
  val imageResolution = <span class="number">144</span>

  def renderImage(ean: Long): Future[Try[Array[Byte]]] = {
    implicit val timeout = Timeout(<span class="number">20.</span>seconds)
    barcodeCache ? RenderImage(ean) map {
      case RenderResult(result) =&gt; result
    }
  }
}
</pre></td></tr></table></figure>

<p><code>app/com/github/playforscala/barcodes/</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">package</span> com.github.playforscala.barcodes
<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="keyword">import</span> util.{Failure, Success}
<span class="keyword">import</span> play.api.libs.concurrent.Execution.Implicits._

<span class="class"><span class="keyword">object</span> <span class="title">BarcodesController</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> barcode(ean: Long) = Action {
    Async {
      Barcodes.renderImage(ean) map {
        <span class="keyword">case</span> Success(image) =&gt; Ok(image).as(Barcodes.mimeType)
        <span class="keyword">case</span> Failure(e) =&gt;
          BadRequest(<span class="string">"Couldn’t generate bar code. Error: "</span> + e.getMessage)
      }
    }
  }
}
</pre></td></tr></table></figure>

<p><code>.../playforscala/barcodes/BarcodesPlugin.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">package</span> com.github.playforscala.barcodes

<span class="keyword">import</span> play.api.{Application, Logger, Plugin}
<span class="keyword">import</span> play.api.libs.concurrent.Akka
<span class="keyword">import</span> play.api.Play.current
<span class="keyword">import</span> akka.actor.Props

<span class="class"><span class="keyword">class</span> <span class="title">BarcodesPlugin</span><span class="params">(val app: Application)</span> <span class="keyword">extends</span> <span class="title">Plugin</span> {</span>
  <span class="keyword">override</span> <span class="keyword">def</span> onStart(){
    Logger.info(<span class="string">"initializing cace"</span>)
    Barcodes.barcodeCache = Akka.system.actorOf(Props[BarcodeCache])
  }
  
  <span class="keyword">override</span> <span class="keyword">def</span> onStop() {
    Logger.info(<span class="string">"stopping application"</span>)
  }
  <span class="comment">// if this method returns false, none of the others are ever called</span>
  <span class="keyword">override</span> <span class="keyword">def</span> enable = <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<p>There’s one more thing to do to make the plugin work.
It must be configured in a file called <code>conf/play.plugins</code></p>
<p>The priority determines the order in which the plugins are initialized,
with lower numbers being first.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="number">1000</span>:<span class="keyword">com</span><span class="preprocessor">.github</span><span class="preprocessor">.playforscala</span><span class="preprocessor">.barcodes</span><span class="preprocessor">.BarcodesPlugin</span>
</pre></td></tr></table></figure>

<p>If your application is going to get hit with a lot of requests for different
bar codes simultaneously, you’re going to fill up the default thread pool—which might
slow things down in the rest of the application. You might want to use a separate
thread pool for your bar code Future objects. If your application runs on multiple
servers for performance reasons, you might want to use Akka’s distributed features to
run one instance of the BarcodeCache actor that all application instances will talk to.</p>
<h1 id="deploying-to-production">Deploying to production</h1>
<p>As a better alternative, you can use play start. This will start Play in production
mode. In this mode, a new JVM is forked for your application, and
it’s running separately from the play command.</p>
<p>The play process will terminate but leave your application running.
Your application’s process ID is written to a file RUNNING_PID.</p>
<p>You can stop this application with play stop. This will send the SIGTERM signal to
your application’s process. </p>
<p>Play provides the <code>stage</code> and <code>dist</code> tasks. When running play
stage, Play compiles your application to a JAR file, and—together with all the
dependency JARs—puts it in the <code>target/staged</code> directory.
It also creates a start script in <code>target/start</code>.</p>
<p>After running <code>play dist</code>, you get a directory dist that contains a zip file
with your application. You might need to make the start script
executable first with <code>chmod +x</code> start.</p>
<h2 id="working-with-multiple-configurations">Working with multiple configurations</h2>
<p>Don’t use the same credentials for your production database</p>
<p><code>conf/application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>mail<span class="preprocessor">.override</span><span class="preprocessor">.enabled</span> = true
mail<span class="preprocessor">.override</span><span class="preprocessor">.address</span> = <span class="string">"info@example.org"</span>

include <span class="string">"development.conf"</span>
</pre></td></tr></table></figure>

<p>The first two lines of this configuration override email recipient addresses, making the
application send all notifications to one address, <code>info@example.org</code></p>
<p>The last line includes settings from another configuration file in the same
directory called development.conf. This allows each developer to create their
own <code>conf/development.conf</code> and override the default test configuration.</p>
<p>Be sure to add this file to .gitignore or your source control system’s equivalent.</p>
<p>A nice thing about the configuration library is that the configuration doesn’t break
if the <code>development.conf</code> file doesn’t exist; the library just silently ignores it.</p>
<p>For production, then, we can use a separate /etc/paperclips/production.conf
configuration file:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>include classpath(<span class="string">"application.conf"</span>)
email.<span class="keyword">override</span>.enabled=<span class="keyword">false</span>
</pre></td></tr></table></figure>

<p>To use the production configuration instead of the default configuration,
specify the file as a system property when starting the application:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">play</span> <span class="string">"start -Dconfig.file=/etc/paperclips/production.conf"</span>
</pre></td></tr></table></figure>

<h2 id="creating-native-packages-for-a-package-manager">Creating native packages for a package manager</h2>
<p>The sbt plugin sbt-native-packager helps you create these deb and rpm
packages as well as Homebrew packages that can be used on Mac OS X,
and MSI packages for Windows.</p>
<p>The play2-native-packager plugin builds deb packages for Debian or Ubuntu,
and the play2-ubuntu-package plugin builds lightweight deb packages
designed specifically for recent versions of Ubuntu.</p>
<h2 id="setting-up-a-front-end-proxy">Setting up a front-end proxy</h2>
<p>It also gives you the ability to do upgrades without downtime. If you have a front-end
proxy doing load balancing between two application instances, you can take one
instance down, upgrade it, and bring it back up, all without downtime.</p>
<p>HAProxy is a powerful and reliable proxy that has a plethora of advanced options,
but is still easy to get started with.</p>
<p>Suppose we want to set up HAProxy to listen on port 80, and redirect traffic to two
instances of our Play application. We’ll also use WebSockets in this application,
so we must make sure that these connections are properly proxied as well.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>global
  daemon
  maxconn <span class="number">256</span>
  
defaults
  mode http
  timeout connect <span class="number">5</span>s
  timeout client <span class="number">50</span>s
  timeout <span class="built_in">server</span> <span class="number">50</span>s
  <span class="keyword">option</span> forwardfor
  <span class="keyword">option</span> http-<span class="built_in">server</span>-close
  
frontend http-<span class="keyword">in</span>
  bind *:<span class="number">80</span>
  default_backend playapp
  
backend playapp
  <span class="built_in">server</span> s1 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9000</span> maxconn <span class="number">32</span> check
  <span class="built_in">server</span> s2 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span> maxconn <span class="number">32</span> check
</pre></td></tr></table></figure>

<p>If you set the pidfile.path to <code>/dev/null</code>, no PID file will be created.</p>
<h2 id="using-ssl">Using SSL</h2>
<p>Play can automatically generate a key store for you with a self-signed certificate,
which is useful in development mode. All you need to start experimenting with SSL is
to set the <code>https.port</code> system property:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">play -Dhttps.port</span>=<span class="string">9001 run</span>
</pre></td></tr></table></figure>

<p>The generated key store is saved in <code>conf/generated.keystore</code>, and Play will reuse
it if you restart your application so you don’t get the certificate warning again and again.</p>
<p>Once you have a key store file with your key and certificates, you need to point Play
to it. Set <code>https.keyStore</code> to point to your key store and <code>https.keyStorePassword</code> to
your password:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>play -Dhttps<span class="preprocessor">.port</span>=<span class="number">9001</span> -Dhttps<span class="preprocessor">.keyStore</span>=mykeystore<span class="preprocessor">.jks</span>
  -Dhttp<span class="preprocessor">.keyStorePassword</span>=mypassword run
</pre></td></tr></table></figure>

<p>Even though Play supports SSL, the recommended way to use SSL with Play in produc-
tion is to let the front end—like HAProxy or Apache—handle it.</p>
<h2 id="deploying-to-an-application-server">Deploying to an application server</h2>
<p>e Play doesn’t use the Servlet API, which makes it
impossible to run on an application server that expects web applications to use it.
Luckily, there’s a plugin for Play 2, the <code>play2-war-plugin</code>, that can package your
application as a WAR. It provides a layer between the Servlet API and your Play application.</p>
<p>Some of the more advanced features of Play, like WebSockets, don’t work with all
Servlet API versions.</p>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-JSON]]></title>
    <link href="http://zhpooer.github.io/2014/08/18/play-for-scala-json/"/>
    <id>http://zhpooer.github.io/2014/08/18/play-for-scala-json/</id>
    <published>2014-08-18T02:39:36.000Z</published>
    <updated>2014-08-18T12:42:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="creating-the-single-page-play-application">Creating the single-page Play application</h1>
<p>In this section, we’ll add dynamic data from the server to our web page: a table of
products that shows each product’s EAN code</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">package</span> models
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(ean: Long, name: String, description: String)</span></span>
<span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">var</span> products = Set(
    Product(<span class="number">5010255079763</span>L, <span class="string">"Paperclips Large"</span>,
      <span class="string">"Large Plain Pack of 1000"</span>),
    Product(<span class="number">5018206244666</span>L, <span class="string">"Giant Paperclips"</span>,
      <span class="string">"Giant Plain 51mm 100 pack"</span>),
    Product(<span class="number">5018306332812</span>L, <span class="string">"Paperclip Giant Plain"</span>,
      <span class="string">"Giant Plain Pack of 10000"</span>),
    Product(<span class="number">5018306312913</span>L, <span class="string">"No Tear Paper Clip"</span>,
      <span class="string">"No Tear Extra Large Pack of 1000"</span>),
    Product(<span class="number">5018206244611</span>L, <span class="string">"Zebra Paperclips"</span>,
      <span class="string">"Zebra Length 28mm Assorted 150 Pack"</span>)
  )

  <span class="keyword">def</span> findAll = <span class="keyword">this</span>.products.toList.sortBy(_.ean)
  <span class="keyword">def</span> findByEan(ean: Long) = <span class="keyword">this</span>.products.find(_.ean == ean)
  <span class="keyword">def</span> save(product: Product) = {
    findByEan(product.ean).map( oldProduct =&gt;
      <span class="keyword">this</span>.products = <span class="keyword">this</span>.products - oldProduct + product
    ).getOrElse(
      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Product not found"</span>)
    )
  }
}
</pre></td></tr></table></figure>

<p>Page template</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Products<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'stylesheet'</span> <span class="attribute">type</span>=<span class="value">'text/css'</span>
          <span class="attribute">href</span>=<span class="value">'@routes.Assets.at("stylesheets/bootstrap.css")'</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'stylesheet'</span> <span class="attribute">type</span>=<span class="value">'text/css'</span>
          <span class="attribute">href</span>=<span class="value">"@routes.Assets.at("</span><span class="value">stylesheets</span>/<span class="attribute">main.css</span>")"&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"@routes.Assets.at("</span><span class="value">javascripts</span>/<span class="attribute">jquery-1.9.0.min.js</span>")"
            <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'@routes.Assets.at("javascripts/products.js")'</span>
            <span class="attribute">type</span>=<span class="value">'text/javascript'</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"screenshot"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"navbar navbar-fixed-top"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"navbar-inner"</span>&gt;</span>
          <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"brand"</span> <span class="attribute">href</span>=<span class="value">"@routes.Application.index()"</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"nav"</span>&gt;</span><span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
          <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="constructing-json-data-value-objects">Constructing JSON data value objects</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers
<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="keyword">import</span> models.Product
<span class="keyword">import</span> play.api.libs.json.Json

<span class="class"><span class="keyword">object</span> <span class="title">Products</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> list = Action {
    <span class="keyword">val</span> productCodes = Product.findAll.map(_.ean)
    <span class="comment">//  automatically add a Content-Type: application/json HTTP response header</span>
    Ok(Json.toJoson(productCodes))
  }
}
</pre></td></tr></table></figure>

<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>GET / controllers.Application.index
GET /products controllers.Products.<span class="type">list</span>
GET /assets/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public"</span>, <span class="type">file</span>)
</pre></td></tr></table></figure>

<p>可以通过<code>curl --include http://localhost:9000/products</code>, 测试</p>
<h3 id="working-with-the-json-objects">WORKING WITH THE JSON OBJECTS</h3>
<p>The <code>play.api.libs.json.JsValue</code> type represents any kind of JSON value.</p>
<p>Play’s JSON library is located in <code>play.api.libs.json</code>, and it contains case classes
for each of JSON’s types:</p>
<ul>
<li>JsString,  takes a String as a parameter </li>
<li>JsNumber, takes a BigDecimal</li>
<li>JsBoolean,  can be constructed from a sequence of key/value tuples: <code>Seq[(String, JsValue)]</code>.</li>
<li>JsObject</li>
<li>JsArray, takes a Seq[JsValue]</li>
<li>JsNull</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="reserved">import</span> play.api.libs.json._
val category = JsString(<span class="string">"paperclips"</span>)
val quantity = JsNumber(<span class="number">42</span>)

val product = Json.obj(
  <span class="string">"name"</span><span class="function"> -&gt;</span> JsString(<span class="string">"Blue Paper clips"</span>),
  <span class="string">"ean"</span><span class="function"> -&gt;</span> JsString(<span class="string">"12345432123"</span>),
  <span class="string">"description"</span><span class="function"> -&gt;</span> JsString(<span class="string">"Big box of paper clips"</span>),
  <span class="string">"pieces"</span><span class="function"> -&gt;</span> JsNumber(<span class="number">500</span>),
  <span class="string">"manufacturer"</span><span class="function"> -&gt;</span> Json.obj(
    <span class="string">"name"</span><span class="function"> -&gt;</span> JsString(<span class="string">"Paperclipfactory Inc."</span>),
    <span class="string">"contact_details"</span><span class="function"> -&gt;</span> Json.obj(
      <span class="string">"email"</span><span class="function"> -&gt;</span> JsString(<span class="string">"contact@paperclipfactory.example.com"</span>),
      <span class="string">"fax"</span><span class="function"> -&gt;</span> JsNull,
      <span class="string">"phone"</span><span class="function"> -&gt;</span> JsString(<span class="string">"+12345654321"</span>)
    )
  ),
  <span class="string">"tags"</span><span class="function"> -&gt;</span> Json.arr(
    JsString(<span class="string">"paperclip"</span>),
    JsString(<span class="string">"coated"</span>)
  ),
  <span class="string">"active"</span><span class="function"> -&gt;</span> JsBoolean(<span class="literal">true</span>)
)
</pre></td></tr></table></figure>

<h3 id="generating-strings-from-json-values">GENERATING STRINGS FROM JSON VALUES</h3>
<p>When you return JSON from a controller action,
you pass the JsValue to the result directly.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">val productJsonString </span>=<span class="string"> Json.stringify(product)</span>
</pre></td></tr></table></figure>

<h3 id="fetching-json-data-from-the-client">FETCHING JSON DATA FROM THE CLIENT</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">table</span> <span class="attribute">data-list</span>=<span class="value">"@routes.Products.list"</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p><code>app/assets/javascripts/products.coffee</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>jQuery (<span class="variable">$)</span> -&gt;
  <span class="variable">$table</span> = <span class="variable">$(</span><span class="string">'.container table'</span>)
  productListUrl = <span class="variable">$table</span>.data(<span class="string">'list'</span>)

  <span class="variable">$.</span>get productListUrl, (products) -&gt;
    <span class="variable">$.</span>each products, (index, eanCode) -&gt;
      row = <span class="variable">$(</span><span class="string">'&lt;tr/&gt;'</span>).append <span class="variable">$(</span><span class="string">'&lt;td/&gt;'</span>).<span class="keyword">text</span>(eanCode)
      <span class="variable">$table</span>.append row
</pre></td></tr></table></figure>

<h2 id="converting-model-objects-to-json-objects">Converting model objects to JSON objects</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">GET</span> /products/:ean controllers.Products.details(ean: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>def details(ean: Long) = Action {
  Product<span class="preprocessor">.findByEan</span>(ean)<span class="preprocessor">.map</span> { product =&gt;
    Ok(Json<span class="preprocessor">.toJson</span>(product))
  }<span class="preprocessor">.getOrElse</span>(NotFound)
}
</pre></td></tr></table></figure>

<h3 id="json-formatters">JSON FORMATTERS</h3>
<p>The type signature of the toJson method looks like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">def</span> toJson[T](<span class="keyword">object</span>: T)(implicit writes: Writes[T]): JsValue

<span class="comment">// writes implementations</span>
implicit <span class="class"><span class="keyword">object</span> <span class="title">StringWrites</span> <span class="keyword">extends</span> <span class="title">Writes</span>[<span class="title">String</span>] {</span>
  <span class="keyword">def</span> writes(o: String) = JsString(o)
}
</pre></td></tr></table></figure>

<p>Play also provides implicit conversions from <code>Writes[T]</code> to <code>Writes[List[T]]</code>,
<code>Writes[Set[T]]</code>, and <code>Writes[Map[String, T]]</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>case class Product(ean: Long, name: String, description: String)

import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.json</span>._
implicit object ProductWrites extends Writes[Product] {
  def writes(p: Product) = Json<span class="preprocessor">.obj</span>(
    <span class="string">"ean"</span> -&gt; Json<span class="preprocessor">.toJson</span>(p<span class="preprocessor">.ean</span>),
    <span class="string">"name"</span> -&gt; Json<span class="preprocessor">.toJson</span>(p<span class="preprocessor">.name</span>),
    <span class="string">"description"</span> -&gt; Json<span class="preprocessor">.toJson</span>(p<span class="preprocessor">.description</span>)
  )
}

// 更简介的方法
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.json</span>._
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.functional</span><span class="preprocessor">.syntax</span>._
implicit val productWrites: Writes[Product] = (
  (JsPath \ <span class="string">"ean"</span>)<span class="preprocessor">.write</span>[Long] <span class="keyword">and</span>
  (JsPath \ <span class="string">"name"</span>)<span class="preprocessor">.write</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"description"</span>)<span class="preprocessor">.write</span>[String]
)(unlift(Product<span class="preprocessor">.unapply</span>))

// we can use a helper function that defines a default case
// class formatter at runtime, which gives
// the same output as the previous example:
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.json</span>._
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.functional</span><span class="preprocessor">.syntax</span>._
implicit val productWrites = Json<span class="preprocessor">.writes</span>[Product]
</pre></td></tr></table></figure>

<p><code>Writes[Product]</code> for the administrative interface</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.json</span>._
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.functional</span><span class="preprocessor">.syntax</span>._
val adminProductWrites: Writes[Product] = (
  (JsPath \ <span class="string">"ean"</span>)<span class="preprocessor">.write</span>[Long] <span class="keyword">and</span>
  (JsPath \ <span class="string">"name"</span>)<span class="preprocessor">.write</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"description"</span>)<span class="preprocessor">.write</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"price"</span>)<span class="preprocessor">.write</span>[BigDecimal]
)(unlift(Product<span class="preprocessor">.unapply</span>))

val json = Json<span class="preprocessor">.toJson</span>(product)(AdminProductWrites)
</pre></td></tr></table></figure>

<h3 id="using-a-custom-formatter">USING A CUSTOM FORMATTER</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="subst">&lt;</span>table <span class="built_in">data</span><span class="attribute">-list</span><span class="subst">=</span><span class="string">"@routes.Products.list"</span>
       <span class="built_in">data</span><span class="attribute">-details</span><span class="subst">=</span><span class="string">"@routes.Products.details(0)"</span><span class="subst">&gt;</span>
<span class="subst">&lt;</span>/table<span class="subst">&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>jQuery <span class="function"><span class="params">($)</span> -&gt;</span>
  $table = $(<span class="string">'.container table'</span>)
  productListUrl = $table.data(<span class="string">'list'</span>)

  <span class="function"><span class="title">loadProductTable</span> = -&gt;</span>
    $.get productListUrl, <span class="function"><span class="params">(product)</span> -&gt;</span>
      $.each products, <span class="function"><span class="params">(index, eanCode)</span> -&gt;</span>
        row = $(<span class="string">'&lt;tr/&gt;'</span>).append $(<span class="string">'&lt;td/&gt;'</span>).text(eanCode)
        $table.append row
        loadProductDetail row

  <span class="function"><span class="title">productDetailUrl</span> = <span class="params">(eanCode)</span> -&gt;</span>
    $talbe.data(<span class="string">'details'</span>).replace <span class="string">'0'</span>, eanCode

  <span class="function"><span class="title">loadProductDetails</span> = <span class="params">(tableRow)</span> -&gt;</span>
    eanCode = tableRow.text()

    $.get productDetailUrl <span class="function"><span class="params">(eanCode)</span>, <span class="params">(product)</span> -&gt;</span>
      tableRow.append $(<span class="string">'&lt;td/&gt;'</span>).text(product.name)
      tableRow.append $(<span class="string">'&lt;td/&gt;'</span>).text(product.description)
      
  loadProductTable()
</pre></td></tr></table></figure>

<h1 id="sending-json-data-to-the-server">Sending JSON data to the server</h1>
<p>We’re going to cheat by using the HTML5 contenteditable attribute to
make the table cells directly editable.</p>
<h2 id="editing-and-sending-client-data">Editing and sending client data</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>saveRow = (<span class="variable">$row</span>) -&gt;
  [ean, name, description] = <span class="variable">$row</span>.children().map -&gt; <span class="variable">$(</span>this).<span class="keyword">text</span>()
  product =
    ean: parseInt(ean)
    name: name
    description: description
  jqxhr = <span class="variable">$.</span>ajax
    type: <span class="string">"PUT"</span>
    url: productDetailsUrl(ean)
    contentType: <span class="string">"application/json"</span>
    data: JSON.stringify product

  jqxhr.done (response) -&gt;
    <span class="variable">$label</span> = <span class="variable">$(</span><span class="string">'&lt;span/&gt;'</span>).addClass(<span class="string">'label label-success'</span>)
    <span class="variable">$row</span>.children().last().append <span class="variable">$label</span>.<span class="keyword">text</span>(response)
    <span class="variable">$label</span>.delay(<span class="number">3000</span>).fadeout()
  jqxhr.fail (data) -&gt;
    <span class="variable">$label</span> = <span class="variable">$(</span><span class="string">'&lt;span/&gt;'</span>).addClass(<span class="string">'label label-important'</span>)
    message = data.responseText || data.statusText
    <span class="variable">$row</span>.children().last().append <span class="variable">$label</span>.<span class="keyword">text</span>(message)
    
<span class="variable">$table</span>.on <span class="string">'focusout'</span>, <span class="string">'tr'</span>, () -&gt;
  saveRow <span class="variable">$(</span>this)
</pre></td></tr></table></figure>

<h2 id="consuming-json">Consuming JSON</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>PUT /products/:ean controllers<span class="preprocessor">.Products</span><span class="preprocessor">.save</span>(ean: Long)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>def save(ean: Long) = Action(parse<span class="preprocessor">.json</span>) { request =&gt;
  val productJson = request<span class="preprocessor">.body</span>
  val product = productJson<span class="preprocessor">.as</span>[Product]

  try {
    Product<span class="preprocessor">.save</span>(product)
    Ok(<span class="string">"Saved"</span>)
  } catch {
    case e: IllegalArgumentException =&gt;
      BadRequest(<span class="string">"Product not found"</span>)
  }
}

import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.functional</span><span class="preprocessor">.syntax</span>._
implicit val productReads: Reads[Product] = (
  (JsPath \ <span class="string">"ean"</span>)<span class="preprocessor">.read</span>[Long] <span class="keyword">and</span>
  (JsPath \ <span class="string">"name"</span>)<span class="preprocessor">.read</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"description"</span>)<span class="preprocessor">.read</span>[String]
)(Product<span class="preprocessor">.apply</span> _)

def save(product: Product) = {
  findByEan(product<span class="preprocessor">.ean</span>)<span class="preprocessor">.map</span>( oldProduct =&gt;
    this<span class="preprocessor">.products</span> = this<span class="preprocessor">.products</span> - oldProduct + product
  )<span class="preprocessor">.getOrElse</span>(
    throw new IllegalArgumentException(<span class="string">"Product not found"</span>)
  )
}
</pre></td></tr></table></figure>

<h2 id="consuming-json-in-more-detail">Consuming JSON in more detail</h2>
<p>Consuming JSON is a two-step process. The first step is going from a JSON string to JsValue objects.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">import</span> play.api.libs.json._
<span class="keyword">val</span> jsValue: JsValue = Json.parse(<span class="string">"""{ "name" : "Johnny" }"""</span>)
</pre></td></tr></table></figure>

<p>Often, you don’t even need to manually perform this step.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def postProduct() = Action { request =&gt;
  val jsValueOption = request.body.asJson
  jsValueOption.map { json =&gt;
    <span class="comment">// Do something with the JSON</span>
  }.getOrElse {
    <span class="comment">// Not a JSON body</span>
  }
}
</pre></td></tr></table></figure>

<p>If you’re only willing to accept JSON for an action, which is common,
you can use the <code>parse.json</code> body parser:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>// <span class="keyword">it</span>’ll <span class="constant">return</span> <span class="operator">an</span> HTTP status <span class="operator">of</span> <span class="number">400</span> Bad Request <span class="keyword">if</span> <span class="operator">the</span> content type is wrong.
def postProduct2() = Action(parse.json) { request =&gt;
  val jsValue = request.body
 <span class="comment"> // Do something with the JSON</span>
}
</pre></td></tr></table></figure>

<p>Sometimes you have to deal with misbehaving clients that send JSON without
proper Content-Type headers. In that case, you can use the <code>parse.tolerantJson</code>
body parser, which doesn’t check the header, but just tries to parse the body as JSON.</p>
<p>JsValue has the <code>as[T]</code> and <code>asOpt[T]</code> methods,</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">val</span> jsValue = JsString(<span class="string">"Johnny"</span>)
<span class="keyword">val</span> name = jsValue.<span class="keyword">as</span>[String]

<span class="keyword">val</span> age = jsValue.<span class="keyword">as</span>[Int] <span class="comment">// Throws play.api.libs.json.JsResultException</span>
<span class="keyword">val</span> age: Option[Int] = jsValue.asOpt[Int] <span class="comment">// == None</span>
<span class="keyword">val</span> name: Option[String] = jsValue.asOpt[String] <span class="comment">// == Some("Johnny")</span>

<span class="keyword">val</span> age = jsValue.validate[Int] <span class="comment">// == JsError</span>
<span class="keyword">val</span> name = jsValue.validate[String] <span class="comment">// == JsSuccess(Johnny,)</span>
</pre></td></tr></table></figure>

<p>Of course, often you’ll be dealing with more complex JSON structures. There are
three methods for traversing a <code>JsValue</code> tree:</p>
<ul>
<li><code>\</code>—Selects an element in a <code>JsObject</code>, returning a <code>JsValue</code></li>
<li><code>\\</code>—Selects an element in the entire tree, returning a <code>Seq[JsValue]</code></li>
<li><code>apply</code>—Selects an element in a <code>JsArray</code> , returning a <code>JsValue</code><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="reserved">import</span> Json._
val <span class="attribute">json</span>: JsValue = toJson(Map(
  <span class="string">"name"</span><span class="function"> -&gt;</span> toJson(<span class="string">"Johnny"</span>),
  <span class="string">"age"</span><span class="function"> -&gt;</span> toJson(<span class="number">42</span>),
  <span class="string">"tags"</span><span class="function"> -&gt;</span> toJson(List(<span class="string">"constructor"</span>, <span class="string">"builder"</span>)),
  <span class="string">"company"</span><span class="function"> -&gt;</span> toJson(Map(
    <span class="string">"name"</span><span class="function"> -&gt;</span> toJson(<span class="string">"Constructors Inc."</span>)))))

val name = (json \ <span class="string">"name"</span>).as[Strnig]
val age = (json \ <span class="string">"age"</span>).asOpt[Int]
val companyName = (json \ <span class="string">"company"</span> \ <span class="string">"name"</span>).as[String]
val firstTag = (json \ <span class="string">"tags"</span>)(<span class="number">0</span>).as[String]
val allNames = (json \\ <span class="string">"name"</span>).map(_as[String])

(json \ <span class="string">"name"</span>) match {
  <span class="reserved">case</span> JsString<span class="function"><span class="params">(name)</span> =&gt;</span> println(name)
  <span class="reserved">case</span> JsUndefined<span class="function"><span class="params">(error)</span> =&gt;</span> println(error)
  <span class="reserved">case</span> _<span class="function"> =&gt;</span> println(<span class="string">"Invalid type!"</span>)
}
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="reusable-consumers">Reusable consumers</h2>
<p>The <code>Reads[T]</code> trait has a single method, <code>reads(json: JsValue): JsResult[T]</code>,
which deserializes JSON into a <code>JsSuccess</code> that wraps an object of type T or a <code>JsError</code>
that gives you access to JSON parsing errors, following the pattern of Scala’s
<code>Either[Error, T]</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>jsValue.as[String]
jsValue.as[<span class="link_label">String</span>](<span class="link_url">play.api.libs.json.Reads.StringReads</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PricedProduct</span><span class="params">(
  name: String,
  description: Option[String],
  purchasePrice: BigDecimal,
  sellingPrice: BigDecimal)</span></span>

<span class="keyword">val</span> productJsonString = <span class="string">"""{
  "name": "Sample name",
  "description": "Sample description",
  "purchase_price" : 20,
  "selling_price": 35
}"""</span>

<span class="keyword">import</span> play.api.libs.json._
<span class="keyword">import</span> play.api.libs.functional.syntax._
implicit <span class="keyword">val</span> productReads: Reads[PricedProduct] = (
  (JsPath \ <span class="string">"name"</span>).read[String] and
  (JsPath \ <span class="string">"description"</span>).readNullable[String] and
  (JsPath \ <span class="string">"purchase_price"</span>).read[BigDecimal] and
  (JsPath \ <span class="string">"selling_price"</span>).read[BigDecimal]
)(PricedProduct.apply _)

<span class="keyword">val</span> productJsValue = Json.parse(productJsonString)
<span class="keyword">val</span> product = productJsValue.as[PricedProduct]
</pre></td></tr></table></figure>

<h2 id="combining-json-formatters-and-consumers">Combining JSON formatters and consumers</h2>
<p>The trait <code>Format[T]</code> extends both <code>Reads[T]</code> and <code>Writes[T]</code></p>
<p>We can define a <code>Format[PricedProduct]</code> implementation,
using JsPath’s format and <code>formatNullable</code> methods, as shown in the following listing.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.json</span>._
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.functional</span><span class="preprocessor">.syntax</span>._
implicit val productFormat = (
  (JsPath \ <span class="string">"name"</span>)<span class="preprocessor">.format</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"description"</span>)<span class="preprocessor">.formatNullable</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"purchase_price"</span>)<span class="preprocessor">.format</span>[BigDecimal] <span class="keyword">and</span>
  (JsPath \ <span class="string">"selling_price"</span>)<span class="preprocessor">.format</span>[BigDecimal]
)(PricedProduct<span class="preprocessor">.apply</span>, unlift(PricedProduct<span class="preprocessor">.unapply</span>))

// 也可以这样
implicit val productFormat = Format(productReads, productWrites)

import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.json</span>._
implicit val productReads = Json<span class="preprocessor">.reads</span>[PricedProduct]
implicit val productWrites = Json<span class="preprocessor">.writes</span>[PricedProduct]
</pre></td></tr></table></figure>

<h1 id="validating-json">Validating JSON</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>{
  "<span class="attribute">name</span>": <span class="value"><span class="string">"Blue Paper clips"</span></span>,
  "<span class="attribute">ean</span>": <span class="value"><span class="string">"12345432123"</span></span>,
  "<span class="attribute">description</span>": <span class="value"><span class="string">"Big box of paper clips"</span></span>,
  "<span class="attribute">pieces</span>": <span class="value"><span class="number">500</span></span>,
  "<span class="attribute">manufacturer</span>": <span class="value">{
    "<span class="attribute">name</span>": <span class="value"><span class="string">"Paperclipfactory Inc."</span></span>,
    "<span class="attribute">contact_details</span>": <span class="value">{
      "<span class="attribute">email</span>": <span class="value"><span class="string">"contact@paperclipfactory.example.com"</span></span>,
      "<span class="attribute">fax</span>": <span class="value"><span class="literal">null</span></span>,
      "<span class="attribute">phone</span>": <span class="value"><span class="string">"+12345654321"</span>
    </span>}
  </span>}</span>,
  "<span class="attribute">tags</span>": <span class="value">[
    <span class="string">"paperclip"</span>,
    <span class="string">"coated"</span>
  ]</span>,
  "<span class="attribute">active</span>": <span class="value"><span class="literal">true</span>
</span>}
</pre></td></tr></table></figure>

<h2 id="mapping-the-json-structure-to-a-model">Mapping the JSON structure to a model</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="keyword">class</span> Contact(email: <span class="keyword">Option</span>[<span class="built_in">String</span>], fax: <span class="keyword">Option</span>[<span class="built_in">String</span>],
    phone: <span class="keyword">Option</span>[<span class="built_in">String</span>])
<span class="keyword">case</span> <span class="keyword">class</span> Company(name: <span class="built_in">String</span>, contactDetails: Contact)
<span class="keyword">case</span> <span class="keyword">class</span> Product(ean: <span class="built_in">Long</span>, name: <span class="built_in">String</span>,
    description: <span class="keyword">Option</span>[<span class="built_in">String</span>], pieces: <span class="keyword">Option</span>[Int],
    manufacturer: Company, tags: List[<span class="built_in">String</span>], active: <span class="built_in">Boolean</span>)

implicit val companyReads: Reads[Company] = (
  (JsPath \ <span class="string">"name"</span>).read[<span class="built_in">String</span>] <span class="keyword">and</span>
  (JsPath \ <span class="string">"contact_details"</span>).read(
  (
    (JsPath \ <span class="string">"email"</span>).readNullable[<span class="built_in">String</span>] <span class="keyword">and</span>
    (JsPath \ <span class="string">"fax"</span>).readNullable[<span class="built_in">String</span>] <span class="keyword">and</span>
    (JsPath \ <span class="string">"phone"</span>).readNullable[<span class="built_in">String</span>]
  )(Contact.apply _))
)(Company.apply _)

implicit val productReads: Reads[Product] = (
  (JsPath \ <span class="string">"ean"</span>).read[<span class="built_in">Long</span>] <span class="keyword">and</span>
  (JsPath \ <span class="string">"name"</span>).read[<span class="built_in">String</span>] <span class="keyword">and</span>
  (JsPath \ <span class="string">"description"</span>).readNullable[<span class="built_in">String</span>] <span class="keyword">and</span>
  (JsPath \ <span class="string">"pieces"</span>).readNullable[Int] <span class="keyword">and</span>
  (JsPath \ <span class="string">"manufacturer"</span>).read[Company] <span class="keyword">and</span>
  (JsPath \ <span class="string">"tags"</span>).read[List[<span class="built_in">String</span>]] <span class="keyword">and</span>
  (JsPath \ <span class="string">"active"</span>).read[<span class="built_in">Boolean</span>]
)(Product.apply _)
</pre></td></tr></table></figure>

<h2 id="handling-empty-values">Handling “empty” values</h2>
<p>The JSON API uses a nullable[T] to handle the JsNull case, such as our example’s
description: Option[String] property. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">nullable</span>[<span class="title">T</span>]<span class="params">(implicit rds: Reads[T])</span>:</span> Reads[Option[T]] = Reads(js =&gt;
  js match {
    case JsNull =&gt; JsSuccess(<span class="keyword">None</span>)
    case js =&gt; rds.reads(js).map(Some(_))
  }
)
</pre></td></tr></table></figure>

<h2 id="adding-validation-rules-and-validating-input">Adding validation rules and validating input</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>implicit val companyReads: Reads[Company] = (
  (JsPath \ <span class="string">"name"</span>)<span class="preprocessor">.read</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"contact_details"</span>)<span class="preprocessor">.read</span>(
  (
    (JsPath \ <span class="string">"email"</span>)<span class="preprocessor">.readNullable</span>[String](email) <span class="keyword">and</span>
    (JsPath \ <span class="string">"fax"</span>)<span class="preprocessor">.readNullable</span>[String](minLength[String](<span class="number">10</span>)) <span class="keyword">and</span>
    (JsPath \ <span class="string">"phone"</span>)<span class="preprocessor">.readNullable</span>[String](minLength[String](<span class="number">10</span>))
  )(Contact<span class="preprocessor">.apply</span> _))
)(Company<span class="preprocessor">.apply</span> _)

implicit val productReads: Reads[Product] = (
  (JsPath \ <span class="string">"ean"</span>)<span class="preprocessor">.read</span>[Long] <span class="keyword">and</span>
  (JsPath \ <span class="string">"name"</span>)<span class="preprocessor">.read</span>[String](minLength[String](<span class="number">5</span>)) <span class="keyword">and</span>
  (JsPath \ <span class="string">"description"</span>)<span class="preprocessor">.readNullable</span>[String] <span class="keyword">and</span>
  (JsPath \ <span class="string">"pieces"</span>)<span class="preprocessor">.readNullable</span>[Int] <span class="keyword">and</span>
  (JsPath \ <span class="string">"manufacturer"</span>)<span class="preprocessor">.read</span>[Company] <span class="keyword">and</span>
  (JsPath \ <span class="string">"tags"</span>)<span class="preprocessor">.read</span>[List[String]] <span class="keyword">and</span>
  (JsPath \ <span class="string">"active"</span>)<span class="preprocessor">.read</span>[Boolean]
)(Product<span class="preprocessor">.apply</span> _)

def save = Action(parse<span class="preprocessor">.json</span>) { implicit request =&gt;
  val json = request<span class="preprocessor">.body</span>
  json<span class="preprocessor">.validate</span>[Product]<span class="preprocessor">.fold</span>(
    valid = { product =&gt;
      Product<span class="preprocessor">.save</span>(product)
      Ok(<span class="string">"Save"</span>)
    },
    invalid = {
      error =&gt; BadRequest(JsError<span class="preprocessor">.toFlatJson</span>(errors))
    }
  )
}
</pre></td></tr></table></figure>

<h2 id="returning-json-validation-errors">Returning JSON validation errors</h2>
<p>This fails validation with the following JSON result, which is generated by the
<code>JsError.toFlatJson</code> helper.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre>{
  <span class="string">"obj.manufacturer.contact_details.email"</span> : [
    { <span class="string">"msg"</span> : <span class="string">"validate.error.email"</span>, <span class="string">"args"</span> : [] }
  ],
  <span class="string">"obj.name"</span> : [
    {<span class="string">"msg"</span> : <span class="string">"validate.error.minlength"</span>, <span class="string">"args"</span> : [<span class="number">5</span>] }
  ],
  <span class="string">"obj.tags"</span> : [
    {<span class="string">"msg"</span> : <span class="string">"validate.error.missing-path"</span>, <span class="string">"args"</span> : [] }
  ]
}

// You may requires errors in a particular simplified JSON <span class="keyword">format</span>
[
  {
    <span class="string">"path"</span> : <span class="string">"/manufacturer/contact_details/email"</span>,
    <span class="string">"errors"</span>: [<span class="string">"validate.error.email"</span>]
  },
  { <span class="string">"path"</span> : <span class="string">"/name"</span>, <span class="string">"errors"</span> : [<span class="string">"validate.error.minlength"</span>] },
  { <span class="string">"path"</span> : <span class="string">"/tags"</span>, <span class="string">"errors"</span> : [<span class="string">"validate.error.missing-path"</span>] }
]

// <span class="keyword">format</span> a path as a string
implicit val JsPathWrites =
  Writes[JsPath](<span class="string">p =&gt;</span> JsString(p.toString))

// <span class="keyword">format</span> an error as a string
implicit val ValicateionErrorWrites =
  Writes[ValidationError](<span class="string">e =&gt;</span> JsString(e.message))

implicit val jsonValidateErrorWrites = (
  (JsPath \ <span class="string">"path"</span>).<span class="keyword">write</span>[JsPath] <span class="keyword">and</span>
  (JsPath \ <span class="string">"errors"</span>).<span class="keyword">write</span>[Se<span class="string">q[ValidationError]</span>]
  tupled
)
</pre></td></tr></table></figure>

<p>One such library is Jerkson; it’s possible to use Jerkson directly, or
you can use any other JSON library that you like.</p>
<h1 id="authenticating-json-web-service-requests">Authenticating JSON web service requests</h1>
<p>Authentication means identifying the “user” who’s sending the request,
by requiring and checking valid credentials, usually username and password.</p>
<p>In a conventional web application, authentication is usually implemented by using
an HTML login form to submit credentials to a server application, which then
maintains a session state that future requests from the same user are
associated with. In our JSON web service architecture, there are no HTML forms,
so we use different methods to associate authentication credentials with requests.</p>
<h2 id="adding-authentication-to-action-methods">Adding authentication to action methods</h2>
<p>The simplest approach is to perform authentication for every HTTP request, before
returning the usual response or an HTTP error that indicates that the client isn’t
authorized to access the requested resource.</p>
<h3 id="composing-actions-to-add-behavior">COMPOSING ACTIONS TO ADD BEHAVIOR</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>def index = AuthenticatedAction { <span class="built_in">request</span> =&gt;
  Ok(<span class="string">"Authenticated response..."</span>)
}

def AuthenticatedAction(f: <span class="built_in">Request</span>[AnyContent] =&gt; Result):
    Action[AnyContent] = {
  Action { <span class="built_in">request</span> =&gt;
    <span class="keyword">if</span> (authenticate(<span class="built_in">request</span>)) {
      f(<span class="built_in">request</span>)
    } <span class="keyword">else</span> {
      Unauthorized
    }
  }
}
</pre></td></tr></table></figure>

<h3 id="extracting-credentials-from-the-request">EXTRACTING CREDENTIALS FROM THE REQUEST</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>// Helper function to extract credentials <span class="keyword">from</span> a request query string
<span class="function"><span class="keyword">def</span> <span class="title">readQueryString</span><span class="params">(request: Request[_])</span>:</span>
    Option[Either[Result, (String, String)]] = {
  request.queryString.get(<span class="string">"user"</span>).map{ user =&gt;
    request.queryStirng.get(<span class="string">"password"</span>).map { password =&gt;
      Right((user.head, password.head))
    }.getOrElse {
      Left(BadRequest(<span class="string">"Password not specified"</span>))
    }
  }
}

// Updated action helper that extracts credentials before authentication
<span class="function"><span class="keyword">def</span> <span class="title">AuthenticatedAction</span><span class="params">(f: Request[AnyContent] =&gt; Result)</span>:</span>
    Action[AnyContent] = {
  Action { request =&gt;
    val maybeCredentials = readQueryString(request)
    maybeCredentials.map { resultOrCredentials =&gt;
      resultOrCredentials match {
        case Left(errorResult) =&gt; errorResult
        case Right(credentials) =&gt; {
          val (user, password) = credentials
          <span class="keyword">if</span> (authenticate(user, password)) {
            f(request)
          } <span class="keyword">else</span> {
            Unauthorized(<span class="string">"Invalid user name or password"</span>)
          }
        }
      }
    }.getOrElse {
      Unauthorized(<span class="string">"No user name and password provided"</span>)
    }
  }    
}
</pre></td></tr></table></figure>

<h2 id="using-basic-authentication">Using basic authentication</h2>
<p>A more standard way to send authentication credentials with an HTTP request is to use
HTTP basic authentication, which sends credentials in an HTTP header.</p>
<p>A server requests basic authentication by sending an HTTP 401 Unauthorized
response with an additional <code>WWW-Authenticate</code> header. The header has a value like
<code>Basic realm=&quot;Product catalog&quot;</code>. This specifies the required authentication type
and names the protected resource.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>def readBasicAuthentication(<span class="attribute">headers</span>: Headers):
    Option[Either[Result, (String, String)]] = {
  headers.get(Http.HeaderNames.AUTHORIZATION).map { header<span class="function"> =&gt;</span>
    val BasicHeader = <span class="string">"Basic (.*)"</span>.r
    header match {
      <span class="reserved">case</span> BasicHeader<span class="function"><span class="params">(base64)</span> =&gt;</span> {
        <span class="keyword">try</span> {
          <span class="reserved">import</span> org.apache.commons.codec.binary.base64
          val decodedBytes = base64.decodeBase64(base64.getBytes)
          val credentials = <span class="keyword">new</span> String(decodedBytes).split(<span class="string">":"</span>, <span class="number">2</span>)
          credentials match {
            <span class="reserved">case</span> Array<span class="function"><span class="params">(username, password)</span> =&gt;</span>
              Right(username<span class="function"> -&gt;</span> password)
            <span class="reserved">case</span> _<span class="function"> =&gt;</span> Left(<span class="string">"Invalid basic authentication"</span>)
          }
        }
      }
      <span class="reserved">case</span> _<span class="function"> =&gt;</span> Left(BadRequest(<span class="string">"Bad Authorization header"</span>))
    }
  }
}
val maybeCredentials = readQueryString(request) orElse
  readBasicAuthentication(request.headers)
<span class="regexp">//</span> curl --include --user <span class="attribute">peter</span>:secret <span class="attribute">http</span>:<span class="regexp">//</span><span class="attribute">localhost</span>:<span class="number">9000</span>/
</pre></td></tr></table></figure>

<h2 id="other-authentication-methods">Other authentication methods</h2>
<p>Web services often use one of two alternatives:</p>
<ul>
<li>Token-based authentication—Providing a signed API key that clients can send with
requests, either in a custom HTTP header or query string parameter</li>
<li>Session-based authentication—Using one method to authenticate, and then
providing a session identifier that clients can send, either in an HTTP cookie or an
HTTP header</li>
</ul>
]]></content>
    
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day70-Hive数据挖掘]]></title>
    <link href="http://zhpooer.github.io/2014/08/17/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day70-hive%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    <id>http://zhpooer.github.io/2014/08/17/传智播客day70-hive数据挖掘/</id>
    <published>2014-08-17T01:21:57.000Z</published>
    <updated>2014-08-18T02:39:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hive">Hive</h1>
<p>Hive是建立在Hadoop上的数据仓库基础架构, 它提供了一系列的工具,
可以存储、查询和分析在 Hadoop中的大规模数据机制.
Hive 定义了简单的类 SQL 查询工具, 成为 QL, 将 QL 转换为 MapReduce.</p>
<p>可以结合 MapReduce 来处理复杂的分析工具</p>
<p>Hive表就是 HDFS 的目录, Hive数据就是目录里边的文件</p>
<h2 id="-">系统架构</h2>
<ul>
<li>用户接口, CLI, JDBC/ODBC, WebUI</li>
<li>元数据存储(Hive字段, 字段类型), 通常是存储在关系数据库如 mysql, derby 中</li>
<li>解释器, 编译器, 优化器, 执行器</li>
<li>Hadoop, 用HDFS进行存储, 利用 MapReduce 进行计算</li>
</ul>
<h1 id="-">相关操作</h1>
<p>启动Hive <code>hive</code>, 所有创建的表存在 <code>/user/hive/warehouse</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">show</span> databases;</span>
<span class="comment">-- 默认使用 default</span>
<span class="operator"><span class="keyword">show</span> tables;</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> student (
  id <span class="keyword">int</span>,
  name string
);</span>

<span class="comment">-- /warehouse/itcast.db</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">database</span> itcast;</span>
use itcast;
<span class="comment">-- /warehouse/itcast.db/teacher</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> teacher (
  tid bigint,
  name string
);</span>

<span class="comment">-- 插入数据</span>
<span class="operator"><span class="keyword">load</span> data <span class="keyword">local</span> inpath <span class="string">'/home/a.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> student;</span>
<span class="comment">-- 四行 `Null Null`, 因为没有指定分隔符</span>
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span>
<span class="comment">-- 执行 MapReduce</span>
<span class="operator"><span class="keyword">select</span> <span class="aggregate">count</span>(*) <span class="keyword">from</span> student;</span>

<span class="operator"><span class="keyword">load</span> data <span class="keyword">local</span> inpath <span class="string">'/home/a.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> student;</span>

<span class="comment">-- 创建一张表, 以 \t 为分割</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> people(
  pid <span class="keyword">in</span>,
  name string
) <span class="keyword">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">'\t'</span>;</span>

<span class="operator"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> people;</span>
<span class="operator"><span class="keyword">load</span> data <span class="keyword">local</span> inpath <span class="string">'/home/a.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> people;</span>
<span class="comment">-- 不会产生 mapReduce</span>
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> people limit <span class="number">2</span>;</span>

<span class="comment">-- 会产生 mapReduce</span>
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> people groupby pid <span class="keyword">desc</span>;</span>

<span class="comment">-- 执行 hadoop 命令</span>
dfs -ls /
dfs -put /home/hadoop/b.txt /user/hive/warehouse/peoples
</pre></td></tr></table></figure>

<p><code>data.txt</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>1  zhangsan
2  lisi
3  wangwu
</pre></td></tr></table></figure>

<p>可以将 <code>data2.txt</code> 放入 <code>/user/hive/warehouse/people</code>, 以至于也可以将文件加入数据库
<code>data2.txt</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>10 zhangsan
11  lisi
</pre></td></tr></table></figure>

<h1 id="-">设置数据库</h1>
<p>hive默认数据库是 derby, 只允许连接一个用户</p>
<ul>
<li>安装mysql <code>/usr/bin/mysql_secure_installation</code></li>
<li><p>配置<code>hive-default.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="comment">&lt;!-- url --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">name</span>&gt;</span> javax.jdo.option.ConnectionURL
        <span class="tag">&lt;/<span class="title">name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">value</span>&gt;</span>?createDatabaseInNotExist=true
        <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 连接驱动 --&gt;</span>
    <span class="comment">&lt;!-- 用户名 --&gt;</span>
    <span class="comment">&lt;!-- 密码 --&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>拷贝jar文件到<code>lib</code>文件夹下</p>
</li>
<li>数据库授权<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>grant all priveleges on <span class="strong">*.*</span> to <span class="smartquote">`root`@`%` identity by '</span>root';
flush priveleges;
</pre></td></tr></table></figure>

</li>
</ul>
<h1 id="-">外部表</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="title">dfs</span> -mkdir /<span class="typedef"><span class="keyword">data</span>;</span>
<span class="title">dfs</span> -put /home/hadoop/*.txt /<span class="typedef"><span class="keyword">data</span></span>
<span class="title">dfs</span> -ls /<span class="typedef"><span class="keyword">data</span></span>
<span class="comment">-- 在其他目录创建 /data, 关联到表, 外部表</span>
<span class="title">create</span> external table users (
  uid int,row format delimited fields terminated by '\t' location '/<span class="typedef"><span class="keyword">data</span>';</span>
  uname string
) row format delimited fields terminated by '\t' location '/<span class="typedef"><span class="keyword">data</span>';</span>
</pre></td></tr></table></figure>

<h1 id="-">分区表</h1>
<p>如按月份分区存储数据, 在数据量非常大的情况下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>
<span class="comment">-- 建立外部分区表</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> beauties (
  id <span class="keyword">int</span>,
  name string,
  <span class="keyword">size</span> <span class="keyword">double</span>
) <span class="keyword">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">'\t'</span> location <span class="string">'/beauty'</span>;</span>

<span class="comment">-- 指定分区 'China', 在hdfs上要增加一个 `notion=China` 的文件夹(dfs -mkdir /beauty/nation=China), 和一个字段 </span>
<span class="operator"><span class="keyword">load</span> data <span class="keyword">local</span> inpath <span class="string">'/home/hadoop/b.c'</span> <span class="keyword">into</span> <span class="keyword">table</span> beauties partition (nation=<span class="string">'China'</span>);</span>

dfs -mkdir /beauty/nation=Japan;
<span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> beauties <span class="keyword">add</span> partition (nation=<span class="string">'Japan'</span>) location <span class="string">`/beauty/nation=Japan`</span>;</span>

<span class="comment">-- 建分区表是为了可以快速查询</span>
<span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> beauties <span class="keyword">where</span> nation = <span class="string">'china'</span>;</span>
<span class="operator"><span class="keyword">select</span> nation, <span class="aggregate">avg</span>(<span class="keyword">size</span>) si <span class="keyword">from</span> beauties <span class="keyword">group</span> <span class="keyword">by</span> nation <span class="keyword">order</span> <span class="keyword">by</span> si;</span>
</pre></td></tr></table></figure>

<h1 id="sqoop-">sqoop 导入导出</h1>
<p>mysql数据导入到 hdfs</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">##</span> <span class="comment">导入到</span> <span class="comment">hdfs</span>
<span class="comment">##</span> <span class="literal">-</span><span class="comment">m</span> <span class="comment">启动</span> <span class="comment">2个</span> <span class="comment">mapreduce</span> <span class="comment">一起导入</span>
<span class="comment">sqoop</span> <span class="comment">import</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">connect</span> <span class="comment">jdbc:mysql://mysql:3306/itcast</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">username</span> <span class="comment">root</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">password</span> <span class="comment">123</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">table</span> <span class="comment">trade_detail</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">target</span><span class="literal">-</span><span class="comment">dir</span> <span class="comment">/sqoop</span> <span class="literal">-</span><span class="comment">m</span> <span class="comment">2</span>

<span class="comment">##</span> <span class="comment">导入到</span> <span class="comment">mysql</span>
<span class="comment">##</span> <span class="comment">create</span> <span class="comment">table</span> <span class="comment">td1</span> <span class="comment">like</span> <span class="comment">trade_detail;</span>

<span class="comment">sqoop</span> <span class="comment">exoport</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">connect</span> <span class="comment">jdbc:mysql://mysql:3306/itcast</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">username</span> <span class="comment">root</span>
<span class="literal">-</span><span class="literal">-</span><span class="comment">password</span> <span class="comment">123</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">password</span> <span class="comment">123</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">export</span><span class="literal">-</span><span class="comment">dir</span> <span class="comment">'/sqoop/td'</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">table</span> <span class="comment">td1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">fields</span><span class="literal">-</span><span class="comment">terminatd</span><span class="literal">-</span><span class="comment">by</span> <span class="comment">'\t'</span>
</pre></td></tr></table></figure>

<h1 id="-udf-">自定义函数(UDF)</h1>
<ol>
<li>导入jar包, <code>hive.jar</code>, <code>hadoop-common.jar</code></li>
<li><p>编写程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NationUDF</span> <span class="keyword">extends</span> <span class="title">UDF</span> {</span>
    <span class="keyword">private</span> <span class="keyword">static</span> map&lt;String, String&gt; nationMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;;
    <span class="keyword">static</span> {
        nationMap.put(<span class="string">"China"</span>, <span class="string">"天朝"</span>);
        nationMap.put(<span class="string">"Japan"</span>, <span class="string">"小日本"</span>);
        nationMap.put(<span class="string">"USA"</span>, <span class="string">"米国"</span>);
    }
    
    <span class="keyword">private</span> Text t = <span class="keyword">new</span> Text();
    
    <span class="comment">// 返回 hadoop 支持的序列化类型</span>
    <span class="keyword">public</span> Text <span class="title">evaluate</span>(Text ename) {
        String en = ename.toString();
        String cname = nationMap.get(en);
        <span class="keyword">if</span>(cname == <span class="keyword">null</span>) {
            cname = <span class="string">"火星人"</span>;
        }
        t.set(cname);
        <span class="keyword">return</span> t;
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>打包</p>
</li>
<li>运行 hive 命令<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>add jar /home/hadoop/udf.jar
<span class="comment">-- 创建临时函数</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">temporary</span> function getNN <span class="keyword">as</span> <span class="string">'cn.itcast.hive.udf.NationUDF'</span>;</span>
<span class="comment">-- 调用</span>
<span class="operator"><span class="keyword">select</span> id, name, getNN(nation) <span class="keyword">from</span> beauties;</span>
<span class="comment">-- 将查询语句的结果存入表</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> result <span class="keyword">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">'\t'</span> <span class="keyword">as</span>
     <span class="keyword">select</span> id, name, getNN(nation) <span class="keyword">from</span> beauties;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-flume-">数据采集框架(flume)</h1>
<p>注意版本(0.9和1.0)</p>
<p>Agent, 采集数据的单元, 包括 Source, Channel, Sink</p>
<p>Redis可用于分布式session存储</p>
<p>Flume 可用于收集多台机器的产生的数据(如 log), 写入到 HDFS 里面</p>
<ol>
<li><p>修改配置文件 <code>flume.env</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>JAVA_HOME=<span class="keyword">...</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>conf/a2.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="preprocessor">## 设置 agent 的 源 通道 代理</span>
a2<span class="preprocessor">.sources</span> = <span class="built_in">r1</span>
a2<span class="preprocessor">.channels</span> = c1
a2<span class="preprocessor">.sinks</span> = k1

<span class="preprocessor"># 定义具体的soruce</span>
a2<span class="preprocessor">.sources</span><span class="preprocessor">.r</span>1<span class="preprocessor">.type</span> = exec   <span class="preprocessor"># 或 spooldir 监听数据变化</span>
a2<span class="preprocessor">.sources</span><span class="preprocessor">.r</span>1<span class="preprocessor">.command</span> = tail -F /root/a<span class="preprocessor">.log</span> <span class="preprocessor"># /home/hadoop/logs</span>

<span class="preprocessor"># 定义具体的 channel</span>
a2<span class="preprocessor">.channles</span><span class="preprocessor">.c</span>1<span class="preprocessor">.type</span> = memory
a2<span class="preprocessor">.channles</span><span class="preprocessor">.c</span>1<span class="preprocessor">.capacity</span> = <span class="number">1000</span>
a2<span class="preprocessor">.channles</span><span class="preprocessor">.c</span>1<span class="preprocessor">.transactionCapacity</span> = <span class="number">100</span>

<span class="preprocessor"># 定义具体的 sink</span>
a2<span class="preprocessor">.sinks</span><span class="preprocessor">.k</span>1<span class="preprocessor">.type</span> = logger  <span class="preprocessor"># 或 hdfs</span>

<span class="preprocessor"># 可以定义拦截器, 为消息添加时间戳</span>

<span class="preprocessor"># 关联 channel</span>
a2<span class="preprocessor">.sources</span><span class="preprocessor">.r</span>1<span class="preprocessor">.channels</span> = c1
a2<span class="preprocessor">.sinks</span><span class="preprocessor">.k</span>1<span class="preprocessor">.channnels</span> = c1
</pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">## -c 配置文件目录, -D jvm 配置</span>
flume-ng agent -n a2 -f conf/a2<span class="preprocessor">.conf</span> -c conf -Dflume<span class="preprocessor">.root</span><span class="preprocessor">.logger</span>=INFO,console
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-">论坛数据分析</h1>
<p>网站指标</p>
<ul>
<li>浏览量PV: 每个页面访问页面数</li>
<li>访客数UV: 通常以 Cookie 为依据</li>
<li>IP数</li>
<li>跳出率, 浏览一个页面的访问次数/全部访问次数汇总</li>
<li>版块热度排行</li>
</ul>
<p>开发步骤</p>
<ul>
<li>flume 采集数据</li>
<li>对数据进行清洗(可以使用flume拦截器)</li>
<li>使用hive进行数据的多维分析</li>
<li>hive分析结果通过 sqoop 导出到 mysql 中</li>
<li>提供视图工具供用户使用</li>
</ul>
<p>hive 创建表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> hmbbs(
  ip string,
  logtime string,
  url string
) partitioned <span class="keyword">by</span> (logdate string) <span class="keyword">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">'\t'</span> location <span class="string">"/cleaned"</span>;</span>
</pre></td></tr></table></figure>

<p>定时运行脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>CURRENT=`date +%y%m%d`
hadoop jar /cleaner.jar /flume/$CURRENT /cleaned/$CURRENT

## 清洗数据 
hive -e "<span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> hmbbs <span class="keyword">add</span> partition (logdate=$<span class="keyword">CURRENT</span>) location <span class="string">'/cleaned/$CURRENT'</span><span class="string">"
## PV
hive -e "</span><span class="keyword">select</span> <span class="aggregate">count</span>(*) <span class="keyword">from</span> hmbbs <span class="keyword">where</span> logdate=$<span class="keyword">CURRENT</span><span class="string">";
## UV
hive -e "</span><span class="keyword">select</span> <span class="aggregate">count</span>(<span class="keyword">distinct</span> ip) <span class="keyword">from</span> hmbbs <span class="keyword">where</span> logdate=$<span class="keyword">CURRENT</span><span class="string">";
## 注册用户数
hive -e "</span><span class="keyword">select</span> <span class="aggregate">count</span>(*) <span class="keyword">from</span> hmbbs <span class="keyword">where</span> logdate=$<span class="keyword">CURRENT</span> <span class="keyword">and</span> instr(url, <span class="string">'member.php?mod=register'</span>)&gt;<span class="number">0</span><span class="string">";

## 查找重点用户, 倒叙
hive -e "</span><span class="keyword">create</span> <span class="keyword">table</span> vip_$<span class="keyword">current</span> <span class="keyword">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">'\t'</span>
    <span class="keyword">select</span> ip, <span class="aggregate">count</span>(*) <span class="keyword">as</span> vtimes <span class="keyword">from</span> hmbbs groupby ip <span class="keyword">having</span> vtimes &gt;= <span class="number">50</span> <span class="keyword">order</span> <span class="keyword">by</span> vtimes <span class="keyword">desc</span><span class="string">";

## 导出数据到 mysql
sqoop export --connect jdbc:mysql://mysql:3306/itcast --username root
  --password root "</span>/<span class="keyword">user</span>/hive/warehouse/vip_$<span class="keyword">CURRENT</span><span class="string">" --table vip --fields-terminatd-by '\t';</span></span>
</pre></td></tr></table></figure>

<h1 id="-">建立简历</h1>
<p>虚拟化: openStack, cloudStack</p>
<p>需要掌握技能:</p>
<ul>
<li>集群的搭建</li>
<li>MapReduce 编写</li>
</ul>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="hadoop" scheme="http://zhpooer.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day69-搭建Hadoop集群]]></title>
    <link href="http://zhpooer.github.io/2014/08/16/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day69-%E6%90%AD%E5%BB%BAhadoop%E9%9B%86%E7%BE%A4/"/>
    <id>http://zhpooer.github.io/2014/08/16/传智播客day69-搭建hadoop集群/</id>
    <published>2014-08-16T01:17:30.000Z</published>
    <updated>2014-08-17T01:20:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="zookeeper">ZooKeeper</h1>
<p>ZooKeeper 是 Google 的 Chubby 的一个开源实现, Hadoop的分布式协调服务</p>
<p>负载均衡, 分布式锁, 协调服务, 数据同步, 数据发布与订阅</p>
<p>为了保证服务安全, 可以将 ZooKeeper 布置位一个集群,
一个 Leader Server 和 多个 Follower Server,
一般要配置奇数台机器</p>
<p>客户端连接 ZooKeeper, 一个 Follower Server 数据发生变化,
会自动同步到其他 ZooKeeper 服务器</p>
<p>为什么使用</p>
<ul>
<li>大部分分布式引用需要一个主控, 协调器或控制器来管理物理分布的子进程(如资源, 任务分配)</li>
<li>提供通用的分布式锁服务, 用以协调分布式应用</li>
</ul>
<p>在Hadoop中保证整个集群只有一个活跃的 NameNode, 存储配置信息. 在Hbase集群中, 确保 HMaster</p>
<h2 id="-zookeeper">部署单节点 ZooKeeper</h2>
<ol>
<li>切换用户到 hadoop</li>
<li>安装 ZooKeeper 到 <code>/itcast</code> 目录, <code>chown -R hadoop:hadoop /itcast</code></li>
<li><p><code>mv zoo_sample.cfg zoo.cfg</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">dataDir</span>=/itcast/<span class="typedef"><span class="keyword">data</span></span>
</pre></td></tr></table></figure>
</li>
<li><p>启动 ZooKeeper 服务, <code>zkServer.sh</code></p>
</li>
<li><p>连接 ZooKeeper <code>zkcli.sh</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="preprocessor"># 创建 sh_0329 文件夹</span>
create /sh_0329 $<span class="number">8000</span>
<span class="preprocessor"># 获取 sh_0329 存储的信息</span>
<span class="keyword">get</span> /sh_0329
</pre></td></tr></table></figure>
</li>
<li><p>停止 <code>zkServer.sh stop</code></p>
</li>
</ol>
<p>目录结构</p>
<ul>
<li><code>bin</code>, 可执行文件</li>
<li><code>conf</code>, 配置文件</li>
</ul>
<h2 id="-zookeeper-">搭建 ZooKeeper 集群</h2>
<ol>
<li><p>修改 <code>zoo.cfg</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="preprocessor"># 心跳时间</span>
tickTime=<span class="number">2000</span>
<span class="preprocessor"># 容忍心跳时间</span>
initLimit=<span class="number">10</span>
<span class="preprocessor"># 数据同步时间限制</span>
syncLimit=<span class="number">5</span>
<span class="preprocessor"># 运行时,目录</span>
dataDir=/data
<span class="preprocessor"># 端口</span>
clientport=<span class="number">2081</span>

<span class="preprocessor"># ZooKeeper 之间的关系</span>
<span class="preprocessor"># 数字代表id, 主机名或者ip:端口(learder follower 通信端口):端口(选举端口)</span>
server<span class="number">.4</span>=itcast04:<span class="number">2888</span>:<span class="number">3888</span>
server<span class="number">.5</span>=itcast05:<span class="number">2888</span>:<span class="number">3888</span>
server<span class="number">.6</span>=itcast06:<span class="number">2888</span>:<span class="number">3888</span>
</pre></td></tr></table></figure>
</li>
<li><p>在 数据保存文件夹 <code>/data</code>, 创建文件 <code>myid</code>, 对应 <code>server.N</code> 的 <code>N</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>4
</pre></td></tr></table></figure>
</li>
<li><p>拷贝文件到其他机器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>scp -r /itcast/zookeeper hadoop<span class="variable">@itcast05</span><span class="symbol">:/itcast/</span>
</pre></td></tr></table></figure>
</li>
<li><p>修改远程 ZooKeeper 的 <code>myip</code></p>
</li>
<li>分别启动各个机器上的 ZooKeeper <code>zkServer.sh start</code></li>
</ol>
<p>因为是通过选举来决定 Leader, 所以必须保证 <code>n/2+1</code> 台运行, 而且一定要配置奇数个 ZooKeeper</p>
<h1 id="hadoop-">hadoop 集群搭建</h1>
<p>CDH 认证, 大数据专业认证</p>
<p>TODO: 集群分布</p>
<ul>
<li>两台运行 NameNode, 和 zkfc(失败控制, ZooKeeper组件)</li>
<li>两台运行 ResourceManager</li>
<li>三台运行 DataNode, NodeManager, JournalNode(存放共享 edits), QuorumPeerMain(ZooKeeper主程序)</li>
</ul>
<p>hadoop2.0 中, NameService = 主NameNode + 备NameNode, 元数据会进行同步(通过 JournalNode 或 nfs, 共享 edits),
通过 ZooKeeper服务进行协调, 多个 NameService 可以横向扩展</p>
<p>JournalNode, 用来存放共享 edits, 使 NameService 进行数据同步, 要求必须存在奇数个.</p>
<p>jkfc 负责监控 NameNode, 向 ZooKeeper 汇报信息, 一旦发现 主NameNode当机,
监视 副NameNode 的 jkfc 启动 副NameNode</p>
<p>修改Hadoop配置文件</p>
<ol>
<li><p><code>hadoop-env.sh</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>export Java_Home=<span class="keyword">...</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>core-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- nameservice 地址 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://ns2<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- 运行时产生文件,非临时, 重要! --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/tmp/hadoop<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- 设置 zookeeper 连接地址 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast04:2181,itcast05:2181,itcast07:2181<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>hdfs-site</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- 指定 nameservice  --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.nameservice<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>ns1<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- ns1下的两个 namenode --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.ha.namenodes.ns1<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>nn1, nn2<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.namenode.rpc-address.ns1.nn1<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast01:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.namenode.http-address.ns1.nn1<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast01:50070<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.namenode.rpc-address.ns1.nn2<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast01:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.namenode.http-address.ns1.nn2<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast01:50070<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- journal 主机 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.namenode.shareed.edits.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>qjournal://itcast06:8485;itcast06:8485;itcast07:8485/ns1<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- journal 自动备份在硬盘 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/itcast/journal<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

  <span class="comment">&lt;!-- 开启自动切换  --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- TODO 自动切换实现方式 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.client.failover.proxy.provider<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span><span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- sshfence隔离机制 --&gt;</span>
  <span class="comment">&lt;!-- sshfence: 一台 nameNode 出错但是没有终止, 另一台 NameNode 主动通过ssh 终止他   --&gt;</span>
  <span class="comment">&lt;!-- TODO: shell: 一台 namenode 当掉, 从 namenode 通过 shell 切换到 active   --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>
      sshfence
      shell(/bin/true)
    <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.ha.fencing.ssh.privaate-key-files<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/.ssh/id_rsa <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- 隔离机制 超时时间 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.ha.fencing.ssh.connects-timeout<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>30000 <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>mapred-site.xml.template</code> copy to <code>mapred-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- mapreduce运行在yarn上 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>yarn-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- 开启 ha  --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.ha.enabled<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- 指定集群id --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.cluster-id<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>yrc<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- RM 名字 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.ha.rm-ids<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>rm1, rm2<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.hostname.rm1<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast3<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.hostname.rm2<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast04<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- TODO zk集群个地址 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.???<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast04:2181,itcast05:2181,itcast05:2181<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>

  <span class="comment">&lt;!-- reduce 获取数据的方式 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>添加<code>slaves</code>文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>itcast05
itcast06
itcast07
</pre></td></tr></table></figure>
</li>
<li><p>拷贝配置好的文件到主机 <code>itcast01-06</code></p>
</li>
</ol>
<p>启动集群</p>
<ol>
<li>在05, 06, 07上启动 Zookeeper</li>
<li>在05, 06, 07上启动, 启动 JournalNode, <code>hadoop-deamon.sh start journalnode</code></li>
<li>在 01 上初始化 namenode <code>hdfs namenode -format</code>, 并拷贝 <code>/hadoop/tmp</code> 到 02 机子上</li>
<li>格式化 Zookeeper, <code>hdfs zkfc -formatZK</code>, 在一台机子上, 会在 zk 上产生目录 <code>hadoop-ha</code></li>
<li>在01上启动hdfs, <code>start-dfs.sh</code>, 所有机子上的 DataNode 服务都会自动启动, <code>itcast:50070</code> 查看 NameNode 状态</li>
<li>在 03 上启动yarn(ResourceManager), <code>start-yarn.sh</code>, 在 04 上启动 <code>yarn-daemon.sh start resourcemanager</code>,
访问 <code>itcast:8088</code> 查看 ResourceManager 状态</li>
</ol>
<h1 id="-">动态增加节点</h1>
<p><code>hadoop-deamon.sh start datanode</code></p>
<p>如果 一台datanode当掉, 那么其他datanode 会自动同步数据到新的一台 datanode,
以至于所有数据块都保持3份</p>
<h1 id="-nameservice">程序连接 NameService</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(){
    Configuration conf = <span class="keyword">new</span> Configuration();
    conf.<span class="keyword">set</span>(<span class="string">"fs.defaultFS"</span>, <span class="string">"hdfs://ns1"</span>);
    conf.<span class="keyword">set</span>(<span class="string">"dfs.nameservices"</span>, ns1);
    conf.<span class="keyword">set</span>(<span class="string">"dfs.ha.namenodes.ns1"</span>, <span class="string">"nn1,nn2"</span>);
    conf.<span class="keyword">set</span>(<span class="string">"dfs.ha.rpc-address.ns1.nn1"</span>, <span class="string">"itcast1:9000"</span>);
    conf.<span class="keyword">set</span>(<span class="string">"dfs.ha.namenodes.rpc-address.ns1.nn2"</span>, <span class="string">"itcast2:9000"</span>);
    <span class="comment">// TODO </span>
    conf.<span class="keyword">set</span>(<span class="string">"dfs.client.failover.proxy.provider.ns1"</span>, )
    <span class="comment">// 使用 hadoop 用户登陆</span>
    FileSystem fs = FileSystem.<span class="keyword">get</span>(<span class="keyword">new</span> URI(<span class="string">"hdfs://ns1"</span>), conf, <span class="string">"hadoop"</span>);
}
</pre></td></tr></table></figure>

<p>TODO: 最后20分钟</p>
]]></content>
    
    
      <category term="hadoop" scheme="http://zhpooer.github.io/tags/hadoop/"/>
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day68-Hadoop高级编程]]></title>
    <link href="http://zhpooer.github.io/2014/08/14/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day68-hadoop%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhpooer.github.io/2014/08/14/传智播客day68-hadoop高级编程/</id>
    <published>2014-08-14T00:52:42.000Z</published>
    <updated>2014-08-14T14:26:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="partitioner">Partitioner</h1>
<p>MapReduce 通过 Partitioner 来进行分区, 如按 月份, 地区进行分区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="comment">// 对电话号码进行 服务商分区</span>
<span class="comment">// 在 Mapper 执行完成, Reducer 还没有开始时, 执行</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderPartitioner</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Partitioner</span>&lt;<span class="title">Text</span>, <span class="title">DataBean</span>&gt;{</span>
    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; providerMap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();
    <span class="keyword">static</span> {
        <span class="comment">// 移动</span>
        providerMap.put(<span class="string">"135"</span>, <span class="number">1</span>);
        providerMap.put(<span class="string">"136"</span>, <span class="number">1</span>);
        providerMap.put(<span class="string">"137"</span>, <span class="number">1</span>);
        providerMap.put(<span class="string">"138"</span>, <span class="number">1</span>);
        providerMap.put(<span class="string">"139"</span>, <span class="number">1</span>);
        <span class="comment">// 联通</span>
        providerMap.put(<span class="string">"150"</span>, <span class="number">2</span>);
        providerMap.put(<span class="string">"159"</span>, <span class="number">2</span>);
        <span class="comment">// 电信</span>
        providerMap.put(<span class="string">"182"</span>, <span class="number">3</span>);
        providerMap.put(<span class="string">"183"</span>, <span class="number">3</span>);
        providerMap.put(<span class="string">"187"</span>, <span class="number">3</span>);
    }
    <span class="comment">// numPartitions 有几个 partition</span>
    <span class="keyword">public</span> <span class="keyword">int</span> getPartition(Text key, DataBean value, <span class="keyword">int</span> numPartitions) {
        String account = key.toString();
        String sub_acc = account.subString(<span class="number">0</span>, <span class="number">3</span>);
        Integer code = providerMap.get(sub_acc);
        <span class="keyword">if</span>(code == <span class="keyword">null</span>) {
            code = <span class="number">0</span>;
        }
        <span class="comment">// 如果返回值是0, 存到0号 reducer</span>
        <span class="keyword">return</span> code;
    }
}

<span class="comment">// main</span>
job.getJobInstance(conf);
<span class="comment">// 本地模式, 只能启动一个 reducer, partitioner 会启动多个 reducer</span>
job.setPartitionerClass(ProviderPartitioner.class);

<span class="comment">// 设置 reducer 的数量, 如果不设置, 默认启动一个, 文件会被写到一个结果文件, 不会被分区</span>
<span class="comment">// 若设置的Reducer 超过分区数, 那么会产生 多余的结果文件, 且多余结果文件会是空的</span>
<span class="comment">// 如果 Reducer 小于分区数, 那么会抛错</span>
job.setNumReduceTasks(<span class="number">4</span>);
job.waitForCompletion();
</pre></td></tr></table></figure>

<h1 id="-">排序</h1>
<p><em>数据</em></p>
<table>
<thead>
<tr>
<th>账号</th>
<th>收入</th>
<th>支出</th>
<th>日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>zhangsan@163.com</td>
<td>6000</td>
<td>0</td>
<td>2014-02-20</td>
</tr>
<tr>
<td>lisi@163.com</td>
<td>2000</td>
<td>0</td>
<td>2014-02-20</td>
</tr>
<tr>
<td>lisi@163.com</td>
<td>0</td>
<td>100</td>
<td>2014-02-20</td>
</tr>
</tbody>
</table>
<p><em>求和过程, 中间结果</em></p>
<table>
<thead>
<tr>
<th>账号</th>
<th>收入</th>
<th>支出</th>
<th>结余</th>
</tr>
</thead>
<tbody>
<tr>
<td>zhangsan@163.com</td>
<td>6000</td>
<td>0</td>
<td>6000</td>
</tr>
<tr>
<td>lisi@163.com</td>
<td>2000</td>
<td>100</td>
<td>1900</td>
</tr>
</tbody>
</table>
<p><em>根据收入进行排序, 在收入相同的情况下, 根据支出排序</em></p>
<table>
<thead>
<tr>
<th>账号</th>
<th>收入</th>
<th>支出</th>
<th>结余</th>
</tr>
</thead>
<tbody>
<tr>
<td>lisi@163.com</td>
<td>2000</td>
<td>100</td>
<td>1900</td>
</tr>
<tr>
<td>zhangsan@163.com</td>
<td>6000</td>
<td>0</td>
<td>6000</td>
</tr>
</tbody>
</table>
<h2 id="maven-">Maven 建立工程</h2>
<p>TODO: pom 文档</p>
<p><code>pom.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">dependencies</span>&gt;</span>
   <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
       <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.hadoop <span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
       <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span> hadoop-common<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
       <span class="tag">&lt;<span class="title">version</span>&gt;</span> 2.4.1<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
   <span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
       <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.hadoop <span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
       <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>  hadoop-mapreduce-cl <span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
       <span class="tag">&lt;<span class="title">version</span>&gt;</span> 2.4.1 <span class="tag">&lt;/<span class="title">version</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre></td><td class="code"><pre><span class="comment">// 求和程序</span>
<span class="keyword">public</span> <span class="keyword">class</span> SumStep {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(){
        Configuration conf = <span class="keyword">new</span> Configuration()
        Job job = job.getInstance(conf);
        job.setJarByClass(SumStep.class);
        job.setMapperClass(SumMapper.class);
        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(InfoBean.class);
        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Paht(args[<span class="number">0</span>]));

        job.setReducerClass(SumReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(InfoBean.class);
        FileInputFormat.setOutputPaths(job, <span class="keyword">new</span> Paht(args[<span class="number">1</span>]));
        
        job.waitForComletion(<span class="keyword">true</span>);
    }
    
}

<span class="comment">// 实现序列化和排序功能</span>
<span class="keyword">public</span> <span class="keyword">class</span> InfoBean extends WritableComparable&lt;InfoBean&gt;{
    <span class="keyword">private</span> String account;
    <span class="comment">// 如果是账目, 应该用 BigDecimal</span>
    <span class="keyword">private</span> <span class="keyword">double</span> income;
    <span class="keyword">private</span> <span class="keyword">double</span> expenses;
    <span class="comment">// 结余</span>
    <span class="keyword">private</span> <span class="keyword">double</span> surplus;
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span>(DataOutput <span class="keyword">out</span>) {
        <span class="keyword">out</span>.writeUTF(account);
        <span class="keyword">out</span>.writeDouble(income);
        <span class="keyword">out</span>.writeDouble(expenses);
        <span class="keyword">out</span>.writeDouble(surplus);
        
    }
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(String account, <span class="keyword">double</span> income, <span class="keyword">double</span> expenses) {
        <span class="keyword">this</span>.account = account;
        <span class="keyword">this</span>.income = income;
        <span class="keyword">this</span>.expenses = expenses;
        <span class="keyword">this</span>.surplus = inomce - expenses;
    }
    
    @Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readFields</span>(DataInput <span class="keyword">in</span>) {
        <span class="keyword">this</span>.account = <span class="keyword">in</span>.readUTF();
        <span class="keyword">this</span>.income = <span class="keyword">in</span>.readDouble();
        <span class="keyword">this</span>.expenses = <span class="keyword">in</span>.readDouble();
        <span class="keyword">this</span>.surplus = <span class="keyword">in</span>.readDouble();
    }

    @Override <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span>(InfoBean o) {
        <span class="keyword">if</span>(<span class="keyword">this</span>.income == <span class="number">0.</span>getIncome()) {
            <span class="keyword">return</span> <span class="keyword">this</span>.expenses &gt; o.getExpenses() ? <span class="number">1</span> : -<span class="number">1</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>.income &gt; o.getIncome() ? -<span class="number">1</span> : <span class="number">1</span>;
        }
    }
    
    @Override <span class="keyword">public</span> String <span class="title">toString</span>(){}
}

<span class="keyword">public</span> <span class="keyword">class</span> SumMapper extends Mapper&lt;LongWritable, Text, Text, InfoBean&gt; {
    <span class="comment">// 虽然是有状态的变量, 但是它们设置完之后会马上序列化</span>
    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();
    <span class="keyword">private</span> InfoBean v = <span class="keyword">new</span> InfoBean();
    
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable key, Text <span class="keyword">value</span>, Context context) {
        String line = <span class="keyword">value</span>.toString();
        String[] fields = line.split(<span class="string">"\t"</span>);
        String account = fields[<span class="number">0</span>];
        <span class="keyword">double</span> <span class="keyword">in</span> = Double.parseDouble(fields[<span class="number">1</span>]);
        <span class="keyword">double</span> <span class="keyword">out</span> = Double.parseDouble(fields[<span class="number">2</span>]);
        k.<span class="keyword">set</span>(account);
        v.<span class="keyword">set</span>(account, <span class="keyword">in</span>, <span class="keyword">out</span>);
        context.write(k, v);
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> SumReducer extends Reducer&lt;Text, InfoBean, Text, InfoBean&gt;  {
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(Text key, Iterable&lt;InfoBean&gt; values, Context context){
        <span class="keyword">double</span> in_sum = <span class="number">0</span>;
        <span class="keyword">double</span> out_sum = <span class="number">0</span>;
        <span class="keyword">for</span>(InfoBean bean : values) {
            in_sum += bean.getIncome();
            out_sum += bean.getExpenses();
        }
        v.<span class="keyword">set</span>(<span class="string">""</span>, int_sum, out_sum);
        context.write(key, v);
    }
}
</pre></td></tr></table></figure>

<p>排序方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> SortStep {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>() {
        <span class="comment">// TODO</span>
    }
}

<span class="comment">// 根据输出的 key 进行排序, NullWritable</span>
<span class="keyword">public</span> <span class="keyword">class</span> SortMapper extends Mapper&lt;LongWritable, Text, InfoBean, NullWritable&gt; {
    <span class="keyword">private</span> InfoBean k = <span class="keyword">new</span> InfoBean();
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable key, Text <span class="keyword">value</span>, Context context) {
        String line = <span class="keyword">value</span>.toString();
        String[] fields = line.split(<span class="string">"\t"</span>);
        String account = fields[<span class="number">0</span>];
        <span class="keyword">double</span> <span class="keyword">in</span> = Double.parseDouble(fields[<span class="number">1</span>]);
        <span class="keyword">double</span> <span class="keyword">out</span> = Double.parseDouble(fields[<span class="number">2</span>]);
        k.<span class="keyword">set</span>(account, <span class="keyword">in</span>, <span class="keyword">out</span>);
        context.write(k, NullWritable.<span class="keyword">get</span>());
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> SortReducer extends Reducer&lt;InfoBean, NullWritable, Text, InfoBena&gt; {
    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();

    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(InfoBean bean, Interable&lt;NullWritable&gt; <span class="keyword">value</span>, Context context) {
        String account = bean.getAccount();
        k.<span class="keyword">set</span>(account);
        context.write(k, bean);
    }
}
</pre></td></tr></table></figure>

<h1 id="combiners-">Combiners 编程</h1>
<p>Combiners 是一个特殊的 Reducer, 在Map端进行一次简单的 Reducer.
使Reducer端的减少计算. 如果所有结果都是reduce完成, 效率会相对低下.
使用combiner, 先完成的map会在本地聚合, 提升速度</p>
<p>Combiners 是可插拔的, 绝不能改变最终的计算结果</p>
<p>可以用 Combiners 来过滤数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>job<span class="preprocessor">.setCombinerClass</span>(WCReducer<span class="preprocessor">.class</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<h1 id="shuffle">Shuffle</h1>
<p>MapReduce 的核心, 是指 reducer 获取 Mapper 的输出数据的过程</p>
<p>一个输入切片对应一个 Mapper, 一个Mapper 对应一个 数据缓存区(默认大小100M),
当数据缓存区数据达到域值(80%), 那么通过 partitioner 对数据进行分区, 按键排序, 写入磁盘,
生成分区且排序的小文件. 最后对小文件进行合并, 形成分区且合并的大文件, 并汇报给 MrAppMaster </p>
<p>Reducer 通过 MrAppMaster(JobTracker) 获取数据信息,  一号 Reducer 取一号分区中的数据,
二号 Reducer 取二号分区中的数据, 然后进行合并, 执行 Reduce, 输出数据</p>
<p>在 Hadoop1.0 中, 由 JobTracker 来监控任务, 管理资源, JobTracker 下辖多个 TaskTrack</p>
<p>在 Hadoop2.0 中, 由 ResourceManager 来管理资源, ResourceManager 下辖多个 NodeManager,
任务启动时, 启动一个 MrAppMaster 监控任务运行</p>
<p>Hadoop2.0 中, 将 JobTracker 职能分成 MrAppMaster 和 ResourceManager,
提交一个一个任务, 就有一个 AppMaster</p>
<h1 id="-mapreduce">倒排索引 MapReduce</h1>
<p>统计某个单词在文章中出现了多少次</p>
<p><code>a.txt</code></p>
<pre><code>hello world
hello Hadoop
</code></pre><p><code>b.txt</code></p>
<pre><code>hello ruby
hello world
</code></pre><p>结果</p>
<pre><code>hello a.txt:2 b.txt:2
world a.txt:1 b.txt:2
Hadoop a.txt:1
ruby a.txt:1
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InverseIndex</span> {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String [] args){
        Configuration conf = <span class="keyword">new</span> Configuration();
        Job job = Job.getInstance(conf);
        job.setJarByClass(InverseIndex.class);

        job.setMapperClass(IndexMapper.class);
        job.setMapperOutputKeyClass(Text.class);
        job.setMapperOutputValueClass(Text.class);
        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));

        job.setReducerClass(IndexReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputKeyClass(Text.class);
        FileOutputFormat.setOutputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));
        
        job.setCombinerClass(IndexCombiner.class);
        job.waitForCompletion();
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMapper</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">Text</span>&gt; {</span>
    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();
    <span class="keyword">private</span> Text v = <span class="keyword">new</span> Text();
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> map(LongWritable key, Text value, Context context) {
        String line = value.toString();
        String[] words = line.split(<span class="string">" "</span>);
        <span class="comment">// 得到输入切片</span>
        FileSplit fileSplit = (FileSplit)context.getInputSplit();
        
        <span class="comment">// 得到文件名 hdfs://itcast:9000</span>
        String path = fileSplit.getPath().toString();
        <span class="keyword">for</span>(String w:words) {
            k.set(w + <span class="string">"-&gt;"</span> + path);
            v.set(<span class="string">"1"</span>);
            context.write(k, v);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexCombiner</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>&gt; {</span>
    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();
    <span class="keyword">private</span> Text v = <span class="keyword">new</span> Text();
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> Reduce(Text key, Iterable&lt;Text&gt; value, Context context) {
        String[] workdAndPath = key.toString().split(<span class="string">"-&gt;"</span>);
        String word = wordAndPath[<span class="number">0</span>];
        String path = wordAndPath[<span class="number">1</span>];
        <span class="keyword">int</span> counter = <span class="number">0</span>;
        <span class="keyword">for</span>(Text t : values) {
            counter += Integer.parseInt(t.toString());
        }
        k.set(word);
        v.set(path + <span class="string">"-&gt;"</span> + counter);
        context.write(k, v);
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexReducer</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Reducer</span> {</span>
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> reduce(Text key, Iterable&lt;Text&gt; values, Context context) {
        String result = <span class="string">""</span>;
        <span class="keyword">for</span>(Text t: values) {
            result += t.toString() + <span class="string">"\t"</span>;
        }
        v.set(result);
        context.write(key, v);
    }
}
</pre></td></tr></table></figure>

<h1 id="-">切片大小</h1>
<p>在任务运行任务时, 会下载分片下载数据默认3128M,
所以系统会根据 block 块生成对应个数的 Map 程序</p>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="hadoop" scheme="http://zhpooer.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day67-MapReduce]]></title>
    <link href="http://zhpooer.github.io/2014/08/13/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day67-MapReduce/"/>
    <id>http://zhpooer.github.io/2014/08/13/传智播客day67-MapReduce/</id>
    <published>2014-08-13T01:04:09.000Z</published>
    <updated>2014-08-14T01:35:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mapreduce">MapReduce</h1>
<p>MapReduce 计算海量数据, 将一个任务切分成多个小任务, 分给多个进程计算</p>
<ul>
<li>MapReduce 是一种分布式计算模型, 用户搜索领域, 解决海量数据计算的问题</li>
<li>MR由两个项目阶段组成: Map和Reduce, 用户只需要实现 <code>map()</code>和<code>reduce</code>两个函数,
即可以实现分布式计算</li>
<li>两个函数的形参是key、value对, 表示函数的输入信息</li>
</ul>
<h2 id="demo">Demo</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor"># 启动 NameNode DataNode</span>
start-dfs.sh
<span class="preprocessor"># 启动 ResourceManager</span>
start-yarn.sh

<span class="preprocessor"># 启动 DataNode 上启动 RunJar 和 NodeManager(DataNode 上)</span>
<span class="preprocessor"># 过程中启动 MRAppMaster, 监控任务(每个任务都会对应有一个), 监控 YarnChild</span>
<span class="preprocessor"># YarnChild(DataNode上), 运行计算任务</span>
hadoop jar hadoop-mapreduce-example.jar wordcount hdfs:<span class="comment">//itcast:9000/words  hdfs://itcast:9000/words-out</span>
</pre></td></tr></table></figure>

<p>运行流程</p>
<ol>
<li>RunJar 把jar包上传到 HDFS, 默认写10份.</li>
<li>客户端提供任务描述信息</li>
<li>ResourceManager 任务初始化, 将任务放到任务调度器</li>
<li>NodeManager 主动申请任务, 采用心跳机制(RPC)</li>
<li>NodeManager 启动 YarnChild进程, 进行计算, YarnChild 有Map, Reduce 对象</li>
</ol>
<h2 id="-mapreduce">编写 MapReduce</h2>
<p>TODO 插入 MapReduce 图片</p>
<p><code>[K1, V1]</code> Map <code>[k2, V2]</code> Shuffle <code>[K2, {V2...}]</code> Reduce <code>[K3, V3]</code></p>
<p>Map执行处理
1.读取输入文件的内容, 解析出 key value 对, 对输入的问价的每一行, 解析成key value对
每一个键值对调用一次 <code>map()</code></p>
<p>reduce任务处理 TODO</p>
<pre><code>输入数据
  hello world
  hello hadoop
Map阶段(key: 字符偏移量)
  &lt;0, &quot;hello world&quot;&gt;
  &lt;11, &quot;hello hadoop&quot;&gt;
  代码
    map(){
      String line = v1;
      String[] words = ling.split(&quot; &quot;);
      for(String w: words) {
        context.write(w, 1);
      }
    }
Reduce 阶段(数据已经按key字符排序)
  &lt;&quot;hello&quot;, 1, 1&gt;
  &lt;&quot;hadoop&quot;, 1&gt;
  &lt;&quot;world&quot;, 1&gt;
  代码:
    reduce(){
      String word = K2
      List list = V2
      for(int i : list) {
        counter += 1
      }
      context.write(word, counter)
    }
输出数据
  hello 2
  world 1
  hadoop 1
</code></pre><h2 id="-">编写代码</h2>
<p>导入jar包 <code>hadoop-common.jar</code>, <code>hadoop-mapreduce.jar</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre>public <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> {</span>
    public <span class="class"><span class="keyword">class</span> <span class="title">void</span> <span class="title">main</span><span class="params">()</span> {</span>
        <span class="comment">// 可以通过 conf 设置, 副本拷贝数 默认是 10</span>
        Configuration conf = <span class="keyword">new</span> Configuration();
        
        Job job = Job.getInstance(conf);
        
        <span class="comment">// 重要, 将 main 方法所在的类注册</span>
        job.setJarByClass(WordCount.<span class="keyword">class</span>);
        <span class="comment">// Mapper 类</span>
        job.setMapperClass(WCMapper.<span class="keyword">class</span>);
        <span class="comment">// 设置 K2 V2</span>
        job.setMapOutputKeyClass(Text.<span class="keyword">class</span>);
        job.setMapOutputValueClass(LongWritable.<span class="keyword">class</span>);
        <span class="comment">// 设置读取文件</span>
        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(<span class="string">"/word.txt"</span>));
        
        job.setReducerClass(WCReducer.<span class="keyword">class</span>);
        <span class="comment">// 最终将数据到hdfs 的key的类型</span>
        job.setOutputKeyClass(Text.<span class="keyword">class</span>);
        job.setOutputValueClass(LongWritable.<span class="keyword">class</span>);
        <span class="comment">// 设置输出文件, 如果文件已经存在, 抛错</span>
        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(<span class="string">"/wcount1"</span>));
        
        <span class="comment">// 不太好的方法job.submit();</span>
        <span class="comment">// true 打印执行详情</span>
        job.waitForComletion(<span class="keyword">true</span>);
    }
}

<span class="comment">// Hadoop 提供了自己序列化机制</span>
public <span class="class"><span class="keyword">class</span> <span class="title">WCMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt;{</span>
    <span class="keyword">protected</span> void map(LongWritable key, Text value, Context context) {
        String line = value.toString();
        String[] words = line.split(<span class="string">" "</span>);
        <span class="keyword">for</span>(String w : words) {
            context.write(<span class="keyword">new</span> Text(w), <span class="keyword">new</span> LongWritable(<span class="number">1</span>))
        }
    }
}

public <span class="class"><span class="keyword">class</span> <span class="title">WCReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context) {
        <span class="comment">// super.reduce</span>
        long count = <span class="number">0</span>;
        <span class="keyword">for</span>(LongWritable l : values) {
            counter += l.get();
        }
        context.write(key, <span class="keyword">new</span> LongWritable(counter));
    }
}
</pre></td></tr></table></figure>

<p>打成Jar包, 运行 <code>hadoop jar /root/mrs.jar</code></p>
<h1 id="debug-mapreduce-">Debug MapReduce 程序</h1>
<h2 id="-">本地调试</h2>
<p>在eclipse中调试, 并没有提交到集群</p>
<p>修改 <code>Path</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// 读取本地</span>
<span class="keyword">new</span> Path(<span class="string">"/root/words"</span>)
<span class="comment">// 或 读取 hdfs 上的</span>
<span class="keyword">new</span> Path(<span class="string">"hdfs://itcast:9000/words"</span>)
</pre></td></tr></table></figure>

<h2 id="mr-">MR流程</h2>
<ul>
<li>代码编写</li>
<li>作业配置<ul>
<li>在 <code>etc/mapred-site.xml</code> 配置全局变量</li>
<li>在 <code>Configuration</code> 中设置局部变量</li>
</ul>
</li>
<li>提交作业, <code>hadoop jar **.jar</code></li>
<li>初始化作业</li>
<li>分配任务</li>
<li>执行任务</li>
<li>更新状态和任务</li>
<li>完成作业</li>
</ul>
<p>TODO 运行状态图</p>
<h1 id="-">序列化</h1>
<p>序列化是把结构化对象转换为字节流</p>
<p>反序列化(Deserialization)将字节流转换为结构化的对象</p>
<p>因为 JDK 序列化机制效率太低, JDK序列化要记录额外的数据, 如继承结构, 而 Hadoop 需要只需要传递数据,
以至于 Hadoop 要重新实现序列化</p>
<p>Hadoop 序列化特点</p>
<ul>
<li>紧凑, 高效的使用存储空间</li>
<li>快速, 读写数据的额外开销小</li>
<li>可扩展, 透明读取老的数据格式</li>
<li>互操作, 支持多语言交互</li>
</ul>
<p>Hadoop 序列化要实现接口 <code>Writable</code></p>
<h1 id="demo-">Demo 统计用户上网流量</h1>
<p>测试数据</p>
<pre><code>电话号码     上行流量 下行流量
13888888888  2000      1000
13988888888  1000      6000
13988888888  2000      5000
13988888888  3000      4000
</code></pre><p>运行结果</p>
<pre><code>号码   上行流量    下行流量    总流量
138    2000        1000        3000
139    6000        15000       21000
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> DataCount {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Configuration conf = <span class="keyword">new</span> Configuration();
        Job job = Job.getInstance(conf);
        job.setJarByClass(DataCount.class);

        job.setMapperClass(DCMapper.class);
        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(DataBean.class);
        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));

        job.setReducerClass(DCReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(DataBean.class);
        FileInputFormat.setOutputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));

        job.waitForCompletion(<span class="keyword">true</span>);
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> DataBean implements Writable {
    <span class="keyword">private</span> String account;
    <span class="keyword">private</span> String upPayLoad;
    <span class="keyword">private</span> String downPayLoad;
    <span class="keyword">private</span> String totalPayLoad;

    <span class="keyword">public</span> <span class="title">DataBean</span>(){}
    
    <span class="comment">// 构造函数</span>
    <span class="keyword">public</span> <span class="title">DataBean</span>(String account, <span class="keyword">long</span> upPayLoad, <span class="keyword">long</span> downPayLoad){
        super();
        <span class="keyword">this</span>.account = account;
        <span class="keyword">this</span>.upPayLoad = upPayLoad;
        <span class="keyword">this</span>.downPayLoad = downPayLoad;
        <span class="keyword">this</span>.totalPayLoad = upPayLoad + downPayLoad;
    }
    
    <span class="comment">// 在序列化时要注意 1. 类型, 2. 顺序</span>
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(DataOutput <span class="keyword">out</span>) {
        <span class="keyword">out</span>.writeUTF(account);
        <span class="keyword">out</span>.writeLong(upPayLoad);
        <span class="keyword">out</span>.writeLong(downPayLoad);
        <span class="keyword">out</span>.writeLong(totalPayLoad);
    }
    
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span>(DataInput <span class="keyword">in</span>) {
        account = <span class="keyword">in</span>.readUTF();
        upPayLoad = <span class="keyword">in</span>.readLong();
        downPayLoad = <span class="keyword">in</span>.readLong();
        totalPayLoad  = <span class="keyword">in</span>.readLong();
    }
    
    @Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span>(){
        <span class="comment">// TODO</span>
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> DCMapper extends Mapper&lt;LongWritable, Text, Text, DataBean&gt; {
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable key, Text <span class="keyword">value</span>, Context context) {
        String ling = <span class="keyword">value</span>.toString();
        String[] fields = line.split(<span class="string">"\t"</span>);
        String account = fields[<span class="number">1</span>];
        <span class="keyword">long</span> up = Long.parseLong(fields[<span class="number">8</span>]);
        <span class="keyword">long</span> down = Long.parseLong(fields[<span class="number">9</span>]);
        context.write(<span class="keyword">new</span> Text(account), <span class="keyword">new</span> DataBean(<span class="string">""</span>, up, down));
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> DCReduce extends Reducer&lt;Text, DataBean, Text, DataBean&gt; {
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(Text key, Iterable&lt;DataBean&gt; values, Context context) {
        <span class="keyword">long</span> up_sum = <span class="number">0</span>;
        <span class="keyword">long</span> down_sum = <span class="number">0</span>;
        <span class="keyword">for</span>(DataBean bean : values) {
            up_sum +=  bean.getUpPayLoad();
            down_sum +=  bean.getDownPayLoad();
        }
        context.write(key, <span class="keyword">new</span> DataBean(key, upPayLoad, downPayLoad));
    }
}
</pre></td></tr></table></figure>

<p>如果想要在集群上运行, 安装 hadoop 插件</p>
<h1 id="-">源码分析</h1>
<ol>
<li>初始化DistributeFS, 获取 HDFS 代理对象(DFSClient)</li>
<li>启动Job, 获取 ResourceManager 代理对象(Cluster), 通过ResourceManager 获取 jar包路径, 和jobId</li>
<li>提交jar包, 默认10份</li>
<li>提交信息给 ResourceManager, jar包路径, jobId</li>
<li>NodeManager 通过心跳来申请任务</li>
<li>启动 YarnChild, 下载Jar包</li>
<li>启动任务</li>
</ol>
<p>一个 Reducer 对应一个结果文件, 可以通过配置来设置 Reducer 个数. Mapper不能设置个数.</p>
]]></content>
    
    
      <category term="hadoop" scheme="http://zhpooer.github.io/tags/hadoop/"/>
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MIT Algorithm-算法分析]]></title>
    <link href="http://zhpooer.github.io/2014/08/12/mit-algorithm-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://zhpooer.github.io/2014/08/12/mit-algorithm-算法分析/</id>
    <published>2014-08-12T13:40:09.000Z</published>
    <updated>2014-08-13T01:04:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">算法分析</h1>
<p>关于计算机性能的研究 和 资源的利用</p>
<p>What&#39; more important than performance?</p>
<ul>
<li>User-friendly</li>
<li>Security</li>
<li>健壮性</li>
<li>简洁性</li>
</ul>
<p>为什么研究算法和性能?</p>
<ul>
<li>有时候用户友好和性能是正相关的</li>
<li>性能关系到 行和不行, 如实时计算, 空间的利用, 时间的花费</li>
<li>描述算法的领域语言</li>
</ul>
<p>像经济系统中的钞票, 为其他功能支付性能</p>
<p>java 比 C 花费了3倍性能</p>
<h1 id="problem-sorting">Problem: Sorting</h1>
<p>Input: Sequence<a1, a2,...,an></p>
<p>Output: 已经排序好的</p>
<h2 id="-">插入排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">Insert</span>.<span class="keyword">Sort</span>(An)
  for
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="algorithm" scheme="http://zhpooer.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Input with forms]]></title>
    <link href="http://zhpooer.github.io/2014/08/12/play-for-scala-input-with-forms/"/>
    <id>http://zhpooer.github.io/2014/08/12/play-for-scala-input-with-forms/</id>
    <published>2014-08-12T08:22:42.000Z</published>
    <updated>2014-08-15T08:26:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="forms-the-concept">Forms—the concept</h1>
<p>Play provides the so-called forms API. The term form isn’t just about HTML forms in
a Play application; it’s a more general concept. The forms API helps you to validate data,
manage validation errors, and map this data to richer data structures.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="reserved">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(</span>
  username : String,
  realname : Option[String],
  email    : String )

val userForm = Form(
  mapping(
    <span class="string">"username"</span><span class="function"> -&gt;</span> nonEmptyText(<span class="number">8</span>),
    <span class="string">"realname"</span><span class="function"> -&gt;</span> optional(text),
    <span class="string">"email"</span><span class="function"> -&gt;</span> email)(User.apply)(User.unapply))

def createUser() = Action { implicit request<span class="function"> =&gt;</span>
  userForm.bindFromRequest.fold(
    formWithErrors<span class="function"> =&gt;</span> BadRequest,
    user<span class="function"> =&gt;</span> Ok(<span class="string">"User OK!"</span>))
}
</pre></td></tr></table></figure>

<h1 id="forms-basics">Forms basics</h1>
<p>Play’s forms are powerful, but they’re built on a few simple ideas.</p>
<h2 id="mappings">Mappings</h2>
<p>A Mapping is an object that can construct something from the data in an HTTP
request. This process is called binding.</p>
<p>So a Mapping[User] can construct a User instance, and
a Mapping[Int] can create an Int.</p>
<p> If you submit an HTML form with an input tag
<code>&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;</code>, a <code>Mapping[Int]</code> can convert that age value,
which is submitted as a string, into a Scala Int.</p>
<p>The data from the HTTP request is transformed into a <code>Map[String, String]</code>, and
this is what the Mapping operates on.</p>
<p>But a Mapping can not only construct an object from a map of data;
it can also do the reverse operation of deconstructing an object
into a map of data.</p>
<p> A mapping is an object of type <code>Mapping[T]</code> that can take a
<code>Map[String, String]</code>, and use it to construct an object of type T ,</p>
<p>For example, <code>Forms.number</code> is a mapping of type <code>Mapping[Int]</code>,
whereas <code>Forms.text</code> is a mapping of type
<code>Mapping[String]</code>. There’s also <code>Forms.email</code>,
which is also of type <code>Mapping[String]</code>,
but it also contains a constraint that the
string must look like an email address.</p>
<h2 id="creating-a-form">Creating a form</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>val data = <span class="keyword">Map</span>(
  <span class="string">"name"</span> -&gt; <span class="string">"Box of paper clips"</span>,
  <span class="string">"ean"</span> -&gt; <span class="string">"1234567890123"</span>,
  <span class="string">"pieces"</span> -&gt; <span class="string">"300"</span>
)

// The <span class="keyword">type</span> <span class="keyword">of</span> mapping <span class="keyword">is</span>
// play.api.data.Mapping[(<span class="typename">String</span>, <span class="typename">String</span>, Int)]
// indicates the <span class="keyword">type</span> <span class="keyword">of</span> objects that this mapping can construct.
val mapping = Forms.tuple(
  <span class="string">"name"</span> -&gt; Forms.text,
  <span class="string">"ean"</span> -&gt; Forms.text,
  <span class="string">"pieces"</span> -&gt; Forms.number)

// This form <span class="keyword">is</span> <span class="keyword">of</span> <span class="keyword">type</span> Form[(<span class="typename">String</span>, <span class="typename">String</span>, Int)].
// Form has a single <span class="keyword">type</span> parameter, <span class="keyword">and</span> it has the same meaning.
// But a form <span class="keyword">not</span> only wraps a Mapping, it can also contain data.
val productForm = Form(mapping)
</pre></td></tr></table></figure>

<p>You can use the following Play-provided
basic mappings to start composing more complex mappings:</p>
<ul>
<li><code>boolean: Mapping[Boolean]</code></li>
<li><code>checked(msg: String): Mapping[Boolean]</code></li>
<li><code>date: Mapping[Date]</code></li>
<li><code>email: Mapping[String]</code></li>
<li><code>ignored[A](value: A): Mapping[A]</code></li>
<li><code>longNumber: Mapping[Long]</code></li>
<li><code>nonEmptyText: Mapping[String]</code></li>
<li><code>number: Mapping[Int]</code></li>
<li><code>sqlDate: Mapping[java.sql.Date]</code></li>
</ul>
<h2 id="processing-data-with-a-form">Processing data with a form</h2>
<p>The process of putting your data in the form is called binding,
and we use the bind method to do it:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>//  <span class="keyword">it</span> returns <span class="operator">a</span> <span class="built_in">new</span> Form—<span class="operator">a</span> copy <span class="operator">of</span> <span class="operator">the</span> original form populated <span class="operator">with</span> <span class="operator">the</span> data.
val processedForm = productForm.bind(data)

<span class="keyword">if</span>(!processedForm.hasErrors) {
  val productTuple = processedForm.<span class="built_in">get</span><span class="comment"> // Do something with the product</span>
} <span class="keyword">else</span> {
  val errors = processedForm.getErrors<span class="comment"> // Do something with the errors</span>
}
</pre></td></tr></table></figure>

<p><code>Form.fold</code> takes two parameters, where the first is a function that accepts the
“failure” result, and the second accepts the “success” result as the single parameter.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val processedForm = productForm<span class="preprocessor">.bind</span>(data)
processedForm<span class="preprocessor">.fold</span> (
  formWithErrors =&gt; BadRequest,
  productTuple =&gt; {
    Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.product</span><span class="preprocessor">.show</span>(product))
  }
)
</pre></td></tr></table></figure>

<h3 id="either">Either</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>def getProduct(): Either[String, Product] = {
  if(validation<span class="preprocessor">.hasError</span>) {
    Left(validation<span class="preprocessor">.error</span>)
  } else {
    Right(Product())
  }
}
def showProduct() = Action {
  getProduct()<span class="preprocessor">.fold</span>(
    failureReason =&gt; InternalServerError(failureReason),
    product =&gt; Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.product</span><span class="preprocessor">.show</span>(product))
  )
}
</pre></td></tr></table></figure>

<h2 id="object-mapping">Object mapping</h2>
<p>To do so, we’ll have to provide the mapping with a function to construct the value.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">case</span> class Product(
  name: <span class="built_in">String</span>,
  ean: <span class="built_in">String</span>,
  pieces: Int)

<span class="keyword">import</span> play<span class="built_in">.</span>api<span class="built_in">.</span><span class="built_in">data</span><span class="built_in">.</span>Forms<span class="built_in">.</span>_

<span class="comment">// This makes the type of this mapping Mapping[Product].</span>
val productMapping <span class="subst">=</span> mapping(
  <span class="string">"name"</span> <span class="subst">-&gt; </span>text,
  <span class="string">"ean"</span> <span class="subst">-&gt; </span>text,
  <span class="string">"pieces"</span> <span class="subst">-&gt; </span>number)(Product<span class="built_in">.</span>apply)(Product<span class="built_in">.</span>unapply)

<span class="comment">// Using our Mapping[Product], we can now easily create a Form[Product]:</span>
val productForm <span class="subst">=</span> Form(productMapping)

productForm<span class="built_in">.</span>bind(<span class="built_in">data</span>)<span class="built_in">.</span>fold(
  formWithErrors <span class="subst">=&gt;</span> <span class="attribute">...</span>,
  product <span class="subst">=&gt;</span> 
)
</pre></td></tr></table></figure>

<h2 id="mapping-http-request-data">Mapping HTTP request data</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def processForm() = Action { request =&gt;
  productForm.bindFromRequest()(request).fold(
  <span class="keyword">...</span>
  )
}

// 加入 imlicit
def processForm() = Action { implicit request =&gt;
  productForm.bindFromRequest().fold(
    <span class="keyword">...</span>
  )
}
</pre></td></tr></table></figure>

<p>Browsers submit HTTP bodies with either an <code>application/x-www-form-urlencoded</code>
or a <code>multipart/form-data</code> content type, depending on the form, and it’s
also common to send JSON over the wire. The bindFromRequest method uses the
Content-Type header to determine a suitable decoder for the body.</p>
<h1 id="creating-and-processing-html-forms">Creating and processing HTML forms</h1>
<p>Play also provides helpers that generate forms and take the
tedium out of showing validation and error messages in the appropriate places.</p>
<h2 id="writing-html-forms-manually">Writing HTML forms manually</h2>
<p>model class:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="reserved">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span>(</span>
  <span class="attribute">ean</span>: Long,
  <span class="attribute">name</span>: String,
  <span class="attribute">description</span>: String,
  <span class="attribute">pieces</span>: Int,
  <span class="attribute">active</span>: Boolean)

val productForm = Form(mapping(
  <span class="string">"ean"</span><span class="function"> -&gt;</span> longNumber,
  <span class="string">"name"</span><span class="function"> -&gt;</span> nonEmptyText,
  <span class="string">"description"</span><span class="function"> -&gt;</span> text,
  <span class="string">"pieces"</span><span class="function"> -&gt;</span> number,
  <span class="string">"active"</span><span class="function"> -&gt;</span> boolean)(Product.apply)(Product.unapply))

def create() = Action { implicit request<span class="function"> =&gt;</span>
  productForm.bindFromRequest.fold(
    formWithErrors<span class="function"> =&gt;</span> BadRequest(<span class="string">"Oh noes, invalid submission!"</span>),
    value<span class="function"> =&gt;</span> Ok(<span class="string">"created: "</span> + value)
  )
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>@()
@main("Product Form") {
  <span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"@routes.Products.create()"</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"name"</span>&gt;</span>Product name<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">id</span>=<span class="value">"name"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"description"</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">id</span>=<span class="value">"description"</span> <span class="attribute">name</span>=<span class="value">"description"</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"ean"</span>&gt;</span>EAN Code<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"ean"</span> <span class="attribute">id</span>=<span class="value">"ean"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"pieces"</span>&gt;</span>Pieces<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"pieces"</span> <span class="attribute">id</span>=<span class="value">"pieces"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"active"</span>&gt;</span>Active<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"active"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"buttons"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span>&gt;</span>Create Product<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">form</span>&gt;</span>
}
</pre></td></tr></table></figure>

<h2 id="generating-html-forms">Generating HTML forms</h2>
<p>Play provides helpers, template snippets that can render a form field for you, including
extra information like an indication when the value is required and an error message
if the field has an invalid value. The helpers are in the <code>views.template</code> package.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="at_rule">@(productForm:<span class="preprocessor"> Form</span>[Product])

@<span class="function">main(<span class="string">"Product Form"</span>)</span> {</span>
  <span class="at_rule">@helper.<span class="function">form(action = routes.GeneratedForm.create)</span> {</span>
    <span class="at_rule">@helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"name"</span>)</span>)</span>
    @helper.<span class="function">textarea(<span class="function">productForm(<span class="string">"description"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"ean"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"pieces"</span>)</span>)</span>
    @helper.<span class="function">checkbox(<span class="function">productForm(<span class="string">"active"</span>)</span>)</span>
    &lt;div<span class="preprocessor"> class</span>=<span class="string">"form-actions"</span>&gt;
      &lt;button<span class="preprocessor"> type</span>=<span class="string">"submit"</span>&gt;Create<span class="preprocessor"> Product</span>&lt;/button&gt;
    &lt;/div&gt;
  }
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>def createForm() = Action {
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.form</span>(productForm))
}
</pre></td></tr></table></figure>

<h2 id="input-helpers">Input helpers</h2>
<p>Play ships predefined helpers for the most common input types:</p>
<ul>
<li>inputDate—Generates an input tag with type date .</li>
<li>inputPassword—Generates an input tag with type password.</li>
<li>inputFile—Generates an input tag with type file .</li>
<li>inputText—Generates an input tag with type text .</li>
<li>select—Generates a select tag.</li>
<li>inputRadioGroup—Generates a set of input tags with type radio.</li>
<li>checkbox—Generates an input tag with type checkbox.</li>
<li>textarea—Generates a textarea element.</li>
<li>input—Creates a custom input.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>@*  notation '_class creates a <span class="type">Scala</span> <span class="type">Symbol</span> named _class *@
@helper.inputText(productForm(<span class="string">"name"</span>), '_class -&gt; <span class="string">"important"</span>, 'size -&gt; <span class="number">40</span>)
</pre></td></tr></table></figure>

<p>These are the extra symbols with underscores that you can use:</p>
<ul>
<li><code>_label</code>—Use to set a custom label</li>
<li><code>_id</code>—Use to set the id attribute of the dl element</li>
<li><code>_class</code>—Use to set the class attribute of the dl element</li>
<li><code>_help</code>—Use to show custom help text</li>
<li><code>_showConstraints</code>—Set to false to hide the constraints on this field</li>
<li><code>_error</code>—Set to a <code>Some[FormError]</code> instance to show a custom error</li>
<li><code>_showErrors</code>—Set to false to hide the errors on this field</li>
</ul>
<h2 id="customizing-generated-html">Customizing generated HTML</h2>
<p>Play allows you to customize the generated HTML in two ways. First, you
can customize which input element is generated, in case you need some special input
type. Second, you can customize the HTML elements around that input element.</p>
<p>Suppose we want to create an input with type datetime.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>@* the first <span class="keyword">is</span> the Field that we want to create the input <span class="keyword">for</span> *@
<span class="property">@helper</span>.input<span class="function"><span class="params">(myForm(<span class="string">"mydatetime"</span>))</span> { <span class="params">(id, name, value, args)</span> =&gt;</span>
  @* a type <span class="function"><span class="params">(String, String, Option[String], Map[Symbol,Any])</span> =&gt;</span> Html *@
  &lt;input type=<span class="string">"datetime"</span> name=<span class="string">"@name"</span> id=<span class="string">"@id"</span> value=<span class="string">"@value"</span> <span class="property">@toHtmlArgs</span>(args)&gt;
}
</pre></td></tr></table></figure>

<p>We use the toHtmlArgs method from the <code>play.api.templates.PlayMagic</code>
object to construct additional attributes from the args map.</p>
<p>They have an additional parameter list that takes an implicit <code>FieldConstructor</code> and a <code>Lang</code>.</p>
<p><code>FieldConstructor</code> is a trait with a single apply method that takes a
<code>FieldElements</code> object and returns Html. Play provides a <code>defaultFieldConstructor</code>
that generates the HTML we saw earlier, but you can implement
your own <code>FieldConstructor</code> if you want different HTML.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>@(elements: views.html.helper.FieldElements)

<span class="keyword">@import</span> play.api.i18n._
<span class="keyword">@import</span> views.html.helper._

&lt;div <span class="keyword">class</span>=<span class="string">"control-group @elements.args.get('_class)
  @if(elements.hasErrors) {error}"</span>
  id=<span class="string">"@elements.args.get('_id).getOrElse(elements.id + "</span>_field<span class="string">")"</span> &gt;
    &lt;label <span class="keyword">class</span>=<span class="string">"control-label"</span> <span class="keyword">for</span>=<span class="string">"@elements.id"</span>&gt;
      <span class="keyword">@elements</span>.label(elements.lang)
    &lt;/label&gt;
    &lt;div <span class="keyword">class</span>=<span class="string">"controls"</span>&gt;
      <span class="keyword">@elements</span>.input
      &lt;span <span class="keyword">class</span>=<span class="string">"help-inline"</span>&gt;
        <span class="keyword">@if</span>(elements.errors(elements.lang).nonEmpty) {
          <span class="keyword">@elements</span>.errors(elements.lang).mkString(<span class="string">", "</span>)
        } <span class="keyword">else</span> {
          <span class="keyword">@elements</span>.infos(elements.lang).mkString(<span class="string">", "</span>)
        }
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">package</span> views.html.helper

<span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">bootstrap</span> {</span>
implicit <span class="keyword">val</span> fieldConstructor = <span class="keyword">new</span> FieldConstructor {
  <span class="keyword">def</span> apply(elements: FieldElements) =
    bootstrap.bootstrapFieldConstructor(elements)
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="at_rule">@(productForm:<span class="preprocessor"> Form</span>[Product])
@<span class="keyword">import</span><span class="preprocessor"> views.html.helper.bootstrap._</span>
@<span class="function">main(<span class="string">"Product Form"</span>)</span> {</span>
  <span class="at_rule">@helper.<span class="function">form(action = routes.GeneratedForm.create)</span> {</span>
    <span class="at_rule">@helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"name"</span>)</span>)</span>
    @helper.<span class="function">textarea(<span class="function">productForm(<span class="string">"description"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"ean"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"pieces"</span>)</span>)</span>
    @helper.<span class="function">checkbox(<span class="function">productForm(<span class="string">"active"</span>)</span>)</span>
    &lt;div<span class="preprocessor"> class</span>=<span class="string">"form-actions"</span>&gt;
      &lt;button<span class="preprocessor"> type</span>=<span class="string">"submit"</span>&gt;Create<span class="preprocessor"> Product</span>&lt;/button&gt;
    &lt;/div&gt;
  }
}</span>
</pre></td></tr></table></figure>

<h1 id="validation-and-advanced-mappings">Validation and advanced mappings</h1>
<p>Additionally, we’ll see how we can create our own mappings,
for when we want to bind things that don’t have a predefined mapping.</p>
<h2 id="basic-validation">Basic validation</h2>
<p>Mappings contain a collection of constraints, and when a value is bound, it’s checked
against each of the constraints.</p>
<p>A <code>Mapping[T]</code> has the method <code>verifying(constraints: Constraint[T]*)</code>, which
copies the mapping and adds the constraints. Play provides a small number of
constraints on the <code>play.api.data.validation.Constraints</code> object:</p>
<ul>
<li><code>min(maxValue: Int): Constraint[Int]</code>—A minimum value for an Int mapping</li>
<li><code>max(maxValue: Int): Constraint[Int]</code>—A maximum value for an Int mapping</li>
<li><code>minLength(length: Int): Constraint[String]</code>—A minimum length for a String mapping</li>
<li><code>maxLength(length: Int): Constraint[String]</code>—A maximum length for a String mapping</li>
<li><code>nonEmpty</code>: Constraint[String]—Requires a not-empty string</li>
<li><code>pattern(regex: Regex, name: String, error: String): Constraint[String]</code>—
A constraint that uses a regular expression to validate a String</li>
</ul>
<p>These are also the constraints that Play uses when you utilize one of the mappings
with built-in validations, like <code>nonEmptyText</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="string">"name"</span> -&gt; text<span class="preprocessor">.verifying</span>(Constraints<span class="preprocessor">.nonEmpty</span>)
</pre></td></tr></table></figure>

<h2 id="custom-validation">Custom validation</h2>
<p>In our product form, we’d like to check whether a product with the same EAN code
already exists in our database. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>def eanExists(ean: Long) = Product<span class="preprocessor">.findByEan</span>(ean)<span class="preprocessor">.isEmpty</span>

// We can then use verifying to <span class="keyword">add</span> it to our mapping
<span class="string">"ean"</span> -&gt; longNumber<span class="preprocessor">.verifying</span>(eanExists(_))

// <span class="keyword">add</span> the validation massage
<span class="string">"ean"</span> -&gt; longNumber<span class="preprocessor">.verifying</span>(<span class="string">"This product already exists."</span>, Product<span class="preprocessor">.findByEan</span>(_)<span class="preprocessor">.isEmpty</span>)
</pre></td></tr></table></figure>

<h2 id="validating-multiple-fields">Validating multiple fields</h2>
<p>In our product form, we might want to allow people to add new products to the
database without a description, but not to make it active if there’s no description.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>val productForm = Form(mapping(
  <span class="string">"ean"</span> -&gt; longNumber<span class="preprocessor">.verifying</span>(<span class="string">"This product already exists!"</span>,
    Product<span class="preprocessor">.findByEan</span>(_)<span class="preprocessor">.isEmpty</span>),
  <span class="string">"name"</span> -&gt; nonEmptyText,
  <span class="string">"description"</span> -&gt; text,
  <span class="string">"pieces"</span> -&gt; number,
  <span class="string">"active"</span> -&gt; boolean)(Product<span class="preprocessor">.apply</span>)(Product<span class="preprocessor">.unapply</span>)<span class="preprocessor">.verifying</span>(
    <span class="string">"Product can not be active if the description is empty"</span>,
    product =&gt;
      !product<span class="preprocessor">.active</span> || product<span class="preprocessor">.description</span><span class="preprocessor">.nonEmpty</span>))
</pre></td></tr></table></figure>

<p>If this top-level mapping causes an error, it’s called the global error,
which you can retrieve with the globalError method on Form.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">@productForm</span>.globalError.map { error =&gt;
  &lt;span <span class="keyword">class</span>=<span class="string">"error"</span>&gt;<span class="keyword">@error</span>.message&lt;/span&gt;
}
</pre></td></tr></table></figure>

<h2 id="optional-mapings">Optional mapings</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="keyword">class</span> Person(name: <span class="built_in">String</span>, age: <span class="keyword">Option</span>[Int])

val personMapping = mapping(
  <span class="string">"name"</span> -&gt; nonEmptyText,
  <span class="string">"age"</span>  -&gt; <span class="keyword">optional</span>(number)
)(Person.apply)(Person.unapply)
</pre></td></tr></table></figure>

<h2 id="repeated-mappings">Repeated mappings</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;input <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"tags[0]"</span>&gt;
&lt;input <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"tags[1]"</span>&gt;
&lt;input <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"tags[2]"</span>&gt;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="property">@helper</span>.repeat(form(<span class="string">"tags"</span>), min = <span class="number">3</span>) { tagField<span class="function"> =&gt;</span>
  <span class="property">@helper</span>.inputText(tagField, <span class="string">'_label -&gt; "Tag")
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="string">"tags"</span> -&gt; <span class="type">list</span>(<span class="type">text</span>)
</pre></td></tr></table></figure>

<h2 id="nested-mappings">Nested mappings</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="title">val</span> contactsForm = <span class="type">Form</span>(tuple(
  <span class="string">"main_contact_name"</span> -&gt; text,
  <span class="string">"main_contact_email"</span> -&gt; email,
  <span class="string">"technical_contact_name"</span> -&gt; text,
  <span class="string">"technical_contact_email"</span> -&gt; email,
  <span class="string">"administrative_contact_name"</span> -&gt; text,
  <span class="string">"administrative_contact_email"</span> -&gt; email))

// same <span class="keyword">as</span>
<span class="title">val</span> contactMapping = tuple(
  <span class="string">"name"</span> -&gt; text,
  <span class="string">"email"</span> -&gt; email)
  
<span class="title">val</span> contactsForm = <span class="type">Form</span>(tuple(
  <span class="string">"main_contact"</span> -&gt; contactMapping,
  <span class="string">"technical_contact"</span> -&gt; contactMapping,
  <span class="string">"administrative_contact"</span> -&gt; contactMapping))
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="at_rule">@helper.<span class="function">inputText(<span class="function">form(<span class="string">"main_contact.name"</span>)</span>)</span>
@helper.<span class="function">inputText(<span class="function">form(<span class="string">"main_contact.email"</span>)</span>)</span></span>
</pre></td></tr></table></figure>

<p>Also like this</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>val appointmentMapping <span class="subst">=</span> tuple(
  <span class="string">"location"</span> <span class="subst">-&gt; </span>text,
  <span class="string">"start"</span> <span class="subst">-&gt; </span>tuple(  <span class="comment">// Field name start.date</span>
    <span class="string">"date"</span> <span class="subst">-&gt; </span><span class="built_in">date</span>,
    <span class="string">"time"</span> <span class="subst">-&gt; </span>text),
  <span class="string">"attendees"</span> <span class="subst">-&gt; </span><span class="built_in">list</span>(mapping(
    <span class="string">"name"</span> <span class="subst">-&gt; </span>text,
    <span class="string">"email"</span> <span class="subst">-&gt; </span>email)(Person<span class="built_in">.</span>apply)(Person<span class="built_in">.</span>unapply))) <span class="comment">// attendees[0].name&gt;</span>
</pre></td></tr></table></figure>

<h2 id="custom-mappings">Custom mappings</h2>
<p>For example, we might have a date picker in our HTML form that we want to bind
to a Joda Time LocalDate, which is basically a date without time zone information.</p>
<p>We can create a <code>Mapping[LocalDate]</code> by transforming a Mapping[String] as
follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val localDateMapping = text.transform(
  <span class="function"><span class="params">(dateString: String)</span> =&gt;</span>
    LocalDate.parse(dateString),
  <span class="function"><span class="params">(localDate: LocalDate)</span> =&gt;</span>
    localDate.toString)
</pre></td></tr></table></figure>

<p>The transform method uses these to transform a <code>Mapping[String]</code> into a
<code>Mapping[LocalDate]</code>.</p>
<p>The transform method is therefore best used for transformations that are
guaranteed to work. When that’s not the case, you can use the second,
more powerful method of creating your own Mapping,
which is also how Play’s built-in mappings are created.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>implicit val localDateFormatter = new Formatter[LocalDate] {
  def <span class="keyword">bind</span>(key:String, data: Map[String, String]) =
    data.get(key) <span class="keyword">map</span> { <span class="string">value =&gt;</span>
      Try {
        Right(LocalDate.parse(value))
      } getOrElse Left(Se<span class="string">q(FormError(key, "error.date", Nil)</span>))
    } getOrElse Left(Se<span class="string">q(FormError(key, "error.required", Nil)</span>))
  def unbind(key: String, id: LocalDate) = Map(key -&gt; id.toString)
  
  override val <span class="keyword">format</span> = Some((<span class="string">"date.format"</span>, Nil))
}

//  we can easily construct a Mapping[LocalDate] using the Forms.of method
val localDateMapping = Forms.of(localDateFormatter)
</pre></td></tr></table></figure>

<p><code>conf/messages</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">date</span><span class="built_in">.</span>format<span class="subst">=</span><span class="built_in">Date</span> (YYYY<span class="attribute">-MM</span><span class="attribute">-DD</span>)
error<span class="built_in">.</span><span class="built_in">date</span><span class="subst">=</span><span class="built_in">Date</span> formatted as YYYY<span class="attribute">-MM</span><span class="attribute">-DD</span> expected
</pre></td></tr></table></figure>

<p>Because the parameter of the of method is implicit, and we’ve declared our <code>localDateFormatter</code>
as implicit as well, we can leave it off, but we do have to specify the
type parameter then. Additionally, if we have <code>Forms._</code> imported, we can write this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val localDateMapping = <span class="keyword">of</span>[LocalDate]

// The single method <span class="keyword">is</span> identical <span class="keyword">to</span> the tuple method,
// except it’s the one you need <span class="keyword">to</span> <span class="keyword">use</span> <span class="keyword">if</span> you have only a single field.
val localDateForm = Form(single(
  <span class="string">"introductionDate"</span> -&gt; localDateMapping
))
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>@helper.inputText(productForm(<span class="string">"introductionDate"</span>), '_label -&gt; <span class="string">"Introduction Date"</span>)
</pre></td></tr></table></figure>

<h2 id="dealing-with-file-uploads">Dealing with file uploads</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>&lt;form action=<span class="string">"@routes.FileUpload.upload"</span> <span class="keyword">method</span>=<span class="string">"post"</span>
      enctype=<span class="string">"multipart/form-data"</span>&gt;
  &lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"file"</span> name=<span class="string">"image"</span>&gt;
  &lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"submit"</span>&gt;
&lt;/form&gt;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>//  request.body is <span class="operator">of</span> type MultipartFormData[TemporaryFile]
def upload() = Action(parse.multipartFormData) { request =&gt;
  request.body.<span class="built_in">file</span>(<span class="string">"image"</span>).map { <span class="built_in">file</span> =&gt;
   <span class="comment"> // FilePart[TemporaryFile], which has a ref property</span>
   <span class="comment"> // This TemporaryFile deletes its underlying file when it’s garbage collected</span>
    <span class="built_in">file</span>.ref.moveTo(<span class="built_in">new</span> File(<span class="string">"/tmp/image"</span>))
    Ok(<span class="string">"Retrieved file %s"</span> <span class="built_in">format</span> <span class="built_in">file</span>.filename)
  }.getOrElse(BadRequest(<span class="string">"File missing!"</span>))
}
</pre></td></tr></table></figure>

<p>Even though you don’t use forms for processing files, you can still use them for
generating inputs and reporting validation errors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>def upload() = Action (parse<span class="preprocessor">.MultipartFormData</span>) { implicit request =&gt;
  val form = Form(tuple(
    <span class="string">"description"</span> -&gt; text,
    // ignores the form data but delivers its parameter as the value
    <span class="string">"image"</span> -&gt; ignored(request<span class="preprocessor">.body</span><span class="preprocessor">.file</span>(<span class="string">"image"</span>)).
       verifying(<span class="string">"file missing"</span>, _<span class="preprocessor">.isDefined</span>) // If not defined, no file was uploaded
  ))
  form<span class="preprocessor">.bindFromRequest</span><span class="preprocessor">.fold</span>(
    formWithErrors =&gt; {
      Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.fileupload</span><span class="preprocessor">.uploadform</span>(formWithErrors))
    },
    value =&gt; Ok
  )
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// actually is </span>
<span class="comment">// Form[(String,Option[play.api.mvc.MultipartFormData.FilePart[play.api.libs.Files.TemporaryFile]])]</span>
@(form: Form[_])
@helper.form(action = routes.FileUpload.upload, 'enctype -&gt; <span class="string">"multipart/form-data"</span>) {
  @helper.inputText(form(<span class="string">"description"</span>))  
  @helper.inputFile(form(<span class="string">"image"</span>))
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>def showUploadForm() = Action {
  val dummyForm = Form(ignored(<span class="string">"dummy"</span>))
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.fileupload</span><span class="preprocessor">.uploadform</span>(dummyForm))
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-View Template]]></title>
    <link href="http://zhpooer.github.io/2014/08/12/play-for-scala-view-template/"/>
    <id>http://zhpooer.github.io/2014/08/12/play-for-scala-view-template/</id>
    <published>2014-08-12T03:36:59.000Z</published>
    <updated>2014-08-15T06:32:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="the-why-of-a-template-engine">The why of a template engine</h1>
<p>Templates allow you to reuse pieces of your HTML when you need them, such as a
header and a footer section that are the same or similar on every page. </p>
<p>Another reason to use templates is because they help you to separate business logic
from presentation logic; separating these two concerns has several advantages.</p>
<h1 id="type-safety-of-a-template-engine">Type safety of a template engine</h1>
<p>Play Scala templates are HTML files containing snippets of Scala code,
which are compiled into plain Scala code before your application is started. </p>
<p>As an example, we’ll build a catalog application. The main page will be a list of all
the articles in the catalog, and every article on this page will have a hyperlink to a
details page for that article, where more information about that article is shown. </p>
<h2 id="a-type-safe-template-engine">A type-safe template engine</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="xml">@(articles: Seq[models.Article])
<span class="tag">&lt;<span class="title">hi</span>&gt;</span>Articles<span class="tag">&lt;/<span class="title">hi</span>&gt;</span>
<span class="tag">&lt;<span class="title">ul</span>&gt;</span>
@for(article <span class="tag">&lt;<span class="title">-</span> <span class="attribute">articles</span>) {
  &lt;<span class="attribute">li</span>&gt;</span>
    @article.name -
    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@controllers.routes.Aritcles.show(article.id)"</span>&gt;</span>
      details
    <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
}
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Articles</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> index = Action {
    <span class="keyword">val</span> articles = Article.findAll()
    Ok(views.html.articles.index(articles))
  }
  <span class="keyword">def</span> show(id:Long) = Action {
    Articles.findById(id) <span class="keyword">match</span> {
      <span class="keyword">case</span> None =&gt; NotFound
      <span class="keyword">case</span> Some(article) =&gt; Ok(views.html.articles.show(article))
    }
  }
}
</pre></td></tr></table></figure>

<p>Play’s type-safe template engine will help you build a more robust application. Both
your IDE and Play itself will warn you when a refactoring causes type errors, even
before you render the template.</p>
<h1 id="template-basics-and-common-structures">Template basics and common structures</h1>
<p>In Scala templates, the <code>@</code> character marks the start of a Scala expression.</p>
<h2 id="-">特殊字符 @</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Hello <span class="decorator">@name!</span>
Your age <span class="keyword">is</span> <span class="decorator">@user.age.</span>
Next year, your age will be <span class="decorator">@(user.age + 1)</span>

<span class="decorator">@* 这样是错误的 *@</span>
Next year, your age will be <span class="decorator">@user.age + 1</span>

Next year, your age will be
<span class="decorator">@{val ageNextYear = user.age + 1; ageNextYear}</span>

<span class="decorator">@* 输出 @ 符号 *@</span>
username<span class="decorator">@@example.com</span>

<span class="decorator">@* 这是注释 *@</span>
</pre></td></tr></table></figure>

<h2 id="-">表达式</h2>
<p>Play also imports various things into the scope of your templates. The following are
automatically imported by Play:</p>
<ul>
<li><code>models._</code></li>
<li><code>controllers._</code></li>
<li><code>play.api.i18n._</code></li>
<li><code>play.api.mvc._</code>, makes MVC components available.</li>
<li><code>play.api.data._</code>, contains tools for dealing with forms and validation. </li>
<li><code>views.%format%._</code>,  is replaced by the template format that you’re using.</li>
</ul>
<h2 id="displaying-collections">Displaying collections</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="xml"><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
@articles.map { article =&gt;
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>@article.name<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
}
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>

@* The template compiler automatically adds the yield keyword *@
<span class="tag">&lt;<span class="title">ul</span>&gt;</span>
@for(article <span class="tag">&lt;<span class="title">-</span> <span class="attribute">articles</span>) {
  &lt;<span class="attribute">li</span>&gt;</span>@article.name<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
}
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>

@for(article <span class="tag">&lt;<span class="title">-</span> <span class="attribute">articles</span>) {
  <span class="attribute">Article</span> <span class="attribute">name:</span> @<span class="attribute">article.name</span>
}</span></span>
</pre></td></tr></table></figure>

<p>If you’re interested in the details of the template engine,
you can take a look at the file <code>ScalaTemplateCompiler.scala</code> in the Play
framework source. </p>
<h3 id="adding-the-index-of-the-element">ADDING THE INDEX OF THE ELEMENT</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>&lt;ul&gt;
<span class="variable">@for</span>((article, <span class="keyword">index</span>) &lt;- articles.zipWithIndex) {
  &lt;li&gt;Best seller number <span class="variable">@(</span><span class="keyword">index</span> + <span class="number">1</span>): <span class="variable">@article</span>.name&lt;<span class="regexp">/li&gt;
}
&lt;/ul</span>&gt;

&lt;ul&gt;
<span class="variable">@for</span>((article, <span class="keyword">index</span>) &lt;- articles.zipWithIndex) {
  &lt;li class=<span class="string">"<span class="variable">@if</span>(index == 0){first}
    <span class="variable">@if</span>(index == articles.length - 1){last}"</span>&gt;
  Best seller number <span class="variable">@(</span><span class="keyword">index</span> + <span class="number">1</span>): <span class="variable">@article</span>.name&lt;<span class="regexp">/li&gt;
}
&lt;/ul</span>&gt;
</pre></td></tr></table></figure>

<h2 id="security-and-escaping">Security and escaping</h2>
<p>An application developer must always keep security in mind, and when dealing with
templates, avoiding cross-site scripting vulnerabilities is especially relevant. </p>
<h3 id="cross-site-scripting-vulnerabilities">CROSS-SITE SCRIPTING VULNERABILITIES</h3>
<p>HTML injection could lead to minor annoyances, like broken markup and invalid
HTML documents, but much more serious problems arise when a malicious user
inserts scripts in your web page. These scripts could, for example, steal other visitors’
cookies when they use your application, and send these cookies to a server under the
attacker’s control.</p>
<h3 id="escaping">ESCAPING</h3>
<p>Everything that you write literally in a template is considered HTML by Play, and is
output unescaped. This HTML is always written by the template author, so it’s consid-
ered safe. </p>
<p>But all Scala expressions are escaped.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>@* embedCode 在这里被当成 没有特殊字符的文本, 不会被转义 *@
<span class="property">@article</span>.embeddedVideo.map { embedCode<span class="function"> =&gt;</span>
  &lt;h3&gt;Product video&lt;/h3&gt;
  <span class="property">@Html</span>(embedCode)
}
</pre></td></tr></table></figure>

<h2 id="using-plain-scala">Using plain Scala</h2>
<p>As shown earlier, you can use plain Scala if you
create a block with <code>@()</code> or <code>@{}</code>.</p>
<p>By default, the output is escaped. If you want to prevent this, wrap the result in an Html.</p>
<p>Any scala.xml.NodeSeq is also rendered unescaped, so you
can use the following code:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>@{
  <span class="tag">&lt;<span class="title">b</span>&gt;</span>hello<span class="tag">&lt;/<span class="title">b</span>&gt;</span>
}
</pre></td></tr></table></figure>

<p>只调用 <code>article.countReview()</code> 一次, 值映射到 total</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="property">@defining</span>(article.countReview()) { total<span class="function"> =&gt;</span>
  &lt;h3&gt;This article has been reviewed <span class="property">@total</span> times&lt;/h3&gt;
  &lt;p&gt;@(article.countPositiveReviews()) out <span class="keyword">of</span> these
  <span class="property">@total</span> reviews were positive!&lt;/p&gt;
}
</pre></td></tr></table></figure>

<h1 id="structuring-pages-template-composition">Structuring pages: template composition</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>def catalog() = Action {
  val products = ProductDAO<span class="preprocessor">.list</span>
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.shop</span><span class="preprocessor">.catalog</span>(products))
}
</pre></td></tr></table></figure>

<p><code>views/navigation.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>@()
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"navigation"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@routes.Application.home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@routes.Shop.catalog"</span>&gt;</span>Catalog<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@routes.Application.contact"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p><code>views/catalog.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- other code --&gt;</span>
<span class="comment">&lt;!-- 导入 navigation 模板 --&gt;</span>
  @navigation()
<span class="comment">&lt;!-- other code --&gt;</span>
</pre></td></tr></table></figure>

<h2 id="layouts">Layouts</h2>
<p><code>app/views/main.scala.html</code>, with a single parameter named content of type <code>Html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>@(content: Html)
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>paperclips.example.com<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"@routes.Assets.at("</span><span class="value">stylesheets</span>/<span class="attribute">main.css</span>")"
          <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Products<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    @navigation
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"content"</span>&gt;</span>
      @content
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">footer</span>&gt;</span>
      <span class="tag">&lt;<span class="title">p</span>&gt;</span>Copyright paperclips.example.com<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">footer</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<p>可以这样使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="xml">@(products: Seq[Product])
@main {
  <span class="tag">&lt;<span class="title">h2</span>&gt;</span>Products<span class="tag">&lt;/<span class="title">h2</span>&gt;</span>
  <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"products"</span>&gt;</span>
  @for(product <span class="tag">&lt;<span class="title">-</span> <span class="attribute">products</span>) {
    &lt;<span class="attribute">li</span>&gt;</span>
      <span class="tag">&lt;<span class="title">h3</span>&gt;</span>@product.name<span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
      <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"description"</span>&gt;</span>@product.description<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  }
  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
}</span>
</pre></td></tr></table></figure>

<p>可以这样定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>@* @(title="paperclips.example.com")(content: Html) 或这样*@
@(title: String)(content: Html)
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">title</span>&gt;</span>@title<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="comment">&lt;!-- any --&gt;</span>
</pre></td></tr></table></figure>

<p>这样使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="at_rule">@<span class="function">main(<span class="string">"Products"</span>)</span> {</span>
  <span class="comment">// content here</span>
}
</pre></td></tr></table></figure>

<h2 id="tags">Tags</h2>
<p><code>views/products/tags/productlist.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="xml">@(products: Seq[Product])
<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"products"</span>&gt;</span>
@for(product <span class="tag">&lt;<span class="title">-</span> <span class="attribute">products</span>) {
  &lt;<span class="attribute">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h3</span>&gt;</span>@product.name<span class="tag">&lt;/<span class="title">h3</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"description"</span>&gt;</span>@product.description<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
}
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p><code>catalog.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="variable">@(</span>products: Se<span class="string">q[Product]</span>)
<span class="variable">@main</span> {
  &lt;h2&gt;Products&lt;<span class="regexp">/h2&gt;
  @views.html.products.tags.productlist(products)
}</span>
</pre></td></tr></table></figure>

<h1 id="reducing-repetition-with-implicit-parameters">Reducing repetition with implicit parameters</h1>
<p>Let’s continue with our web shop example. This time we’ll assume that we want to
maintain a shopping cart on the website, and in the top-right corner of every page we
want to show the number of items the visitor has in their shopping cart.</p>
<p><code>main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>@(cart: Cart)(content: Html)
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<p>Now that the main template needs a Cart parameter, we’ll have to pass one to it,
which means adapting our catalog template. But this template doesn’t have a refer-
ence to a Cart object, so it’ll need to take one as a parameter as well:</p>
<p><code>cart.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="variable">@(</span>products: Se<span class="string">q[Product]</span>, cart: Cart)
<span class="variable">@main</span>(cart) {
  &lt;h2&gt;Catalog&lt;<span class="regexp">/h2&gt;
  @views.html.products.tags.productlist(products)
}</span>
</pre></td></tr></table></figure>

<p>We’ll also have to pass a Cart from the action:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">def</span> catalog() = Action { request =&gt;
  <span class="keyword">val</span> products = ProductDAO.list
  Ok(views.html.shop.catalog(products, cart(request)))
}

<span class="keyword">def</span> cart(request: Request) = {
  <span class="comment">// Get cart from session</span>
}
</pre></td></tr></table></figure>

<p>可以这样:</p>
<p>We can use an implicit parameter to change the method signature of our catalog
template as follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">@(</span>products: Se<span class="string">q[Product]</span>)(implicit cart: Cart)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def catalog() = Action { <span class="keyword">implicit</span> request =&gt;
  val products = ProductDAO.list
  Ok(views.html.shop.catalog(products))
}

<span class="keyword">implicit</span> def cart(<span class="keyword">implicit</span> request: RequestHeader) = {
  <span class="comment">// Get cart from session</span>
}
</pre></td></tr></table></figure>

<p>We can make our newly created cart method reusable, by moving it into a trait:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">WithCart</span> {</span>
  implicit <span class="keyword">def</span> cart(implicit request: RequestHeader) = {
    <span class="comment">// Get cart from session</span>
  }
}
</pre></td></tr></table></figure>

<p>If you have an implicit Request in
scope in your controller, you also have an implicit RequestHeader, Session,
Flash, and Lang in scope, because the Controller trait defines
implicit conversions for these types.</p>
<h1 id="using-less-and-coffeescript-the-asset-pipeline">Using LESS and CoffeeScript: the asset pipeline</h1>
<p>LESS is a stylesheet language that’s
transformed to CSS by a LESS interpreter or compiler,
whereas CoffeeScript is a scripting language that’s transformed into
JavaScript by a CoffeeScript compiler.</p>
<h2 id="less">LESS</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class">.header</span> <span class="rules">{
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#0b5c20</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.footer</span> <span class="rules">{
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"><span class="hexcolor">#0b5c20</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.footer</span> <span class="tag">a</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>LESS:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="at_rule">@green: <span class="hexcolor">#0b5c20</span>;</span>
<span class="class">.header</span> {
  <span class="attribute">background-color</span><span class="value">:@green;</span>
}

<span class="class">.footer</span> {
  <span class="attribute">background-color</span><span class="value">:@green;</span>
  <span class="tag">a</span> {
    <span class="attribute">font-weight</span><span class="value">:bold;</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="coffeescript">CoffeeScript</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>math =
  <span class="attribute">root</span>: Math.sqrt
  <span class="attribute">square</span>: square
  <span class="attribute">cube</span>: <span class="function"><span class="params">(x)</span> -&gt;</span> x * square x
</pre></td></tr></table></figure>

<h2 id="the-asset-pipeline">The asset pipeline</h2>
<p>Play supports automatic build-time CoffeeScript and LESS compilation, and it
shows compilation errors in the familiar Play error page.</p>
<p>For example, if you place a CoffeeScript file in
<code>app/assets/javascripts/application.coffee</code>,
you can reference it from a template like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"@routes.Assets.at("</span><span class="value">javascripts</span>/<span class="attribute">application.js</span>")"&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p>You can also use an automatically generated minified version of
your JavaScript file by changing <code>application.js</code> to <code>application.min.js</code> .</p>
<h1 id="internationalization">Internationalization</h1>
<p>Internationalization is a refactoring to remove locale-specific code from
your application. Localization is making a locale-specific version of an application. In
an internationalized web application, this means having one or more selectable
locale-specific versions.</p>
<p><code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>application<span class="preprocessor">.langs</span>=<span class="string">"en,en-US,nl"</span>
</pre></td></tr></table></figure>

<p><code>conf/messages</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>welcome = Welcome!
users.login = Log <span class="keyword">in</span>
shop.thanks = Thank you <span class="keyword">for</span> your <span class="keyword">order</span>
</pre></td></tr></table></figure>

<p>Play provides an implicit conversion from a Request to a Lang, which is more useful.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">Messages(<span class="string">"users.login"</span>)</span>(<span class="function">Lang(<span class="string">"en"</span>)</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">(implicit</span> request: Request)
&lt;h1&gt;@<span class="function">Messages(<span class="string">"welcome"</span>)</span>&lt;/h1&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">validation.required</span>=<span class="string">{0} is required</span>
</pre></td></tr></table></figure>

<p>You can substitute these by specifying more parameters to the call to Messages:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">Messages</span>(<span class="string">"validation.required"</span>, <span class="string">"email"</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>shop.basketcount=Your cart {<span class="number">0</span>,choice,<span class="number">0</span><span class="array">#is empty</span>|<span class="number">1</span><span class="array">#has one item</span>
  |<span class="number">1</span>&lt; has {<span class="number">0</span>} items}.
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">p</span>&gt;</span>@Messages("shop.basketcount", 0)<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>@Messages("shop.basketcount", 1)<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>@Messages("shop.basketcount", 10)<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="comment">&lt;!-- 输出 --&gt;</span>
<span class="comment">&lt;!-- Your cart is empty. --&gt;</span>
<span class="comment">&lt;!-- Your cart has one item. --&gt;</span>
<span class="comment">&lt;!-- Your cart has 10 items. --&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day66-Hadoop HDFS]]></title>
    <link href="http://zhpooer.github.io/2014/08/11/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day66-hadoop-hdfs/"/>
    <id>http://zhpooer.github.io/2014/08/11/传智播客day66-hadoop-hdfs/</id>
    <published>2014-08-11T00:54:29.000Z</published>
    <updated>2014-08-11T09:15:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-hdfs">分布式文件系统与HDFS</h1>
<p>客户端(Client) 查询 NameNode(记录文件存储信息), 将数据放入datanode(多个)或从中取出<br>数据在上传过程中要进行冗余保存, datanode 自行进行水平复制.(流水线复制)<br>上传过程中, 文件会被分块, 每块128M, 其实是对块的冗余存储</p>
<ul>
<li>数据量越来越多, 在多个操作系统中协调</li>
<li>允许文件通过网络在多台主机上分享文件系统, 增加机器数量来扩张</li>
<li>通透性, 在用户和程序看来, 就像访问本地的磁盘一样</li>
<li>容错, 某些节点脱机, 可以持续运作, 不会由数据损失</li>
<li>分布式文件管理系统有很多种, hdfs 只是其中一种. 适用于一次写入,
多次查询的情况, 不支持并发写(同一个文件分块同时上传), 小文件不合适</li>
</ul>
<p>分布式文件系统</p>
<ul>
<li>GFS</li>
<li>HDFS</li>
<li>Lustre</li>
<li>Ceph</li>
<li>GriddFs</li>
<li>TFS</li>
</ul>
<p>谷歌三大论文(BigTable, MapReduce, GFS)</p>
<h1 id="hdfs-shell-">HDFS的shell操作</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre><span class="preprocessor"># 启动 HDFS</span>
start-dfs.sh

<span class="preprocessor"># 列出文件</span>
hadoop fs -ls hdfs:<span class="comment">//itcast:9000/</span>

<span class="preprocessor"># 取出文件</span>
hadoop fs -<span class="keyword">get</span> hdfs:<span class="comment">//itcast:9000/jdk ~/temp/jdk</span>
<span class="preprocessor"># 也可以这么写</span>
hadoop fs -<span class="keyword">get</span> /jdk ~/temp/jdk

hadoop fs -cat /words.avi

<span class="preprocessor"># 追加文件到 word.avi</span>
hadoop fs -appendToFile ~/appendix /words.avi

<span class="preprocessor"># 查看ls 帮助</span>
hadoop fs -help ls
hadoop fs -ls /wc* -h
<span class="preprocessor"># 递归显示</span>
hadoop fs -ls /wc* -R

<span class="preprocessor"># 改变所属组和所属用户</span>
hadoop fs -chown supergroup:supergroup  /jdk
hadoop fs -chgrp root  /jdk

<span class="preprocessor"># 改变权限</span>
hadoop fs -chmode u+w /wcout
<span class="preprocessor"># 递归改变权限</span>
hadoop fs -chmode u+w /wcout -R

<span class="preprocessor"># 拷贝本地文件到 hdfs 相当于 put</span>
hadoop fs -copyFromLocal /home/hadoop/a.txt /
<span class="preprocessor"># 获得远程文件到本地</span>
hadoop fs -copyToLocal /a.txt /tmp/

<span class="preprocessor"># 列出文件数, 文件夹数, 总大小</span>
hadoop fs -count /

<span class="preprocessor"># 远程拷贝</span>
hadoop fs -cp /a.txt /b.txt

<span class="preprocessor"># 剪切</span>
hadoop fs -cp /a.txt /b.txt

hadoop fs -du
hadoop fs -df

hadoop fs -mkdir -p /abc
hadoop fs -rm /abc -r

<span class="preprocessor"># 合并 a.txt b.txt 到 c.txt</span>
hadoop fs -getmerge /a.txt /b.txt /tmp/c.txt

<span class="preprocessor"># 查看尾部内容</span>
hadoop fs -tail /a.txt

hadoop fs -text /a.txt | more

<span class="preprocessor"># 设置3个副本, 如果只有一台机器, 还是存了一份</span>
hadoop fs -setrep <span class="number">3</span> /a.txt
</pre></td></tr></table></figure>

<p>老版本中所有命令都包含在 <code>hadoop</code> 命令中, 新版本中<code>hdfs dfs</code>代替 <code>hadoop fs</code></p>
<h1 id="-">体系结构和基本概念</h1>
<ul>
<li>NameNode, 索引节点, 存放文件的描述性信息(medadata)</li>
<li>DataNode, 数据节点, 可以有许多个</li>
<li>Secodary NameNode, Name node的帮助节点, 在Hadoop 2.0中已经去除, 但是伪分布式中还会存在</li>
</ul>
<h2 id="-">元数据存储细节</h2>
<p>NameNode包含</p>
<ul>
<li>FileName</li>
<li>replicas</li>
<li>block-ids</li>
<li>id2host</li>
<li>其他</li>
</ul>
<pre><code>metadata: /test/a.log, 3, {blk_1, blk_2}, [{blk_1: [h0, h1, h3]}, {blk_2: [h0, h2, h4]}]
文件/test/a.log, 有三个副本, 分成两块{blk_1, blk_2}, 分别被存在 [h0....]
</code></pre><p>NameNode 是整个文件系统的管理节点. 维护着整个节点的目录树.
文件/目录的元数据和每个文件对应的数据块列表, 接受用户的操作请求.</p>
<p>文件包括:</p>
<ul>
<li>fsimage 元数据镜像文件, 存储着某一时段 NameNode 内存元数据信息.
序列化写入到磁盘; 1.0非实时同步, 但是2.0可以通过设置实现</li>
<li>edits, 操作日志文件, 记录用户的操作日志</li>
<li>fstime, 保存最近一次checkpoint的时间, 上一次数据同步的时间点; 内存数据和磁盘数据同步的时间点;</li>
</ul>
<p>工作特点</p>
<ul>
<li>始终在内存中保存metedata</li>
<li>有写请求到来时, namenode会首先写editlog到磁盘. 成功返回后, 修改内存(metedata), 返回客户端</li>
<li>namenode 维护 fsimage 文件, 不会随时与 metedata 同步, 每隔一段时间通过合并edits 文件来更新内容.
SecondaryNameNode 合并 fsimage 和 edits 来完成工作</li>
</ul>
<h2 id="secondarynamenode">SecondaryNameNode</h2>
<p>Hadoop2 中已经不使用这种方法同步</p>
<p>HA(高可靠性) 解决方案, 不支持热备份(数据实时同步)</p>
<p>执行过程, 从Namenode下载数据信息(fsimage, edits), 然后把二者合并,
生成新的fsimage, 返回给NameNode. 通常部署到两个节点</p>
<p>以下两个任意两个参数满足, 就会启动合并</p>
<ul>
<li><code>fs.checkpoint.period</code> 指定两次checkpoint的最大时间间隔, 默认 3600秒</li>
<li><code>fs.checkpoint.size</code>, edits size 的最大值, 默认为64M</li>
</ul>
<h2 id="datanode">DataNode</h2>
<p>提供真实文件的存储服务</p>
<p>文件块(block): 最基本的存储单位. Hdfs1.0默认大小为64M, Hdfs1.0默认大小为128M.</p>
<p>HDFS中, 如果一个文件不小于数据块大小, 并不会占用整个block</p>
<p>replication, 多副本, 默认3块</p>
<h1 id="java-api">java接口与常用API</h1>
<p>导入jar包 <code>hdfs.jar common.jar</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> HDFSDemo {

    FileSystem fs = <span class="keyword">null</span>;
    @Before <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>() {
        fs = FileSystem.<span class="keyword">get</span>(<span class="keyword">new</span> URI(<span class="string">"hdfs://itcast:9000"</span>), <span class="keyword">new</span> Configuration());
    }
    
    @Test <span class="keyword">public</span> <span class="keyword">void</span> testDownload{
        InputStream <span class="keyword">in</span> = fs.open(<span class="keyword">new</span> Path(<span class="string">"/jdk7"</span>));
        OutputStream <span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/jdk4"</span>);
        <span class="comment">// true, 拷贝完成自动关闭</span>
        IOUtils.copyBytes(<span class="keyword">in</span>, <span class="keyword">out</span>, <span class="number">4096</span>, <span class="keyword">true</span>);
    }

    @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span>() {
        InputStream <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/test"</span>);
        OutputStream <span class="keyword">out</span> = fs.create(<span class="keyword">new</span> Path(<span class="string">"/in.log"</span>));
        IOUtils.copyBytes(<span class="keyword">in</span>, <span class="keyword">out</span>, <span class="number">4096</span>, <span class="keyword">true</span>);
    }

    @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMkDir</span>() {
        fs.mkdirs(<span class="keyword">new</span> Path(<span class="string">"/itcast/shanghai"</span>));
    }

    @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDel</span>() {
        <span class="comment">// 是否递归删除</span>
        Boolean flag = fs.delete(<span class="keyword">new</span> Path(<span class="string">"/jdk7"</span>), <span class="keyword">false</span>);
    }

   @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExist</span>() {
       fs.exists(<span class="keyword">new</span> Path(<span class="string">"/jdk7"</span>));
   }

}
</pre></td></tr></table></figure>

<h1 id="rpc-">RPC 机制</h1>
<p>RMI 效率低</p>
<p>Remote Procedure Call, 远程过程调用协议</p>
<p>datanode 与 namenode 之间通信(心跳检测)使用RPC</p>
<p>Client 与 namenode 之间通信使用RPC</p>
<p>Client 与 datanode 之间使用 HTTP</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bizable</span> {</span>
    <span class="comment">// 初始化时需要版本号</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> versionID = <span class="number">10010</span>l;
    <span class="keyword">public</span> String <span class="title">sysHi</span>(String name);
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> <span class="keyword">implements</span> <span class="title">Bizable</span>{</span>
    <span class="keyword">public</span> String <span class="title">sysHi</span>(String name) {
        <span class="keyword">return</span> <span class="string">"Hi ~"</span> + name;
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>() {
        Server serveer = <span class="keyword">new</span> RPC.Builder(<span class="keyword">new</span> Configuration())
                               .setInstance(<span class="keyword">new</span> RPCServer())
                               .setProtocol(Bizable.class)
                               .setBindAddress(<span class="string">"192.168.1.101"</span>)
                               .setPort(<span class="number">9527</span>)
                               .build();
        Server.start();
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span>() {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>() {
        Bizable proxy = RPC.getProxy(Bizable.class, <span class="number">10010</span>,
                               <span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.1.101"</span>, <span class="number">9527</span>), <span class="keyword">new</span> Configuration());
        String result = proxy.sysHi(<span class="string">"world"</span>);
        RPC.stopProxy(proxy);
    }
}
</pre></td></tr></table></figure>

<p>NameNode 和 DataNode 都是一个 main 方法</p>
<h1 id="-">源码分析</h1>
<p><code>FileSystem</code> 通过反射生成 实际子类.</p>
<h1 id="-debug">远程debug</h1>
<p>JDPA, java远程调试框架</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>hadoop-deamon.sh <span class="operator"><span class="keyword">start</span> dataNode</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="hadoop" scheme="http://zhpooer.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-the persistence layer]]></title>
    <link href="http://zhpooer.github.io/2014/08/11/play-for-scala-the-persistence-layer/"/>
    <id>http://zhpooer.github.io/2014/08/11/play-for-scala-the-persistence-layer/</id>
    <published>2014-08-11T00:00:25.000Z</published>
    <updated>2014-08-12T03:33:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="what-are-anorm-and-squeryl-">What are Anorm and Squeryl?</h1>
<p>In order to talk to the database, you’ll have to create SQL at some point.
A modern object-relation mapper (ORM) like Hibernate or the Java Persistence API (JPA)
provides its own query language (HQL and JPQL, respectively), which is then translated
into the target database’s SQL dialect.</p>
<p>Anorm and Squeryl are at opposite ends of the SQL-generation/translation spectrum.</p>
<p>Squeryl generates SQL by providing a Scala domain-specific language ( DSL)
that’s similar to actual SQL. Anorm doesn’t generate any SQL, and instead
relies on the developer to write SQL. </p>
<ul>
<li>Anorm allows you to write any SQL that you can come up with, even using
proprietary extensions of the particular database that you’re using.</li>
<li>Squeryl’s DSL allows the compiler to check that your queries are correct, which
meshes well with Play’s emphasis on type safety.</li>
</ul>
<h2 id="configuring-your-database">Configuring your database</h2>
<p>Play comes with support for an H2 in-memory database out of the box, but there’s no
database configured by default. </p>
<p><code>conf/application.conf</code>, 要配置其他的数据库, 可以注释掉</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span>=org<span class="preprocessor">.h</span>2<span class="preprocessor">.Driver</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=<span class="string">"jdbc:h2:mem:play"</span>
</pre></td></tr></table></figure>

<p>An in-memory database is fine for development and testing but doesn’t cut it
for most production environments.</p>
<p><code>Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val appDependencies = Se<span class="string">q(
  jdbc,
  anorm,
  "postgresql" % "postgresql" % "9.1-901.jdbc4"
)</span>
</pre></td></tr></table></figure>

<p><code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db<span class="preprocessor">.default</span><span class="preprocessor">.user</span>=user
db<span class="preprocessor">.default</span><span class="preprocessor">.password</span>=qwerty
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=<span class="string">"jdbc:postgresql://localhost:5432/paperclips"</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span>=org<span class="preprocessor">.postgresql</span><span class="preprocessor">.Driver</span>
</pre></td></tr></table></figure>

<h2 id="creating-the-schema">Creating the schema</h2>
<p>Anorm can’t create your schema for you because it doesn’t know anything about your model.
Squeryl can create your schema for you, but it’s unable to update it. This means
you’ll have to write the SQL commands to create (and later update) your schema yourself.</p>
<p>Play does offer some help in the form of evolutions. To use evolutions, you write an
SQL script for each revision of your database; Play will then automatically detect that a
database needs to be upgraded and will do so after asking for your permission.</p>
<p>Evolutions scripts should be placed in the <code>conf/evolutions/default</code> directory
and be named <code>1.sql</code> for the first revision, <code>2.sql</code> for the second, and so on.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre># <span class="comment">--- !Ups</span>
<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (
  id long,
  ean long,
  name <span class="keyword">varchar</span>,
  description <span class="keyword">varchar</span>);</span>
  
<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> warehouses (
  id long,
  name <span class="keyword">varchar</span>);</span>

<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_items (
  id long,
  product_id long,
  warehouse_id long,
  quantity long);</span>

# <span class="comment">--- !Downs</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> products;</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> warehouses;</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> stock_items;</span>
</pre></td></tr></table></figure>

<p>Just click the red button labeled “Apply this script now!”</p>
<h1 id="using-anorm">Using Anorm</h1>
<p>Anorm lets you write SQL queries and provides an API to parse result sets. </p>
<p>When you retrieve data with Anorm, there are three ways to
process the results: the Stream API, pattern matching, and parser combinators. </p>
<h2 id="defining-your-model">Defining your model</h2>
<p>Therefore, your model is simply a bunch of classes that represent the entities
that you want to use in your application and store in the database.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="keyword">class</span> Product(
  id: <span class="built_in">Long</span>,
  ean: <span class="built_in">Long</span>,
  name: <span class="built_in">String</span>,
  description: <span class="built_in">String</span>)
<span class="keyword">case</span> <span class="keyword">class</span> Warehouse(id: <span class="built_in">Long</span>, name: <span class="built_in">String</span>)

<span class="keyword">case</span> <span class="keyword">class</span> StockItem(
  id: <span class="built_in">Long</span>,
  productId: <span class="built_in">Long</span>,
  warehouseId: <span class="built_in">Long</span>,
  quantity: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h2 id="using-anorm-s-stream-api">Using Anorm’s stream API</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">import</span> anorm.SQL
<span class="keyword">import</span> anorm.SqlQuery

// The apply method has an implicit parameter
// block that takes a java.sql.Connection
// which Play provides <span class="keyword">in</span> the form of DB.withConnection.
val sql: SqlQuery = SQL(<span class="string">"select * from products order by name asc"</span>)

<span class="keyword">import</span> play.api.Play.current
<span class="keyword">import</span> play.api.db.DB

<span class="function"><span class="keyword">def</span> <span class="title">getAll</span>:</span>List[Product] = DB.withConnection{
    implicity connection =&gt;
    sql().map(row =&gt;
        Product(row[Long](<span class="string">"id"</span>), row[Long](<span class="string">"ean"</span>),
                row[String](<span class="string">"name"</span>), row[String](<span class="string">"description"</span>))
    ).toList
}
</pre></td></tr></table></figure>

<p>The <code>row</code> variable in the function body passed to map is an <code>SqlRow</code> ,
which has an apply method that retrieves the requested field by name.</p>
<h2 id="pattern-matching-results">Pattern matching results</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">getAllWithPatterns</span>:</span> List[Product] = DB.withConnection {
  implicit connection =&gt;
  <span class="keyword">import</span> anorm.Row
  sql().collect {
    case Row(Some(id: Long), Some(ean: Long),
             Some(name: String), Some(description: String)) =&gt;
      Product(id, ean, name, description)
  }.toList
}
</pre></td></tr></table></figure>

<p>We’ve said before that the query’s apply method returns a standard Scala <code>Stream</code>.</p>
<p>Streams are simply lists that haven’t computed—or in this case retrieved—their
contents yet. This is why we had to convert
them to Lists with toList to actually retrieve the contents.</p>
<h2 id="parsing-results">Parsing results</h2>
<p>You can also parse results with parser combinators,1 a functional programming
technique for building parsers by combining other parsers,</p>
<h3 id="building-a-single-record-parser">BUILDING A SINGLE-RECORD PARSER</h3>
<p>We’ll need to retrieve (and therefore parse) our entities many times, so it’s a good
idea to build parsers for each of our entities.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">import</span> anorm.RowParser
val productParser: RowParser[Product] = {
  <span class="keyword">import</span> anorm.~
  <span class="keyword">import</span> anorm.SqlParser._
  long(<span class="string">"id"</span>) ~
  long(<span class="string">"ean"</span>) ~
  str(<span class="string">"name"</span>) ~
  str(<span class="string">"description"</span>) map {
    case id ~ ean ~ name ~ description =&gt;
      Product(id, ean, name, description)
  }
}

<span class="keyword">import</span> anorm.ResultSetParser
// Anorm needs a ResultSetParser 
val productsParser: ResultSetParser[List[Product]] = {
  productParser *
}

// 查询结果
<span class="function"><span class="keyword">def</span> <span class="title">getAllWithParser</span>:</span> List[Product] = DB.withConnection {
  implicit connection =&gt;
  sql.<span class="keyword">as</span>(productsParser)
}
</pre></td></tr></table></figure>

<h2 id="building-a-multirecord-parser">BUILDING A MULTIRECORD PARSER</h2>
<p>To fetch stock item data, we’ll use SQL to query the <code>products</code> and
<code>stock_items</code> database tables.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>val stockItemParser: RowParser[StockItem] = {
  <span class="keyword">import</span> anorm.SqlParser._
  <span class="keyword">import</span> anorm.~
  long(<span class="string">"id"</span>) ~ long(<span class="string">"product_id"</span>) ~
  long(<span class="string">"warehouse_id"</span>) ~ long(<span class="string">"quantity"</span>) map {
    case id ~ productId ~ warehouseId ~ quantity =&gt;
      StockItem(id, productId, warehouseId, quantity)
  }
}

<span class="function"><span class="keyword">def</span> <span class="title">productStockItemParser</span>:</span> RowParser[(Product, StockItem)] = {
  <span class="keyword">import</span> anorm.SqlParser._
  <span class="keyword">import</span> anorm.~
  // flatten (<span class="keyword">in</span> map (flatten) ) turns the given ~[Product, StockItem] into a standard tuple.
  productParser ~ StockItem.stockItemParser map (flatten)
}

<span class="function"><span class="keyword">def</span> <span class="title">getAllProductsWithStockItems</span>:</span> Map[Product, List[StockItem]] = {
  DB.withConnection { implicit connection =&gt;
    val sql = SQL(<span class="string">"select p.*, s.* "</span> +
                  <span class="string">"from products p "</span> +
                  <span class="string">"inner join stock_items s on (p.id = s.product_id)"</span>)
    val results: List[(Product, StockItem)] =
    sql.<span class="keyword">as</span>(productStockItemParser *)
    //  Map[Product, StockItem] =&gt;
    //  Map[Product, List[(Product, StockItem)]] =&gt; 
    //  Map[Product, List[StockItem]]
    results.groupBy { _._1 }.mapValues { _.map { _._2 } }
  }
}
</pre></td></tr></table></figure>

<h2 id="inserting-updating-and-deleting-data">Inserting, updating, and deleting data</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="keyword">def</span> insert(product: Product): Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> addedRows =
      SQL(<span class="string">"""insert
             into products
             values ({id}, {ean}, {name}, {description})"""</span>).on(
               <span class="string">"id"</span> -&gt; product.id,
               <span class="string">"ean"</span> -&gt; product.ean,
               <span class="string">"name"</span> -&gt; product.name,
               <span class="string">"description"</span> -&gt; product.description
      ).executeUpdate()
  addedRows == <span class="number">1</span>
}

<span class="keyword">def</span> update(product: Product):Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> updateRows =
      SQL(<span class="string">"""update products
             set name = {name},
             ean = {ean},
             description = {description},
             where id = {id}
      """</span>).on (
        <span class="string">"id"</span> -&gt; product.id,
        <span class="string">"name"</span> -&gt; product.name,
        <span class="string">"ean"</span> -&gt; product.ean,
        <span class="string">"description"</span> -&gt; product.description
      ).executeUpdate()
    updatedRows == <span class="number">1</span>
  }

<span class="keyword">def</span> delete(product: Product): Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> updatedRows = SQL(<span class="string">"delete from products where id = {id}"</span>).
    on(<span class="string">"id"</span> -&gt; product.id).executeUpdate()
    updatedRows == <span class="number">0</span>
  }
</pre></td></tr></table></figure>

<h1 id="using-squeryl">Using Squeryl</h1>
<p>This means that Squeryl is an ORM that gives you a feature that other
ORMs don’t: a type-safe query language.</p>
<p>You can write queries in a language that the Scala compiler understands,
and you’ll find out whether there are errors in your queries at compile time.</p>
<p>Contrast this with other ORMs (or Anorm—Anorm is not an ORM) that rely
on the database to tell you that there are errors in your query,
and don’t complain until the queries are actually run.</p>
<h2 id="plugging-squeryl-in">Plugging Squeryl in</h2>
<p><code>project/Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>val appDependencies = <span class="constant">Seq</span>(
  jdbc,
  <span class="string">"org.squeryl"</span> <span class="string">%% "squeryl" %</span> <span class="string">"0.9.5-6"</span>
)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.adapters.H2Adapter
<span class="keyword">import</span> org.squeryl.{Session, SessionFactory}
<span class="keyword">import</span> play.api.db.DB
<span class="keyword">import</span> play.api.{Application, GlobalSettings}

<span class="class"><span class="keyword">object</span> <span class="title">Global</span> <span class="keyword">extends</span> <span class="title">GlobalSettings</span> {</span>
  <span class="keyword">override</span> <span class="keyword">def</span> onStart(app: Application) {
    SessionFactory.concreteFactory = Some(() =&gt;
      Session.create(DB.getConnection()(app), <span class="keyword">new</span> H2Adapter) )
  }
}
<span class="comment">// DB.getConnection is intended to be used in an environment where an</span>
<span class="comment">// Application is available as an</span>
<span class="comment">// implicit, and you can call it without the second parameter list.</span>
implicit <span class="keyword">val</span> implicitApp = app
DB.getConnection()
</pre></td></tr></table></figure>

<h2 id="defining-your-model">Defining your model</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.KeyedEntity

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(
  id: Long,
  ean: Long,
  name: String,
  description: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>
  
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Warehouse</span><span class="params">(
  id: Long,
  name: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StockItem</span><span class="params">(
  id: Long,
  product: Long,
  location: Long,
  quantity: Long)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>
</pre></td></tr></table></figure>

<p>The only thing that’s different from vanilla case classes here is that
we’re extending <code>KeyedEntity</code>. This tells Squeryl that it can use the
id for updates and deletes.</p>
<h3 id="immutability-and-threads">IMMUTABILITY AND THREADS</h3>
<p>When an object is immutable, you can only change it by making a copy.
This ensures that other threads that have a
reference to the same object won’t be affected by the changes.</p>
<h3 id="defining-the-schema">DEFINING THE SCHEMA</h3>
<p><code>org.squeryl.Schema</code> contains some utility methods and will allow
us to group our entity classes in such a way that Squeryl can make sense of them.</p>
<p>We’ve defined three classes to contain records, and we’ve
told Squeryl which tables we want it to create and how to map them to our model.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.Schema
<span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._

<span class="class"><span class="keyword">object</span> <span class="title">Database</span> <span class="keyword">extends</span> <span class="title">Schema</span> {</span>
  <span class="comment">// The table method returns a table for the</span>
  <span class="comment">// class specified as the type parameter</span>
  <span class="keyword">val</span> productsTable: Table[Product] =
    table[Product](<span class="string">"products"</span>)
  <span class="keyword">val</span> stockItemsTable: Table[StockItem] =
    table[StockItem](<span class="string">"stock_items"</span>)
  <span class="keyword">val</span> warehousesTable: Table[Warehouse] =
    table[Warehouse](<span class="string">"warehouses"</span>)
    
  on(productsTable) { p =&gt; declare {
    p.id is(autoIncremented)
  }}
  
  on(stockItemsTable) { s =&gt; declare {
    s.id is(autoIncremented)
  }}
  
  on(warehousesTable) { w =&gt; declare {
    w.id is(autoIncremented)
  }}
}
</pre></td></tr></table></figure>

<p>Squeryl does define a create method that creates the schema when
called from the Database object.</p>
<h2 id="extracting-data-queries">Extracting data—queries</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._
<span class="keyword">import</span> org.squeryl.Table
<span class="keyword">import</span> org.squeryl.Query
<span class="keyword">import</span> collection.Iterable
object Product {
  <span class="keyword">import</span> Database.{productsTable, stockItemsTable}
  // product: Query result row name
  <span class="function"><span class="keyword">def</span> <span class="title">allQ</span>:</span> Query[Product] = <span class="keyword">from</span>(productsTable) {
    product =&gt; select(product) orderBy(product.name desc)
  }
}

// it also extends Iterable
<span class="function"><span class="keyword">def</span> <span class="title">findAll</span>:</span> Iterable[Product] = inTransaction {
  allQ.toList
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def productsInWarehouse(<span class="attribute">warehouse</span>: Warehouse) = {
  join<span class="function"><span class="params">(productsTable, stockItemsTable)((product, stockItem) =&gt;
    where(stockItem.location === warehouse.id).
    select(product).
    <span class="literal">on</span>(stockItem.product === product.id)
  )</span>
}
<span class="title">def</span> <span class="title">productsInWarehouseByName</span><span class="params">(name: String, warehouse: Warehouse)</span>: <span class="title">Query</span>[<span class="title">Product</span>]= {
  <span class="title">from</span><span class="params">(productsInWarehouse(warehouse))</span>{ <span class="title">product</span> =&gt;</span>
    where(product.name like name).select(product)
  }
}
</pre></td></tr></table></figure>

<h2 id="saving-records">Saving records</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>def insert(product: <span class="keyword">Product</span>): <span class="keyword">Product</span> = inTransaction <span class="list">{
  productsTable.insert(product)
}</span>

def update(product: <span class="keyword">Product</span>) <span class="list">{
  inTransaction { productsTable.update(product) }</span>
}
</pre></td></tr></table></figure>

<p>如果不这样, 那么插入时会产生 原先的 id 会变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(product: Product)</span>:</span> Product = inTransaction {
  val defensiveCopy = product.copy
  productsTable.insert(defensiveCopy)
}

val myImmutableObject = Product(<span class="number">0</span>, <span class="number">5010255079763l</span>,
  <span class="string">"plastic coated blue"</span>,
  <span class="string">"standard paperclip, coated with blue plastic"</span>)
Database.productsTable.insert(myImmutableObject)
// id 会变成 xxx
println(myImmutableObject)
</pre></td></tr></table></figure>

<h2 id="handling-transactions">Handling transactions</h2>
<p>In order to ensure your database’s data integrity, you’ll want to use transactions.
Databases that provide transactions guarantee that all write operations
in the same transaction will either succeed together or fail together.</p>
<p>Squeryl provides two methods for working with transactions: <code>transaction</code> and
<code>inTransaction</code>.</p>
<p>The difference is that transaction always makes its own transaction and
inTransaction only makes a transaction (and eventually commits) if it’s not already
in a transaction.</p>
<p>This means that because our DAO methods wrap everything in an
inTransaction, they themselves can be wrapped in a transaction and succeed or fail
together and never separately.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>import models.{ Database, Product, StockItem }
import org<span class="preprocessor">.squeryl</span><span class="preprocessor">.PrimitiveTypeMode</span><span class="preprocessor">.transaction</span>
import Database.{productsTable, stockItemsTable}

def addNewProductGood(product: Product, stockItem: StockItem) {
  transaction {
    productsTable<span class="preprocessor">.insert</span>(product)
    stockItemsTable<span class="preprocessor">.insert</span>(stockItem)
  }
}

// 不推荐
def addNewProductBad(product: Product, stockItem: StockItem) {
  productsTable<span class="preprocessor">.insert</span>(product)
  stockItemsTable<span class="preprocessor">.insert</span>(stockItem)
}
</pre></td></tr></table></figure>

<h2 id="entity-relations">Entity relations</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._
<span class="keyword">import</span> org.squeryl.dsl.{OneToMany, ManyToOne}
<span class="keyword">import</span> org.squeryl.{Query, Schema, KeyedEntity, Table}

<span class="class"><span class="keyword">object</span> <span class="title">Database</span> <span class="keyword">extends</span> <span class="title">Schema</span> {</span>
  <span class="keyword">val</span> productsTable = table[Product](<span class="string">"products"</span>)
  <span class="keyword">val</span> warehousesTable = table[Warehouse](<span class="string">"warehouses"</span>)
  <span class="keyword">val</span> stockItemsTable = table[StockItem](<span class="string">"stockItems"</span>)

  <span class="keyword">val</span> productToStockItems =
    oneToManyRelation(productsTable, stockItemsTable).
      via((p,s) =&gt; p.id === s.productId)

  <span class="keyword">val</span> warehouseToStockItems =
    oneToManyRelation(warehousesTable, stockItemsTable).
      via((w,s) =&gt; w.id === s.warehouseId)
}


<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(
  id: Long,
  ean: Long,
  name: String,
  description: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> stockItems: OneToMany[StockItem] =
    Database.productToStockItems.left(<span class="keyword">this</span>)
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Warehouse</span><span class="params">(
  id: Long,
  name: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> stockItems: OneToMany[StockItem] =
    Database.warehouseToStockItems.left(<span class="keyword">this</span>)
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StockItem</span><span class="params">(
  id: Long,
  productId: Long,
  warehouseId: Long,
  quantity: Long)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> product: ManyToOne[Product] =
    Database.productToStockItems.right(<span class="keyword">this</span>)
  <span class="keyword">lazy</span> <span class="keyword">val</span> warehouse: ManyToOne[Warehouse] =
    Database.warehouseToStockItems.right(<span class="keyword">this</span>)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>def getStockItems(product: Product) =
  inTransaction {
    product<span class="preprocessor">.stockItems</span><span class="preprocessor">.toList</span>
  }

def getLargeStockQ(product: Product, quantity: Long) =
  from(product<span class="preprocessor">.stockItems</span>) ( s =&gt;
    where(s<span class="preprocessor">.quantity</span> gt quantity)
      select(s)
  )
</pre></td></tr></table></figure>

<p>Obviously, you need to be able to add stock items to products and warehouses. You
could set the foreign keys in each stock item by hand, which is simple enough, but
Squeryl offers some help here.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// 建立外键联系
product<span class="preprocessor">.stockItems</span><span class="preprocessor">.assign</span>(stockItem)
warehouse<span class="preprocessor">.stockItems</span><span class="preprocessor">.assign</span>(stockItem)
transaction { Database<span class="preprocessor">.stockItemsTable</span><span class="preprocessor">.insert</span>(stockItem) }

// The difference between assign <span class="keyword">and</span> associate is
// that associate also saves the stock item
transaction {
  product<span class="preprocessor">.stockItems</span><span class="preprocessor">.associate</span>(stockItem)
  warehouse<span class="preprocessor">.stockItems</span><span class="preprocessor">.associate</span>(stockItem)
}
</pre></td></tr></table></figure>

<h3 id="stateful-relations">STATEFUL RELATIONS</h3>
<p>Instead of providing queries, Squeryl’s stateful relations
provide collections of related entities that you can access directly.</p>
<p>You only need to change the call to
left to leftStateful and similarly right to rightStateful:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">lazy</span> <span class="keyword">val</span> stockItems =
  Database.productToStockItems.leftStateful(<span class="keyword">this</span>)
</pre></td></tr></table></figure>

<p>You’ll have problems instantiating entities out-
side of a transaction.</p>
<p><code>StatefulOneToMany</code> has an associate method that does the same thing as its non-
stateful counterpart, but it doesn’t have an assign method.</p>
<p>Apart from that, there’s a refresh method that refreshes the list from the database. </p>
<h1 id="caching-data">Caching data</h1>
<p>Any database worth its salt will cache results for queries it encounters often. But
you’re still dealing with the overhead of talking to the database, and there are usually
more queries hitting the database, which may push these results out of the cache or
invalidate them eagerly. </p>
<p>An application cache can be more useful than a database cache, because it knows
what it’s doing with the data and can make informed decisions about when to invali-
date what.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>def insert(product: Product) {
  val insertedProduct = Product.insert(product)
  Cache.set("product-" + product.id, product)
}

def show(productId: Long) {
  Cache.getAs[<span class="link_label">Product</span>](<span class="link_url">"product-" + productId</span>) match {
<span class="code">    case Some(product) =&gt; Ok(product)</span>
<span class="code">    case None =&gt; Ok(Product.findById(productId))</span>
  }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day65-Hadoop入门]]></title>
    <link href="http://zhpooer.github.io/2014/08/10/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day65-hadoop%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/08/10/传智播客day65-hadoop入门/</id>
    <published>2014-08-10T01:04:39.000Z</published>
    <updated>2014-08-10T09:18:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">云计算</h1>
<!-- QQ群 316336020 -->
<!-- about.com -->

<p>熟悉java集合类(Vector, ArrayList, LinkedList), io, 并发编程(锁 Lock, synchronized)和熟悉jvm原理及内存管理,
对数据结构, 算法有深刻的理解</p>
<h1 id="-">项目简介</h1>
<p>作者 Doug Cuttng, 是 Lucene, Nutch, Hadoop 等项目发起人</p>
<p>解决问题</p>
<ul>
<li>海量数据的存储(HDFS)</li>
<li>海量数据的分析(MapReduce), 分布式计算模型</li>
<li>资源调度(YARN)</li>
</ul>
<p>受Google三篇论文的启发(GFS, MapReduce, BigTable)</p>
<p>hadoop 擅长日志分析, facebook利用Hive来进行日志分析, HiveSQL进行数据分析;
Pig可以做高级的数据处理, 推荐系统.</p>
<p>用廉价的服务器搭建搭建集群服务器</p>
<p>Storm + Hadoop 具有强大的优势</p>
<p>Hadoop缺点, 只能进行离线数据</p>
<p>Storm能进行实时数据处理</p>
<p>核心</p>
<ul>
<li>HDFS(Hadoop Distributed File System), 分布式文件系统,
通过水平扩展机器的数量来增加存放文件的能力, 将数据进行冗余存储(多分存储)</li>
<li>YARN(Yet Another Resource Negotiator), 资源调度管理系统,
可以运行其他的编程模型, 使实时处理出现了可能</li>
</ul>
<p>特点</p>
<ul>
<li>扩容能力强(scalable)</li>
<li>成本低(Economical): 通过普通机器组成的服务器来分发以及处理数据</li>
<li>高效(Efficient), 分发数据, 并行计算</li>
<li>可靠(Reliable), 失败任务的转移</li>
</ul>
<h2 id="-">生态圈</h2>
<p>TODO</p>
<p>nutch 抓取数据, HDFS存储数据, Lucence检索分析 , Zookeeper 进行管理</p>
<p>版本: Apache(2.4.1), Cloudera, HDP(Hortonworks Data Platform)</p>
<h1 id="hdfs-">HDFS的架构</h1>
<p>主从结构</p>
<ul>
<li>主节点, namenode</li>
<li>从节点, 很多个: datanode</li>
</ul>
<p>namenode 负责管理</p>
<ul>
<li>接受用户操作请求</li>
<li>维护文件系统的目录结构</li>
<li>管理文件与block之间关系,</li>
</ul>
<p>datanode 负责存储文件</p>
<ul>
<li>存储文件</li>
<li>文件被分成block存储在磁盘上</li>
<li>保证安全</li>
</ul>
<p>如何自己设计一个分布式文件系统?</p>
<blockquote>
<p>客户端(Client) 查询 NameNode(记录文件存储信息), 将数据放入datanode(多个)或从中取出<br>数据在上传过程中要进行冗余保存, datanode 自行进行水平复制.<br>上传过程中, 文件会被分成8块, 每块128M, 其实是对块的冗余存储</p>
</blockquote>
<p>如何解决海量数据的计算?</p>
<blockquote>
<p>求和 1+2+3+4+5+6=?<br>map: 1+2, 3+4, 5+6<br>reduce: 3 + 7 + 11</p>
</blockquote>
<h1 id="hadoop-">hadoop版本对比</h1>
<p><code>hadoop 1.0</code>: MapReduce + HDFS</p>
<p><code>hadoop 2.0</code>: MapReduce + YARN(资源管理) + Others + HDFS</p>
<h1 id="-hadoop">部署 Hadoop</h1>
<p>三种模式</p>
<ul>
<li>本地模式</li>
<li>伪分布式</li>
<li>集群模式</li>
</ul>
<h2 id="-">伪分布模式</h2>
<p>在centos环境下</p>
<p>fileziler, windows下ftp工具</p>
<p>secureCRT, windows下ssh工具</p>
<ul>
<li><p>修改主机名 <code>/etc/sysconfig/network</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">HOSTNAME</span>=<span class="string">itcast</span>
</pre></td></tr></table></figure>
</li>
<li><p>修改 IP, <code>/etc/sysconfig/network-script/ifcfg-eth0</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="setting">DEVICE=<span class="value"><span class="string">"eth0"</span></span></span>
<span class="setting">BOOTABLETO=<span class="value"><span class="string">"static"</span></span></span>
<span class="setting">HWADDR=<span class="value"><span class="string">""</span></span></span>
<span class="setting">IPV6INIT=<span class="value"><span class="string">"yes"</span></span></span>
<span class="setting">NM_controlled=<span class="value"><span class="string">"yes"</span></span></span>
<span class="setting">ONBOOT=<span class="value"><span class="string">"yes"</span></span></span>
<span class="setting">TYPE=<span class="value"><span class="string">"Ethernet"</span></span></span>
<span class="setting">UUID=<span class="value"><span class="string">""</span></span></span>
<span class="setting">IPADDR=<span class="value"><span class="string">"192.168.1.101"</span></span></span>
<span class="setting">NETMASK=<span class="value"><span class="string">"255.255.255.0"</span></span></span>
<span class="setting">GATEWAY=<span class="value"><span class="string">"192.168.1.1"</span></span></span>
<span class="setting">NDS1=<span class="value"><span class="string">"8.8.8.8"</span></span></span>
<span class="setting">NDS2=<span class="value"><span class="string">"4.4.4.4"</span></span></span>
</pre></td></tr></table></figure>
</li>
<li><p>主机名和ip的映射关系, <code>/etc/hosts</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>192.168.1.101 itcast
</pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>service iptables <span class="keyword">stop</span>
chkconfig iptables --list
chkconfig iptables <span class="keyword">off</span>
</pre></td></tr></table></figure>
</li>
<li><p>安装JDK 64位或32位</p>
</li>
<li><p>修改Hadoop配置文件</p>
<ol>
<li><p><code>hadoop-env.sh</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>export Java_Home=<span class="keyword">...</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>core-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- namenode 地址 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://itcast:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- 运行时产生文件,非临时, 重要! --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/tmp/hadoop<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>hdfs-site</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- hdfs副本的数量 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>1<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>mapred-site.xml.template</code> copy to <code>mapred-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- mapreduce运行在yarn上 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>yarn-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 指定yarn的 ResourceManager 所在地址 --&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- reduce 获取数据的方式 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>初始化 Hadoop, 初始化 HDFS, <em>只需要执行一次</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">## hadoop namenode -format, 已被舍弃</span>
hdfs namenode -<span class="built_in">format</span>
</pre></td></tr></table></figure>
</li>
<li><p>启动 Hadoop</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="preprocessor"># start-all.sh, 已过时</span>
start-dfs<span class="preprocessor">.sh</span>
start-yarn<span class="preprocessor">.sh</span>

<span class="preprocessor"># stop-all.sh 停止进程</span>
stop-dfs<span class="preprocessor">.sh</span>
stop-yarn<span class="preprocessor">.sh</span>
</pre></td></tr></table></figure>
</li>
<li><p>执行<code>jps</code>, 查看运行进程</p>
<pre><code>  NodeManager
  NameNode
  DataNode
  ResourceManager
  SecondaryNameNode
</code></pre></li>
<li>查看管理界面<ul>
<li>hdfs <code>http://192.168.1.101:50070</code></li>
<li>yarn <code>http://192.168.1.101:8088</code></li>
</ul>
</li>
</ul>
<p>Hadoop目录结构</p>
<ul>
<li><code>sbin</code>, 启动或停止hadoop相关进程的命令</li>
<li><code>bin</code>, 操作hadoop相关模块的一些命令</li>
<li><code>lib</code>, 动态库</li>
<li><code>share</code>, 相关jar包</li>
<li><code>etc</code>, 配置文件</li>
</ul>
<h2 id="-">测试</h2>
<p>hdfs操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="preprocessor">## 上传文件命名为 jdk</span>
hadoop fs -put /root/jdk_***.tar hdfs:<span class="comment">//itcast:9000/jdk</span>

<span class="preprocessor">## 查看文件, 也可以通过 htfs管理页面查看目录</span>
hadoop fs -ls hdfs:<span class="comment">//itcast:9000/</span>

<span class="preprocessor">## 下载文件</span>
hadoop fs -<span class="keyword">get</span> hdfs:<span class="comment">//itcast:9000/jdk /root/jdk_***.tar</span>
</pre></td></tr></table></figure>

<p>运行 mapreduce, 词频统计 <code>share/mapreduce/hadoop-example</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="preprocessor">## 将文件放入hdfs</span>
hadoop fs -put word-in.txt hdfs:<span class="comment">//itcast:9000/words</span>

<span class="preprocessor">## 查看 hdfs</span>
hadoop fs -cat hdfs:<span class="comment">//itcast:9000/words</span>

<span class="preprocessor">## 运行 wordcount 程序, 将 words 文件进行词频统计, 输出到 hdfs://itcast:9000/words-out 文件夹</span>
hadoop jar hadoop-mapreduce-example.jar wordcount hdfs:<span class="comment">//itcast:9000/words  hdfs://itcast:9000/words-out</span>

<span class="preprocessor">## 查看 正在运行的命令</span>
jps

<span class="preprocessor">## 查看运行后的结构</span>
hadoop fs -cat hdfs:<span class="comment">//itcast:9000/words-out/part-r-00000</span>
</pre></td></tr></table></figure>

<h1 id="ssh-">SSH 协议</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="preprocessor"># 登陆</span>
ssh <span class="number">192.168</span><span class="number">.1</span><span class="number">.208</span>

<span class="preprocessor"># 执行命令</span>
ssh <span class="number">192.168</span><span class="number">.1</span><span class="number">.208</span> mkdir /itcast1008

<span class="preprocessor"># 免密码登陆</span>
<span class="preprocessor"># 生成私钥和公钥</span>
ss-keygen -t rsa

<span class="preprocessor"># 拷贝公钥到远程服务器</span>
ssh-copy-id <span class="number">192.168</span><span class="number">.1</span><span class="number">.208</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="Hadoop" scheme="http://zhpooer.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Define Http interface]]></title>
    <link href="http://zhpooer.github.io/2014/08/09/play-for-scala-define-http-interface/"/>
    <id>http://zhpooer.github.io/2014/08/09/play-for-scala-define-http-interface/</id>
    <published>2014-08-09T08:20:51.000Z</published>
    <updated>2014-08-10T14:14:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="benefits-of-good-url-design">Benefits of good URL design</h1>
<p>If you don’t think changing the URL matters, then this is probably a good time to read
Cool URIs Don’t Change, which Tim Berners-Lee wrote in
1998 (<a href="http://www.w3.org/Provider/Style/URI.html" target="_blank">http://www.w3.org/Provider/Style/URI.html</a>),
adding to his 1992 WWW style guide, which is an important
part of the documentation for the web itself.</p>
<p>ervlet API URL
mapping is too limited to handle even our first three example URLs, because it only
lets you match URLs exactly, by prefix or by file extension. What’s missing is a notion
of path parameters that match variable segments of the URL, using URL templates:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>/product/{ean}/<span class="keyword">edit</span>
/product/(\d+)/<span class="keyword">edit</span>
</pre></td></tr></table></figure>

<p>Here are several benefits of good URL design:</p>
<ul>
<li>A consistent public API —The URL scheme makes your application easier to
understand by providing an alternative machine-readable interface.</li>
<li>The URLs don’t change—Avoiding implementation-specifics makes the URLs sta-
ble, so they don’t change when the technology does.</li>
<li>Short URLs—Short URLs are more usable; they’re easier to type or paste into
other media, such as email or instant messages.</li>
</ul>
<h1 id="controllers-the-interface-between-http-and-scala">Controllers—the interface between HTTP and Scala</h1>
<p>Controllers are the application components that handle HTTP requests for application
resources identified by URLs.</p>
<p>In Play, you use controller classes to make your application respond to HTTP
requests for URLs, such as the product catalog URLs:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>/products
/product/<span class="number">5010255079763</span>
/product/<span class="number">5010255079763</span>/<span class="keyword">edit</span>
</pre></td></tr></table></figure>

<h2 id="controller-classes-and-action-methods">Controller classes and action methods</h2>
<p>We’ll start by defining a Products controller class, which will contain four action
methods for handling different kinds of requests: list, details , edit, and update</p>
<p>A controller is a Scala object that’s a subclass of <code>play.api.mvc.Controller</code> ,
which provides various helpers for generating actions. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="class"><span class="keyword">object</span> <span class="title">Products</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> list(pageNumber: Int) = Action {
    NotImplemented
  }
  <span class="keyword">def</span> detail(ean: Long) = Action {
    NotImplemented
  }
  <span class="keyword">def</span> edit(ean: Long) = Action {
    NotImplemented
  }
  <span class="keyword">def</span> update(ean: Long) = Action {
    NotImplemented
  }
}
</pre></td></tr></table></figure>

<p><strong>GROUP CONTROLLERS BY MODEL ENTITY</strong></p>
<p>Create one controller for each of the
key entities in your application’s high-level data model. For example, the four
key entities—Product, Order, Warehouse, and User—might correspond to a
data model with more than a dozen entities. In this case, it’d probably be a
good idea to have four controller classes: Products, Orders, Warehouses, and
Users. </p>
<p>In Play, each controller is a Scala object that defines one or more actions. Play uses an
object instead of a class because the controller doesn’t have any state; the controller is
used to group some actions.</p>
<p><strong>DON’T DEFINE A var IN A CONTROLLER OBJECT</strong></p>
<p>Each action is a Scala function that takes an HTTP request and returns an HTTP result.
<code>Request[A] =&gt; Result</code></p>
<p>The controller layer is therefore the mapping between stateless HTTP requests and
responses and the object-oriented model. In MVC terms, controllers process events
(HTTP requests in this case), which can result in updates to the model. Controllers are
also responsible for rendering views. </p>
<h2 id="http-and-the-controller-layer-s-scala-api">HTTP and the controller layer’s Scala API</h2>
<p>Play models controllers, actions, requests, and responses as Scala traits in the
<code>play.api.mvc</code> package—the Scala API for the controller layer.</p>
<p>MVC API traits and classes correspond to HTTP concepts and act as
wrappers for the corresponding HTTP data:</p>
<ul>
<li><code>play.api.mvc.Cookie</code> —An HTTP cookie: a small amount of data stored on the client and sent with subsequent requests</li>
<li><code>play.api.mvc.Request</code> —An HTTP request: HTTP method, URL, headers, body, and cookies</li>
<li><code>play.api.mvc.RequestHeader</code> —Request metadata: a name-value pair</li>
<li><code>play.api.mvc.Response</code> —An HTTP response, with headers and a body; wraps a Play Result</li>
<li><code>play.api.mvc.ResponseHeader</code>  —Response metadata: a name-value pair</li>
</ul>
<p>Play controllers use the following concepts in addition
to HTTP concepts:</p>
<ul>
<li><code>play.api.mvc.Action</code> — A function that processes a client Request
and returns a Result</li>
<li><code>play.api.mvc.Call</code> — An HTTP request: the combination of an HTTP method
and a URL</li>
<li><code>play.api.mvc.Content</code> — An HTTP response body with a particular content type</li>
<li><code>play.api.mvc.Controller</code> — A generator for Action functions</li>
<li><code>play.api.mvc.Flash</code> — A short-lived HTTP data scope used to set data for
the next request</li>
<li><code>play.api.mvc.Result</code> — The result of calling an Action to process a Request,
used to generate an HTTP response</li>
<li><code>play.api.mvc.Session</code> — A set of string keys and values,
stored in an HTTP cookie</li>
</ul>
<h2 id="action-composition">Action composition</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>def <span class="keyword">list</span> = Action {
  <span class="comment">// Check authentication.</span>
  <span class="comment">// Check for a cached result.</span>
  <span class="comment">// Process request...</span>
  <span class="comment">// Update cache.</span>
}

<span class="comment">// 可以这样写</span>
def <span class="keyword">list</span> =
  Authenticated {
    Cached {
      Action {
        <span class="comment">// Process request...</span>
      }
    }
  }
</pre></td></tr></table></figure>

<p>This example uses Action to create an action function that’s passed as a parameter to
Cached, which returns a new action function. This, in turn, is passed as a parameter to
Authenticated, which decorates the action function again.</p>
<h1 id="routing-http-requests-to-controller-actions">Routing HTTP requests to controller actions</h1>
<p>Once you have controllers that contain actions, you need a way to map different
request URLs to different action methods.</p>
<p>In Play, mapping the combination of an HTTP method and a URL to an action
method is called routing. </p>
<h2 id="router-configuration">Router configuration</h2>
<p>The great thing about this approach is that your web application’s URLs—its public
HTTP interface—are all specified in one place, which makes it easier for you to
maintain a consistent URL design.</p>
<p>The routes file structure is line-based: each line is either a blank line, a comment line,
or a route definition. A route definition has three parts on one line, separated by
whitespace.</p>
<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>GET / controllers<span class="preprocessor">.Products</span><span class="preprocessor">.home</span>()

GET /products  controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>()

GET /products controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>(page: Int ?= <span class="number">1</span>) <span class="preprocessor">## Option[Int]</span>

GET /products controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>(page: Int = <span class="number">1</span>) <span class="preprocessor">## Int</span>

GET /product/:ean controllers<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(ean: Long)

GET /product/:ean/edit controllers<span class="preprocessor">.Products</span><span class="preprocessor">.edit</span>(ean: Long)
</pre></td></tr></table></figure>

<p>The benefit of this format is that you can see your whole URL design in one place,
which makes it more straightforward to manage than if the URLs were specified in
many different files.</p>
<h2 id="matching-url-path-parameters-that-contain-forward-slashes">Matching URL path parameters that contain forward slashes</h2>
<pre><code>/photo/5010255079763.jpg
/photo/customer-submissions/5010255079763/42.jpg
/photo/customer-submissions/5010255079763/43.jpg
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="preprocessor">## 这样上面的配置不会匹配 斜杠(slash)</span>
<span class="keyword">GET</span> /photo/:file controllers.Media.photo(file: <span class="built_in">String</span>)

<span class="preprocessor">## 必须这样</span>
<span class="keyword">GET</span> /photo/*file controllers.Media.photo(file: <span class="built_in">String</span>)
</pre></td></tr></table></figure>

<h2 id="constraining-url-path-parameters-with-regular-expressions">Constraining URL path parameters with regular expressions</h2>
<p>为如下的url做匹配</p>
<pre><code>/product/5010255079763
/product/paper-clips-large-plain-1000-pack
</code></pre><p>正则表达式要写在<code>&lt;&gt;</code>里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>GET /product/$ean&lt;\d{<span class="number">13</span>}&gt; controllers<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(ean: Long)

GET /product/:alias controllers<span class="preprocessor">.Products</span><span class="preprocessor">.alias</span>(alias: String)
</pre></td></tr></table></figure>

<h2 id="binding-http-data-to-scala-objects">Binding HTTP data to Scala objects</h2>
<p>Play, along with other modern web frameworks such as Spring MVC, improves on
treating HTTP request parameters as strings by performing type conversion before it
attempts to call your action method. </p>
<p>Here’s what happens when Play’s router handles the request <code>PUT /product/5010255079763</code></p>
<ol>
<li>The router matches the request against configured routes and selects the route:
<code>PUT /product/:ean controllers.Products.update(ean: Long)</code></li>
<li>The router binds the ean parameter using one of the type-specific binders—in
this case, the Long binder converts 5010255079763 to a Scala Long object</li>
<li>The router invokes the selected route’s Products.update action, passing
<code>5010255079763L</code> as a parameter.</li>
</ol>
<p>If you send an HTTP request for <code>/product/x</code>,
the binding will fail because x isn’t a number, and Play
will return an HTTP response with the 400 (Bad Request)
status code and an error page</p>
<h1 id="generating-http-calls-for-actions-with-reverse-routing">Generating HTTP calls for actions with reverse routing</h1>
<p>In addition to mapping incoming URL requests to controller actions,
a Play application can do the opposite: map a particular action
method invocation to the corresponding URL.</p>
<h2 id="hardcoded-urls">Hardcoded URLs</h2>
<p>The interesting part is what happens next, after the product is deleted.
Let’s suppose that after deleting the product,
we want to show the updated product list. We could
render the product list page directly, but this exposes us to the double-submit
problem: if the user “reloads” the page in a web browser,
this could result in a second call
to the delete action, which will fail because the specified product no longer exists.</p>
<p>The standard solution to the double-submit problem is the redirect-after-POST pattern:
after performing an operation that updates the application’s persistent state, the
web application sends an HTTP response that consists of an HTTP redirect.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>def <span class="operator"><span class="keyword">delete</span>(ean: Long) = <span class="keyword">Action</span> {
  Product.<span class="keyword">delete</span>(ean)
  Redirect(<span class="string">"/proudcts"</span>)
}</span>
</pre></td></tr></table></figure>

<p>This looks like it will do the job, but it doesn’t smell too nice because
we’ve hardcoded the URL in a string.</p>
<p>解决办法如下</p>
<h2 id="reverse-routing">Reverse routing</h2>
<p>You can do reverse routing by writing Scala code.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>def <span class="operator"><span class="keyword">delete</span>(ean: Long) = <span class="keyword">Action</span> {
  Product.<span class="keyword">delete</span>(ean)
  Redirect(routes.Products.list())
}</span>
</pre></td></tr></table></figure>

<p>Keeping these two points in mind:</p>
<ul>
<li>Routing is when URLs are routed to actions—left to right in the routes file</li>
<li>Reverse routing is when call definitions are “reversed” into URL s—right to left</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>scala&gt; val call = controllers.routes.Products.list()
scala&gt; val (<span class="function"><span class="keyword">method</span>, <span class="title">url</span>) = <span class="params">(call.<span class="keyword">method</span>, call.url)</span></span>
</pre></td></tr></table></figure>

<h1 id="generating-a-response">Generating a response</h1>
<p>An HTTP response consists of an HTTP status code, optionally followed by response
headers and a response body. Play gives you total control over all three, which lets you
craft any kind of HTTP response you like, but it also gives you a convenient API for
handling common cases.</p>
<h2 id="debugging-http-responses">Debugging HTTP responses</h2>
<p>To use cURL, use the <code>--request</code> option to specify the HTTP method and
<code>--include</code> to include HTTP response headers in the output</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">curl</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">request</span> <span class="comment">GET</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">include</span> <span class="comment">http://localhost:9000/products</span>
</pre></td></tr></table></figure>

<h2 id="response-body">Response body</h2>
<p>The response body will consist of this representation, in some particular format.</p>
<ul>
<li>Plain text—Such as an error message, or a lightweight web service response</li>
<li>HTML —A web page, including a representation of the resource as well as
application user-interface elements, such as navigation controls</li>
<li>JSON —A popular alternative to XML that’s better suited to Ajax applications</li>
<li>XML —Data accessed via a web service</li>
<li>Binary data—Typically nontext media such as a bitmap image or audio</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="comment">// plain text</span>
<span class="keyword">def</span> version = Action {
  Ok(<span class="string">"Version 2.0"</span>)
}

<span class="comment">// html</span>
<span class="keyword">def</span> index = Action {
  Ok(views.html.index())
}

<span class="comment">// json</span>
<span class="keyword">def</span> json = Action {
  <span class="keyword">import</span> play.api.libs.json.Json
  <span class="keyword">val</span> success = Map(<span class="string">"status"</span> -&gt; <span class="string">"success"</span>)
  <span class="keyword">val</span> json = Json.toJson(success)
  Ok(json)
}

<span class="comment">// scala.xml.NodeSeq</span>
<span class="keyword">def</span> xml = Action {
  Ok(&lt;status&gt;success&lt;/status&gt;)
}
</pre></td></tr></table></figure>

<h3 id="binary-data">BINARY DATA</h3>
<p>In Play, returning a binary result to the
web browser is the same as serving other formats: as with XML and JSON, pass the
binary data to a result type. </p>
<p>条形码生成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>val appDependencies = Se<span class="string">q(
  "net.sf.barcode4j" % "barcode4j" % "2.0"
)</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>def ean13Barcode(ean: Long, mimeType: String): Array[Byte] = {
  import java<span class="preprocessor">.io</span><span class="preprocessor">.ByteArrayOutputStream</span>
  import java<span class="preprocessor">.awt</span><span class="preprocessor">.image</span><span class="preprocessor">.BufferedImage</span>
  import org<span class="preprocessor">.krysalis</span><span class="preprocessor">.barcode</span>4j<span class="preprocessor">.output</span><span class="preprocessor">.bitmap</span><span class="preprocessor">.BitmapCanvasProvider</span>
  import org<span class="preprocessor">.krysalis</span><span class="preprocessor">.barcode</span>4j<span class="preprocessor">.impl</span><span class="preprocessor">.upcean</span><span class="preprocessor">.EAN</span>13Bean
  
  val BarcodeResolution = <span class="number">72</span>
  val output: ByteArrayOutputStream = new ByteArrayOutputStream
  val canvas: BitmapCanvasProvider =
    new BitmapCanvasProvider(output, mimeType,
          BarcodeResolution, BufferedImage<span class="preprocessor">.TYPE</span>_BYTE_BINARY, false, <span class="number">0</span>)
  val barcode = new EAN13Bean()
  
  barcode<span class="preprocessor">.generateBarcode</span>(canvas, String valueOf ean)
  canvas<span class="preprocessor">.finish</span>
  output<span class="preprocessor">.toByteArray</span>
}

// GET /barcode/:ean controllers<span class="preprocessor">.Products</span><span class="preprocessor">.barcode</span>(ean: Long)
def barcode(ean: Long) = Action {
  import java<span class="preprocessor">.lang</span><span class="preprocessor">.IllegalArgumentException</span>
  val MimeType = <span class="string">"image/png"</span>
  try {
    val imageData: Array[Byte] = ean13Barcode(ean, MimeType)
    Ok(imageData)<span class="preprocessor">.as</span>(MimeType)
  } catch {
    case e: IllegalArgumentException =&gt;
      BadRequest(<span class="string">"Could not generate bar code. Error: "</span> + e<span class="preprocessor">.getMessage</span>)
  }
}
</pre></td></tr></table></figure>

<h2 id="http-status-codes">HTTP status codes</h2>
<p>The simplest possible response that you might want to generate consists of only an
HTTP status line that describes the result of processing the request. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def <span class="keyword">list</span> = Action { request =&gt;
  NotImplemented
}

<span class="comment">// 等同于</span>
def <span class="keyword">list</span> = Action {
  <span class="keyword">new</span> Status(<span class="number">501</span>)
}
</pre></td></tr></table></figure>

<p><em>NotImplemented</em> is one of many HTTP status codes that are defined in the
<code>play.api.mvc.Controller</code> class via the <code>play.api.mvc.Results</code> trait.</p>
<h2 id="response-headers">Response headers</h2>
<p>In addition to a status, a response may also include response headers:
metadata that instructs HTTP clients how to handle the response</p>
<pre><code>HTTP/1.1 501 Not Implemented
Content-Length: 0
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Status(FOUND)<span class="preprocessor">.withHeaders</span>(LOCATION -&gt; url)

val url = routes<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(product<span class="preprocessor">.ean</span>)<span class="preprocessor">.url</span>
Created<span class="preprocessor">.withHeaders</span>(LOCATION -&gt; url)
</pre></td></tr></table></figure>

<h3 id="setting-the-content-type">SETTING THE CONTENT TYPE</h3>
<p>Every HTTP response that has a response body also has a Content-Type header,
whose value is the MIME type that describes the response body format.</p>
<p>Play automatically sets
the content type for supported types, such as text/html when rendering an HTML
template, or text/plain when you output a string response.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">val</span> json = <span class="string">"""{ "status": "success" }"""</span>
Ok(json).withHeaders(CONTENT_TYPE -&gt; <span class="string">"application/json"</span>)

<span class="comment">// 也可以这样</span>
Ok(<span class="string">"""{ "status": "success" }"""</span>).as(<span class="string">"application/json"</span>)

<span class="comment">//  JSON is defined in the play.api.http.ContentTypes trait</span>
<span class="comment">//  which Controller extends.</span>
Ok(<span class="string">"""{ "status": "success" }"""</span>).as(JSON)
</pre></td></tr></table></figure>

<p>Play sets the content type automatically for some more types:
Play selects <code>text/xml</code> for
<code>scala.xml.NodeSeq</code> values, and <code>application/json</code>
for <code>play.api.libs.json.JsValue</code> values.</p>
<h3 id="session-data">SESSION DATA</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Ok(results)<span class="preprocessor">.withSession</span>(
  request<span class="preprocessor">.session</span> + (<span class="string">"search.previous"</span> -&gt; query)
)

Ok(results)<span class="preprocessor">.withSession</span>(
  request<span class="preprocessor">.session</span> - <span class="string">"search.previous"</span>
)
</pre></td></tr></table></figure>

<p>The session is implemented as an HTTP session cookie, which means that
its total size is limited to a few kilobytes.</p>
<p><strong>DON’T CACHE DATA IN THE SESSION COOKIE</strong> Don’t try to use session data as a
cache to improve performance by avoiding fetching data from server-side
persistent storage. Apart from the fact that session data is limited to the 4 KB of data
that fits in a cookie, this will increase the size of subsequent HTTP requests,
which will include the cookie data, and may make performance worse overall.</p>
<p>The canonical use case for session cookies is to identify the currently authenticated
user.  You can load user-specific data from a persistent data model instead.</p>
<p>The session Play cookie is signed using the application secret key as a salt to pre-
vent tampering.</p>
<h3 id="flash-data">FLASH DATA</h3>
<p>Displaying a message when handling the next request, after a redirect, is such a
common use case that Play provides a special session scope called flash scope.</p>
<p>Flash scope works the same way as the session, except that any data
that you store is only available when processing the next HTTP request,
after which it’s automatically deleted. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>// 设置
Redirect(routes<span class="preprocessor">.Products</span><span class="preprocessor">.flash</span>())<span class="preprocessor">.flashing</span>(
  <span class="string">"info"</span> -&gt; <span class="string">"Product deleted!"</span>
)

// 获取
val message = request<span class="preprocessor">.flash</span>(<span class="string">"info"</span>)
</pre></td></tr></table></figure>

<h3 id="setting-cookies">SETTING COOKIES</h3>
<p>Cookies store small amounts of data in an HTTP client, such as a web browser on a
specific computer.</p>
<p>If you do need to use cookies, you can use the Play API to
create cookies and add them to the response, and to read them from the request.</p>
<p><strong>AVOID USING COOKIES</strong></p>
<h2 id="serving-static-content">Serving static content</h2>
<p>Not everything in a web application is dynamic content: a typical web application also
includes static files, such as images, JavaScript files, and CSS stylesheets. Play serves
these static files over HTTP the same way it serves dynamic responses: by routing an
HTTP request to a controller action.</p>
<h3 id="using-the-default-configuration">USING THE DEFAULT CONFIGURATION</h3>
<p>Put files and folders inside your application’s <code>public/</code> folder and access
them using the URL path <code>/assets</code>, followed by the path relative to public.</p>
<p><code>public/images/favicon.png</code> 访问 <code>http://localhost:9000/assets/images/favicon.png</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;link href=<span class="string">"/assets/images/favicon.png"</span> rel=<span class="string">"shortcut icon"</span> <span class="keyword">type</span>=<span class="string">"image/png"</span>/&gt;
</pre></td></tr></table></figure>

<p><code>conf/routes</code> 的默认配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>GET /assets/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public"</span>, <span class="type">file</span>)
GET /images/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public/images"</span>, <span class="type">file</span>)
GET /styles/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public/styles"</span>, <span class="type">file</span>)
</pre></td></tr></table></figure>

<h3 id="using-an-asset-s-reverse-route">USING AN ASSET’S REVERSE ROUTE</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>&lt;link href=<span class="string">"@routes.Assets.at("</span>images/favicon.png<span class="string">")"</span>
      rel=<span class="string">"shortcut icon"</span> <span class="class"><span class="keyword">type</span>=</span><span class="string">"image/png"</span>&gt;

&lt;link href=<span class="string">"@routes.Assets.at("</span>/<span class="keyword">public</span>/images<span class="string">", "</span>favicon.png<span class="string">")"</span>
      rel=<span class="string">"shortcut icon"</span> <span class="class"><span class="keyword">type</span>=</span><span class="string">"image/png"</span>&gt;
</pre></td></tr></table></figure>

<h3 id="caching-and-etags">CACHING AND ETAGS</h3>
<p>In addition to reverse routing, another benefit of using the assets controller
is its builtin caching support, using an HTTP Entity Tag (ET ag).
This allows a web client to make conditional HTTP requests for a resource
so that the server can tell the client it can
use a cached copy instead of returning a resource that hasn’t changed.</p>
<p>Once it has an ET ag value, an HTTP client can make a conditional request, which
means “only give me this resource if it hasn’t been modified since I got the version
with this ET ag.”</p>
<pre><code>If-None-Match: 978b71a4b1fef4051091b31e22b75321c7ff0541
</code></pre><p>When this header is included in the request, and the favicon.png file hasn’t been
modified (it has the same ETag value), then Play’s assets controller will return the fol-
lowing response, which means “you can use your cached copy”:</p>
<pre><code>HTTP/1.1 304 Not Modified
Content-Length: 0
</code></pre><h3 id="compressing-assets-with-gzip">COMPRESSING ASSETS WITH GZIP</h3>
<p>HTTP compression is a feature of modern web servers and web clients that helps
address page sizes by sending compressed versions of resources over HTTP .</p>
<p>The way this works is that the web browser indicates that it can handle a com-
pressed response by sending an HTTP request header such as <code>Accept-Encoding:gzip</code>
that specifies supported compression methods. </p>
<p>In Play, HTTP compression is transparently built into the assets controller, which can
automatically serve a compressed version of a static file, if it’s available, and if gzip is
supported by the HTTP client. This happens when all of the following are true:</p>
<ul>
<li>Play is running in prod mode (production mode is explained in chapter 9); HTTP
compression isn’t expected to be used during development.</li>
<li>Play receives a request that’s routed to the assets controller.</li>
<li>The HTTP request includes an Accept-Encoding: gzip header.</li>
<li>The request maps to a static file, and a file with the same name but with an
additional <code>.gz</code> suffix is found.</li>
</ul>
<p>所以必须要先运行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>gzip --best &lt; ui<span class="preprocessor">.js</span> &gt; ui<span class="preprocessor">.js</span><span class="preprocessor">.gz</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day64-NoSql]]></title>
    <link href="http://zhpooer.github.io/2014/08/09/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day64-nosql/"/>
    <id>http://zhpooer.github.io/2014/08/09/传智播客day64-nosql/</id>
    <published>2014-08-09T01:01:04.000Z</published>
    <updated>2014-08-10T01:04:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nosql-">NoSql 简介</h1>
<p>Not Only SQL, 一系列非关系型数据库的总称</p>
<p>关系型数据库中的表存储一些格式化数据结构,
每条记录的字段的组成都一样, 即使不是每条记录都需要所有字段</p>
<p>非关系型数据库以键值对存储, 结构不固定, 每一条记录可以有不一样的键,
每条记录可以根据需要增加一些自己的键值对.</p>
<p>常见的Nosql</p>
<ul>
<li>CouchDB</li>
<li>Redis</li>
<li>Neo4j</li>
<li>HBase</li>
<li>BigTable</li>
<li>Tair</li>
</ul>
<p>优势</p>
<ul>
<li>简单扩展</li>
<li>快速读写</li>
<li>低廉成本</li>
<li>灵活的数据模型 json</li>
</ul>
<p>不足</p>
<ul>
<li>不提供对SQL的支持</li>
<li>特性不够丰富</li>
<li>现有产品不够成熟</li>
<li>事务支持不够好</li>
</ul>
<h1 id="mongodb-">MongoDB 数据库</h1>
<p>C++语言编写, 高性能 易部署 易使用</p>
<ul>
<li>面向集合存储, json</li>
<li>模式自由</li>
<li>支持动态查询</li>
<li>支持完全索引</li>
<li>支持复制和故障恢复</li>
<li>使用高效的二进制数据存储, 包括大型对象</li>
<li>文件存储格式为 BSON</li>
</ul>
<p>关系型数据库和 mongodb 对应情况</p>
<table>
<thead>
<tr>
<th>关系数据库</th>
<th>mongodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库</td>
<td>数据库</td>
</tr>
<tr>
<td>表</td>
<td>集合</td>
</tr>
<tr>
<td>行</td>
<td>文档</td>
</tr>
</tbody>
</table>
<p>文档(document) 是 Mongodb 的最基本对象, 都有一个 objectId, <code>{&quot;id&quot;: ObjectId()}</code></p>
<p>集合(collection)是文档的聚合</p>
<p>0 和 1 也可以表示 true 或 false</p>
<p>数字类型64位浮点数, 整数都会被转换成64位浮点数</p>
<h2 id="-">安装</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="attribute">mongod --dbpath</span>=<span class="string">/var/any
mongo</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor">## 创建或者切换</span>
use mydb1;
<span class="preprocessor">## 查看当前数据库</span>
db;
<span class="preprocessor">## 删除数据库</span>
db.dropDatabase();

<span class="preprocessor">## 查看所有数据库信息</span>
show dbs;
</pre></td></tr></table></figure>

<h2 id="-">建表</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="code"><pre><span class="preprocessor">## 查看集合</span>
show collections<span class="comment">;</span>
show tables<span class="comment">;</span>


<span class="preprocessor">## 创建集合</span>
db<span class="preprocessor">.createCollections</span>(<span class="string">"erdan"</span>)<span class="comment">;</span>
<span class="preprocessor">## 也可以这样创建集合, 隐式创建</span>
db<span class="preprocessor">.collectionName</span><span class="preprocessor">.insert</span>({})<span class="comment">;</span>

<span class="preprocessor">## 删除集合</span>
db<span class="preprocessor">.collectionName</span><span class="preprocessor">.drop</span>()<span class="comment">;</span>

<span class="preprocessor">## 插入文档</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.insert</span>({name:<span class="string">"xxx"</span>, age:<span class="number">18</span>, city:<span class="string">"shanghai"</span>})<span class="comment">;</span>

<span class="preprocessor">## 删除文档</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.remove</span>({name:<span class="string">"xxx"</span>, age:<span class="number">18</span>, city:<span class="string">"shanghai"</span>})<span class="comment">;</span>

<span class="preprocessor">## 查询</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="comment">;</span>

for(var i=<span class="number">1</span><span class="comment">;i&lt;=10000;1++) {</span>
   db<span class="preprocessor">.drhuo</span><span class="preprocessor">.insert</span>({name: <span class="string">"erhuo"</span>+i, age: i, city: <span class="string">"tokyo"</span>})<span class="comment">;</span>
}

<span class="preprocessor">## 显示name字段</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.findOne</span>({}, name:true)<span class="comment">;</span>
<span class="preprocessor">## 除了不显示name, 其他都显示</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.findOne</span>({}, {name: <span class="number">0</span>})<span class="comment">;</span>

<span class="preprocessor">## 删除名字为 erhuo1</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.remove</span>({name: <span class="string">"erhuo1"</span>})<span class="comment">;</span>

var m = db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="comment">;</span>
m<span class="preprocessor">.next</span>()<span class="comment">;</span>

<span class="preprocessor">## 条件查找</span>
<span class="preprocessor">## 大于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$gt:value}})<span class="comment">;</span>
<span class="preprocessor">## 小于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$lt:value}})<span class="comment">;</span>
<span class="preprocessor">## 大于等于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$gte:value}})<span class="comment">;</span>
<span class="preprocessor">## 小于等于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$lte:value}})<span class="comment">;</span>
<span class="preprocessor">## 不等于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$ne:value}})<span class="comment">;</span>

<span class="preprocessor">## 统计</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.count</span>()<span class="comment">;</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.count</span>()<span class="comment">;</span>
<span class="preprocessor">## 按age升序排序, -1 为降序</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.sort</span>({age:<span class="number">1</span>})<span class="comment">;</span>

<span class="preprocessor">## 分页</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.skip</span>(<span class="number">3</span>)<span class="preprocessor">.limit</span>(<span class="number">4</span>)<span class="comment">;</span>

<span class="preprocessor">## 不管分页, 列出所有数据的大小</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.skip</span>(<span class="number">3</span>)<span class="preprocessor">.limit</span>(<span class="number">4</span>)<span class="preprocessor">.count</span>(<span class="number">0</span>)<span class="comment">;</span>
<span class="preprocessor">## 列出分页数据</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.skip</span>(<span class="number">3</span>)<span class="preprocessor">.limit</span>(<span class="number">4</span>)<span class="preprocessor">.count</span>(<span class="number">1</span>)<span class="comment">;</span>

db<span class="preprocessor">.c</span>2<span class="preprocessor">.insert</span>({name:<span class="string">"user1"</span>, post:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]})<span class="comment">;</span>
<span class="preprocessor">## 查询包含关系</span>
<span class="preprocessor">## 全部满足</span>
db<span class="preprocessor">.c</span>2<span class="preprocessor">.find</span>({post:{$all:[<span class="number">1</span>, <span class="number">2</span>]}})
<span class="preprocessor">## 只要有一个满足</span>
db<span class="preprocessor">.c</span>2<span class="preprocessor">.find</span>({post:{$<span class="keyword">in</span>:[<span class="number">1</span>, <span class="number">2</span>]}})
<span class="preprocessor">## notin</span>
db<span class="preprocessor">.c</span>2<span class="preprocessor">.find</span>({post:{$nin:[<span class="number">1</span>, <span class="number">2</span>]}})

<span class="preprocessor">## 常用操作</span>
db<span class="preprocessor">.customer</span><span class="preprocessor">.find</span>({$<span class="keyword">or</span>:[{name: <span class="string">"a"</span>}, {age: <span class="number">11</span>}]})

<span class="preprocessor">## 1 表示存在, 0 表示不存在, 存在name字段的文档</span>
db<span class="preprocessor">.customer</span><span class="preprocessor">.find</span>({name: {$exist: <span class="number">1</span>}})<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="-">更新</h2>
<p><code>db.collection.update(criteria, objNew, upsert, multi)</code></p>
<ul>
<li><code>criteria</code>, 查询条件的对象</li>
<li><code>objNew</code>, 根系内容的对象</li>
<li><code>upsert</code>, 如果记录已经更新, 更新它, 否则新增一个记录</li>
<li><code>multi</code>, 如果符合多个记录是否全部更新</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>## 覆盖更新
<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">address</span>:<span class="value"><span class="string">"abc"</span></span></span></span>}, <span class="rules">{<span class="rule"><span class="attribute">address</span>:<span class="value"> <span class="string">"bj"</span></span></span></span>});

<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">name</span>:<span class="value"><span class="string">"user1"</span></span></span></span>}, <span class="rules">{<span class="rule">$<span class="attribute">set</span>:<span class="value">{address: <span class="string">"bj"</span></span></span></span>}}, 0, 1)

## <span class="tag">age</span> + 1
<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">name</span>:<span class="value"><span class="string">"user1"</span></span></span></span>}, <span class="rules">{<span class="rule">$<span class="attribute">inc</span>:<span class="value">{age: <span class="number">1</span></span></span></span>}}, 0, 1)

## 删除键
<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">name</span>:<span class="value"><span class="string">"user1"</span></span></span></span>}, <span class="rules">{<span class="rule">$<span class="attribute">unset</span>:<span class="value">{address: <span class="number">1</span></span></span></span>}}, 0, 1)
</pre></td></tr></table></figure>

<h1 id="-">索引</h1>
<p>用来加速查询速度的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="preprocessor">## 查询性能</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>({name: <span class="string">"erhuo12"</span>})<span class="preprocessor">.explain</span>()<span class="comment">;</span>

<span class="preprocessor">## 给 name 创建普通索引</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.ensureIndex</span>({name:<span class="number">1</span>})<span class="comment">;</span>

<span class="preprocessor">## 查看系统表相关参数</span>
db<span class="preprocessor">.user</span><span class="preprocessor">.state</span>()<span class="comment">;</span>

db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>({name: <span class="string">"erhuo12"</span>})<span class="preprocessor">.explain</span>()<span class="comment">;</span>

<span class="preprocessor">## 查看生成的索引</span>
db<span class="preprocessor">.system</span><span class="preprocessor">.indexes</span><span class="preprocessor">.find</span>()<span class="comment">;</span>

<span class="preprocessor">## 删除索引</span>
<span class="preprocessor">## 如果删除集合, 那么也会删除索引</span>
db<span class="preprocessor">.user</span><span class="preprocessor">.dropIndex</span>({name:<span class="number">1</span>})<span class="comment">;</span>

<span class="preprocessor">## 创建唯一索引, 相当于唯一约束</span>
db<span class="preprocessor">.user</span><span class="preprocessor">.ensureIndex</span>({name:<span class="number">1</span>}, {unique:<span class="number">1</span>})<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="-">固定集合</h2>
<p>事先创建而且大小固定的集合, 如果空间不足最早的文旦会被删除,
适用于任何想要自动淘汰过期的属性的场景, 如日志</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>## <span class="keyword">size</span>指定文档大小 单位KB, <span class="keyword">max</span> 指文档数量
db.createCollection(<span class="string">"collectionName"</span>, {capped: true, <span class="keyword">size</span>:<span class="number">10000</span>, <span class="keyword">max</span>: <span class="number">100</span>});
</pre></td></tr></table></figure>

<h1 id="-">数据库备份和恢复</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">## 备份数据</span>
mongodump -h dbhose <span class="operator">-d</span> dbname -o dbdirectory

<span class="comment">## 恢复数据</span>
mongorestore -h localhost <span class="operator">-d</span> test dbdirectory
</pre></td></tr></table></figure>

<h1 id="-">导入和导出</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>mongoexport <span class="attribute">-h</span> dbhost <span class="attribute">-d</span> dbname <span class="attribute">-c</span> collectioName <span class="attribute">-o</span> output

mongoimport <span class="attribute">-h</span> dbhost <span class="attribute">-d</span> dbname <span class="attribute">-c</span> collectioName output
</pre></td></tr></table></figure>

<h1 id="-">安全和认证</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">use</span> <span class="title">admin</span>;
<span class="comment">## 创建超级管理员</span>
db.addUser(<span class="string">"root"</span>, <span class="string">"root"</span>);

<span class="keyword">use</span> <span class="title">test</span>;
db.addUser(<span class="string">"zhangshan"</span>, <span class="string">"123"</span>);
<span class="comment">## 创建只读用户</span>
db.addUser(<span class="string">"lisi"</span>, <span class="string">"123"</span>, <span class="keyword">true</span>);

<span class="comment">## 运行服务, 并且开启安全检查</span>
mongod --dbpath --auth

<span class="comment">## 登陆, 验证用户</span>
db.auth(<span class="string">"zhangshan"</span>, <span class="string">"123"</span>);
</pre></td></tr></table></figure>

<h1 id="-">配置集群 副本集</h1>
<p>实时更新 复制 备份</p>
<h2 id="-">主从复制</h2>
<p>主从复制是MongoDB最常用的复制方式。这种方式非常灵活，可用于备份、故障恢复、读
扩展等。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">##</span> <span class="comment">创建主节点</span>
<span class="comment">mongod</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dbpath=/tmp/master</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">10000</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">master</span>
<span class="comment">##</span> <span class="comment">创建从节点</span>
<span class="comment">mongod</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dbpath=/tmp/slave</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">10001</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">slave</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">source</span> <span class="comment">localhost:10000</span>
</pre></td></tr></table></figure>

<p>启动成功后就可以连接主节点进行操作了，而这些操作会同步到从节点.</p>
<h2 id="-">副本集</h2>
<p>主从集群和副本集最大的区别就是副本集没有固定的“主节点”； 
整个集群会选出一个“主节点”，当其挂掉后，又在剩下的从节点 
中选中其他节点为“主节点”，副本集总有一个活跃点(primary)
和一个或多个备份节点(secondary)。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="preprocessor">## 启动节点一, 默认为主节点</span>
<span class="title">mongod</span> <span class="comment">--dbpath E:\mogodb\dbs\node1 --logpath E:\mogodb\logs\node1\logs.txt --logappend</span>
<span class="comment">--port 10001 --replSet itcast/localhost:10002,localhost:10003 --master</span>

<span class="preprocessor">## 启动节点二</span>
<span class="title">mongod</span> <span class="comment">--dbpath E:\mogodb\dbs\node2 --logpath E:\mogodb\logs\node2\logs.txt --logappend</span>
<span class="comment">--port 10002 --replSet itcast/localhost:10001</span>

<span class="preprocessor">## 启动节点三</span>
<span class="title">mongod</span> <span class="comment">--dbpath E:\mogodb\dbs\node3 --logpath E:\mogodb\logs\node3\logs.txt --logappend</span>
<span class="comment">--port 10003 --replSet itcast/localhost:10001,localhost:10002</span>

<span class="preprocessor">## 连上 节点一</span>
<span class="title">mongo</span> localhost:<span class="number">10001</span>/admin

<span class="preprocessor">## 初始化副本集</span>
<span class="title">db</span>.runCommand({<span class="string">"replSetInitiate"</span>:{<span class="string">"_id"</span>:<span class="string">"itcast"</span>,<span class="string">"members"</span>:[
   {<span class="string">"_id"</span>:<span class="number">1</span>,<span class="string">"host"</span>:<span class="string">"localhost:10001"</span>,<span class="string">"priority"</span>:<span class="number">3</span>},
   {<span class="string">"_id"</span>:<span class="number">2</span>,<span class="string">"host"</span>:<span class="string">"localhost:10002"</span>,<span class="string">"priority"</span>:<span class="number">2</span>},
   {<span class="string">"_id"</span>:<span class="number">3</span>,<span class="string">"host"</span>:<span class="string">"localhost:10003"</span>,<span class="string">"priority"</span>:<span class="number">1</span>}]}});

<span class="preprocessor">## 查询是否主库</span>
<span class="title">db</span>.$cmd.findOne ( {ismaster: <span class="number">1</span> } );
</pre></td></tr></table></figure>

<h2 id="-">分片</h2>
<p>分片(sharding)是指将数据拆分，将其分散存在不同的机器上的过程。有时也用分区
(partitioning)来表示这个概念。将数据分散到不同的机器上，不需要功能强大的大型计算机
就可以储存更多的数据，处理更多的负载。 </p>
<p>分片之前要运行一个路由进程，该进程名为 mongos。这个路由器知道所有数据
的存放位置，所以应用可以连接它来正常发送请求。对应用来说，它仅知道连接了一个普通
的 mongod。路由器知道数据和片的对应关系，能够转发请求到正确的片上。如果请求有了
回应，路由器将其收集起来回送给应用。</p>
<p>config 指明数据存放规则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="preprocessor">## 启动 config 配置服务</span>
mongod --dbpath E:\mogodb\sharding\config_node --port <span class="number">2222</span>

<span class="preprocessor">## 启动分片服务, 连接config服务</span>
mongos --port <span class="number">3333</span> --configdb=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2222</span>

<span class="preprocessor">## 启动分片一 和 二</span>
mongod --dbpath E:\mogodb\sharding\mongod_node1 --port <span class="number">4444</span>
mongod --dbpath E:\mogodb\sharding\mongod_node2 --port <span class="number">5555</span>

<span class="preprocessor">## 连接分片服务器, 并添加分片一 和 分片二</span>
mongo localhost:<span class="number">3333</span>/admin
db.runCommand({<span class="string">"addshard"</span>:<span class="string">"localhost:4444"</span>,<span class="string">"allowLocal"</span>:<span class="literal">true</span>});
db.runCommand({<span class="string">"addshard"</span>:<span class="string">"localhost:5555"</span>,<span class="string">"allowLocal"</span>:<span class="literal">true</span>});

<span class="preprocessor">## 开启数据库 test 的分片服务</span>
db.runCommand({<span class="string">"enablesharding"</span>:<span class="string">"test"</span>});

<span class="preprocessor">## 指定分片的片键</span>
<span class="preprocessor">## 对test.person表进行分片, 根据 name 键, 进行分片</span>
db.runCommand({<span class="string">"shardcollection"</span>:<span class="string">"test.person"</span>,<span class="string">"key"</span>:{name:<span class="number">1</span>}});

<span class="preprocessor">## 查看分片情况</span>
db.printShardingStatus();
</pre></td></tr></table></figure>

<h1 id="java-mongodb">Java 操作 MongoDB</h1>
<p>导入 <code>mongo.jar</code></p>
<p>查找</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Mongo mongo = <span class="keyword">new</span> Mongo(<span class="string">"localost"</span>, <span class="number">27017</span>);
DB db = mongo.getDB(<span class="string">"test"</span>);

<span class="comment">// 获得集合</span>
DBCollection collection = db.getCollection(<span class="string">"customers"</span>);
<span class="comment">// 获得结果集</span>
DBCursor dbCursor = collection.find();
<span class="keyword">while</span>(dbCursor.hasNext()) {
  DBObject dbObject = dbCursor.next();
  <span class="built_in">Object</span> name = dbObject.<span class="keyword">get</span>(<span class="string">"name"</span>);
  <span class="built_in">Object</span> age = dbObject.<span class="keyword">get</span>(<span class="string">"age"</span>);
}
<span class="comment">// 关闭资源</span>
mongo.close();
</pre></td></tr></table></figure>

<p>增加</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Mongo mongo = new Mongo(<span class="string">"localost"</span>, <span class="number">27017</span>)<span class="comment">;</span>
DB db = mongo<span class="preprocessor">.getDB</span>(<span class="string">"test"</span>)<span class="comment">;</span>

// 获得集合
DBCollection collection = db<span class="preprocessor">.getCollection</span>(<span class="string">"customers"</span>)<span class="comment">;</span>

DBObject db0 = new BasicDBObject()<span class="comment">;</span>
db0<span class="preprocessor">.put</span>(<span class="string">"name"</span>, <span class="string">"leo"</span>)<span class="comment">;</span>
db0<span class="preprocessor">.put</span>(<span class="string">"age"</span>, test)<span class="comment">;</span>
collection<span class="preprocessor">.insert</span>(db0)<span class="comment">;</span>

mongo<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>Mongo mongo = <span class="built_in">new</span> Mongo(<span class="string">"localhost"</span>,<span class="number"> 5555</span>);

DB db = mongo.getDB(<span class="string">"test"</span>);

DBCollection personCollection = db.getCollection(<span class="string">"person"</span>);

DBObject o= <span class="built_in">new</span> BasicDBObject();
o.put(<span class="string">"name"</span>, <span class="string">"erdan"</span>);
o.put(<span class="string">"age"</span>,<span class="number"> 30</span>);

<span class="comment">//更改的时候 ,如果以”_id去更改”,那么同样的要以传递ObjectId,</span>
<span class="comment">// 不能直接将id值以字符串的形式传过去</span>
DBObject q = <span class="built_in">new</span> BasicDBObject(<span class="string">"_id"</span>, <span class="built_in">new</span> ObjectId(<span class="string">"525f495bf422c198b9a69bbc"</span>));

<span class="comment">// update方法重载了很多次,这里以这个为例.</span>
WriteResult result = personCollection.update(q , o);

mongo.<span class="built_in">close</span>();
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="NoSql" scheme="http://zhpooer.github.io/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Deconstructing Play]]></title>
    <link href="http://zhpooer.github.io/2014/08/08/play-for-scala-deconstructing-play/"/>
    <id>http://zhpooer.github.io/2014/08/08/play-for-scala-deconstructing-play/</id>
    <published>2014-08-08T07:53:21.000Z</published>
    <updated>2014-08-09T08:05:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="drawing-the-architectural-big-picture">Drawing the architectural big picture</h1>
<p>When a web client sends HTTP requests to a Play application,
the request is handled by the embedded HTTP server,
which provides the Play framework’s network
interface. The server forwards the request data to the Play framework,
which generates a response that the server sends to the client.</p>
<h2 id="the-play-server">The Play server</h2>
<p>Play’s HTTP server is JBoss Netty, one of several Java NIO non-blocking servers.</p>
<p>When you use a web framework that’s based on the Java Servlet API,
you package your web application as some kind of archive that
you deploy to an application
server such as Tomcat, which runs your application. </p>
<p>With the Play framework it’s different:
Play includes its own embedded HTTP server, so you don’t need a separate
application server to run your application.</p>
<h2 id="mvc">MVC</h2>
<p>The MVC design pattern separates an application’s logic and data from the user
interface’s presentation and interaction,
maintaining a loose coupling between the separate components.</p>
<p>The Play framework achieves all of this with fewer layers than traditional Java EE
web frameworks by using the controller API to expose the HTTP directly, using HTTP
concepts, instead of trying to provide an abstraction on top of it. </p>
<h2 id="rest">REST</h2>
<p>REST is an architectural style that characterizes the way HTTP
works, featuring constraints such as stateless client-server
interaction and a uniform interface.</p>
<h1 id="application-configuration">Application configuration</h1>
<p>Play creates an initial configuration file for you, and almost all of the
many configuration parameters are optional, with sensible defaults,
so you don’t need to set them all yourself.</p>
<h2 id="creating-the-default-configuration">Creating the default configuration</h2>
<p><code>conf/application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>application<span class="preprocessor">.secret</span>=<span class="string">"l:2e&gt;xI9kj@GkHu?K9D[L5OU=Dc&lt;8i6jugIVE^[`?xSF]udB8ke"</span>
application<span class="preprocessor">.langs</span>=<span class="string">"en"</span>

logger<span class="preprocessor">.root</span>=ERROR
logger<span class="preprocessor">.play</span>=INFO
logger<span class="preprocessor">.application</span>=DEBUG
</pre></td></tr></table></figure>

<h2 id="configuration-file-format">Configuration file format</h2>
<p>Play uses the Typesafe config library (<a href="https://github.com/typesafehub/config" target="_blank">https://github.com/typesafehub/config</a>).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.Cache</span>=DEBUG
logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.CacheManager</span>=${logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.Cache</span>}
logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.store</span><span class="preprocessor">.MemoryStore</span>=${logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.Cache</span>}

log<span class="preprocessor">.directory</span> = /var/log
log<span class="preprocessor">.access</span> = ${log<span class="preprocessor">.directory</span>}/access<span class="preprocessor">.log</span>
log<span class="preprocessor">.errors</span> = ${log<span class="preprocessor">.directory</span>}/errors<span class="preprocessor">.log</span>
</pre></td></tr></table></figure>

<h3 id="include">include</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">db</span>: <span class="rules">{
  <span class="rule"><span class="attribute">default</span>:<span class="value"> {
    driver: <span class="string">"org.h2.Driver"</span>,
    url: <span class="string">"jdbc:h2:mem:play"</span>,
    user: <span class="string">"sa"</span>,
    password: <span class="string">""</span>,
  </span></span></span>}
}
</pre></td></tr></table></figure>

<p><code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>include <span class="string">"db-default.conf"</span>
<span class="preprocessor"># override user name and password</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.user</span> = products
db<span class="preprocessor">.default</span><span class="preprocessor">.password</span> = clippy
</pre></td></tr></table></figure>

<h3 id="merging-values-from-multiple-files">MERGING VALUES FROM MULTIPLE FILES</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="label">db:</span> {
  default: {
    user: <span class="string">"products"</span>
    password: <span class="string">"clippy must die!"</span>
    logStatements: true
  }
}
// 方式二, 加逗号
<span class="label">db:</span> {
  default: {
    user: <span class="string">"products"</span>,
    password: <span class="string">"clippy must die!"</span>,
    logStatements: true,
  }
}
// 方式三
db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span> = org<span class="preprocessor">.h</span>2<span class="preprocessor">.Driver</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span> = jdbc:h2:mem:play
db<span class="preprocessor">.default</span><span class="preprocessor">.user</span> = products
db<span class="preprocessor">.default</span><span class="preprocessor">.password</span> = <span class="string">"clippy must die!"</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.logStatements</span> = true
</pre></td></tr></table></figure>

<p>The configuration format is specified in detail by the Human-Optimized Config
Object Notation (HOCON )
specification (<a href="https://github.com/typesafehub/config/blob/master/HOCON.md" target="_blank">https://github.com/typesafehub/config/blob/master/HOCON.md</a>).</p>
<h3 id="configuration-file-overrides">Configuration file overrides</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>start -Ddb<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=postgres://localhost:products@clippy/products

run -Dconfig<span class="preprocessor">.file</span>=conf/production<span class="preprocessor">.conf</span>
run -Dconfig<span class="preprocessor">.file</span>=/etc/products/production<span class="preprocessor">.conf</span>
</pre></td></tr></table></figure>

<h3 id="custom-application-configuration">Custom application configuration</h3>
<p>For example, suppose you want to display version information in your web applica-
tion’s page footer.
<code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">application.revision </span>=<span class="string"> 42</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>@import play<span class="preprocessor">.api</span><span class="preprocessor">.Play</span><span class="preprocessor">.current</span>
&lt;footer&gt;
Revision @current<span class="preprocessor">.configuration</span><span class="preprocessor">.getString</span>(<span class="string">"application.revision"</span>)
&lt;/footer&gt;
</pre></td></tr></table></figure>

<p>The getString method returns an Option[String] rather than a String, but the
template outputs the value or an empty string, depending on whether the Option has
a value.</p>
<h1 id="the-model-adding-data-structures-and-business-logic">The model—adding data structures and business logic</h1>
<p>The model contains the application’s domain-specific data and logic.</p>
<p>This data is usually kept in persistent storage, such as a relational database,
in which case the model handles persistence.</p>
<p>In a layered application architecture, the domain-specific logic is usually called
business logic and doesn’t have a dependency on any of the application’s external inter-
faces, such as a web-based user interface.</p>
<h2 id="database-centric-design">Database-centric design</h2>
<p>One good way to design an application is to start with a logical data model,
as well as an actual physical database.</p>
<p>Database-centric design means starting with the data model: identifying entities
and their attributes and relationships. </p>
<p>For example, we can design a product catalog application by first designing a data-
base for all of the data that we’ll process.</p>
<ul>
<li>Product—A Product is a description of a manufactured product as it might appear
in a catalog, such as “Box of 1000 large plain paperclips,” but not an actual box
of paperclips. Attributes include a product code, name, and description.</li>
<li>Stock Item—A Stock Item is a certain quantity of some product at some location,
such as 500 boxes of a certain kind of paperclip, in a particular Warehouse.
Attributes include quantity and references to a Product and Warehouse.</li>
<li>Warehouse—A Warehouse is a place where Stock Items are stored. Attributes
include a name and geographic location or address.</li>
<li>Order—An Order is a request to transfer ownership of some quantity of one or
more Products, specified by Order Lines. Attributes include a date, seller, and
buyer.</li>
<li>Order Line—An Order Line specifies a certain quantity of some Product, as part
of an Order. Attributes include a quantity and a reference to an Order and
Product.</li>
</ul>
<p>The benefit of this approach is that you can use established data modeling techniques
to come up with a data model that consistently and unambiguously describes your
application’s domain.</p>
<h2 id="model-class-design">Model class design</h2>
<p>There’s more than one way to structure your model. Perhaps the most significant
choice is whether to keep your domain-specific data and logic separate or together.</p>
<p>Developers coming to Play and Scala from a Java EE background are likely
to have separated data and behavior in the past, whereas other developers may have
used a more object-oriented approach that mixes data and behavior in model classes.</p>
<p>More generally, the domain data model is specified by classes called
value objects that don’t contain any logic.</p>
<p><img src="/img/play_model_layer.png" alt="Two different ways to structure"></p>
<h2 id="defining-case-classes">Defining case classes</h2>
<p>We need case classes to represent quantities of various
products stored in warehouses.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="keyword">class</span> Product(
  id: <span class="built_in">Long</span>,
  ean: <span class="built_in">Long</span>,
  name: <span class="built_in">String</span>,
  description: <span class="built_in">String</span>)

<span class="keyword">case</span> <span class="keyword">class</span> Warehouse(id: <span class="built_in">Long</span>, name: <span class="built_in">String</span>)

<span class="keyword">case</span> <span class="keyword">class</span> StockItem(
  id: <span class="built_in">Long</span>,
  productId: <span class="built_in">Long</span>,
  warehouseId: <span class="built_in">Long</span>,
  quantity: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h2 id="persistence-api-integration">Persistence API integration</h2>
<p>You can use your case classes to persist the model using a persistence API. In a Play
application’s architecture, this is entirely separate from the web
tier; only the model uses (has a dependency on) the persistence API, which in turn
uses external persistent storage, such as a relational database.</p>
<p>Play includes the Anorm persistence API so that you can build a complete web
application, including SQL database access, without any additional libraries. But
you’re free to use alternative persistence libraries or approaches to persistent storage,
such as the newer Slick library.</p>
<h2 id="using-slick-for-database-access">Using Slick for database access</h2>
<p>Slick is intended as a Scala-based API for relational-database access.</p>
<p>The idea behind Slick is that you use it instead of using JDBC directly or adding
a complex object-relational mapping framework.
Instead, Slick uses Scala language featuresb
to allow you to map database tables to Scala collections and to execute queries.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>object Product extends Table[<span class="link_label">(Long, String, String)</span>](<span class="link_url">"products"</span>) {
  def ean = column[<span class="link_label">Long</span>](<span class="link_url">"ean", O.PrimaryKey</span>)
  def name = column[<span class="link_label">String</span>](<span class="link_url">"name"</span>)
  def description = column[<span class="link_label">String</span>](<span class="link_url">"description"</span>)
  def * = ean ~ name ~ description
}

// you define a query on the Product object:
val products = for {
  product <span class="xml"><span class="tag">&lt;<span class="title">-</span> <span class="attribute">Product.sortBy</span>(<span class="attribute">product</span> =&gt;</span></span> product.name.asc)
} yield (product)

// To execute the query, you can use the query object to generate a list of products,
// in a database session:
val url = "jdbc:postgresql://localhost/slick?user=slick&password=slick"
Database.forURL(url, driver = "org.postgresql.Driver") withSession {
  val productList = products.list
}
</pre></td></tr></table></figure>

<h1 id="controllers-handling-http-requests-and-responses">Controllers—handling HTTP requests and responses</h1>
<p>One aspect of designing your application is to design a URL scheme for HTTP
requests, hyperlinks, HTML forms, and possibly a public API.
In Play, you define this interface in an HTTP routes configuration and implement
the interface in Scala controller classes.</p>
<p>More specifically, controllers are the Scala classes that define your application’s
HTTP interface, and your routes configuration determines which controller method a
given HTTP request will invoke.</p>
<p>These controller methods are called actions—Play’s
architecture is in fact an MVC variant called action-based MVC—so
you can also think of a controller class as a collection of action methods.</p>
<h2 id="url-centric-design">URL-centric design</h2>
<p>This URL-centric design is an alternative to a database-centric design that starts
with the application’s data, or a UI-centric design that’s
based on how users will interact with its user interface.</p>
<p>URL-centric design isn’t better than data model–centric design or UI-centric design,
although it might make more sense for a developer who thinks in a certain way, or for
a certain kind of application.</p>
<h3 id="http-resources">Http resources</h3>
<p>URL-centric design means identifying your application’s resources, and operations on
those resources, and creating a series of URLs that provide HTTP access to those
resources and operations.</p>
<p>Once you have a solid design, you can add a user-interface
layer on top of this HTTP interface, and add a model that backs the HTTP resources.</p>
<p>The key benefit of this approach is that you can create a consistent public API for
your application that’s more stable than either the physical data model represented by
its model classes, or the user interface generated by its view templates.</p>
<p><strong>RESTful web services</strong></p>
<p>This kind of API is often called a RESTful web service, which means that the API is a
web service API that conforms to the architectural constraints of representational
state transfer (REST). </p>
<h3 id="resource-oriented-architecture">RESOURCE-ORIENTED ARCHITECTURE</h3>
<p>Modeling HTTP resources is especially useful if the HTTP API is the basis for more
than one external interface, in what can be called a resource-oriented architecture—a
REST -style alternative to service-oriented architecture based on addressable resources.</p>
<p>Resource-oriented architecture is an API-centric perspective on your application,
in which you consider that HTTP requests won’t necessarily come from your own
application’s web-based user interface.</p>
<h2 id="routing-http-requests-to-controller-action-methods">Routing HTTP requests to controller action methods</h2>
<p>For example, a URL -centric design for our product catalog might give us a URL
scheme with the following URLs:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">GET</span> /

<span class="keyword">GET</span> /products
<span class="keyword">GET</span> /products?page=<span class="number">2</span>
<span class="keyword">GET</span> /products?<span class="built_in">filter</span>=zinc

<span class="keyword">GET</span> /product/<span class="number">5010255079763</span>

<span class="keyword">GET</span> /product/<span class="number">5010255079763</span>/edit

PUT /product/<span class="number">5010255079763</span>
</pre></td></tr></table></figure>

<p>You create a conf/routes file like this</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>GET /                  controllers<span class="preprocessor">.Application</span><span class="preprocessor">.home</span>()
GET /products          controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>(page: Int ?= <span class="number">1</span>)
GET /product/:ean      controllers<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(ean: Long)
GET /product/:ean/edit controllers<span class="preprocessor">.Products</span><span class="preprocessor">.edit</span>(ean: Long)
PUT /product/$ean&lt;\d{<span class="number">13</span>}&gt;   controllers<span class="preprocessor">.Products</span><span class="preprocessor">.update</span>(ean: Long)
</pre></td></tr></table></figure>

<h2 id="binding-http-data-to-scala-objects">Binding HTTP data to Scala objects</h2>
<p>Action methods often have parameters, and you also need to be
able to map HTTP request data to those parameters.</p>
<h2 id="generating-different-types-of-http-response">Generating different types of HTTP response</h2>
<p>An HTTP response is not only a response body; the response also includes HTTP
status codes and HTTP headers that provide additional information about the
response.</p>
<h1 id="view-template-formatting-output">View template—formatting output</h1>
<p>A web framework’s approach to formatting output is a critical design
choice. View templates are a big deal; HTML templates in particular.</p>
<h2 id="ui-centric-design">UI-centric design</h2>
<p>URL-centric design that focuses on the application’s HTTP API.</p>
<p>UI-centric design starts with user-interface mockups and progressively adds detail
without starting on the underlying implementation until later, when the interface
design is established. This approach has become especially popular with the rise of
SAAS (software as a service) applications.</p>
<h3 id="saas-applications">SAAS APPLICATIONS</h3>
<p>37signals popularized UI-centric design in their
book Getting Real (<a href="http://gettingreal.37signals.com/ch09_Interface_First.php" target="_blank">http://gettingreal.37signals.com/ch09_Interface_First.php</a>),
which describes the approach as “interface first,” meaning
simply that you should “design the interface before you start programming.”</p>
<p>UI-centric design works well for software that focuses on simplicity and usability,
because functionality must literally compete for space in the UI, whereas functionality
that you can’t see doesn’t exist.</p>
<p>In this scenario, database-centric design may seem less
relevant because the database design gets less attention
than the UI design, for early versions of the software, at least.</p>
<h3 id="mobile-applications">MOBILE APPLICATIONS</h3>
<p>UI-centric design is also a good idea for mobile applications, because it’s better to
address mobile devices’ design constraints from the start than to attempt to squeeze a
desktop UI into a small screen later in the development process.</p>
<h2 id="html-first-templates">HTML-first templates</h2>
<p>There are two kinds of web framework templating systems, each addressing different
developer goals: component systems and raw HTML templates.</p>
<h3 id="user-interface-components">USER-INTERFACE COMPONENTS</h3>
<p>One approach minimizes the amount of HTML you write, usually by providing a
user-interface component library. </p>
<p>The idea is that you construct your user interface
from UI “building blocks” instead of writing HTML by hand.</p>
<p>In principle, the benefit of this approach is that it results in a more consistent UI
with less coding, and there are various frameworks that achieve this goal. But the risk
is that the UI components are a leaky abstraction, and that you’ll end up having to
debug invalid or otherwise non-working HTML and JavaScript after all.</p>
<h3 id="html-templates">HTML TEMPLATES</h3>
<p>A different kind of template system works by decorating HTML to make content
dynamic, usually with syntax that provides a combination of tags
for things like control structures and iteration, and an expression language
for outputting dynamic values.</p>
<p>The benefits of starting with HTML become apparent in practice, due to a combina-
tion of factors.</p>
<h3 id="javascript-widgets">JAVASCRIPT WIDGETS</h3>
<p>The opportunity to use a wide selection of JavaScript widgets is the most apparent
practical result of having control over your application’s HTML.</p>
<p>JavaScript widgets are different from framework-specific widgets, because they can
work with any server-side code that gives you control over your HTML and the HTTP
interface. </p>
<p>Being in control of the HTML your templates produce means that you have a rich choice of
JavaScript widgets.</p>
<h2 id="type-safe-scala-templates">Type-safe Scala templates</h2>
<p>Play includes a template engine that’s designed to output any kind of text-based
format, the usual examples being HTML, XML, and plain text.</p>
<h3 id="starting-with-a-minimal-template">STARTING WITH A MINIMAL TEMPLATE</h3>
<p>To start with, minimum interference means that all of the template syntax is optional.
<code>app/views/minimal.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="adding-dynamic-content">ADDING DYNAMIC CONTENT</h3>
<p><code>app/views/title.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>@(title:String)
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>@title<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="basic-template-syntax">BASIC TEMPLATE SYNTAX</h3>
<p>The parameter declaration, like all template syntax,
starts with the special <code>@</code> character,
which is followed by a normal Scala function parameter list.</p>
<p>In the body of a template, the <code>@</code> character can be followed by any Scala
expression or statement, whose value is inserted into the rendered template output.</p>
<h2 id="rendering-templates-scala-template-functions">Rendering templates—Scala template functions</h2>
<p>To use the template in the previous example, we first need to save it in a file in the
application, such as <code>app/views/products.scala.html</code>. Then we can render the
template in a controller by calling the template function:
<code>val html = views.html.title(&quot;New Arrivals&quot;)</code></p>
<p>This results in the following compiled template—a file in
<code>target/scala-2.10/src_managed/main/views/html/</code></p>
<h1 id="static-and-compiled-assets">Static and compiled assets</h1>
<p>A typical web application includes static content—images, JavaScript, stylesheets, and
downloads. In Play, these files are called assets.</p>
<h2 id="serving-assets">Serving assets</h2>
<p>Play provides an assets controller whose purpose is to serve static files.
There are two advantages to this approach: you use the usual routes configuration
and you get additional functionality in the assets controller.</p>
<p>Using the routes configuration for assets means that you have the same flexibility
in mapping URLs as you do for dynamic content.</p>
<p>On top of routing, the assets controller provides additional functionality
that’s useful for improving performance when serving static files:</p>
<ul>
<li>Caching support—Generating HTTP Entity Tags (ETags) to enable caching</li>
<li>JavaScript minification—Using Google Closure Compiler to reduce the size of
JavaScript files</li>
</ul>
<h2 id="compiling-assets">Compiling assets</h2>
<p>Play supports one of each:
LESS and CoffeeScript, languages that improve on CSS and JavaScript, respectively.</p>
<p>At compile time, LESS and CoffeeScript assets are compiled into CSS and
JavaScript files. HTTP requests for these assets are handled by the assets controller.</p>
<h1 id="jobs-starting-processes">Jobs—starting processes</h1>
<p>Sometimes an application has to run some code outside the normal HTTP request-
response cycle, either because it’s a long-running task that the web client doesn’t have
to wait for, or because the task must be executed on a regular cycle, independently of
any user or client interaction.
Today, architectures are frequently web-centric,
based around a web application or deployed on a cloud-based
application hosting service. These architectures mean that we need a way
to schedule and execute these jobs from within our web application.</p>
<h2 id="asynchronous-jobs">Asynchronous jobs</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>import java<span class="preprocessor">.util</span><span class="preprocessor">.Date</span>
import models<span class="preprocessor">.PickList</span>
import scala<span class="preprocessor">.concurrent</span>.{ExecutionContext, future}

def sendAsync(warehouse: String) = Action {
  import ExecutionContext<span class="preprocessor">.Implicits</span><span class="preprocessor">.global</span>
  future {
    // Use Scala future to execute block of code asynchronously
    val pickList = PickList<span class="preprocessor">.find</span>(warehouse)
    send(views<span class="preprocessor">.html</span><span class="preprocessor">.pickList</span>(warehouse, pickList, new Date))
  }
  // Build, render, <span class="keyword">and</span> send pick list somewhere
  Redirect(routes<span class="preprocessor">.PickLists</span><span class="preprocessor">.index</span>())
}
</pre></td></tr></table></figure>

<p>This time, the template rendering code is wrapped in a call
to <code>scala.concurrent.future</code>, which executes the code asynchronously. </p>
<h2 id="scheduled-jobs">Scheduled jobs</h2>
<p>Depending on how our warehouse works, it may be more useful to
automatically generate a new pick list every half hour.</p>
<p>To do this, we need a scheduled job that’s triggered automatically,
without needing anyone to click the button in the user interface.
Play doesn’t provide scheduling functionality directly, but instead integrates with
Akka, a library for actor-based concurrency that’s included with Play.</p>
<p><code>app/Global.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>import akka<span class="preprocessor">.actor</span>.{Actor, Props}
import models<span class="preprocessor">.Warehouse</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.concurrent</span><span class="preprocessor">.Akka</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.GlobalSettings</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.templates</span><span class="preprocessor">.Html</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.concurrent</span><span class="preprocessor">.Execution</span><span class="preprocessor">.Implicits</span><span class="preprocessor">.defaultContext</span>

object Global extends GlobalSettings {
  override def onStart(application: play<span class="preprocessor">.api</span><span class="preprocessor">.Application</span>) {
    import scala<span class="preprocessor">.concurrent</span><span class="preprocessor">.duration</span>._
    import play<span class="preprocessor">.api</span><span class="preprocessor">.Play</span><span class="preprocessor">.current</span>
    // Run when Play application starts
    for (warehouse &lt;- Warehouse<span class="preprocessor">.find</span>()) {
      val actor = Akka<span class="preprocessor">.system</span><span class="preprocessor">.actorOf</span>(
        Props(new PickListActor(warehouse))
      )
      // Create actor for each warehouse
      Akka<span class="preprocessor">.system</span><span class="preprocessor">.scheduler</span><span class="preprocessor">.schedule</span>(
        <span class="number">0.</span>seconds, <span class="number">30.</span>minutes, actor, <span class="string">"send"</span>
      )
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="asynchronous-results-and-suspended-requests">Asynchronous results and suspended requests</h2>
<p><code>app/controllers/Dashboard.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="keyword">import</span> concurrent.{ExecutionContext, Future}

<span class="class"><span class="keyword">object</span> <span class="title">Dashboard</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>

  <span class="keyword">def</span> backlog(warehouse: String) = Action {
    <span class="keyword">import</span> ExecutionContext.Implicits.global
    <span class="keyword">val</span> backlog = scala.concurrent.future {
      models.Order.backlog(warehouse)
    }
    <span class="comment">// Get a promise of the order backlog without blocking</span>
    Async {
      backlog.map(value =&gt; Ok(value))
    }
  }
}
</pre></td></tr></table></figure>

<p>This is important because it allows
Play to release threads to a thread pool, making them available to process other HTTP
requests, so the application can serve a large number of requests
with a limited number of threads.</p>
<h1 id="modules-structuring-your-application">Modules—structuring your application</h1>
<p>A Play module is a Play application dependency—either reusable third-party code or
an independent part of your own application. The difference between a module and
any other library dependency is that a module depends on Play and can do the same
things an application can do. </p>
<h2 id="third-party-modules">Third-party modules</h2>
<p>Modules make it possible to extend Play with functionality
that you can use as if it were built-in,
without bloating the core framework with features that not everyone needs.</p>
<p>Here are a few examples of third-party modules that provide different kinds of
functionality:</p>
<ul>
<li>Deadbolt—Role-based authorization that allows you to restrict access
to controllers and views</li>
<li>Groovy templates—An alternative template engine that uses the Play 1.x
Groovy template syntax</li>
<li>PDF — Adds support for PDF output based on HTML templates</li>
<li>Redis—Integrates Redis to provide a cache implementation</li>
<li>Sass—Adds asset file compilation for Sass stylesheet files</li>
</ul>
<p>For more information about these and other modules, see the Play Framework
web site (<a href="http://www.playframework.org" target="_blank">http://www.playframework.org</a>).</p>
<h2 id="extracting-custom-modules">Extracting custom modules</h2>
<p>One way to approach custom modules is to think of them as a way to split your applica-
tions into separate reusable components, which helps keep individual applications
and modules simple.</p>
<h2 id="module-first-application-architecture">Module-first application architecture</h2>
<p>Another approach is to always add new application functionality in a module, when
you can, only adding to the main application when absolutely necessary.</p>
<p>With this approach, each application would consist of a smaller core of
modelspecific functionality and logic, plus a constellation of
modules that provide separate aspects of application functionality.
Some of these modules would inevitably be shared between applications.</p>
<h2 id="deciding-whether-to-write-a-custom-module">Deciding whether to write a custom module</h2>
<h2 id="module-architecture">Module architecture</h2>
<p>A module is almost the same thing as a whole application.
It provides the same kind of things an application has: models, view templates,
controllers, static files, or other utility
code. The only thing a module lacks is its own configuration; only the main application’s
configuration is used. This means that any module configuration properties must be set
in the application’s <code>conf/application.conf</code> file.</p>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Getting Start]]></title>
    <link href="http://zhpooer.github.io/2014/08/07/play-for-scala-getting-start/"/>
    <id>http://zhpooer.github.io/2014/08/07/play-for-scala-getting-start/</id>
    <published>2014-08-07T08:35:31.000Z</published>
    <updated>2014-08-08T02:03:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="what-play-is">What Play is</h1>
<p>Play makes you more productive. Play is also a web framework whose HTTP interface is
simple, convenient, flexible, and powerful. Most importantly, Play improves on the
most popular non-Java web development languages and frameworks—PHP and Ruby
on Rails—by introducing the advantages of the Java Virtual Machine (JVM).</p>
<h1 id="hello-play">Hello Play</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">play</span> new hello
<span class="keyword">play</span> run
</pre></td></tr></table></figure>

<p>Files in a new Play application</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="preprocessor">.gitignore</span>
app/controllers/Application<span class="preprocessor">.scala</span>
app/views/index<span class="preprocessor">.scala</span><span class="preprocessor">.html</span>
app/views/main<span class="preprocessor">.scala</span><span class="preprocessor">.html</span>
conf/application<span class="preprocessor">.conf</span>
conf/routes
project/build<span class="preprocessor">.properties</span>
project/Build<span class="preprocessor">.scala</span>
project/plugins<span class="preprocessor">.sbt</span>
public/images/favicon<span class="preprocessor">.png</span>
public/javascripts/jquery-<span class="number">1.7</span><span class="number">.1</span><span class="preprocessor">.min</span><span class="preprocessor">.js</span>
public/stylesheets/main<span class="preprocessor">.css</span>
test/ApplicationSpec<span class="preprocessor">.scala</span>
test/IntegrationSpec<span class="preprocessor">.scala</span>
</pre></td></tr></table></figure>

<p><code>app/controllers/Application.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> </span>index = <span class="constant">Action</span> {
  <span class="constant">Ok</span>(<span class="string">"Hello world"</span>)
}
</pre></td></tr></table></figure>

<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>GET / controllers<span class="preprocessor">.Application</span><span class="preprocessor">.index</span>()
</pre></td></tr></table></figure>

<p>也可以这样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> </span>hello(<span class="symbol">name:</span> <span class="constant">String</span>) = <span class="constant">Action</span> {
  <span class="constant">Ok</span>(<span class="string">"Hello "</span> + name)
}

/<span class="regexp">/ 访问 http:/</span><span class="regexp">/localhost:9000/hello</span>?n=<span class="constant">Play</span>!
<span class="regexp">//</span> <span class="constant">GET</span> /hello controllers.<span class="constant">Application</span>.hello(<span class="symbol">n:</span> <span class="constant">String</span>)
</pre></td></tr></table></figure>

<h2 id="add-an-html-page-template">Add an HTML page template</h2>
<p><code>app/views/hello.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>@(name:String)
<span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">em</span>&gt;</span>@name<span class="tag">&lt;/<span class="title">em</span>&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>def hello(name: <span class="keyword">String</span>) = Action <span class="list">{
  Ok(views.html.hello(name))
}</span>
</pre></td></tr></table></figure>

<p><code>sbt console</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>views<span class="preprocessor">.html</span><span class="preprocessor">.hello</span><span class="preprocessor">.render</span>(<span class="string">"Play!"</span>)
</pre></td></tr></table></figure>

<h1 id="your-first-play-application">Your first Play application</h1>
<p>We’ll start with a simple list of products, each of which has a name
and a description.
This is a prototype, with a small number of products, so there isn’t
any functionality for filtering, sorting, or paging the list.</p>
<pre><code>Paperclips Large
  Large Plain Pack of 1000
Zebra Paperclips
  Zebra Length 28mm Assorted 150 Pack
</code></pre><p>To make the product list page work, we’ll need a combination of the following:</p>
<ul>
<li>A view template—A template that generates HTML</li>
<li>A controller action—A Scala function that renders the view</li>
<li>Route configuration—Configuration to map the URL to the action</li>
<li>The model—Scala code that defines the product structure, and some test data</li>
</ul>
<h2 id="getting-started">Getting started</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>play <span class="literal">new</span> products
rm products/<span class="keyword">public</span>/images/favicon<span class="built_in">.</span>png
rm products/<span class="keyword">public</span>/javascripts/jquery<span class="subst">-</span><span class="number">1.7</span><span class="number">.1</span><span class="built_in">.</span><span class="keyword">min</span><span class="built_in">.</span>js
</pre></td></tr></table></figure>

<p>copying <code>docs/assets/css/bootstrap.css</code> to our
application’s <code>public/stylesheets</code> directory.
Also copy <code>glyphicons-halflings-white.png</code> and <code>glyphicons-halflings.png</code> to
<code>public/img</code></p>
<p><code>main.css</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="tag">body</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value">black</span></span>; <span class="rule">}</span></span>
<span class="tag">body</span>, <span class="tag">p</span>, <span class="tag">label</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">15</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.label</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">13</span>px</span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"><span class="number">16</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.alert-info</span> <span class="rules">{ <span class="rule"><span class="attribute">border-color</span>:<span class="value">transparent</span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"><span class="hexcolor">#3A87AD</span></span></span>;
  <span class="rule"><span class="attribute">color</span>:<span class="value">white</span></span>; <span class="rule"><span class="attribute">font-weight</span>:<span class="value">bold</span></span>; <span class="rule">}</span></span>
<span class="tag">div</span><span class="class">.screenshot</span> <span class="rules">{ <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">800</span>px</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">20</span>px</span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"><span class="hexcolor">#D0E7EF</span></span></span>; <span class="rule">}</span></span>
<span class="class">.navbar-fixed-top</span> <span class="class">.navbar-inner</span> <span class="rules">{ <span class="rule"><span class="attribute">padding-left</span>:<span class="value"><span class="number">20</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.navbar</span> <span class="class">.nav</span> &gt; <span class="tag">li</span> &gt; <span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#bbb</span></span></span>; <span class="rule">}</span></span>
<span class="class">.screenshot</span> &gt; <span class="class">.container</span> <span class="rules">{ <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">760</span>px</span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">20</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.navbar-fixed-top</span>, <span class="class">.navbar-fixed-bottom</span> <span class="rules">{ <span class="rule"><span class="attribute">position</span>:<span class="value">relative</span></span>; <span class="rule">}</span></span>
<span class="tag">h1</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">125</span>%</span></span>; <span class="rule">}</span></span>
<span class="tag">table</span> <span class="rules">{ <span class="rule"><span class="attribute">border-collapse</span>:<span class="value"> collapse</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100</span>%</span></span>; <span class="rule">}</span></span>
<span class="tag">th</span>, <span class="tag">td</span> <span class="rules">{ <span class="rule"><span class="attribute">text-align</span>:<span class="value">left</span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0.3</span>em <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1</span>px solid white</span></span>; <span class="rule">}</span></span>
<span class="tag">tr</span><span class="class">.odd</span> <span class="tag">td</span> <span class="rules">{ <span class="rule">}</span></span>
<span class="tag">form</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>; <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> <span class="number">1</span>em</span></span>; <span class="rule">}</span></span>
<span class="tag">legend</span> <span class="rules">{ <span class="rule"><span class="attribute">border</span>:<span class="value"> none</span></span>; <span class="rule">}</span></span>
<span class="tag">fieldset</span> &gt; <span class="tag">div</span> <span class="rules">{ <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">12</span>px <span class="number">0</span></span></span>; <span class="rule">}</span></span>
<span class="class">.help-block</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>; <span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> middle</span></span>; <span class="rule">}</span></span>
<span class="class">.error</span> <span class="class">.help-block</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>; <span class="rule">}</span></span>
<span class="class">.error</span> <span class="class">.help-inline</span> <span class="rules">{ <span class="rule"><span class="attribute">padding-left</span>:<span class="value"> <span class="number">9</span>px</span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#B94A48</span></span></span>; <span class="rule">}</span></span>
<span class="tag">footer</span> <span class="rules">{ <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> right</span></span>; <span class="rule">}</span></span>
<span class="tag">dl</span><span class="class">.products</span> <span class="rules">{ <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule">}</span></span>
<span class="tag">dt</span> <span class="rules">{ <span class="rule"><span class="attribute">clear</span>:<span class="value"> right</span></span>; <span class="rule">}</span></span>
<span class="class">.barcode</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value">right</span></span>; <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">10</span>px</span></span>; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">4</span>px solid white</span></span>; <span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p><code>conf/application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="preprocessor">#  Be sure to use a different secret for your production</span>
<span class="preprocessor">#environment and never check that into your source code repository.</span>
application.secret=<span class="string">"Wd5HkNoRKdJP[kZJ@OV;HGa^&lt;4tDvgSfqn2PJeJnx4l0s77NTl"</span>
<span class="preprocessor"># application.langs="en,es,fr,nl"</span>
application.langs=<span class="string">"en"</span>
</pre></td></tr></table></figure>

<p>If you later want to copy entries from the default <code>application.conf</code> file,
you can find it in <code>$PLAY_HOME/framework/skeletons/scalaskel/conf/.</code></p>
<p>We’ll define in a messages file for each language:</p>
<ul>
<li><code>conf/messages—Default</code> messages for all languages, for messages not localized
for a particular language</li>
<li><code>conf/messages.es—Spanish</code> (which is called Español in Spanish)</li>
<li><code>conf/messages.fr—French</code> (Français in French)</li>
<li><code>conf/messages.nl—Dutch</code> (Nederlands in Dutch)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment"># conf/messages</span>
<span class="type">application</span>.<span class="property">name</span> = Product catalog
<span class="comment"># conf/messages.es</span>
<span class="type">application</span>.<span class="property">name</span> = Catálogo de productos
</pre></td></tr></table></figure>

<h2 id="adding-the-model">Adding the model</h2>
<p>We need to include three things in the example application’s model,</p>
<ul>
<li>A model class—The definition of the product and its attributes</li>
<li>A data access object (DAO)—Code that provides access to product data</li>
<li>Test data—A set of product objects</li>
</ul>
<p><code>app/models/Product.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">package</span> models
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(ean: Long, name: String, description: String)</span></span>

<span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">var</span> products = Set(Product(<span class="number">5010255079763</span>L, <span class="string">"Paperclips Large"</span>,<span class="string">"Large Plain Pack of 1000"</span>),
    Product(<span class="number">5018206244666</span>L, <span class="string">"Giant Paperclips"</span>,<span class="string">"Giant Plain 51mm 100 pack"</span>),
    Product(<span class="number">5018306332812</span>L, <span class="string">"Paperclip Giant Plain"</span>,<span class="string">"Giant Plain Pack of 10000"</span>),
    Product(<span class="number">5018306312913</span>L, <span class="string">"No Tear Paper Clip"</span>,<span class="string">"No Tear Extra Large Pack of 1000"</span>),
    Product(<span class="number">5018206244611</span>L, <span class="string">"Zebra Paperclips"</span>,<span class="string">"Zebra Length 28mm Assorted 150 Pack"</span>)
  )
  <span class="keyword">def</span> findAll = products.toList.sortBy(_.ean)
}
</pre></td></tr></table></figure>

<h2 id="product-list-page">Product list page</h2>
<p><code>app/views/products/list.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="xml"><span class="tag">&lt;!<span class="attribute">--</span> <span class="attribute">The</span> <span class="attribute">implicit</span> <span class="attribute">Lang</span> <span class="attribute">parameter</span> <span class="attribute">is</span> <span class="attribute">used</span> <span class="attribute">for</span> <span class="attribute">the</span> <span class="attribute">localized</span> <span class="attribute">message</span> <span class="attribute">--</span>&gt;</span>
<span class="comment">&lt;!-- lookup performed by the Messages object. --&gt;</span>
@(products: List[Product])(implicit lang: Lang)
@main(Messages("application.name")) {
  <span class="tag">&lt;<span class="title">dl</span> <span class="attribute">class</span>=<span class="value">"products"</span>&gt;</span>
  @for(product <span class="tag">&lt;<span class="title">-</span> <span class="attribute">products</span>) {
    &lt;<span class="attribute">dt</span>&gt;</span>@product.name<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dd</span>&gt;</span>@product.description<span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
  }
  <span class="tag">&lt;/<span class="title">dl</span>&gt;</span>
}</span>
</pre></td></tr></table></figure>

<h3 id="layout-template">Layout template</h3>
<p><code>app/views/main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>@(title: String)(content: Html)(implicit lang: Lang)

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>@title<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>
      <span class="attribute">href</span>=<span class="value">'@routes.Assets.at("stylesheets/bootstrap.css")'</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>
      <span class="attribute">href</span>=<span class="value">"@routes.Assets.at("</span><span class="value">stylesheets</span>/<span class="attribute">main.css</span>")"&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"screenshot"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"navbar navbar-fixed-top"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"navbar-inner"</span>&gt;</span>
          <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"brand"</span> <span class="attribute">href</span>=<span class="value">"@routes.Application.index()"</span>&gt;</span>
              @Messages("application.name")
            <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
          <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>@content<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="controller-action-method">Controller action method</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="keyword">import</span> models.Product

<span class="class"><span class="keyword">object</span> <span class="title">Products</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> list = Action { implicit request =&gt;
    <span class="keyword">val</span> products = Product.findAll
    Ok(views.html.products.list(products))
  }
}
</pre></td></tr></table></figure>

<h3 id="adding-a-routes-configuration">Adding a routes configuration</h3>
<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>GET / controllers.Application.index

GET /products controllers.Products.<span class="type">list</span>

GET /assets/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public"</span>, <span class="type">file</span>)
</pre></td></tr></table></figure>

<h3 id="replacing-the-welcome-page-with-a-redirect">Replacing the welcome page with a redirect</h3>
<p><code>app/controllers/Application.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers
<span class="keyword">import</span> play.api.mvc.{Action, Controller}

<span class="class"><span class="keyword">object</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> index = Action {
    Redirect(routes.Products.list())
  }
}
</pre></td></tr></table></figure>

<p>Delete <code>app/views/index.scala.html</code> template.</p>
<h3 id="checking-the-language-localizations">Checking the language localizations</h3>
<p><code>app/views/debug.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>@()(implicit lang: Lang)

@import play<span class="preprocessor">.api</span><span class="preprocessor">.Play</span><span class="preprocessor">.current</span>

&lt;footer&gt;
  lang = @lang<span class="preprocessor">.code</span>,
  user = @current<span class="preprocessor">.configuration</span><span class="preprocessor">.getString</span>(<span class="string">"environment.user"</span>),
  date = @(new java<span class="preprocessor">.util</span><span class="preprocessor">.Date</span>()<span class="preprocessor">.format</span>(<span class="string">"yyyy-MM-dd HH:mm"</span>))
&lt;/footer&gt;
</pre></td></tr></table></figure>

<p><code>conf/application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment"># USER is an environment variable</span>
environment.user=<span class="variable">${USER}</span>
</pre></td></tr></table></figure>

<p><code>app/views/main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;div <span class="keyword">class</span>=<span class="string">"container"</span>&gt;
<span class="keyword">@content</span>
<span class="keyword">@debug</span>()
&lt;/div&gt;
</pre></td></tr></table></figure>

<h2 id="details-page">Details page</h2>
<p>The page’s URL, for example <code>/products/5010255079763</code>, includes the EAN code,
which is also used to generate a bar code image</p>
<ul>
<li>A new finder method—To fetch one specific product</li>
<li>A view template—To show this details page</li>
<li>An HTTP routing configuration—For a URL with a parameter</li>
<li>A bar code image—To display on the page</li>
</ul>
<h3 id="model-finder-method">Model finder method</h3>
<p><code>app/models/Product.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">def</span> findByEan(ean: Long) = products.find(_.ean == ean)
}
</pre></td></tr></table></figure>

<h3 id="details-page-template">Details page template</h3>
<p><code>app/views/products/details.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>@(product: Product)(implicit lang: Lang)
@main(Messages("products.details", product.name)) {
  <span class="tag">&lt;<span class="title">h2</span>&gt;</span>
    <span class="comment">&lt;!-- 生成横条码  --&gt;</span>
    @tags.barcode(product.ean)
    @Messages("products.details", product.name)
  <span class="tag">&lt;/<span class="title">h2</span>&gt;</span>

  <span class="tag">&lt;<span class="title">dl</span> <span class="attribute">class</span>=<span class="value">"dl-horizontal"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dt</span>&gt;</span>@Messages("ean"):<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dd</span>&gt;</span>@product.ean<span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dt</span>&gt;</span>@Messages("name"):<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dd</span>&gt;</span>@product.name<span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dt</span>&gt;</span>@Messages("description"):<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dd</span>&gt;</span>@product.description<span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">dl</span>&gt;</span>

}
</pre></td></tr></table></figure>

<p><code>app/views/tags/barcode.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>@(ean: <span class="built_in">Long</span>)
&lt;img <span class="keyword">class</span>=<span class="string">"barcode"</span> alt=<span class="string">"@ean"</span> src=<span class="string">"@routes.Barcodes.barcode(ean)"</span>&gt;
</pre></td></tr></table></figure>

<h3 id="additional-message-localizations">Additional message localizations</h3>
<p><code>conf/messages</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="constant">ean</span> = EAN
<span class="constant">name</span> = Name
<span class="constant">description</span> = Description

products.details = Product: {0}
</pre></td></tr></table></figure>

<p><code>conf/messages.es</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="constant">ean</span> = EAN
<span class="constant">name</span> = Nombre
<span class="constant">description</span> = Descripción

products.details = Producto: {0}
</pre></td></tr></table></figure>

<h3 id="adding-a-parameter-to-a-controller-action">Adding a parameter to a controller action</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>def show(ean: Long) = Action { implicit request =&gt;
  Product<span class="preprocessor">.findByEan</span>(ean)<span class="preprocessor">.map</span> { product =&gt;
    Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.details</span>(product))
  }<span class="preprocessor">.getOrElse</span>(NotFound)
}
</pre></td></tr></table></figure>

<h3 id="adding-a-parameter-to-a-route">Adding a parameter to a route</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">GET</span> /products/:ean controllers.Products.show(ean: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h3 id="generating-a-bar-code-image">Generating a bar code image</h3>
<p><code>project/Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>val appDependencies = Se<span class="string">q(
  "net.sf.barcode4j" % "barcode4j" % "2.0"
)</span>
</pre></td></tr></table></figure>

<p><code>app/controllers/Barcodes.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}

<span class="class"><span class="keyword">object</span> <span class="title">Barcodes</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">val</span> ImageResolution = <span class="number">144</span>
  <span class="comment">// Action that returns PNG response</span>
  <span class="keyword">def</span> barcode(ean: Long) = Action {
    <span class="keyword">import</span> java.lang.IllegalArgumentException
    <span class="keyword">val</span> MimeType = <span class="string">"image/png"</span>
    <span class="keyword">try</span> {
      <span class="keyword">val</span> imageData = ean13BarCode(ean, MimeType)
      Ok(imageData).as(MimeType)
    } <span class="keyword">catch</span> {
      <span class="keyword">case</span> e: IllegalArgumentException =&gt;
        BadRequest(<span class="string">"Couldn’t generate bar code. Error: "</span> + e.getMessage)
    }
  }
  <span class="keyword">def</span> ean13BarCode(ean: Long, mimeType: String): Array[Byte] = {
    <span class="keyword">import</span> java.io.ByteArrayOutputStream
    <span class="keyword">import</span> java.awt.image.BufferedImage
    <span class="keyword">import</span> org.krysalis.barcode4j.output.bitmap.BitmapCanvasProvider
    <span class="keyword">import</span> org.krysalis.barcode4j.impl.upcean.EAN13Bean
    <span class="keyword">val</span> output: ByteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream
    <span class="keyword">val</span> canvas: BitmapCanvasProvider =
      <span class="keyword">new</span> BitmapCanvasProvider(output, mimeType, ImageResolution,
        BufferedImage.TYPE_BYTE_BINARY, <span class="keyword">false</span>, <span class="number">0</span>)
    <span class="keyword">val</span> barcode = <span class="keyword">new</span> EAN13Bean()
    barcode.generateBarcode(canvas, String valueOf ean)
    canvas.finish
    output.toByteArray
  }
}
</pre></td></tr></table></figure>

<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">GET</span> /barcode/:ean controllers.Barcodes.barcode(ean: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h2 id="adding-a-new-product">Adding a new product</h2>
<h3 id="additional-message-localizations">Additional message localizations</h3>
<p><code>conf/messages</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>products<span class="preprocessor">.form</span> = Product details
products<span class="preprocessor">.new</span> = (new)
products<span class="preprocessor">.new</span><span class="preprocessor">.command</span> = New

products<span class="preprocessor">.new</span><span class="preprocessor">.submit</span> = <span class="keyword">Add</span>
products<span class="preprocessor">.new</span><span class="preprocessor">.success</span> = Successfully added product {<span class="number">0</span>}.

validation<span class="preprocessor">.errors</span> = Please correct the errors <span class="keyword">in</span> the form.
validation<span class="preprocessor">.ean</span><span class="preprocessor">.duplicate</span> = A product with this EAN code already exists
</pre></td></tr></table></figure>

<h3 id="form-object">Form object</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>import play<span class="preprocessor">.api</span><span class="preprocessor">.data</span><span class="preprocessor">.Form</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.data</span><span class="preprocessor">.Forms</span>.{mapping, longNumber, nonEmptyText}
import play<span class="preprocessor">.api</span><span class="preprocessor">.i</span>18n<span class="preprocessor">.Messages</span>

private val productForm: Form[Product] = Form(
  mapping(
    <span class="string">"ean"</span> -&gt; longNumber<span class="preprocessor">.verifying</span>(
      <span class="string">"validation.ean.duplicate"</span>, Product<span class="preprocessor">.findByEan</span>(_)<span class="preprocessor">.isEmpty</span>),
    <span class="string">"name"</span> -&gt; nonEmptyText,
    <span class="string">"description"</span> -&gt; nonEmptyTest
  )(Product<span class="preprocessor">.apply</span>)(Product<span class="preprocessor">.unapply</span>)
)
</pre></td></tr></table></figure>

<h3 id="form-template">Form template</h3>
<p><code>app/views/main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container"</span>&gt;
  &lt;a <span class="type">class</span>=<span class="string">"brand"</span> href=<span class="string">"@routes.Application.index()"</span>&gt;
    @Messages(<span class="string">"application.name"</span>)
  &lt;/a&gt;
  &lt;ul <span class="type">class</span>=<span class="string">"nav"</span>&gt;
    &lt;li <span class="type">class</span>=<span class="string">"divider-vertical"</span>&gt;&lt;/li&gt;
    &lt;li <span class="type">class</span>=<span class="string">"active"</span>&gt;
      &lt;a href=<span class="string">"@routes.Products.list()"</span>&gt;
        @Messages(<span class="string">"products.list.navigation"</span>)
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li <span class="type">class</span>=<span class="string">"active"</span>&gt;
      &lt;a href=<span class="string">"@routes.Products.newProduct()"</span>&gt;
        &lt;i <span class="type">class</span>=<span class="string">"icon-plus icon-white"</span>&gt;&lt;/i&gt;
        @Messages(<span class="string">"products.new.command"</span>)
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li <span class="type">class</span>=<span class="string">"divider-vertical"</span>&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/<span class="keyword">div</span>&gt;

&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container"</span>&gt;
  @<span class="keyword">if</span>(flash.<span class="keyword">get</span>(<span class="string">"success"</span>).isDefined){
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"alert alert-success"</span>&gt;
      @flash.<span class="keyword">get</span>(<span class="string">"success"</span>)
    &lt;/<span class="keyword">div</span>&gt;
  }
  @<span class="keyword">if</span>(flash.<span class="keyword">get</span>(<span class="string">"error"</span>).isDefined){
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"alert alert-error"</span>&gt;
      @flash.<span class="keyword">get</span>(<span class="string">"error"</span>)
    &lt;/<span class="keyword">div</span>&gt;
  }
  @content
  @debug()
&lt;/<span class="keyword">div</span>&gt;
</pre></td></tr></table></figure>

<p><code>app/views/products/list.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@controllers.routes.Products.newProduct()"</span> <span class="attribute">class</span>=<span class="value">"btn"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">i</span> <span class="attribute">class</span>=<span class="value">"icon-plus"</span>&gt;</span><span class="tag">&lt;/<span class="title">i</span>&gt;</span> @Messages("products.new.command")<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</pre></td></tr></table></figure>

<p><code>app/views/products/editProduct.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="at_rule">@(productForm:<span class="preprocessor"> Form</span>[Product])(implicit<span class="preprocessor"> flash</span>:<span class="preprocessor"> Flash</span>,<span class="preprocessor"> lang</span>:<span class="preprocessor"> Lang</span>)

&lt;!--<span class="preprocessor"> Twitter</span><span class="preprocessor"> Bootstrap</span><span class="preprocessor"> helpers</span><span class="preprocessor"> --</span>&gt;
@<span class="keyword">import</span><span class="preprocessor"> helper._</span>
@<span class="keyword">import</span><span class="preprocessor"> helper.twitterBootstrap._</span>

@<span class="function">main(<span class="function">Messages(<span class="string">"products.form"</span>)</span>)</span> {</span>
  &lt;<span class="tag">h2</span>&gt;<span class="at_rule">@<span class="function">Messages(<span class="string">"products.form"</span>)</span>&lt;/h2&gt;

  @helper.<span class="function">form(action = routes.Products.<span class="function">save()</span>)</span> {</span>
    &lt;<span class="tag">fieldset</span>&gt;
      &lt;<span class="tag">legend</span>&gt;
        <span class="at_rule">@<span class="function">Messages(<span class="string">"products.details"</span>, <span class="function">Messages(<span class="string">"products.new"</span>)</span>)</span>
      &lt;/legend&gt;
      @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"ean"</span>)</span>)</span>
      @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"name"</span>)</span>)</span>
      @helper.<span class="function">textarea(<span class="function">productForm(<span class="string">"description"</span>)</span>)</span>
    &lt;/fieldset&gt;
    &lt;p&gt;&lt;input<span class="preprocessor"> type</span>=<span class="string">"submit"</span><span class="preprocessor"> class</span>=<span class="string">"btn primary"</span><span class="preprocessor"> value</span>=<span class="string">'@Messages("products.new.submit")'</span>&gt;&lt;/p&gt;
  }
}</span>
</pre></td></tr></table></figure>

<h3 id="saving-the-new-product">Saving the new product</h3>
<p><code>app/models/Product.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">def</span> add(product: Product) {
    products = products + product
  }
}
</pre></td></tr></table></figure>

<h3 id="validating-the-user-input">Validating the user input</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>import play<span class="preprocessor">.api</span><span class="preprocessor">.mvc</span><span class="preprocessor">.Flash</span>

def save = Action {implicit request =&gt;
  val newProductForm = productForm<span class="preprocessor">.bindFromRequest</span>()
  newProductForm<span class="preprocessor">.fold</span>(
    hasErrors = { form =&gt;
      Redirect(route<span class="preprocessor">.Products</span><span class="preprocessor">.newProduct</span>()).
        flashing(Flash(form<span class="preprocessor">.data</span>) +
          (<span class="string">"error"</span> -&gt; Messages(<span class="string">"validation.errors"</span>)))
    },
    success = { newProduct =&gt;
      Product<span class="preprocessor">.add</span>(newProduct)
      Redirect(routes<span class="preprocessor">.Products</span><span class="preprocessor">.show</span>(newProduct<span class="preprocessor">.ean</span>)).
        flashing(<span class="string">"success"</span> -&gt; message)
    }
  )
}

def newProduct = Action { implicit request =&gt;
  val form = if (flash<span class="preprocessor">.get</span>(<span class="string">"error"</span>)<span class="preprocessor">.isDefined</span>)
    productForm<span class="preprocessor">.bind</span>(flash<span class="preprocessor">.data</span>)
  else
    productForm
    
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.editProduct</span>(form))
}
</pre></td></tr></table></figure>

<h3 id="adding-the-routes-for-saving-products">Adding the routes for saving products</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>POST /products controllers<span class="preprocessor">.Products</span><span class="preprocessor">.save</span>

GET /products/new controllers<span class="preprocessor">.Products</span><span class="preprocessor">.newProduct</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Integration]]></title>
    <link href="http://zhpooer.github.io/2014/08/06/akka-in-action-integration/"/>
    <id>http://zhpooer.github.io/2014/08/06/akka-in-action-integration/</id>
    <published>2014-08-06T06:45:54.000Z</published>
    <updated>2014-08-07T02:17:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="message-endpoints">Message endpoints</h1>
<p>The implementation of an interface between two systems isn&#39;t always
easy, because the interface contains two areas: the transport layer and the data
which is sent over this transport layer.</p>
<p>For example, we are creating an order system for use in a book
stockroom, that processes orders from all kinds of customers. These customers can
order the books by visiting the store. The bookstore already uses an application to
sell and order books.  So the new system needs to exchange data with this existing
application.</p>
<p>Because you probably can&#39;t change the external
application, you have to create a component that can send and/or receive messages
from the existing application. This component is called an endpoint. Endpoints are
part of your system and are the glue between the external system and the rest of
your system.</p>
<p>There are a lot of different transport protocols to potentially
support: REST/HTTP, TCP, MQueues, or simple files. </p>
<h2 id="normalizer">Normalizer</h2>
<p>We have seen that our order system receives the orders from the bookshop
application, but it is possible that our system also receives orders from a web shop,
or by customers sending email.</p>
<p>We can use the Normalizer pattern to make these
different sources all feed into a single interface on the application side. The pattern
translates the different external messages to a common, canonical message.</p>
<p>We create three different endpoints to consume the different messages, but
translate them into the same message, which is sent to the rest of the system.</p>
<p><img src="/img/akka_order_system.png" alt="akka order system"></p>
<p>Translating the different messages into a common message is called the
Normalizer pattern.</p>
<p> Let us assume that
there is another bookshop that is connecting to this system using the same
messages but using MQueue to send those message.</p>
<p><img src="/img/akka_normalizer.png" alt="akka normalizer partern"></p>
<h2 id="canonical-data-model">Canonical Data Model</h2>
<p> But when the connectivity requirements between the systems
increases we need more and more endpoints.</p>
<p>To solve this problem, we can use the Canonical Data Model. This pattern
connects multiple applications using interface(s) that are independent of any
specific system.</p>
<p>When the Bookshop application
wants to send a message to the order system, the message is first translated to the
canonical format and then it is sent using the common transport layer.</p>
<p>The Normalizer
pattern is used to connect several similar clients to another system. But when the
number of integrated systems increases, we need the Canonical Data Model, which
looks like the Normalizer Pattern, because it also uses normalized messages.</p>
<p>The difference is that the Canonical Data Model provides an additional level of
indirection between the application&#39;s individual data formats and those used by the
remote systems. While the Normalizer is only within one application.</p>
<h1 id="camel-framework">Camel Framework</h1>
<p>Camel is an apache framework whose goal is to make integration easier and more
accessible. It makes it possible to implement the standard enterprise integration
patterns in a few lines of code. This is achieved by addressing three areas:</p>
<ol>
<li>Concrete implementations of the widely used Enterprise Integration Patterns</li>
<li>Connectivity to a great variety of transports and APIs</li>
<li>Easy to use Domain Specific Languages (DSLs) to wire EIPs and transports together</li>
</ol>
<p>The Camel module works internally with Camel classes. Important Camel
classes are the camel context and the ProducerTemplate. The CamelContext
represents a single Camel routing rule base, and the ProducerTemplate is needed
when producing messages.</p>
<h2 id="implement-a-consumer-endpoint">Implement a consumer endpoint</h2>
<p>The example we are going to implement is an Order System receiving messages
from a bookshop. 
Let&#39;s say the received messages are XML files in a
directory. The transport layer is in this case the file system. The endpoint of the
order system needs to track new files and when there is a new file it has to parse
the XML content and create a message the system can process.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">// Consumer Endpoint</span>

<span class="keyword">import</span> akka.camel.{CamelMessage, Consumer}

<span class="class"><span class="keyword">class</span> <span class="title">OrderConsumerXml</span><span class="params">(uri:String, next:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Consumer</span>{</span>
  <span class="comment">// override the endpointUri</span>
  <span class="keyword">def</span> endpointUri = uri

  <span class="comment">// receive the Camel message</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg:CamelMessage =&gt; {
      <span class="keyword">val</span> content = msg.bodyAs[String]
      <span class="keyword">val</span> xml = XML.loadString(content)
      <span class="keyword">val</span> order = xml\\<span class="string">"order"</span>
      <span class="keyword">val</span> customer = (order \\ <span class="string">"customerId"</span>).text
      <span class="keyword">val</span> productId = (order \\ <span class="string">"productId"</span>).text
      <span class="keyword">val</span> number = (order \\ <span class="string">"number"</span>).text.toInt
      next ! <span class="keyword">new</span> Order(customer, productId, number)
    }
  }
}

<span class="comment">// This Uri starts with the Camel component.</span>
<span class="comment">// http://camel.apache.org/components.html</span>
<span class="keyword">val</span> camelUri = <span class="string">"file:messages"</span>
</pre></td></tr></table></figure>

<p>When a new message is received, it comes to the Actor through its usual
method, as a CamelMessage. A CamelMessage contains a body, which is the
actual message received, and a map of headers. The content of these headers
depends on the protocol used. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">val</span> probe = TestProbe()
<span class="keyword">val</span> camelUri = <span class="string">"file:messages"</span>
<span class="keyword">val</span> consumer = system.actorOf(Props(<span class="keyword">new</span> OrderConsumerXml(camelUri, probe.<span class="keyword">ref</span>)))
</pre></td></tr></table></figure>

<p>Because we use the Camel Consumer trait, a lot of components are started and
we have to wait for these components before we can proceed with our test. To be
able detect that Camel&#39;s startup has finished, we need to use the CamelExtension.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>val camelExtention = CamelExtension(<span class="keyword">system</span>)
val activated =
  camelExtention.activationFutureFor(consumer)(timeout = <span class="number">10</span> <span class="built_in">seconds</span>, executor = <span class="keyword">system</span>.dispatcher)
Await.<span class="built_in">result</span>(activated, <span class="number">5</span> <span class="built_in">seconds</span>)


val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml =
  &lt;order&gt;
    &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
    &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
    &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
  &lt;/order&gt;
val msgFile = <span class="built_in">new</span> File(dir, <span class="string">"msg1.xml"</span>)
FileUtils.<span class="built_in">write</span>(msgFile, xml.toString())
probe.expectMsg(msg)
<span class="keyword">system</span>.stop(consumer)
</pre></td></tr></table></figure>

<h2 id="changing-the-transport-layer-of-our-consumer">CHANGING THE TRANSPORT LAYER OF OUR CONSUMER</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>val probe = TestProbe()
val camelUri = <span class="string">"mina:tcp://localhost:8888?textline=true&sync=false"</span>
val consumer = <span class="keyword">system</span>.actorOf(Props(<span class="built_in">new</span> OrderConsumerXml(camelUri, probe.ref)))

val activated =
  CamelExtension(<span class="keyword">system</span>).activationFutureFor(consumer)(timeout = <span class="number">10</span> <span class="built_in">seconds</span>, executor = <span class="keyword">system</span>.dispatcher)
  
Await.<span class="built_in">result</span>(activated, <span class="number">5</span> <span class="built_in">seconds</span>)
val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml = &lt;order&gt;
            &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
            &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
            &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
          &lt;/order&gt;
val xmlStr = xml.toString().<span class="built_in">replace</span>(<span class="string">"n"</span>, <span class="string">""</span>)

val sock = <span class="built_in">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8888</span>)
val ouputWriter = <span class="built_in">new</span> PrintWriter(sock.getOutputStream, <span class="constant">true</span>)
ouputWriter.println(xmlStr)
ouputWriter.flush()
probe.expectMsg(msg)
ouputWriter.<span class="built_in">close</span>()
<span class="keyword">system</span>.stop(consumer)
</pre></td></tr></table></figure>

<ul>
<li><code>textline=true</code>, This indicates that we are expecting plain text over this connection and that each message
is ended with a newline</li>
<li><code>sync=false</code>, This indicates that we don&#39;t create a response</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">def</span> receive = {
  <span class="keyword">case</span> msg: CamelMessage =&gt; {
    <span class="keyword">try</span> {
      <span class="keyword">val</span> content = msg.bodyAs[String]
      <span class="keyword">val</span> xml = XML.loadString(content)
      <span class="keyword">val</span> order = xml \ <span class="string">"order"</span>
      <span class="keyword">val</span> customer = (order \ <span class="string">"customerId"</span>).text
      <span class="keyword">val</span> productId = (order \ <span class="string">"productId"</span>).text
      <span class="keyword">val</span> number = (order \ <span class="string">"number"</span>).text.toInt
      next ! <span class="keyword">new</span> Order(customer, productId, number)
      sender ! <span class="string">"&lt;confirm&gt;OK&lt;/confirm&gt;"</span>
    } <span class="keyword">catch</span> {
      <span class="comment">// 如果是同步的通信, 发生错误, actor重启, 会失去发送者的信息</span>
      <span class="keyword">case</span> ex: Exception =&gt;
        sender ! <span class="string">"&lt;confirm&gt;%s&lt;/confirm&gt;"</span>.format(ex.getMessage)
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="using-the-camel-context">USING THE CAMEL CONTEXT</h2>
<p>For example when we want to use the ActiveMQ component. To be able to use
this we need to add the component to the Camel context and define the MQ broker.
This requires the camel context.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>// Component name should be used <span class="keyword">in</span> the Uri
val camelContext = CamelExtension(system)<span class="preprocessor">.context</span>
camelContext<span class="preprocessor">.addComponent</span>(<span class="string">"activemq"</span>,
  ActiveMQComponent<span class="preprocessor">.activeMQComponent</span>(
    <span class="string">"vm:(broker:(tcp://localhost:8899)?persistent=false)"</span>))

val camelUri = <span class="string">"activemq:queue:xmlTest"</span>
val consumer = system<span class="preprocessor">.actorOf</span>(
    Props(new OrderConsumerXml(camelUri, probe<span class="preprocessor">.ref</span>)))
val activated = CamelExtension(system)<span class="preprocessor">.activationFutureFor</span>(
    consumer)(timeout = <span class="number">10</span> seconds, executor = system<span class="preprocessor">.dispatcher</span>)
...
sendMQMessage(xml<span class="preprocessor">.toString</span>())
probe<span class="preprocessor">.expectMsg</span>(msg)
system<span class="preprocessor">.stop</span>(consumer)

// Because a broker is started, we also need to stop them when we are ready. 
// This can be done using the BrokerRegistry of ActiveMQ
val brokers = BrokerRegistry<span class="preprocessor">.getInstance</span>()<span class="preprocessor">.getBrokers</span>
brokers<span class="preprocessor">.foreach</span> { case (name, broker) =&gt; broker<span class="preprocessor">.stop</span>() }
</pre></td></tr></table></figure>

<h2 id="implement-a-producer-endpoint">Implement a producer endpoint</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.camel.Producer

<span class="class"><span class="keyword">class</span> <span class="title">SimpleProducer</span><span class="params">(uri: Strint)</span> <span class="keyword">extends</span> <span class="title">Producer</span> {</span>
  <span class="keyword">def</span> endpointUri = uri
}

implicit <span class="keyword">val</span> ExecutionContext = system.dispatcher
<span class="keyword">val</span> probe = TestProbe()
<span class="keyword">val</span> camelUri =
  <span class="string">"mina:tcp://localhost:8888?textline=true&sync=false"</span>
<span class="keyword">val</span> consumer = system.actorOf(
  Props(<span class="keyword">new</span> OrderConsumerXml(camelUri, probe.ref)))
  
<span class="keyword">val</span> producer = system.actorOf(
  Props(<span class="keyword">new</span> SimpleProducer(camelUri)))
<span class="keyword">val</span> activatedCons = CamelExtension(system).activationFutureFor(
  consumer)(timeout = <span class="number">10</span> seconds, executor = system.dispatcher)
<span class="keyword">val</span> activatedProd = CamelExtension(system).activationFutureFor(
  producer)(timeout = <span class="number">10</span> seconds, executor = system.dispatcher)
  
<span class="keyword">val</span> camel = Future.sequence(List(activatedCons, activatedProd))
Await.result(camel, <span class="number">5</span> seconds)
</pre></td></tr></table></figure>

<p>Here we can do the translation of our message to the expected XML</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderProducerXml</span><span class="params">(uri: String)</span> <span class="keyword">extends</span> <span class="title">Producer</span> {</span>
  <span class="keyword">def</span> endpointUri = uri
  <span class="keyword">override</span> <span class="keyword">def</span> oneway: Boolean = <span class="keyword">false</span>
  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> transformOutgoingMessage(message: Any): Any = {
    message <span class="keyword">match</span> {
      <span class="keyword">case</span> msg: Order =&gt; {
        <span class="keyword">val</span> xml = &lt;order&gt;
          &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
          &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
          &lt;number&gt;{ msg.number }&lt;/number&gt;
        &lt;/order&gt;
        
        xml.toString().replace(<span class="string">"n"</span>, <span class="string">""</span>)
      }
      <span class="keyword">case</span> other =&gt; message
    }
  }
  
  <span class="comment">// 反向序列化</span>
  <span class="keyword">override</span> <span class="keyword">def</span> transformResponse(message: Any): Any = {
    message <span class="keyword">match</span> {
      <span class="keyword">case</span> msg: CamelMessage =&gt; {
        <span class="keyword">try</span> {
          <span class="keyword">val</span> content = msg.bodyAs[String]
          <span class="keyword">val</span> xml = XML.loadString(content)
          (xml \ <span class="string">"confirm"</span>).text
        } <span class="keyword">catch</span> {
          <span class="keyword">case</span> ex: Exception =&gt;
            <span class="string">"TransformException: %s"</span>.format(ex.getMessage)
        }
      }
      <span class="keyword">case</span> other =&gt; message
    }
  }
}
</pre></td></tr></table></figure>

<p>There is a method called routeResponse.
This method is responsible for sending the received
response to the original sender. </p>
<h1 id="example-of-implementing-a-rest-interface">Example of implementing a REST interface</h1>
<p>REST is a standard protocol to expose intuitive interfaces
to systems. We are still creating an endpoint for our system.</p>
<p>Spray is an open-source toolkit for REST/HTTP and low-level network IO on
top of Scala and Akka.</p>
<p>We start by defining the
messages for both interfaces. The Order system will support two functions. The
first function is to add a new order and the second function is to get the status of an
order. The REST interface we are going to implement supports a POST and a GET.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">ProcssOrders</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  val orderList = <span class="keyword">new</span> mutable.HashMap[Long, TrackingOrder]
  val lastOrderId = <span class="number">0</span>L

  def receive = {
    <span class="keyword">case</span> order:Order =&gt; {
      lastOrderId += <span class="number">1</span>
      val newOrder = <span class="keyword">new</span> TrackingOrder(lastOrderId, <span class="string">"received"</span>, order)
      orderList += lastOrdered -&gt; newOrder
      sender ! newOrder
    }
    <span class="keyword">case</span> order:OrderId =&gt; {
      orderList.get(order.id) match {
        <span class="keyword">case</span> Some(intOrder) =&gt;
          sender ! intOrder.copy(status=<span class="string">"process"</span>)
        <span class="keyword">case</span> None =&gt; sender ! NoSuchOrder(order.id)
      }
    }
    <span class="keyword">case</span> <span class="string">"reset"</span> =&gt; {
      lastOrderId = <span class="number">0</span>
      orderList.clear()
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="implementing-a-rest-endpoint-with-spray">Implementing a Rest endpoint with Spray</h2>
<p>Spray also has it own test kit and is able to test your code without
building a complete application.</p>
<p>When you need REST/HTTP support, Spray is a great way to connect your Akka
applications to other Systems.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre>import spray.routing.HttpService

trait OrderService extends HttpService {
  val myRoute = path("orderTest") {
    get {
      parameters('id.as[Long]).as(OrderId) { orderId =&gt;
        complete {
          val askFuture = orderSystem ? orderId
          askFuture.map {
            case result:TrackingOrder =&gt; {
              <span class="tag">&lt;<span class="title">statusResponse</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{result.id}<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>{result.status}<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">statusResponse</span>&gt;</span>
            }
            case result:NoSuchOrder =&gt; {
              <span class="tag">&lt;<span class="title">statusResponse</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{result.id}<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>ID is unknown<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">statusResponse</span>&gt;</span>
            }
          }
        }
      }
    } ~
    post {
      //add order
      entity(as[String]) { body =&gt;
        val order = XMLConverter.createOrder(body.toString)
        complete {
          val askFuture = orderSystem ? order
          askFuture.map {
            case result: TrackingOrder =&gt; {
              <span class="tag">&lt;<span class="title">confirm</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{ result.id }<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>{ result.status }<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">confirm</span>&gt;</span>.toString()
            }
            case result: Any =&gt; {
              <span class="tag">&lt;<span class="title">confirm</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>
                  Response is unknown{ result.toString() }
                <span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">confirm</span>&gt;</span>.toString()
            }
          }
        }
      }
    }
  }
}
class OrderServiceActor (val orderSystem:ActorRef) extends Actor with OrderService {
  // actorRefFactory used by Spray framework
  def actorRefFactory = context
  
  // use Spray Route
  def receive = runRoute(myRoute)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderHttpServer</span><span class="params">(host: String, portNr: Int, orderSystem: ActorRef)</span></span>
    <span class="keyword">extends</span> SprayCanHttpServerApp {
  <span class="comment">//create and start our service actor</span>
  <span class="keyword">val</span> service = system.actorOf(Props(
    <span class="keyword">new</span> OrderServiceActor(orderSystem)), <span class="string">"my-service"</span>)
  <span class="comment">//create a new HttpServer using our handler tell it where to bind to</span>
  <span class="keyword">val</span> httpServer = newHttpServer(service)
  httpServer ! Bind(interface = host, port = portNr)
  
  <span class="keyword">def</span> stop() {
    system.stop(httpServer)
    system.shutdown()
  }
}
</pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre>val orderSystem = <span class="keyword">system</span>.actorOf(Props[OrderSystem])
val orderHttp = <span class="built_in">new</span> OrderHttpServer(<span class="string">"localhost"</span>, <span class="number">8181</span>, orderSystem)

orderSystem ! <span class="string">"reset"</span>
val url = <span class="string">"http://localhost:8181/orderTest"</span>
val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml =
  &lt;order&gt;
    &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
    &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
    &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
  &lt;/order&gt;

val urlConnection = <span class="built_in">new</span> <span class="built_in">URL</span>(url)
val conn = urlConnection.openConnection()
conn.setDoOutput(<span class="constant">true</span>)
conn.setRequestProperty(<span class="string">"Content-type"</span>, <span class="string">"text/xml; charset=UTF-8"</span>)
val writer = <span class="built_in">new</span> OutputStreamWriter(conn.getOutputStream)
writer.<span class="built_in">write</span>(xml.toString())
writer.flush()
<span class="comment">
//check result</span>
val reader = <span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader((conn.getInputStream)))
val response = <span class="built_in">new</span> StringBuffer()
var <span class="built_in">line</span> = reader.readLine()
<span class="keyword">while</span> (<span class="built_in">line</span> != <span class="constant">null</span>) {
  response.append(<span class="built_in">line</span>)
  <span class="built_in">line</span> = reader.readLine()
}
writer.<span class="built_in">close</span>()
reader.<span class="built_in">close</span>()

conn.getHeaderField(<span class="constant">null</span>) must be(<span class="string">"HTTP/1.1 200 OK"</span>)
val responseXml = XML.loadString(response.toString)
val confirm = responseXml \ <span class="string">"confirm"</span>

(confirm \ <span class="string">"id"</span>).<span class="keyword">text</span> must be(<span class="string">"1"</span>)
(confirm \ <span class="string">"status"</span>).<span class="keyword">text</span> must be(<span class="string">"received"</span>)

val url2 = <span class="string">"http://localhost:8181/orderTest?id=1"</span>


val urlConnection2 = <span class="built_in">new</span> <span class="built_in">URL</span>(url2)
val conn2 = urlConnection2.openConnection()<span class="comment">
//Get response</span>
val reader2 = <span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader((conn2.getInputStream)))
val response2 = <span class="built_in">new</span> StringBuffer()
<span class="built_in">line</span> = reader2.readLine()
<span class="keyword">while</span> (<span class="built_in">line</span> != <span class="constant">null</span>) {
  response2.append(<span class="built_in">line</span>)
  <span class="built_in">line</span> = reader2.readLine()
}
reader2.<span class="built_in">close</span>()
<span class="comment">
// check response</span>
conn2.getHeaderField(<span class="constant">null</span>) must be(<span class="string">"HTTP/1.1 200 OK"</span>)
val responseXml2 = XML.loadString(response2.toString)
val status = responseXml2 \ <span class="string">"statusResponse"</span>

(status \ <span class="string">"id"</span>).<span class="keyword">text</span> must be(<span class="string">"1"</span>)
(status \ <span class="string">"status"</span>).<span class="keyword">text</span> must be(<span class="string">"processing"</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Working with Transactions]]></title>
    <link href="http://zhpooer.github.io/2014/08/06/akka-in-action-working-with-transactions/"/>
    <id>http://zhpooer.github.io/2014/08/06/akka-in-action-working-with-transactions/</id>
    <published>2014-08-06T01:47:35.000Z</published>
    <updated>2014-08-06T03:49:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="software-transactional-memory">Software Transactional Memory</h1>
<p>We have an event and we have a number of seats that multiple
threads want to lay claim to. Our shared data is a list of seats</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Seat</span><span class="params">(seatNumber:Int)</span></span>
<span class="keyword">val</span> availableSeats: Seq[Seat])

<span class="comment">// When we want to get a seat from the list we need to</span>
<span class="comment">// get the first available seat and update the list.</span>
<span class="keyword">val</span> head = availableSeats.head
availableSeats = availableSeats.tail
</pre></td></tr></table></figure>

<p>When we can&#39;t or want to use immutable messages
and just want to protect the shared data from becoming inconsistent.</p>
<h2 id="protecting-shared-data">Protecting Shared data</h2>
<p>The most common solution to protecting shared data is that when a thread wants to
access the shared data, we block all other threads from accessing the shared
structure.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val reservedSeat = availableSeats<span class="preprocessor">.synchronized</span> {
  head = availableSeats<span class="preprocessor">.head</span>
  availableSeats = availableSeats<span class="preprocessor">.tail</span>
  head
}
</pre></td></tr></table></figure>

<p>A problem with this is that when a thread only wants to read all available seats
it still has to lock the list too.</p>
<p>All this locking decreases the performance of the system.</p>
<p>This is called &quot;pessimistic locking”.</p>
<p>Clearly, since there is &#39;pessimistic locking,&#39; there must also be &#39;optimistic
locking.&#39;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>import concurrent.stm.Ref
val availableSeats = Ref(Seq[<span class="link_label">Seat</span>](<span class="link_url"></span>))

//  update our availableSeats we can write
availableSeats() = availableSeats().tail

// When we want to protect the seat list, we get the following 
import concurrent.stm._
val availableSeats = Ref(seats)
val reservedSeat = atomic {implicit txn =&gt; {
  val head = availableSeats().head
  availableSeats() = availableSeats().tail
  head
}}
</pre></td></tr></table></figure>

<p>The critical section
will be executed only once when using synchronized, but using the STM atomic,
the critical section can be executed more than once. This is because at the end of
the block&#39;s execution, a check is done to see if there was a collision. </p>
<h2 id="using-the-stm-transactions">Using the STM transactions</h2>
<p>But when we
want to do a simple read of shared data we need to create an atomic block and this
means writing a lot of code just for a single, simple read. When using only one
reference, you could also use the View of a reference. The Ref.View enables you
to execute one action on one Reference.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>availableSeats<span class="preprocessor">.single</span><span class="preprocessor">.get</span>

val mySeat = atomic {implicit txn =&gt; {
    val head = availableSeats()<span class="preprocessor">.head</span>
    availableSeats() = availableSeats()<span class="preprocessor">.tail</span>
    head
  }}
}

val myseat = availableSeats<span class="preprocessor">.single</span><span class="preprocessor">.getAndTransform</span>(_<span class="preprocessor">.tail</span>)<span class="preprocessor">.head</span>
</pre></td></tr></table></figure>

<p>Using the Ref.View method makes the code a little bit more compact and also
makes the critical section smaller, which decreases the chance of a collision,
improving the total performance of the system.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>// 硬重试
// When the availableSeat list is empty, we call the retry,
// which triggers to execute the alternative atomic block.
val availableSeats = Ref(Seq[<span class="link_label">Seat</span>](<span class="link_url"></span>))
val mySeat = atomic { implicit txn =&gt; {
  val allSeats = availableSeats()
  if (allSeats.isEmpty)
<span class="code">    retry</span>
  val reservedSeat = allSeats.head
  availableSeats() = allSeats.tail
  Some(reservedSeat)
}}.orAtomic {implicit txn =&gt; {
  //else give up and do nothing
  // return a None to indicate we were unable to get a seat.
  None
}}
mySeat must be (None)
</pre></td></tr></table></figure>

<h1 id="agents-within-transactions">Agents within transactions</h1>
<p>When an Agent is used within a transaction, it isn&#39;t necessary to wrap it with an
STM reference to be able to use its data.</p>
<p>Our competing thread will update the agent every 50 ms and our test thread
tries to read the Agent&#39;s state twice within a transaction. When the Agent&#39;s state has
changed in the meantime, the transaction has to be retried.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">// Competing thread updating the agent</span>
<span class="keyword">val</span> seats = (<span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">15</span>) <span class="keyword">yield</span> Seat(i))
<span class="keyword">val</span> availableSeats = Agent(seats)
<span class="keyword">val</span> future = Future {
  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">10</span>) {
    availableSeats send (_.tail)
  }
  Thread.sleep(<span class="number">50</span>)
}

<span class="comment">// 获取线程</span>
<span class="keyword">var</span> nrRuns = <span class="number">0</span>
<span class="keyword">val</span> firstSeat = atomic { implicit txn =&gt; {
  nrRuns += <span class="number">1</span>
  <span class="keyword">val</span> currentList = availableSeats.get
  Thread.sleep(<span class="number">100</span>)
  availableSeats.get.head
}}
Await.ready(future, <span class="number">1</span> second)
nrRuns must be &gt; (<span class="number">1</span>)
firstSeat.seatNumber must be (<span class="number">10</span>)
</pre></td></tr></table></figure>

<p>In this example we see that the critical section is executed more than once,
because the value of the agent has changed during the transaction. </p>
<h2 id="updating-agents-within-a-transaction">Updating Agents within a transaction</h2>
<p>This means that
when we send an action, the action is held until the transaction is committed and
when if the transaction is rolled back, the action sent to the Agent is also rolled
back.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>val numberUpdates = Agent(<span class="number">0</span>)
val count = Ref(<span class="number">5</span>)
Future {
  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">10</span>) {
    atomic { <span class="keyword">implicit</span> txn =&gt; {
      count() = count() +<span class="number">1</span>
    }}
    Thread.sleep(<span class="number">50</span>)
  }
}
<span class="keyword">var</span> nrRuns = <span class="number">0</span>
val myNumber = atomic { <span class="keyword">implicit</span> txn =&gt; {
  nrRuns += <span class="number">1</span>
  numberUpdates send (_ + <span class="number">1</span>)
  val <span class="keyword">value</span> = count()
  Thread.sleep(<span class="number">100</span>)
  count()
}}

nrRuns must be &gt; (<span class="number">1</span>)
myNumber must be (<span class="number">15</span>)
Await.ready(numberUpdates.future(), <span class="number">1</span> second)
<span class="comment">// The agent is only one time updated</span>
numberUpdates.<span class="keyword">get</span>() must be (<span class="number">1</span>)
</pre></td></tr></table></figure>

<p> We can&#39;t use Agents and transactions to
solve the problem of transferring money. The problem is that the two actors are
completely unrelated.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(from: Agent[Int], to: Agent[Int], amount: Int)</span>:</span> Boolean = {
  atomic { txn =&gt; 
    <span class="keyword">if</span> (<span class="keyword">from</span>.get &lt; amount) false
    <span class="keyword">else</span> {
      <span class="keyword">from</span> send (_ - amount)
      to send (_ + amount)
      true
    }
  }
}
</pre></td></tr></table></figure>

<h1 id="actors-within-transactions">Actors within transactions</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.transactor.Coordinated
<span class="keyword">import</span> scala.concurrent.duration._
<span class="keyword">import</span> akka.util.Timeout


<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Withdraw</span><span class="params">(amount:Int)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Deposit</span><span class="params">(amount:Int)</span></span>
<span class="class"><span class="keyword">object</span> <span class="title">GetBalance</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">InsufficientFunds</span><span class="params">(msg:String)</span> <span class="keyword">extends</span> <span class="title">Exception</span><span class="params">(msg)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> balance = Ref(<span class="number">0</span>)
  
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> coordinated @ Coordinated(Withdraw(amount)) {
      coordinated atomic { implicit t
        <span class="keyword">val</span> currentBalance = balance()
        <span class="keyword">if</span> ( currentBalance &lt; amount) {
          <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFunds( <span class="string">"Balance is too low: "</span>+ currentBalance)
        }
        balance() = currentBalance - amount
      }
    }
    <span class="keyword">case</span> coordinated @ Coordinated(Deposit(amount)) {
      coordinated atomic { implicit t
        balance() = balance() + amount
      }
    }
    <span class="keyword">case</span> GetBalance =&gt; sender ! balance.single.get
  }
  
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
    self ! Coordinated(Deposit(balance.single.get))(Timeout(<span class="number">5</span> seconds))
    <span class="keyword">super</span>.preRestart(reason, message)
  }
}

<span class="comment">// 测试代码</span>
implicit <span class="keyword">val</span> timeout = Timeout(<span class="number">5</span> seconds)
<span class="keyword">val</span> transaction = Coordinated()
transaction atomic { implicit t =&gt;
  account1 ! transaction(Deposit(amount = <span class="number">100</span>))
}

<span class="keyword">val</span> probe = TestProbe()
probe.send(account1, GetBalance)
probe.expectMsg(<span class="number">100</span>)

<span class="comment">// 更简洁的代码</span>
<span class="keyword">val</span> account1 = system.actorOf(Props[Account])
implicit <span class="keyword">val</span> timeout = <span class="keyword">new</span> Timeout(<span class="number">1</span> second)

account1 ! Coordinated(Deposit(amount = <span class="number">100</span>))

<span class="keyword">val</span> probe = TestProbe()
probe.send(account1, GetBalance)
probe.expectMsg(<span class="number">100</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 转账的代码</span>
def receive = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="keyword">from</span>, to) =&gt; {
    val transaction = Coordinated()
    transaction atomic { <span class="keyword">implicit</span> t
      <span class="keyword">from</span> ! transaction(Withdraw(amount))
      to ! transaction(Deposit(amount))
    }
    sender ! <span class="string">"done"</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="creating-transactors">Creating transactors</h2>
<p>Transactors are actors that are capable of dealing with messages that comprise
Coordinated transactions.</p>
<p>All the functional code will been seen again in the example, only the
Coordinated part is removed, because the transactor will hide it from our code.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.transactor.Transactor
<span class="class"><span class="keyword">class</span> <span class="title">AccountTransactor</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Transactor</span> {</span>
  <span class="keyword">val</span> balance = Ref(<span class="number">0</span>)
  <span class="keyword">def</span> atomically = implicit txn =&gt; {
    <span class="keyword">case</span> Withdraw(amount) =&gt; {
      <span class="keyword">val</span> currentBalance = balance()
      <span class="keyword">if</span> ( currentBalance &lt; amount) {
        <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFunds(<span class="string">"Balance is too low: "</span>+ currentBalance)
      }
      balance() = currentBalance - amount
      
    <span class="keyword">case</span> Deposit(amount) =&gt; {
      balance() = balance() + amount
    }
  }
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message:Option[Any]) {
    <span class="comment">// 为了保存数据</span>
    self ! Deposit(balance.single.get)
    <span class="keyword">super</span>.preRestart(reason, message)
  }
  <span class="comment">// All messages which are implemented in the normally function,</span>
  <span class="comment">// will not be passed to the atomically function. </span>
  <span class="keyword">override</span> <span class="keyword">def</span> normally = {
    <span class="keyword">case</span> GetBalance =&gt; sender ! balance.single.get
  }
}

<span class="comment">// 测试代码</span>
<span class="keyword">val</span> account1 = system.actorOf(Props[AccountTransactor])
<span class="keyword">val</span> account2 = system.actorOf(Props[AccountTransactor])
<span class="keyword">val</span> transaction = Coordinated()
transaction atomic { implicit t
  account1 ! transaction(Withdraw(amount = <span class="number">50</span>))
  account2 ! transaction(Deposit(amount = <span class="number">50</span>))
}
</pre></td></tr></table></figure>

<p>When we deposit some
money in an account it doesn&#39;t need to be done in a Coordinated transaction. We
already saw that we can send a coordinated message without joining the
transaction, but when using a transactor, we can also send just the message.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>// These <span class="constant">two</span> <span class="keyword">lines</span> <span class="operator">of</span> code are equivalent when <span class="keyword">using</span> <span class="operator">a</span> transactor. 
account1 ! Coordinated(Deposit(amount = <span class="number">100</span>))
account1 ! Deposit(amount = <span class="number">100</span>)
</pre></td></tr></table></figure>

<p>The AccountTransactor only
acts within a transaction, but it doesn&#39;t include other actors within its transaction.
When the transfer Actor starts a coordinated transaction we need to include both
accounts in the transaction.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>override def coordinate = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="built_in">from</span>, <span class="built_in">to</span>) =&gt;
    sendTo(<span class="built_in">from</span> -&gt; Withdraw(amount),
    <span class="built_in">to</span> -&gt; Deposit(amount))
}<span class="comment">
// When you want to send the received message to the other actors, you can also use the include method:</span><span class="comment">
// sends the received Message to the three actors. </span>
override def coordinate = {
  <span class="keyword">case</span> msg:Message =&gt; <span class="built_in">include</span>(actor1, actor2, actor3)
}
</pre></td></tr></table></figure>

<p>For these kind of actions, a
transactor has two methods which can be overridden, the before and after method.
These methods are called just before and after the atomically method and are also
partial functions. For our example, we don&#39;t need the before method, but using the
after to be able to send the &quot;done&quot; message when the transaction has successfully
ended.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>override def <span class="keyword">after</span> = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="built_in">from</span>, <span class="built_in">to</span>) =&gt; sender ! <span class="string">"done"</span>
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Message Channels & Finite State Machines]]></title>
    <link href="http://zhpooer.github.io/2014/08/05/akka-in-action-message-channels/"/>
    <id>http://zhpooer.github.io/2014/08/05/akka-in-action-message-channels/</id>
    <published>2014-08-05T03:11:47.000Z</published>
    <updated>2014-08-05T14:26:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="chinnel-types">Chinnel types</h1>
<p>Other names which are often used for these kind of channels are EventQueue or
EventBus. Akka has an EventStream which implements a publish-subscribe
channel. But when this implementation isn&#39;t sufficient, then Akka has a collection
of traits which helps to implement an custom publish subscribe channel.</p>
<p>Next we describe two special channels. The first is the Dead Letter channel,
which contain message that couldn&#39;t be delivered.
This channel can help when debugging, why some messages
aren&#39;t processed or to monitor where there are problems.</p>
<h2 id="point-to-point">Point to Point</h2>
<p>The point-to-point channel sends the message to one receiver.</p>
<p><img src="/img/akka_point2point.png" alt="point 2 point img"></p>
<p>The round-robin
Router in section 7.3.1 is an example of the channel having multiple receivers. The
processing of the messages can be done concurrently by different Receivers, but
only one Receiver consumes any one message.</p>
<p>Because in Akka the ActorRef is the implementation of a point-to-point channel.
Because all the messages send will be delivered to one Actor.</p>
<h2 id="publish-subscribe">Publish subscribe</h2>
<p>The channel can also deliver the same message to multiple receivers.</p>
<p>To solve this problem we can use
the Publish-subscribe channel. The channel is able to send the same message to
multiple receivers, without the sender knows which receiver.</p>
<p>When a receiver is interested in a message of the publisher, it subscribes itself
to the channel.</p>
<p>The most easiest when needed a publish-subscribe channel,
is to use the EventStream.The EventStream can be seen as a
manager of multiple Publish-Subscribe channels.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// subscirbe <span class="built_in">to</span> <span class="operator">the</span> EventStream <span class="built_in">to</span> receive Order messages
<span class="keyword">system</span>.eventStream.subscribe(giftModule, classOf[Order])<span class="comment">
// unsubscribe</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule, classOf[Order])
<span class="comment">
// 取消订阅所有消息</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule.ref)<span class="comment">
// 发布消息</span>
<span class="keyword">system</span>.eventStream.publish(msg)
</pre></td></tr></table></figure>

<h2 id="custom-eventbus">CUSTOM EVENTBUS</h2>
<p>Let assume that we only want to send a gift when someone ordered more than one
book.</p>
<p> An EventBus is generalized so
that it can be used for all implementations of a publish-subscribe channel. In the
generalized form there are three entities.</p>
<ul>
<li>Event, This is the type of all events published on that bus. In the Akka EventStream all uses
AnyRef as event and therefor supports all type of messages</li>
<li>Subscriber, This is the type of subscribers allowed to register on that event bus. In the Akka
EventStream the subscribers are ActorRef&#39;s</li>
<li>Classifier, This defines the classifier to be used in selecting subscribers
for dispatching events. </li>
</ul>
<p>EventBus Interface</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>package akka.event
trait EventBus {
  type Event
  type Classifier
  type Subscriber
  /**
  * Attempts to register the subscriber to the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it was</span>
  * already subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(subscriber: Subscriber, to: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it wasn't</span>
  * subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber, from: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> all Classifiers it may
  * be subscribed to
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber)</span>:</span> Unit
  /**
  * Publishes the specified Event to this bus
  */
  <span class="function"><span class="keyword">def</span> <span class="title">publish</span><span class="params">(event: Event)</span>:</span> Unit
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> {</span>
  <span class="keyword">type</span> Event = Order
  <span class="comment">// chosen to classify the Order messages on the criteria "is Multiple</span>
  <span class="comment">// Book Order" and use a Boolean as classifier </span>
  <span class="keyword">type</span> Classifier = Boolean

}
</pre></td></tr></table></figure>

<p>Akka has three composable traits which can help in keeping
track of the subscribers.</p>
<ul>
<li>LookupClassification,  It maintain a set of subscribers for each
possible classifier and extract a classifier from each event.</li>
<li>SubchannelClassification, This trait is used when classifiers form a hierarchy
and it is desired that subscription can be possible not only at the leaf nodes,
but also to the higher nodes.</li>
<li>ScanningClassification,  it can be used when classifiers have an overlap. This
means that one Event can be part of more classifiers, for example if we give more gifts
when ordering more books.</li>
</ul>
<p>API of LookupClassification</p>
<ul>
<li>classify(event: Event): Classifier
This is used for extracting the classifier from the incoming events.</li>
<li>compareSubscribers(a: Subscriber, b: Subscriber): Int
This method must define a order over the subscribers, to be able to compare them just as
the java.lang.Comparable.compare method.</li>
<li>publish(event: Event, subscriber: Subscriber),
This method will be invoked for each event for all subscribers which registered
themselves for the events classifier.</li>
<li>mapSize: Int, This returns the expected number of the different classifiers.
This is used for the initial size of an internal data structure.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.event.ActorEventBus
<span class="keyword">import</span> akka.event.{ LookupClassification, EventBus }

<span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> <span class="keyword">with</span> <span class="title">LookupClassification</span></span>
    <span class="keyword">with</span> ActorEventBus {  <span class="comment">//  defines that the subscriber is an ActorRef.</span>
  <span class="keyword">type</span> Event = Order
  <span class="keyword">type</span> Classifier = Boolean
  <span class="keyword">def</span> mapSize = <span class="number">2</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> classify(event: StateEventBus#Event) = {
    event.number &gt; <span class="number">1</span>
  }
  
  <span class="comment">// publish method by sending the event to the subscriber</span>
  <span class="keyword">protected</span> <span class="keyword">def</span> publish(event: OrderMessageBus#Event,
      subscriber: OrderMessageBus#Subscriber) {
    subscriber ! event
  }

}


<span class="comment">// Test for event bus</span>
<span class="keyword">val</span> bus = <span class="keyword">new</span> OrderMessageBus
<span class="keyword">val</span> singleBooks = TestProbe()
bus.subscribe(singleBooks.ref, <span class="keyword">false</span>)

<span class="keyword">val</span> multiBooks = TestProbe()
bus.subscribe(multiBooks.ref, <span class="keyword">true</span>)

<span class="keyword">val</span> msg = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)
bus.publish(msg)

singleBooks.expectMsg(msg)
multiBooks.expectNoMsg(<span class="number">3</span> seconds)

<span class="keyword">val</span> msg2 = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">3</span>)
bus.publish(msg2)
singleBooks.expectNoMsg(<span class="number">3</span> seconds)
multiBooks.expectMsg(msg2)
</pre></td></tr></table></figure>

<h1 id="specialize-channel">Specialize Channel</h1>
<p>DeadLetter channel,  Only failed message are put on this channel. Listening on this
channel can help to find problems in your system.</p>
<p>Guaranteed deliver channel, his channel guaranties
all messages which are send are also delivered</p>
<h2 id="dead-letter">Dead letter</h2>
<p>By monitoring this channel you know which messages aren&#39;t processed and can
take corrective actions.</p>
<p> To get these dead letter messages you
only need to subscribe your actor to the EventStream with the DeadLetter class as
the Classifier.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>val deadLetterMonitor: ActorRef

system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
  deadLetterMonitor,
  classOf[DeadLetter])

// 测试代码
val deadLetterMonitor = TestProbe()
system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
    deadLetterMonitor<span class="preprocessor">.ref</span>,
    classOf[DeadLetter])
    
val actor = system<span class="preprocessor">.actorOf</span>(Props[EchoActor], <span class="string">"echo"</span>)
actor ! PoisonPill
val msg = new Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)

actor ! msg

//  wrapped also into a DeadLetter object
val dead = deadLetterMonitor<span class="preprocessor">.expectMsgType</span>[DeadLetter]
dead<span class="preprocessor">.message</span> must be(msg)
dead<span class="preprocessor">.sender</span> must be(testActor)
dead<span class="preprocessor">.recipient</span> must be(actor)
</pre></td></tr></table></figure>

<h1 id="guaranteed-delivery">Guaranteed delivery</h1>
<p>The guaranteed delivery channel is point-to-point channel with the guaranty that
the message is always delivered to the receiver.</p>
<p>This means that the channel must have
all kind of mechanism and checks to be able to guaranty the delivery, for example
the message has to be saved on disk in case the process crashes.</p>
<p>The general rule of message delivery is that messages are delivered
at-most-once. This means that Akka promise that messages are delivered once or
fails to deliver, Which means that the message is lost.</p>
<p>Sending local messages will not likely fails, because it is like a normal method
call. This fails only when there are catastrophic VM errors, like
StackOverflowError, OutOfMemoryError or a memory access violation.
So the guaranties when sending a message to a local actor, are pretty good
and reliable.</p>
<p>The problem of losing the messages is when using remote actors. When using
remote actors, it is a lot more likely for a message delivery failure to occur.</p>
<p>The Egress is an Actor which is started by the
ReliableProxy and both Actors implements the checks and resend functionality to
be able to keep track of which of the messages are delivered to the remote receiver.</p>
<p> One restriction of using the ReliableProxy is that the tunnel is only one-way
and for one receiver. This means that when the receiver replies to the sender the
tunnel is NOT used.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.contrib.pattern.ReliableProxy
<span class="keyword">val</span> echo = system.actorFor(node(server) / <span class="string">"user"</span> / <span class="string">"echo"</span>)
<span class="comment">// In the example we create a proxy using the echo reference.</span>
<span class="comment">// When failing to send a message it is retried after 500 milliseconds.</span>
<span class="keyword">val</span> proxy = system.actorOf(Props(<span class="keyword">new</span> ReliableProxy(echo, <span class="number">500.</span>millis)), <span class="string">"proxy"</span>)
</pre></td></tr></table></figure>

<p>We create a Multi-node test with two nodes, the client and server
node. On the server Node we create a EchoActor as receiver and on the client node
we run our actual test.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.remote.testkit.MultiNodeSpecCallbacks
<span class="keyword">import</span> akka.remote.testkit.MultiNodeConfig
<span class="keyword">import</span> akka.remote.testkit.MultiNodeSpec

<span class="class"><span class="keyword">trait</span> <span class="title">STMultiNodeSpec</span></span>
    <span class="keyword">extends</span> MultiNodeSpecCallbacks
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> BeforeAndAfterAll {
  <span class="keyword">override</span> <span class="keyword">def</span> beforeAll() = multiNodeSpecBeforeAll()
  <span class="keyword">override</span> <span class="keyword">def</span> afterAll() = multiNodeSpecAfterAll()
}

<span class="class"><span class="keyword">object</span> <span class="title">ReliableProxySampleConfig</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> {</span>
  <span class="keyword">val</span> client = role(<span class="string">"Client"</span>)
  <span class="keyword">val</span> server = role(<span class="string">"Server"</span>)
  testTransport(on = <span class="keyword">true</span>)
}

<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode1</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode2</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
</pre></td></tr></table></figure>

<p>TODO P257</p>
<h1 id="using-a-finite-state-machine">Using a Finite State Machine</h1>
<p>Finite-state machine (FSM), also called a state machine, is a common,
language-independent modeling technique.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p><img src="/img/akka_FSM.png" alt="fsm"></p>
<h2 id="creating-an-fsm-model">Creating an FSM Model</h2>
<p>The inventory Service gets requests for
specific books and sends a reply. When the book is in inventory, the order system
gets a reply that a book has been reserved. But it is possible that there aren&#39;t any
books left and that the inventory will have to ask the publisher for more books,
before it can service the order.</p>
<p><img src="/img/akka_FMS.png" alt="fms"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td class="code"><pre>
<span class="comment">// State, The super type of all state names</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForRequests</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessRequest</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForPublisher</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessSoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>

<span class="comment">// StateData, The type of the state data which are tracked by the FSM.</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateData</span><span class="params">(nrBooksInStore:Int,pendingRequests:Seq[BookRequest])</span></span>


<span class="keyword">import</span> akka.actor.{Actor, FSM}
<span class="class"><span class="keyword">class</span> <span class="title">Inventory</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">FSM</span>[<span class="title">State</span>, <span class="title">StateData</span>] {</span>
  <span class="comment">// define the initial state and the initial StateData.</span>
  startWith(WaitForRequests, <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq()))

  <span class="comment">// Declare the transitions for state WaitForRequests</span>
  when(WaitForRequests) {
    <span class="comment">// Declare the possible Event when a BookRequest messages occur</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; 
      <span class="keyword">val</span> newStateData = data.copy(pendingRequests = data.pendingRequests :+ request)
      
      <span class="keyword">if</span> (newStateData.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest) using newStateData
      } <span class="keyword">else</span> {
        goto(WaitForPublisher) using newStateData
      }
    <span class="keyword">case</span> Event(PendingRequests, data:StateData) =&gt; 
      <span class="keyword">if</span> (data.pendingRequests.isEmpty) {
        stay
      } <span class="keyword">else</span> <span class="keyword">if</span>(data.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest)
      } <span class="keyword">else</span> {
        goto(WaitForPublisher)
      }
  }

  when(WaitForPublisher) {
    <span class="keyword">case</span> Event(supply:BookSupply, data:StateData) =&gt; {
      goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
    }
    <span class="keyword">case</span> Event(BookSupplySoldOut, _) =&gt; {
      goto(ProcessSoldOut)
    }
  }

  when(ProcessRequest) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(WaitForRequests) using data.copy(
          nrBooksInStore = data.nrBooksInStore - <span class="number">1</span>,
          pendingRequests = data.pendingRequests.tail)
    }
  }

  when(SoldOut) {
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      goto(ProcessSoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq(request))
    }
  }

  when(ProcessSoldOut) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(SoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq())
    }
  }

  whenUnhandled {
    <span class="comment">// common code for all states</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      <span class="comment">// Only update the stateData</span>
      stay using data.copy(pendingRequests = data.pendingRequests :+ request)
    }
    <span class="comment">// Log when the event isn't handled</span>
    <span class="keyword">case</span> Event(e, s) =&gt; {
      log.warning(<span class="string">"received unhandled request {} in state {}/{}"</span>, e, stateName, s)
      stay
    }
  }

  <span class="comment">// entry Action of the WaitForRequests state</span>
  onTransition {
    <span class="keyword">case</span> _ -&gt; WaitForRequests =&gt; {
      <span class="keyword">if</span> (!nextStateData.pendingRequests.isEmpty) {
        <span class="comment">// go to next state</span>
        self ! PendingRequests
      }
    }
    
    <span class="keyword">case</span> _ -&gt; WaitForPublisher =&gt; {
      publisher ! PublisherRequest
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessRequest =&gt; {
      <span class="keyword">val</span> request = nextStateData.pendingRequests.head
      reserveId += <span class="number">1</span>
      request.target ! <span class="keyword">new</span> BookReply(request.context, Right(reserveId))
      self ! Done
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessSoldOut =&gt; {
      nextStateData.pendingRequests.foreach(request =&gt; {
        request.target ! <span class="keyword">new</span> BookReply(request.context, Left(<span class="string">"SoldOut"</span>))
      })
      self ! Done
    }
  }

}
</pre></td></tr></table></figure>

<h2 id="testing-the-fsm">TESTING THE FSM</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(totalNrBooks: Int, nrBooksPerRequest: Int)</span></span>
    <span class="keyword">extends</span> Actor {
  <span class="keyword">var</span> nrLeft = totalNrBooks
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> PublisherRequest =&gt; {
      <span class="keyword">if</span> (nrLeft == <span class="number">0</span>)
      sender ! BookSupplySoldOut
      <span class="keyword">else</span> {
        <span class="keyword">val</span> supply = min(nrBooksPerRequest, nrLeft)
        nrLeft -= supply
        sender ! <span class="keyword">new</span> BookSupply(supply)
      }
    }
  }
}

<span class="keyword">val</span> publisher = system.actorOf(Props(<span class="keyword">new</span> Publisher(<span class="number">2</span>,<span class="number">2</span>)))
<span class="keyword">val</span> inventory = system.actorOf(Props(<span class="keyword">new</span> Inventory(publisher)))
<span class="keyword">val</span> stateProbe = TestProbe()

<span class="comment">// 订阅状态变化信息</span>
inventory ! <span class="keyword">new</span> SubscribeTransitionCallBack(stateProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> CurrentState(inventory, WaitForRequests))

inventory ! <span class="keyword">new</span> BookRequest(<span class="string">"context1"</span>, replyProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForRequests, WaitForPublisher))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForPublisher, ProcessRequest))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, ProcessRequest, WaitForRequests))
replyProbe.expectMsg(<span class="keyword">new</span> BookReply(<span class="string">"context1"</span>, Right(<span class="number">1</span>)))
</pre></td></tr></table></figure>

<h2 id="timers-within-fsm">Timers within FSM</h2>
<p>When it is in the state &#39;WaitingForPublisher,&#39;
we don&#39;t wait forever for the publisher to reply.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">when</span>(WaitForPublisher, stateTimeout = <span class="number">5</span> seconds) {
  <span class="reserved">case</span> Event<span class="function"><span class="params">(supply:BookSupply, data:StateData)</span> =&gt;</span> {
    goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
  }
  <span class="reserved">case</span> Event<span class="function"><span class="params">(BookSupplySoldOut, _)</span> =&gt;</span> {
    goto(ProcessSoldOut)
  }
  <span class="regexp">//</span> Define the timeout transition
  <span class="reserved">case</span> Event<span class="function"><span class="params">(StateTimeout,_)</span> =&gt;</span> goto(WaitForRequests)
}

<span class="regexp">//</span> 当测试时
<span class="regexp">//</span> stateProbe.expectMsg(<span class="number">6</span> seconds,<span class="keyword">new</span> Transition(inventory, WaitForPublisher, WaitForRequests))
</pre></td></tr></table></figure>

<p>The timer can also be set by specifying the next state using the
method forMax.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">goto</span><span class="params">(<span class="variable">WaitForPublisher</span>)</span> <span class="title">using</span> <span class="params">(new<span class="variable">Data</span>)</span> <span class="title">forMax</span> <span class="params">(<span class="number">5</span> seconds)</span></span>
</pre></td></tr></table></figure>

<h2 id="termination-of-fsm">Termination of FSM</h2>
<p>The FSM has an
specific handler for these cases: onTermination. This handler is also a partial
function and takes a StopEvent as an argument.</p>
<p>There are three possible reasons this can be received.</p>
<ul>
<li>Normal. This is received when there is a normal termination.</li>
<li>Shutdown. This is received when the FSM is stopped due to a shutdown.</li>
<li>Failure(cause: Any), This reason is received when the termination was caused by a failure</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="title">onTermination</span> {
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Normal</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Shutdown</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Failure</span>(cause), state, <span class="typedef"><span class="keyword">data</span>)</span>
}
</pre></td></tr></table></figure>

<h1 id="implement-shared-state-using-agents">Implement Shared state using agents</h1>
<p>Akka accomplishes this by sending
actions to the agent for each operation, where the messaging infrastructure will
preclude a race condition.</p>
<p>For our example, we need to share the number
of copies sold for each book, so we will create an Agent that contains this value.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">BookStatics</span><span class="params">(val nameBook: String, nrSold: Int)</span></span>
<span class="comment">// a BookStatics instance is created which is put into a map using the title as the key</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateBookStatics</span><span class="params">(val sequence: Long, books: Map[String, BookStatics])</span></span>
</pre></td></tr></table></figure>

<p>The state object contained by the agent must be immutable.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.global
<span class="keyword">import</span> akka.agent.Agent
<span class="keyword">val</span> stateAgent = <span class="keyword">new</span> Agent(<span class="keyword">new</span> StateBookStatics(<span class="number">0</span>,Map()))

<span class="keyword">val</span> currentBookStatics = stateAgent.get <span class="comment">// 使用 stateAgent() 效果一样</span>

<span class="comment">// 如果 agent 的值是依赖前一个状态的呢?</span>
<span class="keyword">val</span> newState = StateBookStatics(<span class="number">1</span>, Map(book -&gt; bookStat ))
stateAgent send newState

<span class="comment">// 可以这样</span>
<span class="keyword">val</span> book = <span class="string">"Akka in Action"</span>
<span class="keyword">val</span> nrSold = <span class="number">1</span>
stateAgent send( oldState =&gt; {
  <span class="keyword">val</span> bookStat = oldState.books.get(book) <span class="keyword">match</span> {
    <span class="keyword">case</span> Some(bookState) =&gt;
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="keyword">case</span> None =&gt; <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>, oldState.books + (book -&gt; bookStat ))
})
</pre></td></tr></table></figure>

<h2 id="waiting-for-the-state-update">Waiting for the state update</h2>
<p>In some cases, we need to update shared state and use the new state. For example,
we need to know which book is selling the most, and when a book becomes
popular, we want to notify the authors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>implicit val timeout = Timeout(<span class="number">1000</span>)

<span class="regexp">//</span> It works exactly as the send method only it returns a Future,
<span class="regexp">//</span> which can be used to wait <span class="keyword">for</span> the <span class="keyword">new</span> state.
val future = stateAgent alter( oldState<span class="function"> =&gt;</span> {
  val bookStat = oldState.books.get(book) match {
    <span class="reserved">case</span> Some<span class="function"><span class="params">(bookState)</span> =&gt;</span>
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="reserved">case</span> None<span class="function"> =&gt;</span>
      <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>,oldState.books + (book<span class="function"> -&gt;</span> bookStat ))
})

val newState = Await.result(future, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<p> It is possible that there are multiple changes at
nearly the same time and we want the final state or another thread needs the final
state and only knows that the process before it may have updated the state. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>val <span class="keyword">future</span> = stateAgent.<span class="keyword">future</span>
val newState = <span class="keyword">Await</span>.<span class="keyword">result</span>(<span class="keyword">future</span>, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.<span class="keyword">global</span>
val agent1 = Agent(<span class="number">3</span>)
// When using this notation, agent2 <span class="keyword">is</span> a newly created Agent that contains the
// value <span class="number">4</span> <span class="keyword">and</span> agent1 <span class="keyword">is</span> just the same <span class="keyword">as</span> before (it still contains the value <span class="number">3</span>).
val agent2 = agent1 map (_ + <span class="number">1</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
</feed>
