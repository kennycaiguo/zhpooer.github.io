<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Poe's World]]></title>
  <subtitle><![CDATA[竹杖芒鞋轻胜马，一蓑烟雨任平生]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhpooer.github.io/"/>
  <updated>2014-05-30T23:50:46.335Z</updated>
  <id>http://zhpooer.github.io/</id>
  
  <author>
    <name><![CDATA[zhpooer]]></name>
    <email><![CDATA[zhpooer@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[传智播客day42-Spring 事务管理]]></title>
    <link href="http://zhpooer.github.io/2014/05/29/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day42-spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://zhpooer.github.io/2014/05/29/传智播客day42-spring-事务管理/</id>
    <published>2014-05-29T01:01:42.000Z</published>
    <updated>2014-05-30T01:21:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="spring-">Spring事务管理</h1>
<p>在Java开发中, 事务管理代码放到业务层</p>
<h2 id="-api">事务管理 API</h2>
<ul>
<li><p><code>PlatformTransactionManager</code> 提供事务管理方法, 核心接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">// 提交事务</span>
void <span class="function">commit(TransactionStatus status)</span>;
<span class="comment">// 根据事务定义信息，获得当前状态 </span>
TransactionStatus <span class="function">getTransaction(TransactionDefinition definition)</span>;
<span class="comment">// 回滚事务</span>
void <span class="function">rollback(TransactionStatus status)</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>TransactionDefinition</code> 事务的定义信息(隔离级别, 传播行为, 超时时间, 只读)</p>
<ul>
<li>ISOLATION_xxx 事务隔离级别 </li>
<li>PROPAGATION_xxx  事务传播行为 </li>
<li>int getTimeout()  获得超时信息</li>
<li>boolean isReadOnly()  判断事务是否只读</li>
</ul>
</li>
<li>TransactionStatus 事务具体行为, 每一个时刻点, 事务具体状态信息</li>
</ul>
<p>关系: PlatformTransactionManager 根据 TransactionDefinition 进行事务管理, 
管理过程中事务存在多种状态, 每个状态信息通过 TransactionStatus 表示</p>
<h2 id="platformtransactionmanager">PlatformTransactionManager</h2>
<p>Spring 为不同的持久化框架提供了不同的PlatformTransactionManager接口实现 ,
针对不同的持久层技术, 要选用对应的事务管理器</p>
<table>
<thead>
<tr>
<th>不同平台事务管理器实现</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.springframework.jdbc.datasource.DataSourceTransactionManager</td>
<td>使用Spring JDBC或iBatis 进行持久化数据时使用</td>
</tr>
<tr>
<td>org.springframework.orm.hibernate3.HibernateTransactionManager</td>
<td>使用Hibernate3.0版本进行持久化数据时使用</td>
</tr>
<tr>
<td>org.springframework.orm.jpa.JpaTransactionManager</td>
<td>使用JPA进行持久化时使用</td>
</tr>
<tr>
<td>org.springframework.jdo.JdoTransactionManager</td>
<td>当持久化机制是Jdo时使用</td>
</tr>
<tr>
<td>org.springframework.transaction.jta.JtaTransactionManager</td>
<td>使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用</td>
</tr>
</tbody>
</table>
<h1 id="-">事务的隔离级别</h1>
<p>四大特性: ACID, 原子性, 一致性, 隔离性, 持久性</p>
<p>隔离性引发并发问题：脏读 不可重复读, 幻读</p>
<ul>
<li>脏读 一个事务读取另一个事务 未提交数据</li>
<li>不可重复读 一个事务读取另一个事务 已经提交 update 数据</li>
<li>虚读  一个事务读取另一个事务 已经提交 insert 数据</li>
</ul>
<p>事务的隔离级别: 为了解决事务隔离性引发的问题</p>
<ul>
<li>DEFAULT 默认级别  mysql REPEATABLE_READ 、 oracle READ_COMMITTED</li>
<li>READ_UNCOMMITED  导致所有问题发生</li>
<li>READ_COMMITTED 防止脏读、 发生不可重复读和虚读</li>
<li>REPEATABLE_READ 防止脏读、不可重复读，发生虚读</li>
<li>SERIALIZABLE 防止所有并发问题 </li>
</ul>
<h1 id="-">事务的传播行为</h1>
<p>为什么要有事务的传播行为?(Why)</p>
<pre><code>实际开发中, 业务层方法间相互调用, 如在删除客户信息时, 要先删除订单信息
那么删除订单出错,客户要不要删除?
</code></pre><p>什么是事务的传播行为?(what)</p>
<pre><code>一个业务层事务调用令一个业务层事务, 事务间之间关系如何处理
</code></pre><p>七种传播行为:</p>
<ul>
<li>PROPAGATION_REQUIRED 支持当前事务, 如果不存在 就新建一个</li>
<li>PROPAGATION_SUPPORTS 支持当前事务, 如果不存在，就不使用事务</li>
<li>PROPAGATION_MANDATORY 支持当前事务, 如果不存在，抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW 如果有事务存在, 挂起当前事务, 创建一个新的事务<ul>
<li>生成订单, 发送通知邮件, 通知邮件会创建一个新的事务, 如果邮件失败, 不影响订单生成</li>
</ul>
</li>
<li>PROPAGATION_NOT_SUPPORTED    以非事务方式运行，如果有事务存在，挂起当前事务</li>
<li>PROPAGATION_NEVER 以非事务方式运行, 如果有事务存在, 抛出异常</li>
<li>PROPAGATION_NESTED 如果当前事务存在, 则嵌套事务执行<ul>
<li>依赖于 JDBC3.0 提供 SavePoint 技术 </li>
<li>删除客户 删除订单, 在删除客户后, 设置SavePoint, 执行删除订单, 删除订单和删除客户在同一个事务,
删除订单失败， 事务回滚 SavePoint , 由用户控制是事务提交 还是 回滚</li>
</ul>
</li>
</ul>
<h1 id="-">事务管理方式</h1>
<p>编程式事务管理 </p>
<ul>
<li>在代码中通过 TransactionTemplate 手动进行事务管理, 在实际开发中很少被用到</li>
</ul>
<p>声明式事务管理</p>
<ul>
<li>在配置文件中, 对 Bean 的方法进行事务管理, 基于AOP思想, 无需写代码 </li>
</ul>
<h2 id="-">实际案例: 转账</h2>
<p>如果没有进行事务管理, JdbcTemplate DAO 每一个操作, 都是一个事务</p>
<p>数据库脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> (
  <span class="string">`id`</span> <span class="keyword">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,
  <span class="string">`name`</span> <span class="keyword">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,
  <span class="string">`money`</span> <span class="keyword">double</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,
  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="string">`id`</span>)
) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET=utf8;</span>
<span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`account`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'aaa'</span>, <span class="string">'1000'</span>);</span>
<span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`account`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'bbb'</span>, <span class="string">'1000'</span>);</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 最全的spring 模板 --&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>
	<span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>
	<span class="attribute">xmlns:aop</span>=<span class="value">"http://www.springframework.org/schema/aop"</span>
	<span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>
	<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans 
	http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/context
	http://www.springframework.org/schema/context/spring-context.xsd
	http://www.springframework.org/schema/aop
	http://www.springframework.org/schema/aop/spring-aop.xsd
	http://www.springframework.org/schema/tx 
	http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span>
    <span class="comment">&lt;!-- 导入外部属性文件, 配置连接池 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"accountService"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.AccountServiceImpl"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"accountDao"</span> <span class="attribute">ref</span>=<span class="value">"accountDao"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
         <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionTemplate"</span> <span class="attribute">ref</span>=<span class="value">"transactionTemplate"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"accountDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.AccountDaoImpl"</span>&gt;</span>
    <span class="comment">&lt;!-- 将连接池注入给DAO, JdbcTemplate会自动 创建 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="comment">&lt;!-- 编程式事务管理配置 --&gt;</span>
    <span class="comment">&lt;!-- 事务管理模板 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionTemplate"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionManager"</span> <span class="attribute">ref</span>=<span class="value">"tractionManager"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="comment">&lt;!-- 事务管理器 --&gt;</span>
    <span class="comment">&lt;!-- org.springframework.jdbc.datasource.DataSourceTransactionManager 用来管理jdbc事务操作 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSrouce"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span>{</span>
    <span class="comment">// 自动注入</span>
    <span class="keyword">private</span> AccountDao accountDao;
    <span class="keyword">private</span> TransactionTemplate transactionTemplate;
    
    <span class="comment">// 转账</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span>(String outAccount, String inAccount, Double money) {
            <span class="comment">// 编程式事务管理, 使用事务模板管理事务</span>
        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult(){
            <span class="annotation">@Override</span>
            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span>(){
                accountDao.outMoney(outAccount, money);
                accountDao.inMoney(inAccount, money);
            }
        });
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span>(String outAccount, Double money) {
        String sql = <span class="string">"update account set money = money-? where name=?"</span>;
        getJdbcTemplate().update(sql, money, outAccount);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span>(String inAccount, Double money) {
        String sql = <span class="string">"update account set money = money+? where name=?"</span>;
        getJdbcTemplate().update(sql, money, inAccount);
    }
}
</pre></td></tr></table></figure>

<h3 id="-">声明式事务管理</h3>
<h4 id="transactionproxyfactorybean">TransactionProxyFactoryBean</h4>
<p>通过 TransactionProxyFactoryBean 对业务类创建代理,
实现声明式事务管理, 无需修改 Service 代码</p>
<p>缺点, 需要为每个Bean 都创建单独代理对象，开发量巨大</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 事务管理器 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span> <span class="attribute">class</span>=<span class="value">""</span>&gt;</span>
    <span class="tag">&lt;<span class="title">proerty</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">proerty</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 为目标Servicee创建代理 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">name</span>=<span class="value">"accountServiceProxy"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>&gt;</span>
    <span class="comment">&lt;!-- 目标 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"accountService"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 针对接口代理 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"proxyInterfaces"</span> <span class="attribute">value</span>=<span class="value">"zhpooer.AccountService"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 增强 事务管理 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionManager"</span> <span class="attribute">ref</span>=<span class="value">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 事务管理属性 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionAttributes"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">props</span>&gt;</span>
           <span class="comment">&lt;!-- key 就是方法名  --&gt;</span>
           <span class="comment">&lt;!-- value prop格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception --&gt;</span>
           <span class="comment">&lt;!-- PROPAGATION 事务传播行为 --&gt;</span>
           <span class="comment">&lt;!-- ISOLATION, 事务隔离级别 --&gt;</span>
           <span class="comment">&lt;!-- readOnly  表示事务是只读的，不能进行修改操作  --&gt;</span>
           <span class="comment">&lt;!-- -Exception 发生这些异常事务进行回滚(默认发生任何异常事务都会回滚) --&gt;</span>
            <span class="comment">&lt;!-- +Exception 事务将忽略这些异常，仍然提交事务  --&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"transfer"</span>&gt;</span> PROPAGATION_REQUIRED, readOnly, +java.lang.ArithmeticException <span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">props</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 注入代理对象: @Qualifier("accountServiceProxy") --&gt;</span>
</pre></td></tr></table></figure>

<h4 id="tx-">tx, 自动代理</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 定义事务管理增强 --&gt;</span>
<span class="tag">&lt;<span class="title">tx:advice</span> <span class="attribute">id</span>=<span class="value">"txAdvicd"</span> <span class="attribute">transaction-manager</span>=<span class="value">"transactionManager"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tx:attribute</span>&gt;</span>
        <span class="comment">&lt;!--
        name="transfer" 事务管理方法名
        isolation="DEFAULT" 默认隔离级别
        qpropagation="REQUIRED"  默认传播行为
        read-only="false"  是否只读
        no-rollback-for=""  发生异常不会滚  类似+Exception
        rollback-for=""  发生异常回滚 类似-Exception
        timeout="-1"  不超时
        --&gt;</span>
        <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"transfer"</span> <span class="attribute">isolatioin</span>=<span class="value">"DEFAULT"</span> <span class="attribute">propagation</span>=<span class="value">"REQUIRED"</span>
                   <span class="attribute">read-only</span>=<span class="value">"false"</span> <span class="attribute">timeout</span>=<span class="value">"-1"</span>&gt;</span><span class="tag">&lt;/<span class="title">tx:method</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tx:attribute</span>&gt;</span>
<span class="tag">&lt;/<span class="title">tx:advice</span>&gt;</span>
<span class="comment">&lt;!-- 使用Aop 进行自动代理 --&gt;</span>
<span class="tag">&lt;<span class="title">aop:config</span>&gt;</span>
    <span class="comment">&lt;!-- 定义切点 --&gt;</span>
    <span class="tag">&lt;<span class="title">aop:pointcut</span> <span class="attribute">expression</span>=<span class="value">"execution(public * * (..))"</span> <span class="attribute">id</span>=<span class="value">"mypointcut"</span>&gt;</span><span class="tag">&lt;/<span class="title">aop:pointcut</span>&gt;</span>
    <span class="comment">&lt;!-- 定义切面 --&gt;</span>
    <span class="tag">&lt;<span class="title">aop:advisor</span> <span class="attribute">advice-ref</span>=<span class="value">"txAdvice"</span> <span class="attribute">pointcut-ref</span>=<span class="value">"mypointcut"</span>&gt;</span><span class="tag">&lt;/<span class="title">aop:advisor</span>&gt;</span>
<span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span>
</pre></td></tr></table></figure>

<h4 id="-">注解实现事务管理</h4>
<ol>
<li><p>在需要管理的类或者方法添加 <code>@Trasactional</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// isolation 隔离级别</span>
<span class="comment">// propagation 传播行为</span>
<span class="comment">// readOnly 是否只读</span>
<span class="comment">// noRollbackFor 发生异常不回滚</span>
<span class="comment">// rollbackFor 发生异常回滚</span>
<span class="comment">// timeout 超时时间 -1 不超时</span>

<span class="annotation">@Transactional</span>(isolation=Isolation.DEFAULT,propagation=,
               readyOnly=, noRollbackFor=, rollbackFor, timeout=)
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span>(){}
</pre></td></tr></table></figure>
</li>
<li><p>在 applicationContext.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="subst">&lt;</span>tx:annotation<span class="attribute">-driven</span> transaction<span class="attribute">-manager</span><span class="subst">=</span><span class="string">"transactionManager"</span><span class="subst">&gt;&lt;</span>/tx:annotation<span class="attribute">-driven</span><span class="subst">&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="ssh-">SSH 框架整合</h1>
<p>导入Jar包, 及配置文件</p>
<ul>
<li>表现层框架 struts2, <code>struts2-json-plugin.jar</code>,
<code>struts2-spring-plugin.jar</code>, <code>struts2-conversion.jar</code>(注解), 以及 web.xml(filter), struts2.xml</li>
<li><p>业务层 spring3</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>配置 web.xml
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span> ContextLoaderListner <span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>持久层框架 hibernate3</p>
</li>
</ul>
<h2 id="spring-hibernate-">Spring 和 Hibernate 整合</h2>
<h3 id="-">零障碍整合</h3>
<p>通过 Spring 提供 LocalSessionFactoryBean, 注解引入hibernate配置文件,
在 Spring 容器中获得 SessionFactory对象, 将 SessionFactory, 注入到 DAO 程序</p>
<p>图书添加</p>
<p>移动脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span>(
    id <span class="keyword">int</span> <span class="keyword">not</span> <span class="keyword">null</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> <span class="keyword">key</span>,
    bookname <span class="keyword">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    price <span class="keyword">double</span> <span class="keyword">not</span> <span class="keyword">null</span>
);</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> {</span>
     <span class="keyword">private</span> Integer id;
     <span class="keyword">private</span> String bookname;
     <span class="keyword">private</span> <span class="keyword">double</span> price;
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> <span class="keyword">extends</span> <span class="title">HibernateDaoSupport</span>{</span>
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span>(){}
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="comment">&lt;!-- hibernate.cfg.xml --&gt;</span>
<span class="tag">&lt;<span class="title">mapping</span> <span class="attribute">resource</span>=<span class="value">"domain.Book.hbm.xml"</span>/&gt;</span>

<span class="comment">&lt;!-- Book.hbm.xml --&gt;</span>
<span class="tag">&lt;<span class="title">hibernate-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"domain.Book"</span> <span class="attribute">table</span>=<span class="value">"book"</span> <span class="attribute">catalog</span>=<span class="value">""</span>&gt;</span>
        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"id"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"identity"</span>&gt;</span> <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"bookname"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"price"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>

<span class="comment">&lt;!-- applicationContext.xml --&gt;</span>
<span class="comment">&lt;!-- 配置 sessionFactory --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span>
    <span class="comment">&lt;!-- 加载hibernate配置文件 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"configLocation"</span> <span class="attribute">value</span>=<span class="value">"classpath:hibernate.cfg.xml"</span>&gt;</span>  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 注入 sessionFactory --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bookDao"</span> <span class="attribute">class</span>=<span class="value">"dao.BookDao"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionfactory"</span> <span class="attribute">ref</span>=<span class="value">"sessionfactory"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bookService"</span> <span class="attribute">class</span>=<span class="value">"service.BookService"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"bookDao"</span> <span class="attribute">ref</span>=<span class="value">"bookDao"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">tx:advice</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tx:attribute</span>&gt;</span>
        <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"*"</span>&gt;</span> <span class="tag">&lt;/<span class="title">tx:method</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tx:attribute</span>&gt;</span>
<span class="tag">&lt;/<span class="title">tx:advice</span>&gt;</span>
<span class="tag">&lt;<span class="title">aop:config</span>&gt;</span>
    <span class="tag">&lt;<span class="title">aop:advisor</span> <span class="attribute">advice-ref</span>=<span class="value">"transactionManager"</span> <span class="attribute">pointcut</span>=<span class="value">"execution()"</span>&gt;</span> <span class="tag">&lt;/<span class="title">aop:advisor</span>&gt;</span>
<span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="comment">// BookDao.java</span>
<span class="comment">// HibernateTemplate 常用 api</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span>(Book book){
    <span class="keyword">this</span>.getHibernateTemplate().save(book);
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span>(Book book) {
    <span class="keyword">this</span>.getHibernateTemplate().update(book);
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span>(Book book) {
    <span class="keyword">this</span>.getHibernateTemplate().delete(book);
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span>(Integer id) {
    <span class="keyword">return</span> <span class="keyword">this</span>.getHibernateTemplate().<span class="keyword">get</span>(Book.class, id);
}p
<span class="keyword">public</span> List&lt;Book&gt; <span class="title">findAll</span>(){
    <span class="comment">// this.getSession().createQuery("from Book").list();</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.getHibernateTemplate().find(<span class="string">"from Book"</span>);
}
<span class="keyword">public</span> Book <span class="title">findByName</span>(String name){
    <span class="comment">//  this.getSession().createQuery("from Book where name=?").setParameter(0, name).uniqueResult();</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.getHibernateTemplate().find(<span class="string">"from Book where name=?"</span>, name);
}
</pre></td></tr></table></figure>

<p>业务层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> BookService{
    <span class="keyword">private</span> BookDao bookDao;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span>(Book book) {
        bookDao.saveBook(book);
    }
    <span class="keyword">public</span> List&lt;Book&gt; <span class="title">findAllBooks</span>(){
        <span class="keyword">return</span> bookDao.findAll();
    }
}
</pre></td></tr></table></figure>

<h3 id="-hibernate-spring">将 Hibernate 参数配置到 Spring</h3>
<p>将 hibernate框架的所有参数, 都配置到 applicationContext.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="comment">&lt;!-- applicationContext.xml --&gt;</span>
<span class="tag">&lt;<span class="title">context:property-placeholder</span> <span class="attribute">location</span>=<span class="value">"classpath:"</span>&gt;</span><span class="tag">&lt;/<span class="title">context:property-placeholder</span>&gt;</span>
<span class="comment">&lt;!-- c3p0连接池 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.ComboPooledDataSource"</span>&gt;</span>
    <span class="comment">&lt;!-- any other configuration  --&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="comment">&lt;!-- 配置 sessionFactory --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">props</span>&gt;</span>
            <span class="comment">&lt;!-- 数据库方言 --&gt;</span>        
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span> org.hibernate.dialect.MySQLDialect <span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.hbm2dll.auto"</span>&gt;</span>update <span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.format_sql"</span>&gt;</span>true <span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.show_sql"</span>&gt;</span>true <span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">props</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 配置 hbm 文件 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mappingResources | mappingLocations | mappingDirectoryLocations"</span>&gt;</span>
        <span class="comment">&lt;!-- mappingResources --&gt;</span>
        <span class="tag">&lt;<span class="title">list</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>cn/zhpooer/Person.hbm.xml <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
        
        <span class="comment">&lt;!-- mappingLocations --&gt;</span>
        <span class="tag">&lt;<span class="title">list</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>classpath: cn/zhpooer/Person.hbm.xml <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
        
        <span class="comment">&lt;!-- mappingDirectoryLocations, 查找所有目录下的配置文件 --&gt;</span>
        <span class="tag">&lt;<span class="title">list</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>classpath: cn/zhpooer/domain <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="hibernatetemplate-">HibernateTemplate 用法</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre>template.save(obj);
template.update(obj);
template.saveOrUpdate();
template.delete(obj);
template.get(class, id);
template.load(class, id)

// 查询
template.find(hql, Object... args); // QBC查询, 等价于 session.createQeury(hql);

template.findByCriteria(detachedCriteria) // 完全面向对象查询
template.findByNamedQuery(queryName) // 命名查询, 查询语句写入配置文件, 方便项目管理

public void testQBC {
    HibernateTemplate template = new HibernateTemplate();
    DetachedCriteria criteria = DetachedCriteria.forClass(Book.class); // 生成 select * from book;
    criteria.add(Restrictions.like("bookname", "%为什么%"));
    List<span class="tag">&lt;<span class="title">Book</span>&gt;</span> books = template.findByCriteria(criteria);
}
/* 配置文件
* <span class="tag">&lt;<span class="title">hibernate-mapping</span>&gt;</span>
*     <span class="comment">&lt;!-- 配置 hql --&gt;</span>
*     <span class="tag">&lt;<span class="title">query</span> <span class="attribute">name</span>=<span class="value">"book.findbyname"</span>&gt;</span> from book where bookname like ?<span class="tag">&lt;/<span class="title">query</span>&gt;</span>
*     <span class="comment">&lt;!-- 配置 sql --&gt;</span>
*     <span class="tag">&lt;<span class="title">sql-query</span> <span class="attribute">name</span>=<span class="value">"book.findbynamesql"</span>&gt;</span>
*         <span class="tag">&lt;<span class="title">return</span> <span class="attribute">class</span>=<span class="value">"domain.Book"</span>&gt;</span><span class="tag">&lt;/<span class="title">return</span>&gt;</span> <span class="comment">&lt;!-- 将结果集封装到book对象 --&gt;</span>
*         select * from book where bookname like ?
*     <span class="tag">&lt;/<span class="title">sql-query</span>&gt;</span>
* <span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>
*/ 
public void testFindByNamedQuery(){
    List<span class="tag">&lt;<span class="title">Book</span>&gt;</span> books = template.findByNamedQuery("book.findbyname", "%为什么%")

    List<span class="tag">&lt;<span class="title">Book</span>&gt;</span> books = template.findByNamedQuery("book.findbynamesql", "%为什么%")
}
</pre></td></tr></table></figure>

<h2 id="spring-struts-">Spring 和 Struts 整合</h2>
<p>Struts2 整合 Spring 框架原理: 修改 struts2 默认对象工厂(struts -&gt; spring),
导入 <code>struts2-spring-plugin</code></p>
<h3 id="-service">自动装配 Service</h3>
<p>由 struts2 自己装配Action, 再由 Spring</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookaddAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span>{</span>
    <span class="keyword">private</span> Book book = <span class="keyword">new</span> Book();
    <span class="comment">// 自动装配, 不需要提供任何配置, 只需要在Action里提供 service的 set方法</span>
    <span class="comment">// 原理: struts配置文件中</span>
    <span class="comment">// `struts.objectFactory.spring.autoWire = true`(根据名字自动注入), 生效 </span>

    <span class="keyword">private</span> BookService bookService;
    <span class="keyword">public</span> String <span class="title">execute</span>(){
        pringln(<span class="string">"添加图书"</span>)
        <span class="keyword">return</span> NONE;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"bookadd.action"</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"bookname"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"price"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>

<span class="tag">&lt;<span class="title">struts</span>&gt;</span>
    <span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"default"</span> <span class="attribute">namespace</span>=<span class="value">"/"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"bookadd"</span> <span class="attribute">class</span>=<span class="value">BookaddAction""</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="tag">&lt;/<span class="title">struts</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="action-spring-">Action由 Spring 管理</h3>
<p>将 struts2 的Action配置spring管理的Bean对象</p>
<ol>
<li><p>将Action配置为 Spring 中的一个Bean对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- applicationContext.xml 加入ActionBean --&gt;</span>
<span class="comment">&lt;!-- 必须设置为 prototype --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bookaddAction"</span> <span class="attribute">class</span>=<span class="value">"action.BookaddAction"</span> <span class="attribute">scope</span>=<span class="value">"prototype"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"bookService"</span> <span class="attribute">ref</span>=<span class="value">"bookService"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>Struts.xml 配置 Spring bean 的 id, 作为 class 的属性</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不是真实类名, 只是只给伪类名 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"bookadd"</span> <span class="attribute">class</span>=<span class="value">"bookaddAction"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h3 id="-">结论</h3>
<p>第一种整合方式, Action 由 Struts2 自己管理, Service对象采用自动装配</p>
<p>第二种整合方式, Action 由 spring 自己管理, 依赖注入service对象, struts2 需要配置伪类名</p>
<p>第二种方式, 可以对 Action 进行 AOP 增强</p>
<h1 id="-">延迟加载问题</h1>
<p>懒加载对象, 但是对象已经脱管, 报异常 <code>no session</code></p>
<p>解决方案</p>
<ol>
<li>设置为立即加载 lazy=false, 缺点, 每次查询客户, 都要查询订单</li>
<li>在业务层, 事务关闭前手, 动初始化
<code>Hibernate.initialize(customer.getOrders())</code>, 缺点, 需要写代码</li>
<li>OpenSessionView, session 不随事务关闭而关闭,
将 session 延迟到表现层, 存在性能问题, 通过配置, 无需编码<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">&lt;!-- web.xml --&gt;</span>
<span class="comment">&lt;!-- 在Struts2的过滤器前, 配置 OpenSessionInViewFilter --&gt;</span>
<span class="tag">&lt;<span class="title">filter</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>openfilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.springframework.orm.hiberante3.support.OpenSessionInViewFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>openfilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-">注解整合</h1>
<p>导入 <code>struts-conversion-plugin.jar</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">// hiberante注解 是对 jpa注解的扩展</span>
<span class="annotation">@Entity</span>
<span class="annotation">@Table</span>(name=<span class="string">"book"</span>, catalog=<span class="string">""</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> {</span>
    <span class="annotation">@Id</span>
    <span class="annotation">@GeneratedValue</span>(strategy = GeneratedType.IDENTITY)
    <span class="keyword">private</span> Integer id;
    <span class="comment">// 如果列名和属性名不一致, 可以不写</span>
    <span class="annotation">@Column</span>(name=<span class="string">""</span>, nullable=<span class="keyword">true</span>)
    <span class="keyword">private</span> String bookname;
    <span class="keyword">private</span> <span class="keyword">double</span> price;
}
<span class="annotation">@Repository</span>(<span class="string">"bookDao"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> {</span>
    <span class="annotation">@Resource</span>(name=<span class="string">"hiberanteTemplate"</span>)
    <span class="keyword">private</span> HiberanteTemplate template;
}
<span class="annotation">@Controller</span>(<span class="string">"bookaddAction"</span>)
<span class="annotation">@Scope</span>(<span class="string">"prototype"</span>)
<span class="annotation">@Namespace</span>(<span class="string">"/"</span>)
<span class="annotation">@ParentPackage</span>(<span class="string">"struts-default"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookaddAction</span>{</span>
    <span class="annotation">@Action</span>(<span class="string">"bookadd"</span>)
    <span class="keyword">public</span> String <span class="title">execute</span>(){
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">&lt;!--  AnnotationSessionFactoryBean 支持注解功能--&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hiberante3.annotation.AnnotationSessionFactoryBean "</span>&gt;</span>
    <span class="comment">&lt;!-- 其他配置同上  --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"packageToScan"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">list</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>cn.zhpooer<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"cn.itcast, io.zhpooer."</span>/&gt;</span>
<span class="tag">&lt;<span class="title">context:annotation-config</span>/&gt;</span>
<span class="comment">&lt;!-- 注解事务管理 --&gt;</span>

<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSrouce"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">tx:</span> <span class="attribute">annotation-driven</span> <span class="attribute">transaction-manager</span>=<span class="value">"transactionManager"</span>/&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="spring" scheme="http://zhpooer.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day41-spring AOP]]></title>
    <link href="http://zhpooer.github.io/2014/05/27/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day41-spring-aop/"/>
    <id>http://zhpooer.github.io/2014/05/27/传智播客day41-spring-aop/</id>
    <published>2014-05-27T01:19:03.000Z</published>
    <updated>2014-05-28T01:26:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="aop-">AOP 概念</h1>
<p>Aspect Oriented Programing 面向切面编程, AOP是对OOP(面向对象编程) 思想的延伸,</p>
<p>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码(性能监视、事务管理、安全检查、缓存)</p>
<p>底层原理: <strong>代理</strong> </p>
<ul>
<li><p>传统继承, 纵向结构代码复用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> wirteLog(){doSome()}
}

<span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">BaseDao</span>{</span>}
<span class="class"><span class="keyword">class</span> <span class="title">ProductDao</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">BaseDao</span>{</span>}
</pre></td></tr></table></figure>
</li>
<li><p>AOP, 使用代理机制, 将复用的代码放入代理中</p>
</li>
</ul>
<h2 id="-">相关术语</h2>
<ul>
<li>Joinpoint(连接点), 在代理过程中, 可以被拦截的点(指方法)</li>
<li>Pointcut(切入), 要对哪些Jointpoint进行拦截定义, 指定拦截(个别方法)</li>
<li>Advice(通知, 建议), 增强的代码逻辑(日志记录), 方法级别</li>
<li>Introduction(引介), 特殊类型Advice, 对原有的类对象添加一个新的属性或者方法</li>
<li>Target, 被代理对象</li>
<li>Weaving(织入), 把增强应用到目标对象, 来创建对象的过程</li>
<li>Proxy(代理), 一个类被AOP织入增强后，就产生一个结果代理类</li>
<li>Aspect(切面), 是切入点(Joinpoint)和通知(Advice)的结合, 多个切点和多个通知组成</li>
</ul>
<h1 id="aop-">AOP底层原理</h1>
<p>AOP, 使用代理机制, 将复用的代码放入代理中</p>
<h2 id="jdk-">JDK动态代理</h2>
<p>使用JDK动态代理, JDK1.3新特性</p>
<p>原理： 针对内存中Class对象，使用类加载器 动态为目标对象实现接口的创建代理类</p>
<ul>
<li>代理类 是动态创建的， 代理类 和 被代理对象 实现相同接口 </li>
<li>被代理对象 必须要实现 接口(JDK代理 只能针对接口 进行代理)</li>
</ul>
<h2 id="cglib">CGLIb</h2>
<p>JDK动态代理, 为目标对象接口生成代理对象,
对于不使用接口的业务类, 无法使用JDK动态代理</p>
<p>CGLIB(Code Generation Library)是一个开源项目.
是一个强大的,高性能,高质量的Code生成类库,
它可以在运行期扩展Java类与实现Java接口.
Hibernate支持CGlib 来实现PO字节码的动态生成.</p>
<ul>
<li>Hibernate 默认PO 字节码生成技术  javassist</li>
</ul>
<p>CGLIB 是一个第三方技术，使用时 ，需要下载 jar 包</p>
<ul>
<li>Spring3.2 版本， spring-core jar包 已经集成 cglib 开发类 </li>
</ul>
<p>原理: CGlib采用非常底层字节码技术, 可以为一个类创建子类,
解决无接口代理问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> ProductDao <span class="title">createCglibProxy</span>(){
    <span class="comment">// 创建代理的核心对象</span>
    Enhancer enhancer = <span class="keyword">new</span> Enhancer();
    <span class="comment">// 设置被代理类, 为类创建子类</span>
    enhancer.setSuperclass(productDao.getClass());
    enhancer.setCallback( <span class="keyword">new</span> MethodInterceptor(){
        <span class="keyword">public</span> Object <span class="title">intercept</span>(Object proxy, Method method, Object[] rags, MethodProxy methodProxy){
            <span class="comment">// 为 addProduct 计算运算时间</span>
            <span class="keyword">if</span> (method.getName().equals(<span class="string">"addProduct"</span>)) {<span class="comment">// 当前执行方法</span>
                <span class="keyword">long</span> start = System.currentTimeMillis();
                Object result = methodProxy.invokeSuper(proxy, args);
                <span class="keyword">long</span> end = System.currentTimeMillis();
                System.<span class="keyword">out</span>.println(<span class="string">"addProduct方法运行时间 : "</span> + (end - start));
                <span class="keyword">return</span> result;
            } <span class="keyword">else</span> {
                <span class="comment">// 不进行增强</span>
                <span class="keyword">return</span> methodProxy.invokeSuper(proxy, args);
            }
        }
    });
    <span class="comment">// 返回代理</span>
    <span class="keyword">return</span> (ProductDao) enhancer.create();
}
</pre></td></tr></table></figure>

<h2 id="-">结论</h2>
<p>程序中应优先对接口创建代理，便于程序解耦维护</p>
<ul>
<li>若目标对象实现了若干接口.spring使用JDK的java.lang.reflect.Proxy类代理</li>
<li>若目标对象没有实现任何接口.spring使用CGLIB库生成目标对象的子类</li>
</ul>
<h1 id="-spring-aop">传统Spring AOP</h1>
<p>AOP 开发规范: AOP联盟为通知Advice定义了<code>org.aopalliance.aop.Interface.Advice</code></p>
<p>Spring AOP 实现 AOP 联盟定义的规范</p>
<p>传统Spring AOP提供五类 Advice:
    前置通知(代码增强) org.springframework.aop.MethodBeforeAdvice</p>
<pre><code>* 在目标方法执行前实施增强
后置通知 org.springframework.aop.AfterReturningAdvice
* 在目标方法执行后实施增强
环绕通知 org.aopalliance.intercept.MethodInterceptor
* 在目标方法执行前后实施增强
异常抛出通知 org.springframework.aop.ThrowsAdvice
* 在方法抛出异常后实施增强
引介通知 org.springframework.aop.IntroductionInterceptor （课程不讲 了解）
* 在目标类中添加一些新的方法和属性
</code></pre><h2 id="advisor">Advisor</h2>
<p>Advisor 就是对 PointCut 应用 Advise, 指一个 Point 和一个 Advise</p>
<p>类型：</p>
<ul>
<li>Advisor : 代表一般切面, Advice本身就是一个切面, 对目标类所有方法进行拦截(没有切点)</li>
<li>PointcutAdvisor : 代表具有切点的切面, 可以指定拦截目标类哪些方法</li>
<li>IntroductionAdvisor : 代表引介切面，针对引介通知而使用切面(不重要)</li>
</ul>
<h3 id="-advisor">普通 Advisor</h3>
<p>使用Advice作为一个切面, 不定义切点, 拦截目标类所有方法 </p>
<ol>
<li>导入jar包, <code>spring-aop.jar</code>, <code>com.springsource.org.aopalliance.jar</code></li>
<li><p>被代理接口和实现类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDao</span>{</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span>();}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDAOImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span>{</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span>(){};}
</pre></td></tr></table></figure>
</li>
<li><p>编写前置增强</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodBeforeAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span>(Method method, Object[] args, Object target){
        pring(<span class="string">"方法前"</span>)
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>为目标对象配置代理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">beans</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"customerDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.CusotmerDao"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"mybeforeadvice"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.MyMethodBeforeAdvice"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="comment">&lt;!-- 使用代理工厂类, 创建代理 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"customerDAOProxy"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span>
        <span class="comment">&lt;!--
        target : 代理的目标对象
        proxyInterfaces : 代理要实现的接口, 如果多个接口可以使用以下格式赋值
        proxyTargetClass : 是否对类代理而不是接口，设置为true时，使用CGLib代理
        interceptorNames : 需要织入目标的Advice
        singleton : 返回代理是否为单实例，默认为单例
        optimize : 当设置为true时，强制使用CGLib
        --&gt;</span>
        <span class="comment">&lt;!-- 目标 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"customerDAO"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 针对接口代理,如果不用接口代理, 可以不写 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"proxyInterfaces"</span> <span class="attribute">value</span>=<span class="value">"cn.itcast.aop.c_advisor.CustomerDAO"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 增强 
            interceptorNames 表示可以运用多个 Advice, 必须写value
            value 引用增强的名字
        --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interceptorNames"</span> <span class="attribute">value</span>=<span class="value">"mybeforeadvice"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>使用代理</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>CustomerDao dao = context<span class="preprocessor">.getBean</span>(<span class="string">"customerDAOProxy"</span>)<span class="comment">;</span>
dao<span class="preprocessor">.save</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h3 id="pointcutadvisor">PointcutAdvisor</h3>
<p>带有切点的切面, 指定被代理对象哪些方法会被增强</p>
<ul>
<li>JdkRegexpMethodPointcut 构造正则表达式切点</li>
<li>使用正则表达式 切点切面 <code>org.springframework.aop.support.RegexpMethodPointcutAdvisor</code></li>
</ul>
<ol>
<li>创建被代理接口和对象 <code>public class OrderDaoImpl implements OrderDAO{}</code></li>
<li><p>环绕代码增强</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">extends</span> <span class="title">MethodInterceptor</span>{</span>}
</pre></td></tr></table></figure>
</li>
<li><p>配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">beans</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"OrderDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.OrderDaoImpl"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"mymethodinterceptor"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.MyMethodInterceptor"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="comment">&lt;!-- 定义切点切面 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myadvisor"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span>
        <span class="comment">&lt;!-- 正则表达式规则 --&gt;</span>
        <span class="comment">&lt;!-- pattern: zhooer\.OrderDao\.add.* --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"pattern"</span> <span class="attribute">value</span>=<span class="value">".*"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 多个规则 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"patterns"</span> <span class="attribute">value</span>=<span class="value">"*add, *delete"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"advice"</span> <span class="attribute">ref</span>=<span class="value">"mymethodinterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="comment">&lt;!-- 创建代理 --&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"orderDAOProxy"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.ProxyFactoryBean"</span> &gt;</span>
        <span class="comment">&lt;!-- 目标 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"orderDAO"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 针对类代理 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"proxyTargetClass"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 增强 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interceptorNames"</span> <span class="attribute">value</span>=<span class="value">"myadvisor"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="-">自动代理</h2>
<p>使用ProxyFactoryBean 创建代理，需要为每个Bean 都配置一次, 非常麻烦</p>
<p>自动代理和ProxyFactoryBean本质区别:
    ProxyFactoryBean, 先有被代理对象, 传递ProxyFactoryBean, 创建代理 
    自动代理, Bean构造过程中, 使用后处理Bean 创建代理, 返回构造完成对象就是代理对象 </p>
<p>自动代理原理： 根据xml中配置advisor的规则，得
知切面对哪个类的哪个方法进行代理 (切面中本身就包含 被代理对象信息) ,
就不需要ProxyFactoryBean ，使用BeanPostProcessor 完成自动代理 </p>
<ul>
<li>BeanNameAutoProxyCreator 根据Bean名称创建代理 </li>
<li>DefaultAdvisorAutoProxyCreator 根据Advisor本身包含信息创建代理</li>
<li>AnnotationAwareAspectJAutoProxyCreator 基于Bean中的AspectJ 注解进行自动代理</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 被代理对象 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"OrderDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.OrderDaoImpl"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"customerDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.CusotmerDao"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 增强 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"mymethodinterceptor"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.MyMethodInterceptor"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"mybeforeadvice"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.MyMethodBeforeAdvice"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="comment">&lt;!-- 第一种BeanName自动代理  --&gt;</span>
<span class="comment">&lt;!-- 后处理, 不需要配置id --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>&gt;</span>
    <span class="comment">&lt;!-- 对所有DAO结尾Bean 进行代理 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"beanNames"</span> <span class="attribute">value</span>=<span class="value">"*DAO"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 增强 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"interceptorNames"</span> <span class="attribute">value</span>=<span class="value">"mymethodinterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>

<span class="comment">&lt;!-- 第二种,基于切面信息自动代理 --&gt;</span>
<span class="comment">&lt;!-- 切面 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myadvisor"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span>
    <span class="comment">&lt;!-- 切点拦截信息 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"patterns"</span> <span class="attribute">value</span>=<span class="value">"zhpooer\.OrderDAO\.save.*"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 增强 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"advice"</span> <span class="attribute">ref</span>=<span class="value">"mybeforeadvice"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 后处理会自动读取切面信息   --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="aspectj">AspectJ</h1>
<p>Spring 2.0 之后,</p>
<p>AspectJ是一个面向切面的框架,它扩展了Java语言.
AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件.</p>
<p>Spring2.0之后 为了简化 AOP编程,  整合了 AspectJ, 支持AspectJ 技术 
@AspectJ 是AspectJ1.5新增功能, 通过JDK5注解技术，允许直接在Bean类中定义切面</p>
<p>新版本Spring框架, 建议使用AspectJ方式来开发AOP, 而不需要使用传统 Spring AOP 编程</p>
<h2 id="-">基于注解</h2>
<ol>
<li>导入jar包, <code>aspectj.weaver.jar</code>, <code>spring-aspects.jar</code></li>
<li>spring配置文件, 需要 aop 名称空间, <figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 配置自动代理 --&gt;</span>
<span class="comment">&lt;!-- &lt;bean class="... AnnotationAwareAspectJAutoProxyCreator" /&gt; --&gt;</span>
<span class="tag">&lt;<span class="title">aop:aspectj-autoproxy</span>/&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<p>常用注解</p>
<pre><code>@Aspect 定义切面 
通知类型 
@Before 前置通知，相当于BeforeAdvice
@AfterReturning 后置通知，相当于AfterReturningAdvice
@Around 环绕通知，相当于MethodInterceptor
@AfterThrowing抛出通知，相当于ThrowAdvice
@After 最终final通知，不管是否异常，该通知都会执行
@DeclareParents 引介通知，相当于IntroductionInterceptor (不要求掌握)
</code></pre><p>切点使用指定哪些连接点 会被增强, 通过execution函数，可以定义切点的方法切入</p>
<pre><code>语法： execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)
execution(public * *(..)) 匹配所有public修饰符 任何方法 
execution(* cn.itcast.service.HelloService.*(..))  匹配HelloService类中所有方法 
execution(int cn.itcast.service.UserService.regist(..))  匹配UserService中int返回类型 regist方法 
execution(* cn.itcast.dao..*(..))  匹配cn.itcast.dao包下 （包含子包） 所有类 所有方法
execution(* cn.itcast.dao.*(..)) 不包含子包  
execution(* cn.itcast.dao.GenericDAO+.*(..))  匹配GenericDAO 所有子类 或者 实现类 所有方法
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span>(){}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span>(){}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span>(){}
}

<span class="comment">// 自定义切面类</span>
<span class="annotation">@Aspect</span>
<span class="comment">// 声明一个切面类</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> {</span>

    <span class="comment">//方式一 前置通知</span>
    <span class="annotation">@Before</span>(<span class="string">"execution(public * *(..))"</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span>(){
        <span class="comment">// 前置通知不能拦截目标方法执行</span>
    }
    <span class="annotation">@Before</span>(<span class="string">"execution(public * *(..)"</span>))
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span>(aspactj.Joinpoint joinpoint){
        joinpoint.toString(); <span class="comment">// 获得拦截点的信息</span>
    }
    
    <span class="comment">// 方式二 后置通知</span>
    <span class="annotation">@AfterReturning</span>(<span class="string">"execution(public * *(..))"</span>, returning=<span class="string">"returnValue"</span>)
    <span class="comment">// returnValue 是代理方法参数名, 前后两个参数名必须一致</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span>(Object returnValue){
        <span class="comment">// 获得方法的返回值</span>
    }

    <span class="comment">// 方式三 环绕通知</span>
    <span class="annotation">@Around</span>(<span class="string">"execution()"</span>, )
    <span class="keyword">public</span> Object <span class="title">around</span> (ProceedingJoinPoint pjp){
        <span class="comment">// 可以阻止 search 方法执行</span>
        Object result = pjp.proceed();
        <span class="keyword">return</span> result;
    }

    <span class="comment">//方式四 抛出通知 , 出现异常后, 方法得到执行</span>
    <span class="annotation">@AfterThrowing</span>(<span class="string">"execution()"</span>, throwing=<span class="string">"e"</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span>(Throwable e){
    }

    <span class="comment">//方式五 最终通知, 不管代码是不是抛出代码都执行, 可以用来释放资源</span>
    <span class="annotation">@After</span>(<span class="string">"execution()"</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span>(){
    }
}
<span class="comment">// &lt;bean id="userDao" class="zhpooer.UserDao"&gt;&lt;/bean&gt;</span>
<span class="comment">// &lt;bean id="myAspect" class="zhpooer.MyAspect"&gt;&lt;/bean&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">切点的定义</h3>
<p>直接在通知上定义切点表达式, 会造成切点的重复, 工作量大, 不易维护</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 切点定义</span>
<span class="annotation">@Pointcut</span>(<span class="string">"execution()"</span>)
<span class="comment">// 方法名,就是切点名字</span>
<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mypointcut</span>(){}

<span class="comment">// 应用切点</span>
<span class="annotation">@After</span>(<span class="string">"MyAspect.mypointcut()"</span>)
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span>(){}
</pre></td></tr></table></figure>

<p>advisor 和 aspect 区别 ？</p>
<pre><code>advisor 是 spring 中 aop定义切面，通常由一个切点和一个通知组成
aspect 是规范中切面 ， 允许由多个切点和 多个通知组成     
</code></pre><h2 id="-xml">基于XML</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// 被代理对象</span>
<span class="keyword">public</span> <span class="keyword">class</span> ProductDao {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span>();
}

<span class="keyword">public</span> <span class="keyword">class</span> MyAspect {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span>(){
        <span class="comment">// 前置增强</span>
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span>(Ojbect returnValue){
        <span class="comment">// 后置增强</span>
    }
    <span class="keyword">public</span> Objct <span class="title">around</span>(ProceedingJoinPoint pjp){
        <span class="comment">// 环绕增强</span>
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 定义被代理对象 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"productDao"</span> <span class="attribute">class</span>=<span class="value">"ProductDao"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 定义切面 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myAspect"</span> <span class="attribute">class</span>=<span class="value">"MyAspect"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 进行AOP配置 --&gt;</span>
<span class="tag">&lt;<span class="title">aop:config</span>&gt;</span>
    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">ref</span>=<span class="value">"myAspect"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">aop:pointcut</span> <span class="attribute">expression</span>=<span class="value">"exection"</span> <span class="attribute">id</span>=<span class="value">"mypointcut"</span>&gt;</span><span class="tag">&lt;/<span class="title">aop:pointcut</span>&gt;</span>
        <span class="comment">&lt;!-- 配置前置  --&gt;</span>
        <span class="tag">&lt;<span class="title">aop:before</span> <span class="attribute">method</span>=<span class="value">"before"</span> <span class="attribute">pointcut-ref</span>=<span class="value">"mypointcut"</span>&gt;</span><span class="tag">&lt;/<span class="title">aop:before</span>&gt;</span>
        <span class="comment">&lt;!-- 后置增强 --&gt;</span>
        <span class="tag">&lt;<span class="title">aop:after-returning</span> <span class="attribute">method</span>=<span class="value">"afterReturning"</span> <span class="attribute">pointcut-ref</span>=<span class="value">"mypointcut"</span>
             <span class="attribute">returning</span>=<span class="value">"returnValue"</span>/&gt;</span>
        <span class="comment">&lt;!-- 环绕增强  --&gt;</span>
        <span class="tag">&lt;<span class="title">aop:around</span> <span class="attribute">method</span>=<span class="value">"around"</span> <span class="attribute">pointcut-ref</span>=<span class="value">"mypointcut"</span>&gt;</span><span class="tag">&lt;/<span class="title">aop:around</span>&gt;</span>
        <span class="comment">&lt;!-- 抛出通知  --&gt;</span>
        <span class="tag">&lt;<span class="title">aop:after-throwing</span> <span class="attribute">method</span>=<span class="value">"afterThrowing"</span> <span class="attribute">throwing</span>=<span class="value">"ex"</span>&gt;</span> <span class="tag">&lt;/<span class="title">aop:after-throwing</span>&gt;</span>
        <span class="comment">&lt;!-- 最终通知 --&gt;</span>
        <span class="tag">&lt;<span class="title">aop:after</span> <span class="attribute">method</span>=<span class="value">"after"</span> <span class="attribute">pointcut-ref</span>=<span class="value">"mypointcut"</span>&gt;</span><span class="tag">&lt;/<span class="title">aop:after</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span>
<span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="jdbc-template">JDBC Template</h1>
<p>Spring 为各种支持的持久化技术, 都提供了简单的模板工具类和回调</p>
<table>
<thead>
<tr>
<th>不同持久化技术</th>
<th>模板工具</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDBC</td>
<td>org.springframework.jdbc.core.JdbcTemplate</td>
</tr>
<tr>
<td>Hibernate</td>
<td>org.springframework.orm.hiberante3.HibernateTemplate</td>
</tr>
<tr>
<td>IBatis</td>
<td>org.springframework.orm.ibatis.SqlMapClientTemplate</td>
</tr>
<tr>
<td>JPA</td>
<td>org.springframework.orm.jpa.JpaTemplate</td>
</tr>
</tbody>
</table>
<p>JdbcTemplate 是用来简化JDBC操作的, 类似 DbUtils 框架.</p>
<h2 id="-">快速入门</h2>
<p>导入jar包, <code>spring-jdbc.jar</code>, <code>spring-tx.jar</code></p>
<h3 id="-jdbc">手动运行Jdbc</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span>(){
   <span class="comment">// 数据库连接池</span>
   DirverManagerDataSource ds = <span class="keyword">new</span> DirverManagerDataSource();
   ds.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);
   ds.setUrl(<span class="string">"jdbc:mysql:///"</span>);
   ds.setUsername();
   ds.setPassword();
   JdbcTemplate jt = <span class="keyword">new</span> JdbcTemplate(ds);
   jt.execute(<span class="string">""</span>);
}
</pre></td></tr></table></figure>

<h3 id="-xml-">使用 xml 配置</h3>
<p>常用数据源</p>
<ul>
<li><p>Spring 数据源实现类 <code>DriverManagerDataSource</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>&lt;bean <span class="property">id</span>=<span class="string">"dataSource"</span> <span class="type">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;
    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql:///spring3day2"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"username"</span> value=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"password"</span> value=<span class="string">"abc"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
&lt;/bean&gt;
&lt;bean <span class="property">id</span>=<span class="string">"JdbcTemplate"</span> <span class="type">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;
    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"dataSource"</span> <span class="keyword">ref</span>=<span class="string">"dataSource"</span>&gt; &lt;/<span class="keyword">property</span>&gt;
&lt;/bean&gt;
</pre></td></tr></table></figure>
</li>
<li><p>DBCP 数据源 BasicDataSource </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>&lt;bean <span class="property">id</span>=<span class="string">"dataSource"</span> <span class="type">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;
    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql:///spring3day2"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"username"</span> value=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"password"</span> value=<span class="string">"abc"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
&lt;/bean&gt;
</pre></td></tr></table></figure>
</li>
<li><p>C3P0 数据源 ComboPooledDataSource</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>&lt;bean <span class="property">id</span>=<span class="string">"dataSource"</span> <span class="type">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;
    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"driverClass"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"jdbcUrl"</span> value=<span class="string">"jdbc:mysql:///spring3day2"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"user"</span> value=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"password"</span> value=<span class="string">"abc"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
&lt;/bean&gt;
</pre></td></tr></table></figure>

</li>
</ul>
<p>外部属性文件引入, 在Spring 直接修改常用属性，不方便，
可以将属性抽取出来 建立单独 properties 文件，在Spring 中引入properties</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 方式一  --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"location"</span> <span class="attribute">value</span>=<span class="value">"classpath:jdbc.properties"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="comment">&lt;!-- 方式二 --&gt;</span>
<span class="tag">&lt;<span class="title">context:property-placeholder</span> <span class="attribute">location</span>=<span class="value">"classpath:jdbc.properties"</span>&gt;</span>

<span class="comment">&lt;!-- 将连接池配置参数，使用 ${属性key} --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.driver}"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.url}"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.user}"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"${jdbc.password}"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="jdbctemplate-crud">JdbcTemplate CRUD</h3>
<p>UserDAO 实现数据库操作, 必须要使用 JdbcTemplate, Spring 将jdbcTemplate 注入 UserDAO  </p>
<p>Spring 为每种持久化技术 提供一个支持类, 支持类作用，在DAO 中注入 模板工具类</p>
<pre><code>JDBC: org.springframework.jdbc.core.support.JdbcDaoSupport
Hibernate 3.0: org.springframework.orm.hibernate3.support.HibernateDaoSupport
iBatis: org.springframework.orm.ibatis.support.SqlMapClientDaoSupport
</code></pre><p>用户自己编写DAO 只需要继承 JdbcDaoSupport, 就可以注入 JdbcTemplate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> {</span>
    <span class="comment">// 修改</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span>(User user){
        String sql = <span class="string">"insert into user value(?, ?)"</span>;
        getJdbcTemplate().update(sql, user.getId(), user.getName());
    }
    <span class="comment">// 简单查询查询, 返回原始类型, string类型</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span>(){
        String sql = <span class="string">"select count(*) from user"</span>;
        <span class="keyword">return</span> getJdbcTemplate().queryForInt(sql);
    }
    <span class="keyword">public</span> String <span class="title">findNameById</span>(<span class="keyword">int</span> id){
        String sql = <span class="string">"select name from where id=?"</span>;
        <span class="keyword">return</span> getJdbcTemplate().queryForObject(sql, String.class, id);
    }
    <span class="comment">// 复杂查询, 手动完成对象封装</span>
    <span class="keyword">public</span> User <span class="title">findById</span>(<span class="keyword">int</span> id) {
        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForObject(sql, <span class="keyword">new</span> UserRowMapper(),id);
    }
    <span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span>(){
        <span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().query(sql, <span class="keyword">new</span> UserRowMapper());
    }

    class UserRowMapper implements RowMapper&lt;User&gt; {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> User <span class="title">mapRow</span>(ResultSet rs, <span class="keyword">int</span> rowNum) <span class="keyword">throws</span> SQLException {
        <span class="comment">// rs 已经指向每一条数据，不需要自己调用 next，将rs指向数据 转换 User对象</span>
            User user = <span class="keyword">new</span> User();
            user.setId(rs.getInt(<span class="string">"id"</span>));
            user.setName(rs.getString(<span class="string">"name"</span>));
            <span class="keyword">return</span> user;
        }
    }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="spring" scheme="http://zhpooer.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day40-Spring]]></title>
    <link href="http://zhpooer.github.io/2014/05/26/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day40-spring/"/>
    <id>http://zhpooer.github.io/2014/05/26/传智播客day40-spring/</id>
    <published>2014-05-26T01:08:04.000Z</published>
    <updated>2014-05-26T07:54:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="spring-">Spring 概念</h1>
<p>Spring 是分层的 JavaSE/EE 一站式轻量框架</p>
<p>Java 体系结构分层: 客户端分层, web层, 业务层, 持久层</p>
<p>服务器三层架构: web层, 业务层, 持久层</p>
<ul>
<li>web层: Servlet + Jsp, Struts框架</li>
<li>持久化技术: JDBC 接, Hiberante框架</li>
<li>业务层技术: EJB(复杂), Spring 框架(取代EJB)</li>
</ul>
<p>Spring 出现, 就是为了解决常见的JavaEE企业开发问题</p>
<ul>
<li>一站式: Spring 框架提供了 web层(SpringMVC), 业务层 IoC, AOP,
和事务管理, 持久层JcbcTemplate,</li>
</ul>
<p>IoC: 控制反转</p>
<p>AoP, 面向切面编程</p>
<h2 id="spring-">Spring 框架优点</h2>
<ul>
<li><p>方便解耦，简化开发</p>
<p>  Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理</p>
</li>
<li><p>AOP编程的支持</p>
<p>  Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能</p>
</li>
<li><p>声明式事务的支持</p>
<p>  只需要通过配置就可以完成对事务的管理，而无需手动编程</p>
</li>
<li><p>方便程序的测试</p>
<p>  Spring对Junit4支持，可以通过注解方便的测试Spring程序</p>
</li>
<li><p>方便集成各种优秀框架</p>
<p>  Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持</p>
</li>
<li><p>降低JavaEE API的使用难度</p>
<p>  Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低</p>
</li>
</ul>
<h2 id="spring-">Spring体系结构</h2>
<p>从Spring的规范文档中</p>
<ul>
<li>核心技术 IoC 和 AOP , 测试</li>
<li>数据访问 (持久层解决方案), 事务管理, JDBCTemplate, 其他ORM框架整合</li>
<li>Web层解决方案  SpringMVC </li>
<li>集成(WebService, JavaMail, JMS, 任务调度, 缓存)</li>
</ul>
<h1 id="ioc-di-">IOC 和 DI 开发入门</h1>
<ol>
<li>下载依赖包和开发包, 最新版本是 4.1, 课程使用3.2</li>
<li>导入Jar包,<code>spring-beans</code>, <code>spring-context</code>,
<code>spring-core</code>, <code>spring-expression</code>, <code>commons-logging</code>, <code>log4j</code></li>
</ol>
<p>IOC: 控制反转, 解决程序对象紧密耦合问题(工厂 + 反射 + 配置文件),
将原来程序自己构造的权利, 交给 IoC容器来构造, 需要一个对象,
找IoC容器获取(对象的构造权被反转)</p>
<p>DI: 依赖注入, IoC需要为程序提供依赖对象,
返回这个对象所依赖的对象, 一同可以提供.</p>
<h2 id="-">实现案例</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre><span class="comment">// web层 </span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServlet</span> {</span>
    <span class="comment">// 方式三, DI, 依赖注入,</span>
    <span class="comment">// (Spring 在构造 UserServlet 对象时, 同时提供它所依赖的对象)</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> UserService userService;
    
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span>() {
        println(<span class="string">"表现层, 添加用户"</span>);

        <span class="comment">// 方式一: 传统做法</span>
        UserService userService = <span class="keyword">new</span> UserService();

        <span class="comment">// 方式二: IOC, 通过工厂</span>
        ApplicationContext applicationContext =
            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);
        UserService userServlet = applicationContext.getBean(<span class="string">"userService"</span>);

        userService.regist();
    }
}
<span class="comment">// 业务逻辑层接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> {</span>
    <span class="keyword">void</span> regist();
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> {</span>
    <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span>(){
        println(<span class="string">"业务层, 添加用户"</span>);

        <span class="comment">// 传统做法</span>
        UserDao userDao = <span class="keyword">new</span> UserDao()
        userDao.saveUser();
    }
}

<span class="comment">// 持久层接口</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> {</span>
    <span class="keyword">void</span> saveUser();
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span>(){ println(<span class="string">"持久层, 添加用户"</span>);}
}

<span class="comment">// 测试案例</span>
<span class="annotation">@Test</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRegist</span>(){
    UserServlet us = <span class="keyword">new</span> UserServlet();
    us.regist();
}
<span class="annotation">@Test</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIoC</span>(){
    <span class="comment">// 从Ioc 容器获得对象</span>
    <span class="comment">// 1. 获取Ioc工厂, 每一次都会产生新的Spring工厂</span>
    ApplicationContext applicationContext =
        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);
    <span class="comment">// 2. 从IoC的容器工厂, 获取需要对象(根据bean的id)</span>
    UserServlet userServlet = applicationContext.getBean(<span class="string">"userServlet"</span>);
}
</pre></td></tr></table></figure>

<p>将所有对象交给IoC容器(Spring)来管理</p>
<p>通过 applicationContext 配置 Spring 管理对象</p>
<p>在程序中通过 <code>ApplicationContext</code> 接口获取工厂对象</p>
<ul>
<li>ClassPathXmlApplicationContext, 读取 src下的配置文件</li>
<li>FileSystemXmlApplicationContext, 读取 WEB-INF 下的配置文件</li>
</ul>
<p>DI是IoC的延伸</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">&lt;!-- applicationContext.xml --&gt;</span>
<span class="comment">&lt;!-- 查找文档, 添加 xsd 约束文件 --&gt;</span>
<span class="tag">&lt;<span class="title">beans</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"userServlet"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.UserServlet"</span>&gt;</span>
        <span class="comment">&lt;!-- name: 属性对应对象中 setXXX方法  --&gt;</span>
        <span class="comment">&lt;!-- ref: IoC引用bean的id --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"userService"</span> <span class="attribute">ref</span>=<span class="value">"userService"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"userService"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.UserServiceImpl"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"userDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.UserDaoImpl"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="spring-">Spring对象工厂</h1>
<p><img src="/img/spring_beanfac.png" alt="spring核心继承图">
ApplicationContext 是 BeanFactory 的子接口, BeanFactory
才是 Spring 框架最核心接口.</p>
<p>ApplicationContext 为提供了 BeanFactory 更多扩展, 企业不常用 <code>BeanFactory</code></p>
<ul>
<li>国际化处理</li>
<li>事件传递</li>
<li>Bean自动装配</li>
<li>各种不同应用层的Context实现</li>
</ul>
<p>ApplicationContext 在容器初始化时, 对其中管理Bean对象进行创建,
Bean对象在获取对象时, 才进行Bean对象初始化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>BeanFactory beanFactory =
    <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"ApplicationContext.xml"</span>));
beanFactory.getBean(<span class="string">"userService"</span>);
</pre></td></tr></table></figure>

<h1 id="ioc-bean">IoC 容器装配 Bean</h1>
<p>Spring 提供配置Bean 三种实例化方式</p>
<ul>
<li><p>使用类构造器实例化(默认无参数)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean1"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.spring.b_instance.Bean1"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>使用静态工厂方法实例化(简单工厂模式)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// &lt;bean id="bean2" class="cn.itcast.spring.b_instance.Bean2Factory"</span>
<span class="comment">//      factory-method="getBean2"&gt;&lt;/bean&gt;</span>
<span class="keyword">public</span> <span class="keyword">class</span> Bean2Factory {
    <span class="keyword">public</span> <span class="keyword">static</span> Bean2 <span class="title">getBean2</span>(){
        <span class="keyword">return</span> <span class="keyword">new</span> Bean2();
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>使用实例工厂方法实例化(工厂方法模式)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean3Factory"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.spring.b_instance.Bean3Factory"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean3"</span> <span class="attribute">factory-bean</span>=<span class="value">"bean3Factory"</span> <span class="attribute">factory-method</span>=<span class="value">"getBean3"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<p>应用场景, 大多数情况, 可以通过构造器实例化 , 如果构造过程很复杂, 可以用工厂实例化方式</p>
<h2 id="bean-">Bean 作用域</h2>
<p><code>&lt;bean&gt;</code>元素scope属性</p>
<ul>
<li><code>scope=&quot;singleton&quot;</code> 单例 ，在Spring IoC容器中仅存在一个Bean实例(默认的scope)</li>
<li><code>scope=&quot;prototype&quot;</code> 多例 ，每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时 ，相当于执行new XxxBean()</li>
<li><code>scope=&quot;request&quot;</code> 用于web开发，将Bean放入request范围 ，request.setAttribute(&quot;xxx&quot;) ， 在同一个request 获得同一个Bean</li>
<li><code>scope=&quot;session&quot;</code> 用于web开发，将Bean 放入Session范围，在同一个Session 获得同一个Bean</li>
<li><code>scope=&quot;globalSession&quot;</code> 一般用于Porlet应用环境 , 分布式系统存在全局session概念 ，如果不是porlet环境，globalSession 等同于Session</li>
</ul>
<p>在开发中主要使用 <code>scope=&quot;singleton&quot;</code>、 <code>scope=&quot;prototype</code></p>
<h2 id="bean-">Bean的生命周期</h2>
<p>配置 Spring Bean 初始化和执行方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 初始化方法, 要无返回值, 和无参数 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">init-method</span>=<span class="value">"setup"</span> <span class="attribute">destory-method</span>=<span class="value">"teardown"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<ul>
<li>destroy-method 只对 <code>scope=&quot;singleton&quot;</code> 有效</li>
<li>销毁方法，必须关闭ApplicationContext对象，才会被调用<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>ClassPathXmlApplicationContext applicationContext = <span class="built_in">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);
applicationContext.<span class="built_in">close</span>();
</pre></td></tr></table></figure>

</li>
</ul>
<h3 id="-">后处理器</h3>
<p>使用BeanPostProcessor 就是钩子函数，作用用来对Bean对象进行扩展,
可以实现动态代理, 是AOP的核心</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">// 每一个对象创建都会执行</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> {</span>
   <span class="comment">// bean: Spring容器创建的 duix</span>
   <span class="comment">// beanName, 对象的ID</span>
   <span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span>(Object bean, String beanName){
       <span class="comment">// 后处理器, 执行后</span>
       <span class="keyword">return</span> <span class="keyword">new</span> Proxy().newProxyInstance();
   }
   <span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span>(Object bean, String beanName){
       <span class="comment">// 后处理器,执行前</span>
   }
}
<span class="comment">//&lt;bean class="MyBeanPostProcessor"&gt;&lt;/bean&gt;, 不需要写id</span>
</pre></td></tr></table></figure>

<p>Bean的完整生命周期(十一步骤)</p>
<ol>
<li>instantiate bean对象实例化</li>
<li>populate properties 封装属性</li>
<li>如果Bean实现BeanNameAware 执行 setBeanName</li>
<li>如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext</li>
<li>如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization</li>
<li>如果Bean实现InitializingBean 执行 afterPropertiesSet</li>
<li>调用<code>&lt;bean init-method=&quot;init&quot;&gt;</code> 指定初始化方法 init</li>
<li>如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization</li>
<li>执行业务处理</li>
<li>如果Bean实现 DisposableBean 执行 destroy</li>
<li>调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy</li>
</ol>
<h2 id="spring-">Spring 依赖注入</h2>
<p>为Bean设置一个属性, 三种注入属性的方式</p>
<ol>
<li><p>接口注入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Injection</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectName</span>(String name);
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Injection</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectName</span>(String name){
        <span class="keyword">this</span>.name = name;
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>构造器注入</p>
</li>
<li>setter 注入</li>
</ol>
<p>Spring 只支持 构造器注入, 和 setter方法注入</p>
<ol>
<li><p>构造器注入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">&lt;!--
public class Car { 
    public Car(String name, double price){}
}
--&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"car"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.Car"</span>&gt;</span>
    <span class="comment">&lt;!-- 对象的第一个参数是Stirng --&gt;</span>
    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">index</span>=<span class="value">"0"</span> <span class="attribute">type</span>=<span class="value">"java.lang.String"</span> <span class="attribute">value</span>=<span class="value">"保时捷"</span>&gt;</span><span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span>
    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">index</span>=<span class="value">"1"</span> <span class="attribute">type</span>=<span class="value">"double"</span> <span class="attribute">value</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>setter注入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">&lt;!--  
public class Car{
    @BeanProperty public String name;
    @BeanProperty public String price;
}
public class Employee{
    @BeanProperty public String name;
    @BeanProperty public Car car; 
}
--&gt;</span>
<span class="comment">&lt;!-- 使用 ref 属性, 可以注入复杂对象 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"car2"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.Car"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"宝马"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"price"</span> <span class="attribute">value</span>=<span class="value">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"emplayee"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.Employee"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"zhangsan"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"car"</span> <span class="attribute">ref</span>=<span class="value">"car2"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h3 id="-p">名称空间 p</h3>
<p>Spring 2.5新特性, 简化属性注入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- p:&lt;属性名&gt;="xxx" 引入常量值 --&gt;</span>
<span class="comment">&lt;!-- p:&lt;属性名&gt;-ref="xxx" 引用其它Bean对象 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">xmlns:p</span>=<span class="value">"http://www.springframework.org/schema/p"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"car2"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.Car"</span> <span class="attribute">p:name</span>=<span class="value">"宝马"</span> <span class="attribute">p:price</span>=<span class="value">"1000"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"employee"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.Emplayee"</span> <span class="attribute">p:name</span>=<span class="value">"lisi"</span> <span class="attribute">p:car2-ref</span>=<span class="value">"car2"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="spel-">spEL 表达式</h2>
<ol>
<li><p>完成对象之间注入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"car2"</span> <span class="attribute">ref</span>=<span class="value">"car2"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="comment">&lt;!-- 改为 --&gt;</span>
<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"car2"</span> <span class="attribute">value</span>=<span class="value">"#{car2}"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>应用其他对象属性</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;bean <span class="property">id</span>=<span class="string">"carInfo"</span> <span class="type">class</span>=<span class="string">"cn.itcast.spring.e_di.CarInfo"</span>&gt;&lt;/bean&gt;
&lt;bean <span class="property">id</span>=<span class="string">"car2_2"</span> <span class="type">class</span>=<span class="string">"cn.itcast.spring.e_di.Car2"</span>&gt;
    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"name"</span> value=<span class="string">"#{carInfo.name}"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
&lt;/bean&gt;
</pre></td></tr></table></figure>
</li>
<li><p>调用其他bean的方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>&lt;bean <span class="property">id</span>=<span class="string">"carInfo"</span> <span class="type">class</span>=<span class="string">"cn.itcast.spring.e_di.CarInfo"</span>&gt;&lt;/bean&gt;
&lt;bean <span class="property">id</span>=<span class="string">"car2_2"</span> <span class="type">class</span>=<span class="string">"cn.itcast.spring.e_di.Car2"</span>&gt;
    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"name"</span> value=<span class="string">"#{carInfo.name}"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
	&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"price"</span> value=<span class="string">"#{carInfo.caculatePrice()}"</span>&gt;&lt;/<span class="keyword">property</span>&gt;
&lt;/bean&gt;
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="-">集合属性的注入</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="comment">&lt;!--  
public class CollectionBean{
     @BeanProperty private List&lt;String&gt; hobbies;
     @BeanProperty private Set&lt;Integer&gt; numbers;
     @BeanProperty private Map&lt;String, String&gt; map;
     @BeanProperty private Properties properties;
}
 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"collectionBean"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.CollectionBean"</span>&gt;</span>
    <span class="comment">&lt;!-- List注入 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hobbies"</span>&gt;</span>
        <span class="comment">&lt;!-- 数组也是这么配置 --&gt;</span>
        <span class="tag">&lt;<span class="title">list</span>&gt;</span>
           <span class="comment">&lt;!-- &lt;ref&gt;&lt;/ref&gt;, 表示引用 --&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>学习<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- Set 注入 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"numbers"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">set</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>10 <span class="tag">&lt;/<span class="title">value</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- Map 注入 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"map"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">map</span>&gt;</span>
           <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key-ref</span>=<span class="value">""</span>/&gt;</span> <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
           <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"神"</span>&gt;</span> <span class="tag">&lt;/<span class="title">entry</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">map</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- Properties 注入 --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"properties"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">props</span>&gt;</span>
            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"company"</span>&gt;</span> 传智播客 <span class="tag">&lt;/<span class="title">prop</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">props</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-xml-">多个XML配置文件</h1>
<p>分开配置, 便于管理</p>
<ol>
<li><p>并列引入多个XML</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>ApplicationContext <span class="keyword">context</span> =
    <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean1.xml"</span>, <span class="string">"bean2.xml"</span>);
</pre></td></tr></table></figure>
</li>
<li><p>引入总xml文件，在总xml文件引入 子xml文件, 常用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- applicationContext.xml --&gt;</span>
<span class="tag">&lt;<span class="title">import</span> <span class="attribute">resource</span>=<span class="value">"classpath:bean1.xml"</span>/&gt;</span>
<span class="tag">&lt;<span class="title">import</span> <span class="attribute">resource</span>=<span class="value">"classpath:bean2.xml"</span>/&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-ioc">注解配置 IoC</h1>
<p><code>@Component</code> 描述 Bean</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>@Component(<span class="string">"helloService"</span>)
<span class="comment">// &lt;bean id="helloService" class="..."/&gt;</span>
<span class="keyword">public</span> <span class="keyword">class</span> HelloService{
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(){
        println(<span class="string">""</span>);
    }
}
</pre></td></tr></table></figure>

<p>applicationContext.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 引入context描述文件 --&gt;</span>
<span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmln:context</span>=<span class="value">"http://www.springframework.org /schema/context"</span>&gt;</span>
    <span class="comment">&lt;!-- 使Spring扫描到bean --&gt;</span>
    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"io.zhpooer"</span>&gt;</span><span class="tag">&lt;/<span class="title">context:component-scan</span>&gt;</span>
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<p>spring2.5 引入@Component 等效三个衍生注解</p>
<ul>
<li><code>@Repository</code> 用于对DAO实现类进行标注 (持久层)</li>
<li><code>@Service</code> 用于对Service实现类进行标注 (业务层)</li>
<li><code>@Controller</code> 用于对Controller实现类进行标注 (表现层)</li>
</ul>
<h2 id="-">属性依赖注入</h2>
<ol>
<li>简单属性注入<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="annotation">@Service</span>(<span class="string">"userService"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span>{</span>
    <span class="comment">// 1. 简单属性注入, set 方法都可以不用</span>
    <span class="annotation">@Value</span>(<span class="string">"itcast"</span>)
    <span class="keyword">private</span> String name;
    
    <span class="comment">// 2. 复杂属性注入, 根据类型自动注入</span>
    <span class="annotation">@Autowired</span> 
    <span class="keyword">private</span> UserDao userDao;
    
    <span class="comment">// 3. 复杂属性注入, 结合 Qualifier, 根据名字注入</span>
    <span class="annotation">@Autowired</span>(required=<span class="keyword">false</span>)  <span class="comment">// required默认true, 若注册不成功,或报错</span>
    <span class="annotation">@Qualifier</span>(<span class="string">"userDao"</span>)
    <span class="keyword">private</span> UserDao userDao;

    <span class="comment">// 4. @Resource和@Autowired注解功能相似, 是JSR标准</span>
    <span class="annotation">@Resource</span>(name=<span class="string">"userDAO"</span>)
	<span class="keyword">private</span> UserDAO userDAO ;
}
<span class="annotation">@Repository</span>(<span class="string">"userDao"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span>{</span>
   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span>();
}
</pre></td></tr></table></figure>

</li>
</ol>
<p><code>@Value</code> <code>@Autowired</code> 注解都可以修饰 成员变量 或者 setter方法,
如果修改成员变量，不需要提供setter方法</p>
<h2 id="-">初始化销毁</h2>
<p>指定Bean的初始化方法和销毁方法(注解)
<code>&lt;bean init-method=&quot;&quot; destroy-method=&quot;&quot; /&gt;</code></p>
<ul>
<li><code>@PostConstruct</code>  作用 init-method</li>
<li><code>@PreDestroy</code>  作用 destroy-method</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleBean</span>{</span>
    <span class="annotation">@PostConstruct</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(){}
    <span class="annotation">@PreDestroy</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(){}
}
</pre></td></tr></table></figure>

<h2 id="bean-">Bean作用范围</h2>
<p>Bean的作用范围  <code>&lt;bean scope=&quot;&quot; /&gt;</code></p>
<ul>
<li><code>@Scope</code> 注解 ，默认作用域 singleton 单例</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="annotation">@Service</span>
<span class="annotation">@Scope</span>(<span class="string">"prototype"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeBean</span>{</span>}
</pre></td></tr></table></figure>

<h2 id="spring3-0-">Spring3.0 的注解</h2>
<p>JavaConfig: 以一个Java类做配置文件</p>
<ul>
<li><code>@Configuration</code> 指定POJO类为Spring提供Bean定义信息</li>
<li><code>@Bean</code> 提供一个Bean定义信息</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Car {
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> <span class="keyword">double</span> price;
}

<span class="keyword">public</span> <span class="keyword">class</span> Product {
    <span class="keyword">private</span> String pname;
    <span class="keyword">private</span> <span class="keyword">int</span> pnum;
}

<span class="comment">// 配置Bean, (工厂)</span>
<span class="comment">// 获得两个Bean, 相当于获取配置文件声明两个Bean</span>
@Configuration
<span class="keyword">public</span> <span class="keyword">class</span> BeanConfig {
    @Bean(name=<span class="string">"car"</span>)
    <span class="keyword">public</span> Car <span class="title">initCar</span>(){
        Car car = <span class="keyword">new</span> Car();
        car.setName(<span class="string">"大宗"</span>);
        <span class="keyword">return</span> car;
    }
    @Bean(name=<span class="string">"product"</span>)
    <span class="keyword">public</span> Product <span class="title">showProduct</span>(){
        Product p = <span class="keyword">new</span> Product();
        <span class="keyword">return</span> p;
    }
}
<span class="comment">// 配置自动扫描, 让文件被扫描到</span>
</pre></td></tr></table></figure>

<h1 id="xml-">xml和注解混合使用</h1>
<p>很多企业开发者 还是采用 xml作为主流配置</p>
<ul>
<li>Bean 注册 通过XML完成</li>
<li>注入使用 @Autowired 注解完成</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> CustomerDao {}

<span class="keyword">public</span> <span class="keyword">class</span> OrderDao {}

<span class="keyword">public</span> <span class="keyword">class</span> CustomerService {
    @Autowired
    <span class="keyword">private</span> CustomerDao cDao;
    @Autowired
    <span class="keyword">private</span> OderDap oDao;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">beans</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"customerDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.CustomerDao"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"orderDao"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.OrderDao"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"customerSerivce"</span> <span class="attribute">class</span>=<span class="value">"zhpooer.CustomerService"</span>&gt;</span> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
    <span class="comment">&lt;!-- 启用四个注解 --&gt;</span>
    <span class="comment">&lt;!-- @Resource、@ PostConstruct、@ PreDestroy、@Autowired --&gt;</span>
    <span class="tag">&lt;<span class="title">context:annotation-config</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">beans</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">结论</h1>
<ol>
<li>xml配置 和 注解配置 效果完全相同</li>
<li>如果Bean 来自第三方， 必须使用xml</li>
<li>Spring3.0 Bean注册方式， 使用比较少，
主要用于Bean 构造逻辑及其复杂</li>
</ol>
<h1 id="web-spring-">web spring 整合开发</h1>
<p>直接在Servlet 加载Spring 配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>)<span class="comment">;</span>
HelloService helloService = (HelloService) applicationContext<span class="preprocessor">.getBean</span>(<span class="string">"helloService"</span>)<span class="comment">;</span>
helloService<span class="preprocessor">.sayHello</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>每次请求都会加载Spring环境，初始化所有Bean ，性能问题 ！！！</p>
<ul>
<li>解决方案一 ： 将代码放入Servlet init 中 ， 无法保证所有Servlet都能使用 ApplicationContext</li>
<li>解决方案二 ： ServletContext, tomcat启动时， 加载Spring配置文件，获得对象 ，放入ServletContext</li>
</ul>
<ol>
<li>导入spring-web.jar</li>
<li><p>配置web.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre> <span class="comment">&lt;!-- 保存 ContextLoaderListener 完成在Servlet初始化阶段，
      加载Spring配置文件，将工厂对象放入 ServletContext --&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>默认读取 WEB-INF/applicationContext.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 配置 全局参数 contextConfigLocation 指定 配置文件位置 --&gt;</span>
<span class="tag">&lt;<span class="title">context-param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>在servlet中获取 Spring 容器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// 方式一:
WebApplicationContext applicationContext =
    getServletContext()<span class="preprocessor">.getAttribute</span>(WebApplicationContext<span class="preprocessor">.ROOT</span>_WEB_APPLICATION_CONTEXT_ATTRIBUTE)<span class="comment">;</span>
// 方式二: 
WebApplicationContext applicationContext =
    WebApplicationContextUtils<span class="preprocessor">.getWebApplicationContext</span>(getServletContext())<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-junit">整合Junit</h1>
<p>导入 spring-test.jar</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="annotation">@RunWith</span>(SpringJUnit4ClassRunner.class)
<span class="comment">// 指定配置文件位置</span>
<span class="annotation">@ContextConfiguration</span>(locations=<span class="string">"classpath:applicationContext.xml"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceTest</span>{</span>
    <span class="annotation">@Autowired</span>
	<span class="keyword">private</span> HelloService helloService; <span class="comment">// 注入需要测试对象</span>
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="Spring" scheme="http://zhpooer.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day39-JQuery Dom]]></title>
    <link href="http://zhpooer.github.io/2014/05/25/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day39-jquery-dom/"/>
    <id>http://zhpooer.github.io/2014/05/25/传智播客day39-jquery-dom/</id>
    <published>2014-05-25T08:26:53.000Z</published>
    <updated>2014-05-30T09:10:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">内部插入节点</h1>
<ul>
<li>append(content) : 向每个匹配的元素的内部的结尾处追加内容</li>
<li>appendTo(content) : 将每个匹配的元素追加到指定的元素中的内部结尾处</li>
<li>prepend(content) : 向每个匹配的元素的内部的开始处插入内容</li>
<li>prependTo(content) : 将每个匹配的元素插入到指定的元素内部的开始处</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"#city"</span>).append(<span class="variable">$(</span><span class="string">"#fk"</span>))
</pre></td></tr></table></figure>

<h1 id="-">外部插入节点</h1>
<ul>
<li>after(content) :在每个匹配的元素之后插入内容 </li>
<li>before(content):在每个匹配的元素之前插入内容 </li>
<li>insertAfter(content):把所有匹配的元素插入到另一个、指定的元素元素集合的后面 </li>
<li>insertBefore(content) :把所有匹配的元素插入到另一个、指定的元素元素集合的前面</li>
</ul>
<p>以上方法不但能将新创建的 DOM 元素插入到文档中, 也能对原有的 DOM 元素进行移动.</p>
<h1 id="-">查找节点</h1>
<ul>
<li>查找属性节点: 通过 jQuery 选择器完成.</li>
<li>查找属性节点: 查找到所需要的元素之后, 可以调用 jQuery 对象的 attr() 方法来获取它的各种属性值</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"img"</span>).attr(<span class="string">"name"</span>); <span class="regexp">//</span> 获取 name 属性
</pre></td></tr></table></figure>

<h1 id="-">创建元素</h1>
<p>使用 jQuery 的工厂函数 <code>$(html);</code>
会根据传入的 html 标记字符串创建一个 DOM 对象,
并把这个 DOM 对象包装成一个 jQuery 对象返回.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>$().ready( <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> <span class="variable">$sh</span> = $(<span class="string">"&lt;li&gt;&lt;/li&gt;"</span>);
    <span class="comment">// 方式一:</span>
    <span class="variable">$sh</span>.attr(<span class="string">"id"</span>, <span class="string">"sh"</span>);
    <span class="variable">$sh</span>.attr(<span class="string">"name"</span>, <span class="string">"shanghai"</span>);
    <span class="comment">// 方式二:</span>
    <span class="variable">$sh</span>.attr({id:<span class="string">'sh'</span>, name:<span class="string">'shanghai'</span>});
    
    <span class="variable">$sh</span>.text(<span class="string">"上海"</span>);
    <span class="variable">$sh</span>.appendTo($(<span class="string">"#city"</span>))
});
</pre></td></tr></table></figure>

<h1 id="-">删除节点</h1>
<ul>
<li><code>remove()</code>: 从 DOM 中删除所有匹配的元素,
传入的参数用于根据 jQuery 表达式来筛选元素.
当某个节点用 remove() 方法删除后,
该节点所包含的所有后代节点将被同时删除.
这个方法的返回值是一个指向已被删除的节点的引用.</li>
<li><code>empty()</code>: 清空节点 – 清空元素中的所有后代节点(不包含属性节点).</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>$(<span class="string">"#bj"</span>).remove();
$(<span class="string">"#city"</span>).empty();

$(<span class="string">"&lt;td&gt;&lt;/td&gt;"</span>).append($(<span class="string">"&lt;a&gt;&lt;/a&gt;"</span>).text(<span class="string">"删除"</span>));

$(<span class="string">"a"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    $(<span class="keyword">this</span>).parent().parent().empty();
})
</pre></td></tr></table></figure>

<h1 id="-">复制节点</h1>
<ul>
<li>clone(): 克隆匹配的 DOM 元素, 返回值为克隆后的副本. 但此时复制的新节点不具有任何行为.</li>
<li>clone(true): 复制元素的同时也复制元素中的的事件 </li>
</ul>
<h1 id="-">替换节点</h1>
<ul>
<li>replaceWith(): 将所有匹配的元素都替换为指定的 HTML 或 DOM 元素</li>
<li>replaceAll(): 颠倒了的 replaceWith() 方法.</li>
</ul>
<p>注意: 若在替换之前, 已经在元素上绑定了事件, 替换后原先绑定的事件会与原先的元素一起消失</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"p"</span>).replaceWith(<span class="string">"&lt;button&gt;&lt;/button&gt;"</span>);
<span class="variable">$(</span><span class="string">"&lt;button&gt;&lt;/button&gt;"</span>).replaceAll(<span class="string">"p"</span>);
</pre></td></tr></table></figure>

<h1 id="-">属性操作</h1>
<ul>
<li>attr(): 获取属性和设置属性<ul>
<li>当为该方法传递一个参数时, 即为某元素的获取指定属性</li>
<li>当为该方法传递两个参数时, 即为某元素设置指定属性的值
jQuery 中有很多方法都是一个函数实现获取和设置.
如: attr(), html(), text(), val(), height(), width(), css() 等.</li>
</ul>
</li>
</ul>
<p>removeAttr(): 删除指定元素的指定属性</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>&lt;select id=<span class="string">"single"</span>&gt;
  &lt;<span class="built_in">option</span>&gt;Single&lt;/<span class="built_in">option</span>&gt;
  &lt;<span class="built_in">option</span>&gt;Single2&lt;/<span class="built_in">option</span>&gt;
&lt;/select&gt;
&lt;select id=<span class="string">"multiple"</span> multiple=<span class="string">"multiple"</span>&gt;
  &lt;<span class="built_in">option</span> selected=<span class="string">"selected"</span>&gt;Multiple&lt;/<span class="built_in">option</span>&gt;
  &lt;<span class="built_in">option</span>&gt;Multiple2&lt;/<span class="built_in">option</span>&gt;
  &lt;<span class="built_in">option</span> selected=<span class="string">"selected"</span>&gt;Multiple3&lt;/<span class="built_in">option</span>&gt;
&lt;/select&gt;&lt;br/&gt;
&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"checkbox"</span> <span class="keyword">value</span>=<span class="string">"check1"</span>/&gt; check1
&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"checkbox"</span> <span class="keyword">value</span>=<span class="string">"check2"</span>/&gt; check2
&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"radio"</span> <span class="keyword">value</span>=<span class="string">"radio1"</span>/&gt; radio1
&lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"radio"</span> <span class="keyword">value</span>=<span class="string">"radio2"</span>/&gt; radio2
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="char">$(</span><span class="comment">"#single"</span>).val(<span class="comment">"Single2"</span>);
<span class="char">$(</span><span class="comment">"#multiple"</span>).val([<span class="comment">"Multiple2"</span>, <span class="comment">"Multiple3"</span>]);
<span class="char">$(</span><span class="comment">"input"</span>).val([<span class="comment">"check2"</span>, <span class="comment">"radio1"</span>]);

<span class="char">$(</span>“div”).html(“&lt;p&gt;奥运接受了&lt;/p&gt;<span class="comment">");
$(“div”).html();</span>
</pre></td></tr></table></figure>

<h1 id="-">样式操作</h1>
<ul>
<li>获取 class 和设置 class : class 是元素的一个属性,
所以获取 class 和设置 class 都可以使用 attr() 方法来完成.</li>
<li>追加样式: addClass() </li>
<li>移除样式: removeClass(), 从匹配的元素中删除全部或指定的 class</li>
<li>切换样式: toggleClass(), 控制样式上的重复切换.如果类名存在则删除它,
如果类名不存在则添加它.</li>
<li>判断是否含有某个样式: hasClass(), 判断元素中是否含有某个 class,
如果有, 则返回 true; 否则返回 false</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>$.trim(<span class="string">"  text "</span>)

$(<span class="string">"h1"</span>).each(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    $(<span class="keyword">this</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        $(<span class="keyword">this</span>).slideToggle(<span class="string">"nomal"</span>);
    });
});
</pre></td></tr></table></figure>

<h1 id="css-dom">CSS DOM</h1>
<ul>
<li>获取和设置元素的样式属性: css()</li>
<li>获取和设置元素透明度: opacity 属性, IE6,IE7不支持此属性</li>
<li>获取和设置元素高度, 宽度: height(), width().
在设置值时, 若只传递数字, 则默认单位是 px.
如需要使用其他单位则需传递一个字符串, 例如 $(“p:first”).height(“2em”);</li>
<li>获取元素在当前视窗中的相对位移: offset().
其返回对象包含了两个属性: top, left. 该方法只对可见元素有效</li>
</ul>
<p>em是相对长度单位。相对于当前对象内文本的字体尺寸 </p>
<h1 id="jquery-">Jquery 验证框架</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>&lt;script <span class="keyword">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"jquery.js"</span>/&gt;
&lt;script <span class="keyword">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"jquery-validate.js"</span>/&gt;
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="jquery" scheme="http://zhpooer.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day38-JQuery]]></title>
    <link href="http://zhpooer.github.io/2014/05/24/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day38-jquery/"/>
    <id>http://zhpooer.github.io/2014/05/24/传智播客day38-jquery/</id>
    <published>2014-05-24T03:17:29.000Z</published>
    <updated>2014-05-30T10:44:22.000Z</updated>
    <content type="html"><![CDATA[<p>当前流行的 JavaScript 库有:
jQuery, MooTools, Prototype, Dojo, YUI, EXT_JS(强大, 学习成本高), DWR(用java代码写)</p>
<h1 id="jquery-">JQuery 初识</h1>
<p>轻量级js库, 压缩后只有 21K</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> inputObj = document.getElementById(<span class="string">"uname"</span>);
log(inputObj.value)
<span class="comment">// 等同于, 用 jQuery</span>
log(#(<span class="string">"#username"</span>).val());

<span class="comment">// 文档全部加载完毕后执行, 相当于 window.onload = function(){}</span>
<span class="comment">// 方式一</span>
$(document).ready(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> <span class="comment">/*todo*/</span> });
<span class="comment">// 方式二</span>
$().ready(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>});
<span class="comment">// 方式三</span>
$(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>});
</pre></td></tr></table></figure>

<h1 id="jquery-">JQuery 对象</h1>
<ul>
<li>jQuery 对象就是通过jQuery包装DOM对象后产生的对象</li>
<li>jQuery 对象是 jQuery 独有的. 如果一个对象是 jQuery 对象,
那么它就可以使用 jQuery 里的方法: <code>$(“#test”).html()</code></li>
<li>虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，
同理DOM对象也不能使用jQuery里的方法.乱使用会报错</li>
<li>约定：如果获取的是 jQuery 对象, 那么要在变量前面加上 <code>$</code><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">var</span> <span class="variable">$variable</span> <span class="subst">=</span> jQuery 对象
<span class="built_in">var</span> <span class="built_in">variable</span> <span class="subst">=</span> DOM 对象
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="dom-jquery-">DOM对象和JQuery对象互转</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">// DOM 转换为 JQuery 对象</span>
<span class="keyword">var</span> inputObj = document.getElementById(<span class="string">"username"</span>);
<span class="keyword">var</span> <span class="variable">$obj</span> = $(inputObj);
log(<span class="variable">$obj</span>.val())

<span class="comment">// JQuery -&gt; DOM对象</span>

<span class="keyword">var</span> <span class="variable">$inputObj</span> = $(<span class="string">"#username"</span>);
<span class="comment">// 方式一: JQuery 是一个数组对象, 可以通过[index], 得到 DOM 对象</span>
<span class="keyword">var</span> inputObj = <span class="variable">$inputObj</span>[<span class="number">0</span>];
<span class="comment">// 方式二:</span>
<span class="keyword">var</span> domObj = <span class="variable">$inputObj</span>.get(<span class="number">0</span>);
</pre></td></tr></table></figure>

<h1 id="jquery-">jQuery 对象</h1>
<ul>
<li>通过jQuery 包装DOM对象产生的对象</li>
<li>是jQuery里面独有的, 可以使用jQeury中特有的方法</li>
<li>jQuery对象无法使用Dom中的方法, 反过来也一样</li>
</ul>
<h1 id="jquery-">JQuery 选择器</h1>
<p>对事件处理, 遍历 DOM 和 Ajax 操作都依赖于选择器</p>
<p>优点:</p>
<ul>
<li><p>简洁的写法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"#id"</span>) == document.getElementById(<span class="string">"id"</span>)
<span class="variable">$(</span><span class="string">"tagname"</span>) == document.getElementsByTagName(<span class="string">"tagname"</span>)
</pre></td></tr></table></figure>
</li>
<li><p>完善的事件处理机制</p>
</li>
</ul>
<h2 id="-">基本选择器</h2>
<p>基本选择器是 jQuery 中最常用的选择器, 也是最简单的选择器,
它通过元素 id, class 和标签名来查找 DOM 元素
(在网页中 id 只能使用一次, class 允许重复使用).</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>#id</td>
<td>$(”#myDiv”);</td>
<td>单个元素的组成的集合</td>
<td>这个就是直接选择html中的id=”myDiv”</td>
</tr>
<tr>
<td>Element</td>
<td>$(”div”)</td>
<td>集合元素</td>
<td>例如 div, input, a等等.</td>
</tr>
<tr>
<td>class</td>
<td>$(”.myClass”)</td>
<td>集合元素</td>
<td>直接选择html代码中class=”myClass”的元素或元素组(因为在同一html页面中class是可以存在多个同样值的)</td>
</tr>
<tr>
<td>*</td>
<td>$(”*”)</td>
<td>集合元素</td>
<td>匹配所有元素,多用于结合上下文来搜索</td>
</tr>
<tr>
<td>selector1, selector2, selectorN</td>
<td>$(”div,span,p.myClass”)</td>
<td>集合元素</td>
<td>将每一个选择器匹配到的元素合并后一起返回</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>$(<span class="string">"#b1"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="comment">// 改变id为one的元素的背景色</span>
    $(<span class="string">"#one"</span>).css(<span class="string">"background-color"</span>, <span class="string">"red"</span>);
    $(<span class="string">"span, #one"</span>).css(<span class="string">"background-color"</span>, <span class="string">"red"</span>);
})
</pre></td></tr></table></figure>

<h2 id="-">层次选择器</h2>
<p>如果想通过 DOM 元素之间的层次关系来获取特定元素,
例如后代元素, 子元素, 相邻元素, 兄弟元素等, 则需要使用层次选择器.</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ancestor descendant</td>
<td>$(”form input”)</td>
<td>在给定的祖先元素下匹配所有<em>后代元素</em></td>
</tr>
<tr>
<td>parent &gt; child</td>
<td>$(”form &gt; input”)</td>
<td>在给定的父元素下匹配所有<em>子元素</em></td>
</tr>
<tr>
<td>prev + next</td>
<td>$(”label + input”)</td>
<td>匹配所有紧接在 prev 元素后的 next 元素 (单个)</td>
</tr>
<tr>
<td>prev ~ siblings</td>
<td>$(”form ~ input”)</td>
<td>匹配 prev <em>元素之后</em>的所有 siblings 元素</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// id 为 two的元素的所有 &lt;div&gt; 兄弟元素</span>
$(<span class="string">"#two"</span>).siblings(<span class="string">".div"</span>).css(<span class="string">"background-color"</span>, <span class="string">"red"</span>);
</pre></td></tr></table></figure>

<h2 id="-">过滤选择器</h2>
<p>过滤选择器主要是通过特定的过滤规则来筛选出所需的 DOM 元素,
该选择器都以 “:” 开头</p>
<p>按照不同的过滤规则, 过滤选择器可以分为基本过滤, 内容过滤,
可见性过滤, 属性过滤, 子元素过滤和表单对象属性过滤选择器.</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:first</td>
<td>$(”tr:first”)</td>
<td>匹配找到的第一个元素</td>
</tr>
<tr>
<td>:last</td>
<td>$(”tr:last”)</td>
<td>匹配找到的最后一个元素.与 :first 相对应</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>$(”input:not(:checked)”)</td>
<td>意思是没有被选中的input(当input的type=”checkbox”)</td>
</tr>
<tr>
<td>:even</td>
<td>$(”tr:even”)</td>
<td>匹配所有索引值为偶数的元素，从 0 开始计数</td>
</tr>
<tr>
<td>:odd</td>
<td>$(”tr:odd”)</td>
<td>匹配所有索引值为奇数的元素,和:even对应</td>
</tr>
<tr>
<td>:eq(index)</td>
<td>$(”tr:eq(0)”)</td>
<td>匹配一个给定索引值的元素.eq(0) 括号里面不是元素排列数.</td>
</tr>
<tr>
<td>:gt(index)</td>
<td>$(”tr:gt(0)”)</td>
<td>匹配所有大于给定索引值的元素</td>
</tr>
<tr>
<td>:lt(index)</td>
<td>$(”tr:lt(2)”)</td>
<td>匹配所有小于给定索引值的元素</td>
</tr>
<tr>
<td>:header(固定写法)</td>
<td>$(”:header”).css(”background”, “#EEE”)</td>
<td>匹配如 h1, h2, h3之类的标题元素.这个是专门用来获取h1,h2这样的标题元素.</td>
</tr>
<tr>
<td>:animated(固定写法)</td>
<td></td>
<td>说明: 匹配所有正在执行动画效果的元素</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$(</span><span class="string">"div:first"</span>).css(<span class="string">"background-color"</span>, <span class="string">"red"</span>); <span class="regexp">//</span> == <span class="variable">$(</span><span class="string">"div"</span>).first()
<span class="variable">$(</span><span class="string">"div:not(.one)"</span>).css(<span class="string">"background-color"</span>, <span class="string">"red"</span>);
</pre></td></tr></table></figure>

<h2 id="-">内容过滤选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:contains(text)</td>
<td><code>$(”div:contains(’John’)”)</code></td>
<td>匹配包含给定文本的元素</td>
</tr>
<tr>
<td>:empty</td>
<td><code>$(”td:empty”)</code></td>
<td>匹配所有不包含子元素或者文本的空元素</td>
</tr>
<tr>
<td>:has(selector)</td>
<td><code>$(”div:has(p)”).addClass(”test”)</code></td>
<td>匹配含有选择器所匹配的元素的元素, 给所有包含p元素的div标签加上class=”test”.</td>
</tr>
<tr>
<td>:parent</td>
<td><code>$(”td:parent”)</code></td>
<td>匹配含有子元素或者文本的元素</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>// 不含有 文本 <span class="string">'di'</span> 的元素
<span class="char">$(</span><span class="string">'div:not(:contains('</span>di<span class="string">'))'</span>)
<span class="char">$(</span><span class="string">'div:not(:empty)'</span>) // <span class="char">$(</span><span class="string">'div:parent'</span>)
</pre></td></tr></table></figure>

<h2 id="-">可见度过滤选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:hidden</td>
<td>$(”tr:hidden”)</td>
<td>匹配所有的不可见元素(也包括不可见的孩子们)，意思是css中display:none和input type=”hidden”的都会被匹配到.</td>
</tr>
<tr>
<td>:visible</td>
<td>$(”tr:visible”)</td>
<td>匹配所有的可见元素</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">/*
index: 当前遍历的索引
domElm: 当前遍历的DOM对象
*/</span>
$(<span class="string">"div:hidden"</span>).each( <span class="function"><span class="keyword">function</span><span class="params">(index, domElm)</span>{</span>
    $(<span class="keyword">this</span>).show();  <span class="comment">//相当于 domElm</span>
});
</pre></td></tr></table></figure>

<h2 id="-">练习</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// 给网页中所有 &lt;p&gt; 元素添加 onclick 事件, 打印文本 html()/text()</span>
$(<span class="string">"p"</span>).each( <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    $(<span class="keyword">this</span>).click( <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        $(<span class="keyword">this</span>).html();
        $(<span class="keyword">this</span>).text();
    });
});
<span class="comment">// 使一个特定表格隔行变色</span>
$(<span class="string">"table:eq(0) tr:even"</span>).css(<span class="string">"background-color"</span>, <span class="string">"red"</span>);
$(<span class="string">"table:eq(0) tr:odd"</span>).css(<span class="string">"background-color"</span>, <span class="string">"yellow"</span>);
</pre></td></tr></table></figure>

<h2 id="-">属性过滤选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[attribute]</td>
<td>$(”div[id]“)</td>
<td>选取了所有带”id”属性的div标签</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>$(”input[name=&#39;newsletter&#39;]“)</td>
<td>匹配给定的属性是某个特定值的元素</td>
</tr>
<tr>
<td>[attribute!=value]</td>
<td>$(”input[name!=&#39;newsletter&#39;]“)</td>
<td>匹配所有不含有指定的属性，或者属性不等于特定值的元素</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>$(”input[name^=‘news’]“)</td>
<td>匹配给定的属性是以某些值开始的元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>$(”input[name$=‘letter’]“)</td>
<td>匹配给定的属性是以某些值结尾的元素</td>
</tr>
<tr>
<td>[attribute* =value]</td>
<td>$(”input[name*=‘man’]“)</td>
<td>匹配给定的属性是以包含某些值的元素</td>
</tr>
<tr>
<td>[attributeFilter1][attributeFilter2][attributeFilterN]</td>
<td>$(”input[id][name$=‘man’]“)</td>
<td>复合属性选择器,需要同时满足多个条件时使用</td>
</tr>
</tbody>
</table>
<h2 id="-">子元素过滤选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:nth-child(index/even/odd/equation)</td>
<td>$(”ul li:nth-child(2)”)</td>
<td>匹配其父元素下的第N个子或奇偶元素, 从1开始</td>
</tr>
<tr>
<td>:first-child</td>
<td>$(”ul li:first-child”)</td>
<td>匹配第一个子元素.’:first’ 只匹配一个元素,而此选择符将为每个父元素匹配一个子元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>$(”ul li:last-child”)</td>
<td>匹配最后一个子元素.’:last’ 只匹配一个元素,而此选择符将为每个父元素匹配一个子元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>$(”ul li:only-child”)</td>
<td>如果某个元素是父元素中唯一的子元素,那将会被匹配.如果父元素中含有其他元素,那将不会被匹配</td>
</tr>
</tbody>
</table>
<p>nth-child() 选择器详解如下：</p>
<ul>
<li>:nth-child(even/odd): 能选取每个父元素下的索引值为偶(奇)数的元素</li>
<li>:nth-child(2): 能选取每个父元素下的索引值为 2 的元素</li>
<li>:nth-child(3n): 能选取每个父元素下的索引值是 3 的倍数 的元素</li>
<li>:nth-child(3n + 1): 能选取每个父元素下的索引值是 3n + 1的元素</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// 每个class为one的div父元素下的第一个子元素</span>
$(<span class="string">"div[class='one'] :first-child"</span>)
</pre></td></tr></table></figure>

<h2 id="-">表单对象属性过滤选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:enabled</td>
<td>$(”input:enabled”)</td>
<td>匹配所有可用元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>$(”input:disabled”)</td>
<td>匹配所有不可用元素</td>
</tr>
<tr>
<td>:checked</td>
<td>$(”input:checked”)</td>
<td>匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</td>
</tr>
<tr>
<td>:selected</td>
<td>$(”select option:selected”)</td>
<td>匹配所有选中的option元素</td>
</tr>
</tbody>
</table>
<p>如果一个<code>&lt;input disabled=&quot;true&quot;/&gt;</code>, 提交的时候, 不会提交,
想让他提交 <code>&lt;input readonly=&quot;readonly&quot;/&gt;</code></p>
<h2 id="-">表单选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:input</td>
<td>$(”:input”)</td>
<td>匹配所有 input, textarea, select 和 button 元素</td>
</tr>
<tr>
<td>:text</td>
<td>$(”:text”)</td>
<td>匹配所有的单行文本框</td>
</tr>
<tr>
<td>:password</td>
<td>$(”:password”)</td>
<td>匹配所有密码框</td>
</tr>
<tr>
<td>:radio</td>
<td>$(”:radio”)</td>
<td>匹配所有单选按钮</td>
</tr>
<tr>
<td>:checkbox</td>
<td>$(”:checkbox”)</td>
<td>匹配所有复选框</td>
</tr>
<tr>
<td>:submit</td>
<td>$(”:submit”)</td>
<td>匹配所有提交按钮</td>
</tr>
<tr>
<td>:image</td>
<td>$(”:image”)</td>
<td>匹配所有图像域</td>
</tr>
<tr>
<td>:reset</td>
<td>$(”:reset”)</td>
<td>匹配所有重置按钮</td>
</tr>
<tr>
<td>:button</td>
<td>$(”:button”)</td>
<td>匹配所有按钮.这个包括直接写的元素button</td>
</tr>
<tr>
<td>:file</td>
<td>$(”:file”)</td>
<td>匹配所有文件域.</td>
</tr>
<tr>
<td>:hidden</td>
<td>$(”input:hidden”)</td>
<td>匹配所有不可见元素, 或者type为hidden的元素.这个选择器就不仅限于表单了, 除了匹配input中的hidden外,那些style为hidden的也会被匹配</td>
</tr>
</tbody>
</table>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="JavaScript" scheme="http://zhpooer.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day37-AJAX]]></title>
    <link href="http://zhpooer.github.io/2014/05/23/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day37-ajax/"/>
    <id>http://zhpooer.github.io/2014/05/23/传智播客day37-ajax/</id>
    <published>2014-05-23T11:32:46.000Z</published>
    <updated>2014-05-30T07:17:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">同步和异步</h1>
<p>同步: 提交请求 -&gt; 等待服务器处理 -&gt; 处理完毕返回 -&gt; 这期间客户端不能干任何事</p>
<p>异步: 请求通过事件出发 -&gt; 服务器处理(浏览器可以做其他事) -&gt; 处理完毕返回</p>
<h1 id="ajax">AJAX</h1>
<p>AJAX: Asynchronous Javascript and XML, 允许浏览器和服务器通信而无须刷新
当前页面的技术, 与服务器无关</p>
<p>核心是JavaScript对象: XmlHttpRequest</p>
<h1 id="-">与服务器通信</h1>
<p>服务端</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// ServletDemo</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp) {
    resp.setContentType(<span class="string">"text/xml;charset=utf-8"</span>);
    PrintWriter <span class="keyword">out</span> = resp.getWriter();
    
    <span class="comment">// 返回 xml</span>
    SAXReader reader = <span class="keyword">new</span> SAXReader();
    Document document = reader.read(path);
    String xml = document.asXML();
    <span class="keyword">out</span>.write(xml);
}
</pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">createXmlHttpRequest</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> xmlHttp;
    <span class="keyword">try</span>{
        xmlHttp = <span class="keyword">new</span> XMLHttpRequest();
    } <span class="keyword">catch</span>(e) {
        <span class="keyword">try</span> {
            xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Msxml2.XMLHTTP"</span>);
        } <span class="keyword">catch</span> (e){
            xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);
        } <span class="keyword">catch</span>(e){}
    }
    <span class="keyword">return</span> xmlHttp;
}
window.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span> <span class="comment">// 当页面被全部记载完毕后再执行</span>
    document.getElementById(<span class="string">"b1"</span>).onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        <span class="comment">// 创建 XMLHttpRequest 对象</span>
        <span class="keyword">var</span> xhr = createXmlHttpRequest();
        
        <span class="comment">// xhr的readyState 改变都会触发 onreadystatechange 事件</span>
        <span class="comment">// 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） </span>
        <span class="comment">// 1 (初始化) 对象已建立，尚未调用send方法 </span>
        <span class="comment">// 2 (发送数据) send方法已调用，但是当前的状态及http头未知 </span>
        <span class="comment">// 3 (数据传送中) 已接收部分数据，因为响应及http头不全，</span>
        <span class="comment">// 4 (完成) 数据接收完毕,此时可以通过通过responseBody和responseText获取完整的回应数据 </span>
        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) {
                <span class="comment">// 数据正确返回</span>
                <span class="keyword">if</span>(xhr.status==<span class="number">200</span> || xhr.status ==<span class="number">304</span>){
                    <span class="comment">// 如果返回是文本数据</span>
                    <span class="keyword">var</span> data = xhr.responseText;
                    <span class="comment">// 如果返回是 xml</span>
                    <span class="comment">// 如果文档类型不正确, responseXML 的值将会是空的</span>
                    <span class="keyword">var</span> dom = xhr.responseXML; <span class="comment">// 返回是 dom 对象</span>
                    document.getElementById(<span class="string">"d1"</span>).innerHTML = data;
                }
            }
        }
        <span class="comment">// 初始化xhr对象 ,// 建立与服务器的连接</span>
        xhr.open(<span class="string">"GET"</span>, <span class="string">"/ServletDemo?username=xxx"</span>);
        
        <span class="comment">// 发送数据</span>
        <span class="comment">// 如果是GET方法, 不会发送任何数据, 传递null即可</span>
        xhr.send(<span class="literal">null</span>); 
        
        <span class="comment">// 如果是Post方法, 如果没有数据作为请求的一部分发送, 也是用null</span>
        <span class="comment">// 设置请求消息头, 告知服务器, 发送的正文数据类型</span>
        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);
        xhr.send(<span class="string">"name=xxx&age=xxx"</span>);
        <span class="comment">// 或 xhr.send({name:"itcast"});</span>

    }
}
</pre></td></tr></table></figure>

<h1 id="xmlhttprequest-">XMLHttpRequest 对象方法</h1>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abort()</td>
<td>停止当前请求</td>
</tr>
<tr>
<td>getAllResponseHeaders()</td>
<td>把http请求的所有响应首部作为键/值对返回</td>
</tr>
<tr>
<td>getResponseHeader(&quot;headerLabel&quot;)</td>
<td>返回指定首部的串值</td>
</tr>
<tr>
<td>open(&quot;method&quot;, &quot;url&quot;, &quot;isAsync&quot;)</td>
<td>建立对服务器的调用, method可以为 GET POST</td>
</tr>
<tr>
<td>send(content)</td>
<td>向服务器发送请求</td>
</tr>
<tr>
<td>setRequestHeader(&quot;label&quot;, &quot;value&quot;)</td>
<td>把指定首部设置为所提供的值, 在设置任何首部之前必须先调用open()</td>
</tr>
</tbody>
</table>
<h1 id="xmlhttprequest-">XMLHttpRequest 对象属性</h1>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onreadystatechange</td>
<td>状态改变的事件触发器(回调函数), 服务器触发</td>
</tr>
<tr>
<td>readyState</td>
<td>对象状态(int), 0=未初始化, 1=读取中, 2=已读取, 3=交互中, 4=完成</td>
</tr>
<tr>
<td>responseText</td>
<td>服务器进程返回数据的文本版本</td>
</tr>
<tr>
<td>responseXML</td>
<td>服务器返回数据兼容DOM的XML的文档对象</td>
</tr>
<tr>
<td>status</td>
<td>返回状态码, 404, 200</td>
</tr>
<tr>
<td>statusText</td>
<td>状态文本信息</td>
</tr>
</tbody>
</table>
<h1 id="-">案例校验用户名</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">form</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"username"</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">onblur</span>=<span class="value">"checkUsername()"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"checkResult"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"email"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="function"><span class="keyword">function</span> <span class="title">checkUsername</span><span class="params">()</span>{</span>
     <span class="keyword">var</span> nameInputElm = document.getElementById(<span class="string">"username"</span>);
     <span class="keyword">var</span> xmlHttpReq = createXmlHttpRequest()
     xmlHttpReq.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
         <span class="keyword">if</span>(xmlHttpReq.readyState == <span class="number">4</span>) {
             <span class="keyword">if</span>(xmlHttpReq.status == <span class="number">200</span>  || xhr.status == <span class="number">304</span>) {
                 <span class="keyword">var</span> result = xmlHttpReq.responseText;
                 document.getElementById(<span class="string">"checkResult"</span>).innerHTML = result;
             }
         }
     };
     xmlHttpReq.open(<span class="string">"POST"</span>, <span class="string">"/checkUsername"</span>);
     xmlHttp.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);
     xmlHttpReq.send({username: nameInputElm.value})
}
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">// checkUsernameServlet</span>
<span class="keyword">List</span> names = <span class="keyword">Array</span>.asList(<span class="keyword">new</span> String[]{<span class="string">"abcd"</span>, <span class="string">"efg"</span>, <span class="string">"qwe"</span>});
<span class="keyword">public</span> void doPost(request, response) {
    response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);
    request.setCharactorEncoding(<span class="string">"utf-8"</span>);
    String username = request.getParameter(<span class="string">"username"</span>);
    
    <span class="keyword">if</span>(names.contains(username)) {
        response.getWriter().<span class="keyword">print</span>(<span class="string">"用户名已经存在"</span>);
    } <span class="keyword">else</span> {
        response.getWriter().<span class="keyword">print</span>(<span class="string">"用户名不存在存在"</span>);
    }
}
</pre></td></tr></table></figure>

<h1 id="json">JSON</h1>
<p>JavaScript Object Notation, 比 xml 更轻巧, 是 JavaScript 的原生格式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp) {
    resp.setContentType(<span class="string">"text/json;charset=utf-8"</span>);
    PrintWriter <span class="keyword">out</span> = resp.getWriter();
    String str = <span class="string">"{name:'山东'}"</span>;
    <span class="keyword">out</span>.print(str);
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> xhr = createXmlHttpRequest();
xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span>(xhr.status==<span class="number">200</span> || xhr.status ) {
       <span class="comment">// 返回值是 json 的字符串形式</span>
       <span class="keyword">var</span> data = xhr.responseText;
       <span class="comment">// 把普通的 json 文本转换成 json 数据</span>
       <span class="keyword">var</span> json = <span class="built_in">eval</span>(<span class="string">"("</span>+ data + <span class="string">")"</span>);
    }
}
</pre></td></tr></table></figure>

<h2 id="jsonlib-">JSONlib 使用</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// 省, 邮政编码</span>
Province p = <span class="keyword">new</span> Provice(<span class="string">"山东省"</span>, <span class="number">250000</span>);
JSONObject jsonObj = JSONObject.fromObject(p);
jsonObj.toString();   <span class="comment">// {"name":"山东省", "zipcode":"250000"}</span>

<span class="comment">// 输出数组</span>
Province p1 = <span class="keyword">new</span> Provice(<span class="string">"山东省"</span>, <span class="number">250000</span>);
Province p2 = <span class="keyword">new</span> Provice(<span class="string">"浙江"</span>, <span class="number">320000</span>);
List ps = <span class="keyword">new</span> ArrayList&lt;Province&gt;();
ps.add(p1);
ps.add(p2);
JSONArray jsonArr = JSONArray.fromObject(p2);
jsonArr.toString() <span class="comment">// [{name:**, zipcode:**},{name:**, zipcode:**}]</span>

<span class="comment">// 过滤输出</span>
JsonConfig cfg = <span class="keyword">new</span> JsonConfig();  
cfg.setExcludes(<span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"zipcode"</span>}); <span class="comment">// 不包含的字段列表</span>
JSONArray jsonArr = JSONArray.fromObject(p2, cfg);
jsonArr.toString() <span class="comment">// [{name:**},{name:**}]</span>
</pre></td></tr></table></figure>

<h2 id="flexjson">FlexJson</h2>
<p>flexjson 是一个轻量级的java类库, 序列化 Json</p>
<ul>
<li>序列化对象<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Product p = <span class="keyword">new</span> Product(<span class="number">1</span>, <span class="string">"冰箱"</span>, <span class="number">200</span>);
p.setOrders(orders);
JSONSerializer jsonSerializer = <span class="keyword">new</span> JSONSerializer();
<span class="comment">// jsonStr:  {class:"zhpooer.Product" , id: 1, name: "冰箱", price: "200"}</span>
<span class="comment">// 不会序列化集合</span>
<span class="built_in">String</span> jsonStr = jsonSerializer.serialize(p);
<span class="comment">// 序列化文档</span>
<span class="built_in">String</span> jsonStr =jsonSerializer.include(<span class="string">"orders"</span>).serialize(p);
<span class="comment">// 排除序列化属性</span>
<span class="built_in">String</span> jsonStr =jsonSerializer.exclude(<span class="string">"name"</span>).serialize(p);
<span class="comment">// 使用注解排除属性 @JSON(include=false)</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h1 id="-xml">服务器返回xml</h1>
<p>Xml格式, 不依赖任何语言,, 跨平台第三方通用数据格式</p>
<h2 id="xstream">xstream</h2>
<p>实现 xml 和 java 之间相互转换</p>
<p>XMl解析方式: DOM, SAX, Stax(pull 解析采用Stax)</p>
<p>导入jar包: <code>xstream,jar</code> <code>xpp3.jar</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// 将对象转换为 xml</span>
User user = <span class="keyword">new</span> User();
user.setId(<span class="number">1</span>);
user.setName(<span class="string">""</span>);
user.setGender(<span class="string">"男"</span>);
XStream xStream = <span class="keyword">new</span> XStream();
<span class="comment">// 给User取别名</span>
xStream.<span class="keyword">alias</span>(<span class="string">"user"</span>, User.<span class="keyword">class</span>);
xStream.<span class="keyword">alias</span>(<span class="string">"users"</span>, List.<span class="keyword">class</span>);
String xml = xStream.toXML();

<span class="comment">// 解析XML</span>
XStream xStream = <span class="keyword">new</span> XStream();
xStream.<span class="keyword">alias</span>(<span class="string">"user"</span>, User.<span class="keyword">class</span>);
xStream.<span class="keyword">alias</span>(<span class="string">"users"</span>, List.<span class="keyword">class</span>);
xStream.fromXML(<span class="keyword">new</span> FileInputStream(<span class="string">"user.xml"</span>));
</pre></td></tr></table></figure>

<h2 id="-xml-">使用XML 注解</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">// 起别名</span>
<span class="annotation">@XStreamAlias</span>(<span class="string">"User"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>{</span>
    <span class="annotation">@XStreamAsAttribute</span>
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="comment">// 不使用</span>
    <span class="annotation">@XStreamOmitField</span>
    <span class="keyword">private</span> String gender;
}
XStream xStream = <span class="keyword">new</span> XStream();
<span class="comment">// 是注解生效</span>
xStream.autodetectAnnotations(<span class="keyword">true</span>);
</pre></td></tr></table></figure>

<h1 id="tip">Tip</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不处理链接 --&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:void(0)"</span>&gt;</span>商品数据<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="AJAX" scheme="http://zhpooer.github.io/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[photoshop入门]]></title>
    <link href="http://zhpooer.github.io/2014/05/22/photoshop%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/05/22/photoshop入门/</id>
    <published>2014-05-22T11:57:16.000Z</published>
    <updated>2014-05-24T12:22:22.000Z</updated>
    <content type="html"><![CDATA[<p>构图:</p>
<p>配色: 女性 粉色 柔 圆角 对比, 针对性选择素材</p>
<h1 id="photoshope-">photoshope 软件界面</h1>
<p>菜单栏: 最上面</p>
<p>工具属性栏: 菜单栏下面</p>
<p>工具箱: 左</p>
<p>悬浮面板: 右</p>
<p>画布: 中间</p>
<h1 id="-">快捷键</h1>
<table>
<thead>
<tr>
<th>命令</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>切换画笔工具</td>
<td>B</td>
</tr>
<tr>
<td>隐藏显示图层</td>
<td>F7</td>
</tr>
<tr>
<td>新建画布</td>
<td>C + N</td>
</tr>
<tr>
<td>切换画布的三种模式</td>
<td>F</td>
</tr>
<tr>
<td>暂时切换(拖放)</td>
<td>space</td>
</tr>
<tr>
<td>满画布显示</td>
<td>C + 0(数字)</td>
</tr>
<tr>
<td>切换到放大工具</td>
<td>Z</td>
</tr>
<tr>
<td>暂时 缩小</td>
<td>在放大模式下 alt + click</td>
</tr>
<tr>
<td>画面显示放大</td>
<td>C + +</td>
</tr>
<tr>
<td>缩小</td>
<td>C + -</td>
</tr>
<tr>
<td>显示网格</td>
<td>C + &#39;</td>
</tr>
<tr>
<td>切换画布</td>
<td>C + tab</td>
</tr>
<tr>
<td>打开标尺</td>
<td>C + R</td>
</tr>
<tr>
<td>切换到移动工具</td>
<td>V</td>
</tr>
<tr>
<td>切换到矩形选框工具</td>
<td>M</td>
</tr>
<tr>
<td>显示/隐藏辅助键</td>
<td>C + ;</td>
</tr>
<tr>
<td>填充前景色</td>
<td>alt + 退格</td>
</tr>
<tr>
<td>填充背景色</td>
<td>C + 退格</td>
</tr>
<tr>
<td>恢复前/背景色</td>
<td>D</td>
</tr>
<tr>
<td>交换前/背景色</td>
<td>X</td>
</tr>
<tr>
<td>新建普通图层</td>
<td>C + shift + N</td>
</tr>
<tr>
<td>取消选择</td>
<td>C + D</td>
</tr>
<tr>
<td>返回上一步</td>
<td>ctrl + Z</td>
</tr>
<tr>
<td>一直往回后退</td>
<td>ctrl + alt + Z</td>
</tr>
<tr>
<td>重做</td>
<td>ctrl + shift + Z</td>
</tr>
<tr>
<td>裁剪工具</td>
<td>C(回车执行)</td>
</tr>
<tr>
<td>隐藏工具箱等</td>
<td>TAB</td>
</tr>
<tr>
<td>在隐藏工具箱中显示工具栏</td>
<td>回车</td>
</tr>
</tbody>
</table>
<h1 id="-logo">案例工行LOGO</h1>
<p>分析结构: 两个正圆组成的圆环, 一个正方形</p>
<ol>
<li>新建画布 C+N, 宽度 高度 200毫米, 单位像素, RGB模式</li>
<li>分析图像结构是 7*7 结构的图像<ul>
<li>调节网格大小:
 <code>C+K</code> 打开首选项, 网格选项 <code>C+8</code>, 调整网格线间隔 15 mm, (注意单位)</li>
<li>定义中心点(辅助线), 在标尺上拖拽</li>
</ul>
</li>
<li>使用矩形选框工具(7格*7格)<ul>
<li><em>新建图层</em>, 背景要保持空</li>
<li>约束选区绘制, shift: 约束到正方形和正圆, Alt 以鼠标落点为中心</li>
<li>在新图层中, 填充背景色(中国红)</li>
</ul>
</li>
<li>裁剪</li>
</ol>
<h1 id="tips">tips</h1>
<p>中国红配色: CMYK, 0 100 100 10</p>
<p>同组内隐藏工具之间切换：shift + 相应这一组工具的快捷键</p>
]]></content>
    
    
      <category term="photoshop" scheme="http://zhpooer.github.io/tags/photoshop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day36-javascript加强]]></title>
    <link href="http://zhpooer.github.io/2014/05/22/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day36-javascript%E5%8A%A0%E5%BC%BA/"/>
    <id>http://zhpooer.github.io/2014/05/22/传智播客day36-javascript加强/</id>
    <published>2014-05-22T06:24:14.000Z</published>
    <updated>2014-05-30T07:55:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="window-">window对象常用方法</h1>
<p><code>window</code>中的对象在浏览器中可以随便使用, 如 <code>document</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">//标准输入框, 请输入您的数据</span>
<span class="built_in">String</span> prompt(<span class="built_in">String</span> message, <span class="built_in">String</span> <span class="keyword">default</span>); 
alert(<span class="built_in">String</span> message);
<span class="keyword">var</span> sure = confirm(<span class="string">"are you sure"</span>);
open(<span class="string">""</span>);  <span class="comment">//打开一个窗口</span>
close(); <span class="comment">// 关闭窗口</span>
</pre></td></tr></table></figure>

<h1 id="form-">Form 表单对象</h1>
<p>访问表单的方式</p>
<ul>
<li>document.forms[n]</li>
<li>document.表单名字</li>
</ul>
<p>表单对象常用属性, 可以在 js 中获取或改变</p>
<ul>
<li>action</li>
<li>method</li>
<li>name</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>document<span class="preprocessor">.forms</span>[<span class="number">0</span>]<span class="preprocessor">.action</span><span class="comment">; // 获取表单的 action 值</span>
document<span class="preprocessor">.formname</span><span class="preprocessor">.method</span><span class="comment">; // 获取表单的 method 值</span>
</pre></td></tr></table></figure>

<h1 id="-">定义函数</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 方式一, 构造函数方式</span>
<span class="function"><span class="keyword">function</span> <span class="title">printFormAciton</span><span class="params">()</span> {</span>
    document.forms[<span class="number">0</span>].action
}
<span class="comment">// 方式二, 函数构造函数</span>
<span class="keyword">var</span> printFormMethod = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"p1"</span>, <span class="string">"p2"</span>, <span class="string">"return p1+p2"</span>)</span>;</span>
<span class="comment">// 方式三, 匿名函数</span>
<span class="keyword">var</span> printForm = funciton(any) { alert(any) };
</pre></td></tr></table></figure>

<h1 id="dom-">DOM 编程</h1>
<p>DOM: Document Object Model, 文档对象模型</p>
<ul>
<li>DOM 是针对xml(html)的基于树的API</li>
<li>DOM树: 节点(node)的层次</li>
<li>DOM 把一个文档表示为一个家谱树(父 子 兄弟)</li>
<li>DOM 定义了 Node 接口以及许多种节点类型来表示XML节点的多个方面</li>
</ul>
<h2 id="-">节点</h2>
<p><img src="/img/dom_op.png" alt="domapi"></p>
<p>节点, 一切都是节点</p>
<ul>
<li>整个HTML文档是一个文档节点</li>
<li>每个HTML标签都是一个元素节点</li>
<li>标签中的文字是文本节点</li>
<li>标签的属性是属性节点</li>
</ul>
<h3 id="-">查找操作</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="comment">//搀着节点元素</span>
<span class="keyword">var</span> inputObj = document.getElementById(<span class="string">"tid"</span>);
<span class="comment">// 获取标签中的值</span>
inputObj.<span class="keyword">value</span>;


<span class="comment">// 通过名字查找元素 getElementsByName()</span>
<span class="keyword">var</span> inputObjs = document.getElementsByName(<span class="string">"tname"</span>);
<span class="comment">// 该数据的长度</span>
inputObjs.length;
<span class="comment">// 遍历元素</span>
<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;inputObjs.length;i++){
    inputObjs[i].<span class="keyword">value</span>
}
<span class="comment">// 为每个文本框增加change事件</span>
<span class="keyword">for</span> (<span class="keyword">var</span> i=o;i&lt;inputObjs.length;i++) {
    inputObjs[i].onchange = function(){
        alert(<span class="keyword">this</span>.<span class="keyword">value</span>);
    }
}

<span class="comment">// 查找元素节点</span>
<span class="comment">// 获取所有的input元素, 返回值是数组</span>
<span class="keyword">var</span> inputObjs = document.getElementsByTagName(<span class="string">"input"</span>);
inputObjs.length; <span class="comment">// 元素长度</span>
<span class="comment">// 输出 type="text" 中value属性的值不包含按钮(button)</span>
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;inputObjs.length;i++) {
    <span class="keyword">if</span>(inputObjs[i].type!=<span class="string">"button"</span>) {
         inputObjs[i].<span class="keyword">value</span>;
    }
}
<span class="comment">//输出所有下拉选 id=edu 内容</span>
<span class="keyword">var</span> eduSelectObj = document.getElementById(<span class="string">"edu"</span>);
<span class="keyword">var</span> optionObjs = eduSelectObj.getElementsByTagName(<span class="string">"option"</span>);
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;optionObjs.lenght;i++) {
    alert(optionObjs[i].<span class="keyword">value</span>);
}
<span class="comment">// 输出选中的值</span>
log(eduSelectObj.<span class="keyword">value</span>); <span class="comment">// 方式一</span>
方式二
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;optionObjs.lenght;i++) {
    <span class="keyword">if</span>(optionObjs[i].selected==<span class="keyword">true</span>) log(optionObjs[i].<span class="keyword">value</span>);
}

<span class="comment">// 查看是否存在子节点</span>
<span class="comment">// 文本节点, 和属性节点不可能包含子节点,</span>
<span class="comment">// 如果 hasChildNodes() 方法返回 false,</span>
<span class="comment">// 则 childNodes() firstChild(), lastChild() 将是空数组和空字符串</span>
log(document.getElementById(<span class="string">"edu"</span>).hasChildNodes());

<span class="comment">// nodeName, 一个字符串, 内容是给定节点的名字 node.nodeName</span>
<span class="comment">// 元素节点, 返回这个元素的名称</span>
<span class="comment">// 属性节点, 返回属性名称</span>
<span class="comment">// 文本节点, 返回 内容为 #text 的字符串</span>
document.getElementById(<span class="string">""</span>).nodeName;
<span class="comment">// 返回整数, 1表示: 元素节点, 2表示: 属性节点, 3表示: 文本节点</span>
document.getElementById(<span class="string">""</span>).nodeType;
<span class="comment">// 给定节点当前值, 元素节点 返回 null</span>
document.getElementById(<span class="string">""</span>).nodeValue;

<span class="comment">// 属性节点获取</span>
<span class="keyword">var</span> pObj = document.getElementById(<span class="string">""</span>);
pObj.getAttributeNode(<span class="string">"name"</span>);
</pre></td></tr></table></figure>

<h3 id="-">更新操作</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="comment">// 替换操作</span>
<span class="keyword">var</span> bjElement = document.getElementById(<span class="string">"1"</span>);
bjElement.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> fkElement = document.getElementById(<span class="string">"2"</span>);
    bjElement.parentNode.replaceChild(fkElement);
}
<span class="comment">// 设置节点</span>
bjElement.setAttribute(<span class="string">"name"</span>, <span class="string">"xxxxx"</span>);

<span class="comment">// 创建节点</span>
<span class="keyword">var</span> btElement = document.getElementById(<span class="string">"bt1"</span>);
<span class="keyword">var</span> tjElement = document.createElement(<span class="string">"li"</span>);
tjElement.setAttribute(<span class="string">"id"</span>, <span class="string">"tj"</span>);
tjElement.setAttribute(<span class="string">"value"</span>, <span class="string">"tianjing"</span>);
<span class="keyword">var</span> textNode = document.createTextNode(<span class="string">"天津"</span>);
tjElement.appendChild(textNode);
<span class="keyword">var</span> cityElement = document.getElementById(<span class="string">"city"</span>);
cityElement.appendChild(tjElement);
<span class="comment">// 在bjElement 之前插入</span>
cityElement.insertBefore(bjElement, tjElement);

<span class="comment">// 删除节点</span>
<span class="keyword">var</span> tjElm = cityElement.removeChild(tjElement);

<span class="comment">// innerHTML, 所有浏览器都支持, 但不是DOM标准</span>
 <span class="keyword">var</span> divElm = document.getElementById(<span class="string">"div1"</span>);
divElm.innerHTML = <span class="string">"&lt;h1&gt;今天&lt;/h1&gt;"</span>;

<span class="comment">// table 的 appendChild</span>
<span class="keyword">var</span> table = document.getElementById(<span class="string">"tablename"</span>);
table.appendChild(child); <span class="comment">// 在ie中可以, firefox不可以</span>
table.tbody.appendChild(child); <span class="comment">// 在firefox中可以, 但是 ie 不可以</span>
<span class="comment">// 解决方法</span>
<span class="comment">// table 中是有tbody, 不管什么情况, 都要创建一个tbody并加入到table中把tr接到 tbody上</span>
<span class="keyword">var</span> tbodyElm = document.createElement(<span class="string">"tbody"</span>);
tbodyElm.appendChild(trElm);
table.appendChild(tbodyElm);

<span class="comment">//操作节点数组</span>
<span class="keyword">var</span> optionChildren = selectElm.getElementsByTagName(<span class="string">"option"</span>);
<span class="comment">// 等同于 selectElm.selectedIndex</span>
<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;optionChildren.length;i++) {
    <span class="comment">// 错误, 不能这么写, 因为数组是可变的</span>
    selectElm.removeChild(optionChildren[i]); 
}
</pre></td></tr></table></figure>

<h3 id="-">案例: 列表联动</h3>
<p>xml数据: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">china</span>&gt;</span>
    <span class="tag">&lt;<span class="title">provice</span> <span class="attribute">name</span>=<span class="value">"吉林省"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">city</span>&gt;</span>1 <span class="tag">&lt;/<span class="title">city</span>&gt;</span>
        <span class="tag">&lt;<span class="title">city</span>&gt;</span>2 <span class="tag">&lt;/<span class="title">city</span>&gt;</span>
        <span class="tag">&lt;<span class="title">city</span>&gt;</span>3 <span class="tag">&lt;/<span class="title">city</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">provice</span>&gt;</span>
    <span class="tag">&lt;<span class="title">provice</span> <span class="attribute">name</span>=<span class="value">"辽宁省"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">city</span>&gt;</span> <span class="tag">&lt;/<span class="title">city</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">provice</span>&gt;</span>
<span class="tag">&lt;/<span class="title">china</span>&gt;</span>
</pre></td></tr></table></figure>

<p>Html结构: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"provice"</span> <span class="attribute">name</span>=<span class="value">"provice"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
    <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"吉林省"</span>&gt;</span>吉林省<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
<span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"city"</span> <span class="attribute">name</span>=<span class="value">"city"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="title">option</span>&gt;</span>
<span class="tag">&lt;/<span class="title">select</span>&gt;</span>
</pre></td></tr></table></figure>

<p>javascript:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre>fuunction parseXML(){
    <span class="keyword">try</span> <span class="comment">//Internet Explorer {</span>
        xmlDoc=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLDOM"</span>);
    } <span class="keyword">catch</span>(e) {
        <span class="keyword">try</span> <span class="comment">//Firefox, Mozilla, Opera, etc. {</span>
            xmlDoc=document.implementation.createDocument(<span class="string">""</span>,<span class="string">""</span>,<span class="literal">null</span>);
        } <span class="keyword">catch</span>(e) {
            alert(e.message);
            <span class="keyword">return</span>;
        }
    }
    xmlDoc.async=<span class="literal">false</span>;
    xmlDoc.load();
    <span class="keyword">return</span> xmoDoc;
}
document.getElementById(<span class="string">"province"</span>).onchange = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="comment">// 要先清理 city 选择框</span>
    document.getElementById(<span class="string">"city"</span>).innerHTML = <span class="string">""</span>;
    <span class="keyword">var</span> xmlDoc = parseXML();
    <span class="keyword">var</span> selectedProvice = <span class="keyword">this</span>.value;

    <span class="keyword">var</span> xmlProvice;

    <span class="keyword">var</span> xmlProviceElm = xmlDoc.getElementByTagName(<span class="string">"provice"</span>);
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt; xmlProviceElm.length;i++) {
        <span class="keyword">if</span>( selectedProvice == xmlProviceElm[i].getAttribute(<span class="string">"name"</span>)) {
            xmlProvice = xmlProviceElm[i];
        }
    }
    <span class="keyword">if</span>(xmlProviceElm != <span class="literal">null</span>) {
        <span class="keyword">var</span> xmlCities = xmlProvice.getElemntByTagName(<span class="string">"city"</span>);
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; xmlCities.length; i++) {
            <span class="keyword">var</span> optionElm = document.createElement(<span class="string">"option"</span>);
            <span class="keyword">var</span> textNode = optionElm.setAttribute(<span class="string">"value"</span>, xmlCities[i].firstChild.nodeValue);
            optionElm.appendChild(textNode);
            document.getElementById(<span class="string">"city"</span>).appendChild(optionElm);
        }
    }
}
</pre></td></tr></table></figure>

<h3 id="-">弹出窗口</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">openWindow</span><span class="params">()</span>{</span>
    <span class="comment">// 方式一: </span>
    <span class="comment">/* window.showModalDialog(sUrl[, vArguments],[,sFeature])
    * 只针对ie 有用
    * sUrl: 要打开窗口的页面, 可以使用绝对路径, 相对路径
    * vArguments: 窗口传递的参数
    * sFeature: 其他窗口参数, 可以查看文档
    */</span>
    <span class="comment">// 将window窗口对象传过去</span>
    window.shwoModalDialog(<span class="string">"a2.html"</span>, window, {help:no;status:no;});
    
    <span class="comment">// 方式二:</span>
    <span class="comment">/*
    * newwindow = window.open(sUrl [, sName][, sName][, sFeature][,breplace]);
    * sUrl: 要打开的窗口的页面
    * sName: 窗口的位置: _blank 新窗口, _self 当前窗口
    * sFeature: 窗口样式, 可以查看文档
    */</span>
    window.open(<span class="string">"a2.html"</span>, <span class="string">"_blank"</span>, <span class="string">"toolbar=no, status=no"</span>)
}

<span class="function"><span class="keyword">function</span> <span class="title">viewData</span><span class="params">(pid, pname)</span> {</span>
    <span class="comment">// 和方式一交互</span>
    <span class="keyword">var</span> parentWindow = window.dialogArguments; <span class="comment">// 得到传过来的 window</span>
    <span class="comment">// 和方式二交互</span>
    <span class="keyword">var</span> parentWindow = window.openner();
    
    <span class="comment">// 可以对 parentWindow 进行操作, 或函数调用</span>
    window.close();
}
</pre></td></tr></table></figure>

<h1 id="js-">js中的逻辑判断</h1>
<p>在运算逻辑中, 0, &quot;&quot;, false, null, undefined, NaN 均为 false</p>
<h1 id="-">使用小结</h1>
<ul>
<li>若应用程序不需要与其他应用程序共享数据的时候,
使用 HTML 片段来返回数据时最简单的</li>
<li>如果数据需要重用, JSON 文件是个不错的选择,
其在性能和文件大小方面有优势</li>
<li>当远程应用程序未知时, XML 文档是首选,
因为 XML 是 web 服务领域的 “世界语”</li>
</ul>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="javascript" scheme="http://zhpooer.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day35-HQL]]></title>
    <link href="http://zhpooer.github.io/2014/05/22/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day35-hql/"/>
    <id>http://zhpooer.github.io/2014/05/22/传智播客day35-hql/</id>
    <published>2014-05-22T06:17:00.000Z</published>
    <updated>2014-05-23T08:11:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">单表查询</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="comment">// 返回的是 Classes 对象</span>
<span class="built_in">List</span><span class="subst">&lt;</span>Classes<span class="subst">&gt;</span> cs <span class="subst">=</span> session<span class="built_in">.</span>createQuery(<span class="string">"from Classes"</span>)<span class="built_in">.</span><span class="built_in">list</span>();
<span class="comment">// 带 select 查询, 出来的是 数组 </span>
<span class="built_in">List</span> cs <span class="subst">=</span> session<span class="built_in">.</span>createQuery(<span class="string">"select cid, cname from Classes"</span>)<span class="built_in">.</span><span class="built_in">list</span>();

<span class="comment">// 带构造函数的查询, 必须先有构造函数</span>
<span class="built_in">String</span> sql <span class="subst">=</span> <span class="string">"select new io.zhpooer.Classes(cname, description) from Classes"</span>;
<span class="built_in">List</span><span class="subst">&lt;</span>Classes<span class="subst">&gt;</span> cs <span class="subst">=</span> session<span class="built_in">.</span>createQuery(sql);

<span class="comment">// 条件查询</span>
Query query <span class="subst">=</span> session<span class="built_in">.</span>createQuery(<span class="string">"select cid, cname from Classes where cid=:cid"</span>);
query<span class="built_in">.</span>setLong(<span class="string">"cid"</span> , <span class="number">1</span>L);
Classes cl <span class="subst">=</span> query<span class="built_in">.</span>unique();
<span class="comment">// 或</span>
Query query <span class="subst">=</span> session<span class="built_in">.</span>createQuery(<span class="string">"select cid, cname from Classes where cid=?"</span>);
query<span class="built_in">.</span>setLong(<span class="number">0</span> , <span class="number">1</span>L);

<span class="comment">// 子查询</span>
<span class="built_in">String</span> sql <span class="subst">=</span> <span class="string">"select Classes where cid in (select cid in(select cid from Classes where cid in(1,2,3)))"</span>;
<span class="built_in">List</span><span class="subst">&lt;</span>Classes<span class="subst">&gt;</span> cs <span class="subst">=</span> session<span class="built_in">.</span>createQuery(sql)<span class="built_in">.</span><span class="built_in">list</span>();
</pre></td></tr></table></figure>

<h1 id="-">一对多</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">// 等值连接</span>
<span class="comment">// 返回 Array[tuple2&lt;Classes, Student&gt;]</span>
<span class="built_in">String</span> sql = <span class="string">"from Classes c, Student s where c.cid=s.classes.cid"</span>;
<span class="comment">// 内连接, 放回结果和上面相同</span>
<span class="built_in">String</span> sql = <span class="string">"from Classes c inner join c.students"</span>;
<span class="comment">// 迫切内连接, return List&lt;Classes&gt;</span>
<span class="built_in">String</span> sql = <span class="string">"from Classes c inner join fetch c.students"</span>;

<span class="comment">// 左外连接, return Array[tuple2&lt;Classes, Student&gt;]</span>
<span class="built_in">String</span> sql = <span class="string">"from Classes c left join  c.students"</span>;
<span class="comment">// 迫切左外连接, return List&lt;Classes&gt;</span>
<span class="built_in">String</span> sql = <span class="string">"from Classes c left outer join fetch  c.students"</span>;
<span class="comment">// 迫切左外连接, return List&lt;Student&gt;</span>
<span class="built_in">String</span> sql = <span class="string">"from Student s left outer join s.classes"</span>;

<span class="comment">// 同理也可以查询几个字段, 生成模型类, 带构造函数的查询, 不能带 fetch</span>
<span class="built_in">String</span> sql = <span class="string">"from new io.zhooer.NewClasses(c.cname, s.sname) c left outer join  c.students"</span>;
</pre></td></tr></table></figure>

<p>总结 :</p>
<ol>
<li>如果页面上要显示的数据和数据库中的数据相差甚远, 利用带select的构造器进行查询</li>
<li>如果页面上要显示的数据和数据库中的数据相差不是很远, 用迫切连接</li>
<li>如果采用迫切连接, from 后面跟的那个对象就是结构主体</li>
</ol>
<h1 id="-">多对多</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">String</span> sql <span class="subst">=</span> <span class="string">"from Student s inner join fetch s.courses c"</span>;
<span class="built_in">List</span><span class="subst">&lt;</span>Student<span class="subst">&gt;</span> cs <span class="subst">=</span> session<span class="built_in">.</span>createQuery(sql)<span class="built_in">.</span><span class="built_in">list</span>();
</pre></td></tr></table></figure>

<h1 id="-">一对多结合多对多</h1>
<p>如果多张表进行查询, 找核心表 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="built_in">String</span> hql <span class="subst">=</span> <span class="string">"from Classes c inner join fetch c.students s inner join fetch s.courses co"</span>;
<span class="built_in">List</span><span class="subst">&lt;</span>Classes<span class="subst">&gt;</span> cs <span class="subst">=</span> session<span class="built_in">.</span>createQuery(hql)<span class="built_in">.</span><span class="built_in">list</span>();

<span class="comment">// 会有重复值, 要用Set容器装</span>
<span class="built_in">String</span> hql <span class="subst">=</span> <span class="string">"from Classes c outer join fetch c.students s outer join fetch s.courses co"</span>;
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="hibernate" scheme="http://zhpooer.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day34-Hibernate性能]]></title>
    <link href="http://zhpooer.github.io/2014/05/21/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day34-hibernate%E6%80%A7%E8%83%BD/"/>
    <id>http://zhpooer.github.io/2014/05/21/传智播客day34-hibernate性能/</id>
    <published>2014-05-21T06:20:20.000Z</published>
    <updated>2014-05-22T06:23:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">懒加载</h1>
<p>懒加载主要解决一个问题: 类, 集合, many-to-one 在什么时候发出sql语句, 加载数据</p>
<h2 id="-">类的懒加载</h2>
<ul>
<li>利用session的load可以产生代理对象</li>
<li>在session.load 方法执行的时候并不发出sql语句</li>
<li>在得到一般属性的时候发出sql语句</li>
<li>只针对一般属性有效果, 针对标示符(id)没有效果<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// 得到一个代理对象
Classes c = (Classes) session<span class="preprocessor">.load</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
c<span class="preprocessor">.getCname</span>()<span class="comment">; // 发出sql语句</span>
c<span class="preprocessor">.getCid</span>()<span class="comment">;// 标识符, 不会发出</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
c<span class="preprocessor">.getDescription</span>()<span class="comment">;  // 如果还没有初始化, 抛错 could not initialize proxy, no session</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="-">集合的懒加载</h2>
<p>lazy 的三个变量:</p>
<ul>
<li>false: 当session.get时, 集合就被加载了</li>
<li>true: 在集合遍历时才被加载</li>
<li>extra: 针对集合做count, min, max, sum等操作</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 设置集合懒加载, 默认为 true,
     extra 更进一步的懒加载中, 如 students.size(), 会执行 select count()...--&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">lazy</span>=<span class="value">"false|true|extra"</span>&gt;</span><span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>// 执行 sql 生成 Classes 对象
// 如果 <span class="operator"><span class="keyword">set</span>.lazy=<span class="keyword">false</span>, 会马上加载集合对象
Classes c = <span class="keyword">session</span>.<span class="keyword">get</span>(Classes.class, <span class="number">1</span>L);</span> 
<span class="operator"><span class="keyword">Set</span> students = classes.getStudents();</span> 
for(Student s:students) {  // 执行sql, 生成 真实 students 对象(集合懒加载)
    s.getSname();
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Classes c = session<span class="preprocessor">.load</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
<span class="keyword">Set</span> students = classes<span class="preprocessor">.getStudents</span>()<span class="comment">; // 执行 sql 生成 Classes 对象</span>
for(Student s:students) {  // 执行sql, 生成 真实 students 对象(集合懒加载)
    s<span class="preprocessor">.getSname</span>()<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h2 id="-">单端关联的懒加载(多对一)</h2>
<p>根据多的端加载一的一端, 就一个数据, 所以无所谓</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 默认值 no-proxy --&gt;</span>
<span class="tag">&lt;<span class="title">many-to-one</span> <span class="attribute">lazy</span>=<span class="value">"false|no-proxy|proxy"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">many-to-one</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">抓取策略</h1>
<p>抓取策略, 由一个对象如何抓取集合的策略(主要是Set集合如何提取数据)</p>
<ol>
<li>主要是研究 <code>set</code> 集合如何提取数据</li>
<li>在 Classes.hbm.xml 文件中<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 外连接, 默认, 子查询 --&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">fetch</span>=<span class="value">"join|fetch|subselect"</span>&gt;</span><span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>// 默认 <span class="operator"><span class="keyword">select</span>, 如果学生有N个,要查询 N+<span class="number">1</span> 次, N+<span class="number">1</span> 查询
/* 如果 <span class="keyword">fetch</span>=suselect, 会翻译成
*        <span class="keyword">select</span> student.* <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> cid <span class="keyword">from</span> classes)
*  先查询 Classes, 在查询 students, 两条语句 
*/

List cList = <span class="keyword">session</span>.createQuery(<span class="string">"from classes"</span>).list();</span>
for(Classes classes:cList) {
    <span class="operator"><span class="keyword">Set</span> students = classes.getStudents();</span>
    for(Student s: students) {
        println(s.getSname());
    }
}


<span class="comment">/* 如果 fetch=join
* 发出语句变成一句, class left join student
* 如果把需求分析翻译成sql语句, 存在子查询, 用该策略不起作用(如上面的例子)
*/</span>
Classes classes = session.get(Classes.class, 1L);
jSet students = classes.getStudents();
for(Student s: students) {
    println(s.getSname());
}
</pre></td></tr></table></figure>

<h1 id="-">懒加载和抓取策略的结合</h1>
<table>
<thead>
<tr>
<th>fetch</th>
<th>lazy</th>
<th>sql</th>
<th>sql的执行时机</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>join</td>
<td>false</td>
<td>存在子查询</td>
<td>当查询classes时, classes和student全部查询</td>
<td>join 没有用</td>
</tr>
<tr>
<td>join</td>
<td>true</td>
<td>存在子查询</td>
<td>当遍历student时查询 student</td>
<td>join 没有用</td>
</tr>
<tr>
<td>join</td>
<td>true</td>
<td>不是子查询</td>
<td>在session.get(classes)时, 全部查询</td>
<td>lazy 没有用</td>
</tr>
<tr>
<td>subselect</td>
<td>true/false</td>
<td>存在子查询</td>
<td>发出两条语句</td>
<td>如果lazy为false, 在一开始就发出</td>
</tr>
<tr>
<td>select</td>
<td>true/false</td>
<td></td>
<td>发出 n+1 条语句</td>
<td>同上</td>
</tr>
</tbody>
</table>
<p>主要先看是不是子查询, 再看如果需要一下子全部加载, 就用<code>join</code></p>
<h1 id="session">session</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> doService{
    <span class="comment">// 如果 两个dao都要 begintransaction(), 如何管理?</span>
    dao1.doSome();  
    dao2.doSome();
}
</pre></td></tr></table></figure>

<h2 id="session-">session 的产生</h2>
<p>不同java虚拟机的调用不考虑</p>
<ul>
<li><code>sessionFactory.openSession()</code>, 每次都打开新的会话(session)</li>
<li><code>sessionFactory.getCurrentSession()</code>, 线程绑定一个session</li>
</ul>
<h2 id="-getcurrentsession-">使用 getCurrentSession()</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 告诉hibernate, session由当前线程产生  --&gt;</span>
<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"current_session_context_class"</span>&gt;</span> thread<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">&lt;!-- CRUD 操作必须在事务的环境下运行 --&gt;</span>
<span class="comment">&lt;!-- session和事务绑定在一起 --&gt;</span>
Session s = session.getCurrentSession();
Transaction trans = session.beginTransaction(); // 如果不写会报错
Classes classes = session.get(Classes.class, 1L);
trans.commit();
// 可以不写, 因为session和事务绑定在一起, 在事务提交时会自动关闭
session.close();
</pre></td></tr></table></figure>

<h2 id="session-">session 的缓存</h2>
<p>客户端先从内存中查找数据, 再从数据库获取数据</p>
<h3 id="-">一级缓存</h3>
<ul>
<li>一级缓存的生命周期, 就是session的生命周期</li>
<li>一级缓存的存放的数据都是私有数据<ul>
<li>把session存放在threadlocal中, 不同的线程不能访问</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">// 只发出一条语句</span>
<span class="comment">// session.get 方法把数据放在一级缓存中, load, save, update也一样</span>
session.<span class="keyword">get</span>(Classes.<span class="keyword">class</span>, <span class="number">1</span>L);
session.<span class="keyword">get</span>(Classes.<span class="keyword">class</span>, <span class="number">1</span>L);

session.evict(classes); <span class="comment">// 从一级缓存中清空</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Classes classes = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
session<span class="preprocessor">.clear</span>()<span class="comment">; // 如果不加这句话, 两个不同对象, 相同的id值, 得把缓存中的先清空</span>
Classes c2 = new Classes()<span class="comment">;</span>
c2<span class="preprocessor">.setCid</span>(<span class="number">1</span>L)<span class="comment">;</span>
session<span class="preprocessor">.update</span>(c2)<span class="comment">;</span>
</pre></td></tr></table></figure>

<h3 id="-">数据库和缓存的交互</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// 把数据库的缓存刷新的缓存中</span>
Classes classes = session.<span class="keyword">get</span>(Classes.<span class="keyword">class</span>, <span class="number">1</span>L);
classes.setCname(<span class="string">"66"</span>);
session.refresh(classes); <span class="comment">// 查询classes, 重置classes, 把数据库中的数据同步到缓存中</span>

<span class="comment">// 把把缓存中的数据刷到数据库中</span>
session.flush(); <span class="comment">// 检查缓存内部, 对比快照, 执行数据库操作</span>
</pre></td></tr></table></figure>

<p>批量操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">for</span>(i &lt;- <span class="number">1</span> <span class="keyword">to</span> <span class="number">10000</span>) {
    Classes c = <span class="keyword">new</span> Classes();
    c.setCname(i);
    session.save(c);
    <span class="comment">// 不加下面, 会内存溢出</span>
    <span class="keyword">if</span>(i%<span class="number">50</span>==<span class="number">0</span>) {
        session.flush(); <span class="comment">// 只刷, 不清空</span>
        session.clear();
    }
}
</pre></td></tr></table></figure>

<h2 id="-">二级缓存</h2>
<p>二级缓存, 存放共有数据</p>
<p>适用场合: 数据不能频繁更新, 数据能公开, 私密性不是很强</p>
<p>hibernate 本身并没有提供二级缓存的解决方案, 依赖第三方供应商完成</p>
<ul>
<li>ehcache</li>
<li>oschace</li>
<li>jbosscache</li>
<li>swamcache</li>
</ul>
<p>二级缓存操作:</p>
<ul>
<li>二级缓存存在 sessionFaction 中</li>
<li>生命周期和 sessionFaction 保持一致</li>
<li><p>使用步骤</p>
<ol>
<li><p>开启二级缓存</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 开启二级缓存 --&gt;</span>
<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cache.use_second_level_cache"</span>&gt;</span> true <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="comment">&lt;!-- 导入ehcache包  --&gt;</span>
<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cache.provider_class"</span>&gt;</span>
    org.hibernate.cache.EhCacheProvider
<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>让一个对象进入到二级缓存中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 方式一 在配置文件中 --&gt;</span>
<span class="tag">&lt;<span class="title">class-cache</span> <span class="attribute">usage</span>=<span class="value">"read-only"</span> <span class="attribute">class</span>=<span class="value">"Classes"</span>&gt;</span> <span class="tag">&lt;/<span class="title">class-cache</span>&gt;</span>
<span class="comment">&lt;!-- 方式二 在映射文件(*.hbm.xml)中 --&gt;</span>
<span class="comment">&lt;!-- 缓存策略 --&gt;</span>
<span class="tag">&lt;<span class="title">cache</span> <span class="attribute">usage</span>=<span class="value">"read-only|read-write|transaction|nonstrict-read-write"</span>&gt;</span> <span class="tag">&lt;/<span class="title">cache</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<p>把数据存到一级缓存和二级缓存: <code>get</code> <code>load</code>,但是 <code>save</code> <code>update</code> 不一定</p>
<h3 id="-querycache-">查询缓存(QueryCache)</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Query q = session.createQuery(<span class="string">"from Classes"</span>);
query.setCacheable(<span class="keyword">true</span>); <span class="comment">// classes里的所有数据要往查询缓存中存放</span>
query.<span class="keyword">list</span>(); <span class="comment">// 查询, 并放入二级缓存</span>
session.close();

Query q = session.createQuery(<span class="string">"from Classes"</span>);
query.setCacheable(<span class="keyword">true</span>); <span class="comment">// classes在二级缓存中查询, 不加会查询数据库</span>
query.<span class="keyword">list</span>(); <span class="comment">// 查询</span>

Query q = session.createQuery(<span class="string">"from Classes where id=?"</span>);
query.setCacheable(<span class="keyword">true</span>); 
query.<span class="keyword">list</span>(); <span class="comment">// 查询, 但是会从数据库查, 因为语句变了</span>
</pre></td></tr></table></figure>

<h3 id="ehcache-">ehcache 配置</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="xml"><span class="tag">&lt;<span class="title">ehcache</span>&gt;</span>
    <span class="tag">&lt;<span class="title">diskStore</span> <span class="attribute">path</span>=<span class="value">""</span>&gt;</span><span class="tag">&lt;/<span class="title">diskStore</span>&gt;</span> <span class="comment">&lt;!-- 缓存在磁盘的目录 --&gt;</span>
    <span class="tag">&lt;<span class="title">defaultCache</span> <span class="attribute">maxElementsInMemory</span>=<span class="value">""</span>
                  <span class="attribute">overflowToDisk</span>=<span class="value">""</span> &lt;!<span class="attribute">--</span> 是否保存在硬盘 <span class="attribute">--</span>&gt;</span>
                  maxElementsOnDisk=""&gt;
    <span class="tag">&lt;/<span class="title">defaultCache</span>&gt;</span>
     <span class="comment">&lt;!-- 设置二级缓存的硬盘保存策略--&gt;</span>
    <span class="tag">&lt;<span class="title">Cache</span> <span class="attribute">name</span>=<span class="value">"ClassName"</span>
        <span class="attribute">maxElementsInMemory</span>=<span class="value">""</span>
        <span class="attribute">overflowToDisk</span>=<span class="value">"true"</span>
        <span class="attribute">maxElementsOnDisk</span>=<span class="value">""</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">Cache</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ehcache</span>&gt;</span></span>
</pre></td></tr></table></figure>

]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day33-Hibernate关系传递]]></title>
    <link href="http://zhpooer.github.io/2014/05/20/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day33-hibernate%E5%85%B3%E7%B3%BB%E4%BC%A0%E9%80%92/"/>
    <id>http://zhpooer.github.io/2014/05/20/传智播客day33-hibernate关系传递/</id>
    <published>2014-05-20T07:28:47.000Z</published>
    <updated>2014-05-29T13:17:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hibernate-">Hibernate 关系传递</h1>
<h2 id="-">一对多的单向关联</h2>
<p>可以通过Classes 到 Student, 但不能从 Student 到 Classes.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Classes</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long cid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String cname;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String description;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Set&lt;Student&gt; students; <span class="comment">// Set可以避免重复</span>
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>{</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long sid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String sname;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String description;
}
</pre></td></tr></table></figure>

<p>映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">&lt;!-- Classes.hbm.xml --&gt;</span>
<span class="tag">&lt;<span class="title">hiberante-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Classes"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"cid"</span> <span class="attribute">length</span>=<span class="value">"5"</span> <span class="attribute">type</span>=<span class="value">"long"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">gernerator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">gernerator</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cname"</span> <span class="attribute">length</span>=<span class="value">"20"</span> <span class="attribute">type</span>=<span class="value">"string"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"description"</span> <span class="attribute">length</span>=<span class="value">"100"</span> <span class="attribute">type</span>=<span class="value">"java.lang.String"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- set 元素对应类中的set集合
             通过set元素使classes表和student表建立关联--&gt;</span>
        <span class="comment">&lt;!-- key是通过外键的形式让两张表建立关联  --&gt;</span>
        <span class="comment">&lt;!-- one-to-many 是通络类的形式让两个类建立关联 --&gt;</span>
        <span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"students"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="comment">&lt;!-- 用来描述外键 --&gt;</span>
                <span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"cid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">column</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
            <span class="tag">&lt;<span class="title">one-to-many</span> <span class="attribute">class</span>=<span class="value">"Student"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hiberante-mapping</span>&gt;</span>
<span class="comment">&lt;!-- Student.hbm.xml --&gt;</span>
<span class="tag">&lt;<span class="title">hibernate-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Student"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"sid"</span> <span class="attribute">length</span>=<span class="value">"5"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sname"</span> <span class="attribute">length</span>=<span class="value">"20"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"descscription"</span> <span class="attribute">length</span>=<span class="value">"100"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">执行操作</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
Transaction transaction = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>

Classes classes = new Classes()<span class="comment">;</span>
classes<span class="preprocessor">.setCname</span>(<span class="string">"第八期"</span>)<span class="comment">;</span>
classes<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>
session<span class="preprocessor">.save</span>(classes)<span class="comment">;</span>

Student student = new Student()<span class="comment">;</span>
student<span class="preprocessor">.setSname</span>(<span class="string">"班长"</span>)<span class="comment">;</span>
student<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>
// 如果学生很多, 要执行很多次, 可以用级联(Cascade)来解决
session<span class="preprocessor">.save</span>(student)<span class="comment">;</span>
transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<h3 id="-cascade-">级联(Cascade)</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 配置级联操作,
     save-update: 在保存(save) 或更新(update)班级时,
     也保存(save)和更新(update)学生, 即使学生是临时状态
     delete: 在删除班级的时候, 也删除学生
     all: save-update, delete
     --&gt;</span>
<span class="comment">&lt;!-- inverse 维护关系
             true 不维护(classes 不维护与 student 的关系)
             false 维护
             default false--&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"students"</span> <span class="attribute">cascade</span>=<span class="value">"save-update"</span> <span class="attribute">inverse</span>=<span class="value">"true"</span>&gt;</span>
    <span class="comment">&lt;!-- any --&gt;</span>
<span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</pre></td></tr></table></figure>

<p>在保存 Classes 时, 同时保存 students</p>
<ul>
<li>cascade 通过更新班级 级联保存学生(决定插入学生, 但不决定建立外键关联)<ul>
<li>删除脱管对象, 是<strong>没有级联效果的</strong></li>
</ul>
</li>
<li>inverse 建立班级和学生之间的关系(决定是不是建立外键关联)<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>Classes classes = new Classes()<span class="comment">;</span>
classes<span class="preprocessor">.setCname</span>(<span class="string">"第八期"</span>)<span class="comment">;</span>
classes<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>

Student student = new Student()<span class="comment">;</span>
student<span class="preprocessor">.setSname</span>(<span class="string">"班长"</span>)<span class="comment">;</span>
student<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>

<span class="keyword">Set</span> students = new HashSet&lt;Student&gt;()<span class="comment">;</span>
students<span class="preprocessor">.add</span>(student)<span class="comment">;</span>
// 建立 classes 和 student 之间的关联
classes<span class="preprocessor">.setStudents</span>(students)<span class="comment">; </span>
// student 还是临时状态对象, 在保存班级的时候同时保存学生
// 进行了级联操作
session<span class="preprocessor">.save</span>(classes)<span class="comment">;</span>

// 删除一个学生
session<span class="preprocessor">.delete</span>(student)<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<p>把一个学生从一个班级转到另一个班级</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// 可以不写, 原因如下
// Classes c1 = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
Classes c2 = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">2</span>L)<span class="comment">;</span>
Student s = session<span class="preprocessor">.get</span>(Student<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
// 会执行数据库删除外键操作, 而随后一句会执行更新外键操作, 就变成 <span class="number">2</span>条 sql 语句
// 所以 第一条可以不写
// c1<span class="preprocessor">.getStudents</span>()<span class="preprocessor">.remove</span>(s)<span class="comment">;</span>
c2<span class="preprocessor">.getStudents</span>()<span class="preprocessor">.add</span>(s)<span class="comment">;</span>
// 因为都是持久化状态, 所以不用 `save` 或 `update`
transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>删除Classes中的所有学生</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Classes classes = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
// 方式一: 效率不高, 因为要先查询
<span class="keyword">Set</span> students = classes<span class="preprocessor">.getStudents</span>()<span class="comment">;</span>
students<span class="preprocessor">.clear</span>()<span class="comment">;</span>
// 方式二
classes<span class="preprocessor">.setStudents</span>(null)<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>删除一个班级</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Classes c = session.<span class="keyword">get</span>(Classes.<span class="keyword">class</span>, <span class="number">5</span>L);
<span class="comment">// 如果 inverse=true, classes不会维护和student的关系, 外键不会删除, 会报错</span>
<span class="comment">// 必须 inverse=false, 或者 cascade=delete(会执行多条"delete * from Student where sid=?"语句)</span>
session.<span class="keyword">delete</span>(c);
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 没有在 hbm.xml 设置 cascade, 就不会执行级联,</span>
<span class="comment">// 如果两个关联的对象中有一个的状态是 临时, 会报错,</span>
<span class="comment">// `TransientObjectException`: object references an unsaved transient instance</span>
Classes classes = <span class="keyword">new</span> Classes();
classes.setCname(<span class="string">"xxx"</span>);
Student student = <span class="keyword">new</span> Student();
classes.getStudents().add(student);
session.save(classes); <span class="comment">//  如果 cascade 不设置, 报错</span>
</pre></td></tr></table></figure>

<p>把 <code>session.save()/update()</code> 一个对象的操作是显示操作,
级联一个对象是一个隐式操作</p>
<h2 id="-">一对多的双向</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- Class Student --&gt;</span>
<span class="comment">&lt;!-- @BeanProperty private Classes classes; --&gt;</span>
<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"student"</span>&gt;</span>
    <span class="comment">&lt;!-- any other property --&gt;</span>
    <span class="tag">&lt;<span class="title">many-to-one</span> <span class="attribute">name</span>=<span class="value">"classes"</span> <span class="attribute">class</span>=<span class="value">"io.zhpooer.Classes"</span> <span class="attribute">column</span>=<span class="value">"cid"</span>/&gt;</span> 
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
</pre></td></tr></table></figure>

<p>一对多涉及到关系操作, 在多的一方操作效率高, 因为多的一方不会执行<code>update</code>外键操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Student student = new Student()<span class="comment">;</span>
Classes classes = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">3</span>L)<span class="comment">;</span>
classes<span class="preprocessor">.getStudents</span><span class="preprocessor">.add</span>(student)<span class="comment">; // 如果 inverse 为 false 会发出 update外键 语句</span>
student<span class="preprocessor">.setClasses</span>(classes)<span class="comment">;</span>
session<span class="preprocessor">.save</span>(student)<span class="comment">; // 不会发出 update 外键 语句</span>
</pre></td></tr></table></figure>

<h2 id="-">删除关系的错误</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Classes c = session.<span class="keyword">get</span>(Classes.<span class="keyword">class</span>, <span class="number">1</span>L);
Set students = classes.getStudents();
<span class="keyword">for</span>(Student s:students) {
    <span class="comment">// student.setClass(null);   不能解决下面的问题, 因为是 classes 维护着关系</span>
    <span class="comment">// 解决问题思路: students.remove(student);, 但是不能在迭代中删除</span>
    session.<span class="keyword">delete</span>(student); <span class="comment">// 会报错, 因为 student 还关联着 classes</span>
}
</pre></td></tr></table></figure>

<h2 id="-">一对多总结</h2>
<ul>
<li>如果让一的一方维护关系，取决于的因素有<ol>
<li>在一的一方的映射文件中，set元素的inverse属性为default/false</li>
<li>在客户端的代码中，通过一的一方建立关系</li>
<li><code>session.save/update</code>方法是用来操作表的，和操作关系没有关系</li>
</ol>
</li>
<li>怎么样采用级联的方法通过保存一个对象从而保存关联对象<ol>
<li>如果<code>session.save</code>操作的对象是A，这个时候应该看A.hbm.xml,看set元素中cascade是否设置有级联保存</li>
<li>在客户端通过A建立关联</li>
<li>在客户端执行<code>session.save(A)</code></li>
</ol>
</li>
<li>一对多的情况，多的一方维护关系效率比较高<ol>
<li>在多的一方many-to-one中没有inverse属性</li>
<li>在客户端通过多的一方建立关联</li>
</ol>
</li>
</ul>
<h2 id="-">多对多</h2>
<p>学生和课程的关系是多对多</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long sid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String name;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Set&lt;Course&gt; courses;
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Set&lt;Student&gt; students;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long cid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> name;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Student"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"sid"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
    <span class="comment">&lt;!-- table 就是用来描述第三张表的 --&gt;</span>
    <span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"courses"</span> <span class="attribute">table</span>=<span class="value">"student_course"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">key</span>&gt;</span>
           <span class="comment">&lt;!-- student_course 通过sid, 与student表建立关联 --&gt;</span>
            <span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"sid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">column</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
        <span class="comment">&lt;!-- colomn 也是描述要链接过去的外键 --&gt;</span>
        <span class="tag">&lt;<span class="title">many-to-many</span> <span class="attribute">class</span>=<span class="value">"Cource"</span> <span class="attribute">column</span>=<span class="value">"cid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">many-to-many</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Course"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"cid"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
    <span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"students"</span> <span class="attribute">table</span>=<span class="value">"student_course"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">key</span>&gt;</span>
            <span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"cid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">column</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
        <span class="tag">&lt;<span class="title">many-to-many</span> <span class="attribute">class</span>=<span class="value">"Student"</span> <span class="attribute">column</span>=<span class="value">"sid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">many-to-many</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
</pre></td></tr></table></figure>

<p>关系操作:</p>
<ul>
<li>多对多, 谁操作, 效率都一样</li>
<li>解除关系, 把第三张表一行数据删除掉</li>
<li>建立关系, 把第三张表数据增加一行记录</li>
<li>变更关系, 对第三张表 执行update操作, 先删除后增加</li>
</ul>
<p>级联操作: 都是对象针对集合的操作</p>
<h2 id="-">一对一</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 方式一 --&gt;</span>
<span class="tag">&lt;<span class="title">many-to-one</span> <span class="attribute">unique</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">many-to-one</span>&gt;</span>
<span class="comment">&lt;!-- 方式二: 主键关联, person 的主键是外键 --&gt;</span>
<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Person"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"pid"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"foreign"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"property"</span>&gt;</span> address <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
    <span class="tag">&lt;<span class="title">one-to-one</span> <span class="attribute">name</span>=<span class="value">"address"</span> <span class="attribute">constrained</span>=<span class="value">"true"</span> <span class="attribute">class</span>=<span class="value">"Address"</span>&gt;</span><span class="tag">&lt;/<span class="title">one-to-one</span>&gt;</span>
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="Hibernate" scheme="http://zhpooer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day32-Hibernate入门]]></title>
    <link href="http://zhpooer.github.io/2014/05/20/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day32-hibernate%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/05/20/传智播客day32-hibernate入门/</id>
    <published>2014-05-20T02:45:34.000Z</published>
    <updated>2014-05-29T12:41:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jdbc-">jdbc的优缺点</h1>
<p>缺点</p>
<ul>
<li>查询代码繁琐</li>
<li>重复性代码特别多(频繁的try catch)</li>
<li>没有数据缓存</li>
<li>sql的移植性不好</li>
</ul>
<p>优点</p>
<ul>
<li>速度快</li>
<li>把控性比较好</li>
</ul>
<h1 id="or-mapping-">OR mapping 优缺点</h1>
<p>优点</p>
<ul>
<li>简单</li>
<li>数据缓存, 一级缓存 二级缓存 查询缓存</li>
<li>可移植性比较好</li>
</ul>
<p>缺点</p>
<ul>
<li>因为sql语句是内部生成的, 程序不可控</li>
<li>如果数据量特别大, 程序不可控</li>
</ul>
<h1 id="-">流行数据库框架</h1>
<ul>
<li>JPA Java Persistence API  通过注解描述对象与数据表映射关系(只有接口规范)</li>
<li>Hibernate 最流行ORM框架,通过对象-关系映射配置,可以完全脱离底层SQL, Hibernate实现JPA规范 </li>
<li>MyBatis  本是apache的一个开源项目 iBatit, 支持普通 SQL查询, 存储过程和高级映射的优秀持久层框架(企业主流)<ul>
<li>MyBaits 并不是完全ORM,  需要在xml中配置SQL语句</li>
</ul>
</li>
<li>Apache DBUtils, Spring JDBCTemplate</li>
</ul>
<h1 id="ormapping-hibernate">ORmapping 概念 和 Hibernate</h1>
<p>对象关系映射: 让数据库和对象发生关联, 通过操作对象, 完成对数据库的操作</p>
<p>通过 <code>*.hbm.xml</code>(映射文件),</p>
<ul>
<li>类与表的对应关系</li>
<li>类上属性的名称和表中的字段的名称的对应关系</li>
<li>类上属性的<em>类型</em>和表中的字段的<em>类型</em>的对应关系</li>
<li>把一对多和多对多的关系转化成面向对象的文件</li>
</ul>
<p>Hibernate的配置文件: 用来连接数据库</p>
<h1 id="hibernate-">hibernate入门案例 保存对象</h1>
<p>Hibernate: 根据客户端代码, 参照映射文件, 生成sql语句,
利用jdbc即使进行数据库操作</p>
<h2 id="-">编写持久化类</h2>
<p>POJO: 持久化类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/*
* 属性不能使用 数据库的关键字 如`table`
* 对象序列化作用, 让对象在网络上传输, 以二进制形式传输
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> <span class="keyword">long</span> pid;
    <span class="annotation">@BeanProperty</span> pirvate String pname;
    <span class="annotation">@BeanProperty</span> pirvate String psex;
    <span class="comment">// 必须要写默认的构造函数, hibernate 查询对象时</span>
    <span class="keyword">public</span> <span class="title">Person</span>(){}
}
</pre></td></tr></table></figure>

<h2 id="-">准备映射文件</h2>
<p><code>Person.hbm.xml</code> 类映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">&lt;!-- import hibernate-mapping-3.0.dtd--&gt;</span>
<span class="tag">&lt;<span class="title">hibernate-mapping</span>&gt;</span>
    <span class="comment">&lt;!-- 用来描述一个持久化类  --&gt;</span>
    <span class="comment">&lt;!-- name 类的全名 --&gt;</span>
    <span class="comment">&lt;!-- table 可以不写, 默认值和类名一样 --&gt;</span>
    <span class="comment">&lt;!-- catalog 数据库名称, 一般不写 --&gt;</span>
    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"cn.itcast.Person"</span>&gt;</span>
        <span class="comment">&lt;!-- name 属性名称, 是根据字段, 而不是属性(get, set)--&gt;</span>
        <span class="comment">&lt;!-- column 列的名称 --&gt;</span>
        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"pid"</span> <span class="attribute">length</span>=<span class="value">"5"</span> <span class="attribute">type</span>=<span class="value">"java.lang.Long"</span>&gt;</span>
            <span class="comment">&lt;!-- 主键产生器, 告诉hibernate容器用什么样的方式产生主键 --&gt;</span>
            <span class="tag">&lt;<span class="title">gernerator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">gernerator</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"pname"</span> <span class="attribute">column</span>=<span class="value">"pname"</span> <span class="attribute">length</span>=<span class="value">"20"</span> <span class="attribute">type</span>=<span class="value">"java.lang.String"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"psex"</span> <span class="attribute">column</span>=<span class="value">"psex"</span> &gt;</span>
            <span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"psex"</span> <span class="attribute">sql-type</span>=<span class="value">"varchar(20)"</span>&gt;</span> <span class="tag">&lt;/<span class="title">column</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">准备配置文件</h2>
<p><code>hibernate.cfg.xml</code>, 如果是默认加载, 必须放在根目录下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="comment">&lt;!-- import hibernate-configuration-3.0.dtd --&gt;</span>
<span class="tag">&lt;<span class="title">Hibernate-configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">session-factory</span>&gt;</span>
        <span class="comment">&lt;!-- 还有其他练级信息 --&gt;</span>
        <span class="comment">&lt;!-- 数据库连接信息 --&gt;</span>
        <span class="comment">&lt;!-- 可以省略 hibernate.  --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql:///database<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.username"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.password"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 数据库方言 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.dialect"</span>&gt;</span> org.hibernate.dialect.MySQLDialect <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 根据持久化类和映射文件生成表
            validate 只验证, 不创建表, 如果不一致 就抛出异常
            create-drop 启动创建, 结束删除
            create 每次创建
            update 检查, 如果没有就创建
        --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 格式化输出sql语句 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 显示 hibernate 内部生成的sql语句, 默认false --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"show_sql"</span>&gt;</span>true <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 没有开事务的情况下事务是否自动处理 --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.autocommit"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 导入映射文件 --&gt;</span>
        <span class="tag">&lt;<span class="title">mapping</span> <span class="attribute">resource</span>=<span class="value">"cn/itcast/hibernate/sh/domain/Person.hbm.xml"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">session-factory</span>&gt;</span>
<span class="tag">&lt;/<span class="title">Hibernate-configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">测试运行</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Configuration  conf = new Configuration()<span class="comment">;</span>
conf<span class="preprocessor">.configure</span>()<span class="comment">;  // 加载默认配置文件 `/hibernate.cfg.xml`</span>
SessionFactory fac = configuration<span class="preprocessor">.buildSessionFactory</span>()<span class="comment">;</span>
Session sessioin = fac<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
Transaction trans = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
Person p = new Person()<span class="comment">;</span>
p<span class="preprocessor">.setPname</span>(<span class="string">"p"</span>)<span class="comment">;</span>
p<span class="preprocessor">.setPsex</span>(<span class="string">"p"</span>)<span class="comment">;</span>
session<span class="preprocessor">.save</span>(p)<span class="comment">;</span>
trans<span class="preprocessor">.commit</span>()<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<h1 id="hibernate-api">Hibernate 核心API</h1>
<ol>
<li>Configuration</li>
<li>SessionFactory</li>
<li><p>Session, 是一个单线程对象, 线程不安全</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>session<span class="preprocessor">.save</span>()<span class="comment">;</span>
session<span class="preprocessor">.update</span>()<span class="comment">;</span>
session<span class="preprocessor">.delete</span>()<span class="comment">;</span>
// 根据主键查询
session<span class="preprocessor">.get</span>/load()<span class="comment">;</span>
// 创建查询对象, Query 接受 SQL, sqlQuery 接收 SQL
session<span class="preprocessor">.createQeury</span>()<span class="comment">;</span>
session<span class="preprocessor">.createSQLQuery</span>()<span class="comment">;</span>
// 面向对象查询
session<span class="preprocessor">.createCriteria</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>
</li>
<li><p>Transaction</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 如果没有开启事务, 那么每个Session的操作, 都相当于一个独立的事务</span>
<span class="comment">// 开启事务</span>
sessoin.beginTransaction()
<span class="comment">// 提交事务</span>
transaction.commit();
<span class="comment">// 回滚</span>
transaction.rollback();
transaction.wasCommitted();
</pre></td></tr></table></figure>
</li>
<li><p>Query, 代表面向对象的Hibernate查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>// 分页查询
<span class="variable">Query</span> <span class="keyword">query</span> = session.create<span class="variable">Qeury</span>(<span class="string">"form Person"</span>);
// <span class="number">11</span>-<span class="number">30</span>
<span class="keyword">query</span>.set<span class="variable">FirstResult</span>(<span class="number">10</span>);
<span class="keyword">query</span>.set<span class="variable">MaxResults</span>(<span class="number">20</span>);
</pre></td></tr></table></figure>
</li>
<li><p>Criteria, 主要为了解决多条件查询问题，以面向对象的方式添加条件，无需拼接HQL语句 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Criteria criteria = session<span class="preprocessor">.createCriteria</span>(Customer<span class="preprocessor">.class</span>)<span class="comment">;</span>

// 分页
criteria<span class="preprocessor">.setFirstResult</span>(<span class="number">1</span>)<span class="comment">;</span>
criteria<span class="preprocessor">.setMaxResults</span>(<span class="number">2</span>)<span class="comment">;</span>

// 条件查询
criteria<span class="preprocessor">.add</span>(Restrictions<span class="preprocessor">.eq</span>(<span class="string">"name"</span>, <span class="string">"李四"</span>))<span class="comment">;</span>
criteria<span class="preprocessor">.add</span>(Restrictions<span class="preprocessor">.lt</span>(<span class="string">"age"</span>, <span class="number">20</span>))<span class="comment">;</span>
criteria<span class="preprocessor">.add</span>(Restrictions<span class="preprocessor">.like</span>(<span class="string">"name"</span>, <span class="string">"李%"</span>))<span class="comment">;</span>

criteria<span class="preprocessor">.list</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="hiberante-">hiberante 加载流程分析</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">// 创建 Configuration 对象</span>
Configuration  conf = <span class="built_in">new</span> Configuration();
<span class="comment">// 包括 数据库连接信息 和 加载映射文件</span>
conf.configure();  <span class="comment">// 或 conf.configure("myownconfig");</span>
<span class="comment">// 手动加载hbm</span>
conf.addResource(<span class="string">"Person.hbm.xml"</span>); <span class="comment">// conf.addResource(Person.class); 自动搜索</span>
<span class="comment">// 数据库链接信息, 和映射文件信息, 持久化类信息 封装在 sessionFactory, 是一个连接池</span>
<span class="comment">// 是一个单例模式,一般情况下 hibernate 应该只有一个数据库连接且线程安全</span>
SessionFactory fac = configuration.buildSessionFactory();
<span class="comment">// 打开一个数据库连接, 进行数据库操作</span>
Session sessioin = fac.openSession();
<span class="comment">// 如果进行查询, 不用开启事务</span>
<span class="comment">// 如果进行cud操作, 要开启事务, 事务是由session开启的</span>
<span class="comment">// 事务不是自动提交的, 必须由session开启, 和当前session绑定</span>
Transaction trans = session.beginTransaction();
Person p = <span class="built_in">new</span> Person();
p.setPname(<span class="string">"p"</span>);
p.setPsex(<span class="string">"p"</span>);
<span class="comment">//  改变对象状态</span>
<span class="comment">// 会根据映射文件, 生成sql语句</span>
session.save(p);
<span class="comment">// 执行sql语句, 提交事务</span>
trans.commit();
<span class="comment">// 关闭数据连接</span>
session.<span class="built_in">close</span>();
sessionFactory.<span class="built_in">close</span>(); <span class="comment">// 关闭连接池</span>
</pre></td></tr></table></figure>

<p>得到一个持久化类</p>
<ul>
<li>加载配置文件</li>
<li>在配置文件中加载类映射文件</li>
<li>解析 映射文件中的class标签 name 属性, 找到对应类</li>
</ul>
<p>hibernate错误概览</p>
<ul>
<li><code>Unknown entity</code>, 在映射文件中没有配置该类</li>
<li><code>PropertyNotFound</code>, 映射文件中类字段错误, <code>property name</code> 写错</li>
<li><code>resource not found</code>, 映射文件名没有找到</li>
<li><code>entity class not found</code>, 在配置文件中导入文件映射文件错误, <code>class name</code>写错</li>
</ul>
<h1 id="-c3p0-">配置c3p0连接池</h1>
<ol>
<li>导入 c3p0-0.9.1.jar</li>
<li><p>在hibernate.cfg.xml 修改连接提供者</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;property name=<span class="string">"connection.provider_class"</span>&gt;org<span class="preprocessor">.hibernate</span><span class="preprocessor">.connection</span><span class="preprocessor">.C</span>3P0ConnectionProvider&lt;/property&gt;
</pre></td></tr></table></figure>
</li>
<li><p>配置c3p0连接池属性 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"c3p0.min_size"</span>&gt;<span class="number">5</span>&lt;/<span class="keyword">property</span>&gt;
&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"c3p0.max_size"</span>&gt;<span class="number">20</span>&lt;/<span class="keyword">property</span>&gt;
&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"c3p0.timeout"</span>&gt;<span class="number">120</span>&lt;/<span class="keyword">property</span>&gt;
&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"c3p0.idle_test_period"</span>&gt;<span class="number">3000</span>&lt;/<span class="keyword">property</span>&gt;
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="crud-">CRUD 的操作</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre>public void testQueryPerson(){
    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    List personList = session<span class="preprocessor">.createQuery</span>(<span class="string">"from Person"</span>)<span class="preprocessor">.list</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testQueryPersonById() {
    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    // 按照主键的方式查询数据库表中的记录
    // session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>)<span class="comment">; 会报错, 需要 long 类型</span>
    session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testQuerySQL(){
    String sql = <span class="string">"select * from person"</span><span class="comment">;</span>
    SQLQuery sqlQuery = session<span class="preprocessor">.createSQLQuery</span>(sql)<span class="comment">;</span>
    sqlQuery<span class="preprocessor">.addEntity</span>(Person<span class="preprocessor">.class</span>)<span class="comment">;</span>
    sqlQuery<span class="preprocessor">.list</span>()<span class="comment">;</span>
}
public void testDeletePerson(){

    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    Transaction transaction = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
    // 方式一: 
    Person person = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.delete</span>(person)<span class="comment">;</span>
    
    // 方式二
    Person person = new Person()<span class="comment">;</span>
    // hibernate 内部会检查标示符(id), 看标示符的值在数据库响应的表中有没有对应的行
    // 和其他属性不相关
    person<span class="preprocessor">.setId</span>(<span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.delete</span>(person)<span class="comment">;</span>
    // 如果删除一个不存在的对象, 会报错: SaleStateException, unexpect row
    transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testUpdatePerson(){
    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    Transaction transaction = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
    Person person = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    person<span class="preprocessor">.setPsex</span>(<span class="string">"女"</span>)<span class="comment">;</span>
    session<span class="preprocessor">.update</span>(person)<span class="comment">;</span>
    transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testIdentity(){
    Session session = sessoinFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    Transaction trans = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
    Person person1 = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    Person person2 = new Person()<span class="comment">;</span>
    person<span class="preprocessor">.setPid</span>(<span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.update</span>(person2)<span class="comment">; // 报错, 因为Hibernate不允许两个持久化对象持有同一个 标示符</span>
    transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h1 id="-">类型匹配</h1>
<p>在Hibernate映射文件中type属性支持两种类型, 一种是 java类型, 另一种hibernate类型,
java类型效率更高</p>
<p>以后开发中，PO类属性 都使用包装类型 </p>
<ul>
<li>使用基本类型 ，无法区分 0 和 null,
使用int类型分数，如果学生分数为0 可以没有考试, 也可能考试得了0分</li>
<li>使用包装类型, 如果不设置数据, 数据表存放null, 而不是默认值 0    </li>
</ul>
<table>
<thead>
<tr>
<th>hibernate类型</th>
<th>java类型-&gt;数据库类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer, long, short, float, double, character, byte, boolean, yes_no, true_false</td>
<td>java 原始类型到sql的字段类型</td>
</tr>
<tr>
<td>string</td>
<td>java.lang.String 到 VARCHAR(或者 Oracle 的 VARCHAR2)</td>
</tr>
<tr>
<td>date, time, timestamp</td>
<td>java.util.Date 和其子类到 SQL 类型 DATE，TIME 和 TIMESTAMP（或等价类型）的映射</td>
</tr>
</tbody>
</table>
<h1 id="-gernerator-">产生器(Gernerator)</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">gernerator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">gernerator</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="increment">increment</h2>
<ul>
<li>主键类型必须是数字</li>
<li>主键生成是由hibernate生成的, 程序员不需要干预</li>
<li>效率相对低, 且多线程会冲突</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 没有意义, hibernate是根据主键生成器来生成主键的,</span>
<span class="comment"><span class="xmlDocTag">///</span> 在客户端设置主键不一定起作用. </span>
Person p = <span class="keyword">new</span> Person();
p.setId(<span class="number">1</span>L);   
session.save(p);
</pre></td></tr></table></figure>

<h2 id="identity">identity</h2>
<ul>
<li>生成的主键是由数据库完成的</li>
<li>该表必须支持自动增长机制(auto_increment)</li>
<li>效率高</li>
<li>mysql支持自动增长, oracle不支持自动增长</li>
</ul>
<h2 id="assigned">assigned</h2>
<p>自然主键的生成策略, 由程序(手动)设置主键</p>
<h2 id="sequence">sequence</h2>
<p>标识符生成器利用底层数据库提供的序列来生成标识符</p>
<p>原理: 依赖数据库序列支持, 和hibernate程序无关</p>
<ul>
<li>Oracle 支持序列, Mysql 不支持序列</li>
<li>序列原理<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> sequence customer_seq;</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> customer(id) <span class="keyword">values</span>(customer_seq.nextval);</span> // 自动序列+1
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="native">native</h2>
<p>native 标识符生成器依据底层数据库对自动生成标识符的支持能力,
来选择使用 identity, sequence 或 hilo 标识符生成器.</p>
<ul>
<li>Mysql 自动选择 identity ， oracle 自动选择 sequence</li>
</ul>
<h2 id="uuid">uuid</h2>
<ul>
<li>UUID是由hibernate内部生成</li>
<li>主键的类型必须是字符串</li>
</ul>
<h2 id="-">复合主键</h2>
<p>复合主键(联合主键)，一个数据表中多列共同作为主键, 复合主键是一种特殊 assigned 策略</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">composite-id</span>&gt;</span>
    <span class="comment">&lt;!-- 配置多列 --&gt;</span>
	<span class="tag">&lt;<span class="title">key-property</span> <span class="attribute">name</span>=<span class="value">"firstname"</span>&gt;</span><span class="tag">&lt;/<span class="title">key-property</span>&gt;</span>
	<span class="tag">&lt;<span class="title">key-property</span> <span class="attribute">name</span>=<span class="value">"secondname"</span>&gt;</span><span class="tag">&lt;/<span class="title">key-property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">composite-id</span>&gt;</span>
</pre></td></tr></table></figure>

<p><strong>复合主键类必须实现序列化接口</strong></p>
<h1 id="-">对象的状态</h1>
<p>Hibernate中的对象共有三个状态: 临时(瞬时, transient), 持久化(persist), 托管状态(detach)</p>
<p>持久化对象不允许随意修改OID</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 临时状态对象,</span>
<span class="comment">// 不存在持久化标识OID, 尚未与hibernate session关联</span>
Person p = <span class="built_in">new</span> Person();
<span class="comment">// 持久化状态, 只有在持久化状态, 对象的状态变化才会被Hibernate捕捉</span>
session.save(p);
transaction.commit();
<span class="comment">// 脱管状态, 存在OID, 未与session关联</span>
session.<span class="built_in">close</span>();
</pre></td></tr></table></figure>

<p>把一个临时状态对象, 变成持久化状态的方法:</p>
<ul>
<li><code>Session.save</code></li>
<li><code>Session.update</code></li>
</ul>
<p>当<code>Session.get</code>方法得到一个对象的时候, 是不需要再执行<code>Session.update</code>语句的,
因为已经是持久化状态.</p>
<p>当一个对象是持久化对象时, 当进行提交时, 会根据内存中<em>快照</em>看是否需要执行update语句.</p>
<h2 id="-">对象状态变化</h2>
<p><img src="/img/hibernate_state.png" alt="hibernate状态转换"></p>
<p><code>session.update()</code>, 脱管对象更新, 变成持久化对象</p>
<ul>
<li>调用该方法, 默认会直接生成 update 语句, 如果数据没有改变,
也会更新, 可以设置<code>&lt;class select-before-update=&quot;true&quot;/&gt;</code>, 设置改变</li>
<li>一级缓存不允许存在两个相同OID的对象</li>
</ul>
<p><code>session.saveOrUpdate()</code>, 如果参数是一个瞬时对象, 就用save方法,
如果是脱管对象, 就用 update 方法. <code>&lt;id unsaved-value=&quot;-1&quot;/&gt;</code>,
如果对象id是 -1 , 那么也是瞬时对象</p>
<p><code>session.clear()</code>, 把所有的对象从session中清空(变成托管对象)</p>
<p><code>session.evict(p)</code>, 把一个对象变成托管状态</p>
<p><code>session.flush()</code>, 将缓存的变化同步到数据库, 缓存数据与快照不同时, 才执行</p>
<p><code>session.refresh()</code>, 重新更新缓存, 用数据库的内容更新缓存</p>
<p><code>session.setFlushMode(FlushMode)</code> 设置 缓存刷新时间</p>
<ul>
<li>FlushMode.ALWAYS, 每次查询都会 flush</li>
<li>FlushMode.AUTO, 有些查询时 flush</li>
<li>FlushMode.COMMIT, 提交时 flush</li>
<li>FlushMode.MANUAL, 手动 flush</li>
</ul>
<p>一个对象是否是持久化对象是针对某一个session而言的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Session session = sessionFactory<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
Person person = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
sessoin<span class="preprocessor">.close</span>()<span class="comment">;</span>
// person 相对于 session2 来说是临时状态, 所以不会生成sql语句
Sessoin session2 = sessionFactory<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
person<span class="preprocessor">.setName</span>(<span class="string">""</span>)<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>当 <code>transaction.commit()</code> 时, Hibernate 会检查session,</p>
<ul>
<li>如果一个对象是临时状态对象, session不会管</li>
<li>如果是一个持久化状态对象, 那么先把该对象和快照对比, 来决定是否执行sql update操作</li>
<li>如果是一个没有Id的持久化对象, 则执行save操作</li>
</ul>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="Hibernate" scheme="http://zhpooer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day31-案例]]></title>
    <link href="http://zhpooer.github.io/2014/05/17/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day31-%E6%A1%88%E4%BE%8B/"/>
    <id>http://zhpooer.github.io/2014/05/17/传智播客day31-案例/</id>
    <published>2014-05-17T06:05:42.000Z</published>
    <updated>2014-05-19T11:47:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">项目需求分析</h1>
<p>模块:</p>
<ol>
<li>登陆模块</li>
<li>用户模块的搭建</li>
</ol>
<p>框架的搭建:</p>
<ul>
<li>页面用 JSP, 放在 WEB-INF 下</li>
<li>后台: struts2 + jdbc</li>
<li>后台的分层<ul>
<li>action</li>
<li>service</li>
<li>dao</li>
</ul>
</li>
<li>struts2的配置文件<ul>
<li><code>struts.xml</code>, <code>struts-login.xml</code>, <code>struts-user.xml</code></li>
<li>简单样式, 开发模式为 true</li>
</ul>
</li>
<li>数据库: DBUtils 封装数据库的链接</li>
</ul>
<h1 id="-">代码</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- login.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">action</span>=<span class="value">"LoginAction_login.action"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">cssClass</span>=<span class="value">"text"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">cssClass</span>=<span class="value">"text"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:submit</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">struts</span>&gt;</span>
    <span class="tag">&lt;<span class="title">constants</span> <span class="attribute">name</span>=<span class="value">"struts.devMode"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">constants</span> <span class="attribute">name</span>=<span class="value">"struts.ui.theme"</span> <span class="attribute">value</span>=<span class="value">"simple"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">file</span>=<span class="value">"struts/struts-user.xml"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">file</span>=<span class="value">"struts-login.xml"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">struts</span>&gt;</span>
</pre></td></tr></table></figure>

<p>移动脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> s_user (
    userID <span class="keyword">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,
    username <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    password <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    sex <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    birthday <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    education <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    telephone <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    interest <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    path <span class="keyword">varchar</span>(<span class="number">500</span>) <span class="keyword">null</span>,
    filename <span class="keyword">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,
    remark <span class="keyword">varchar</span>(<span class="number">500</span>) <span class="keyword">null</span>,
    <span class="keyword">primary</span> <span class="keyword">key</span>(userID)
);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> s_user (userID, username, password) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">"admin"</span>, <span class="string">"admin"</span>);</span>
</pre></td></tr></table></figure>

<p>持久层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// cn.itcast.dao</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> {</span>
    <span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span>();
    <span class="keyword">public</span> User <span class="title">getUserById</span>(Serializable id);
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span>(User user);
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span>(Serializable id);
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span>(User user);
    <span class="keyword">public</span> User <span class="title">login</span>(String username, String password);
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> {</span>}
</pre></td></tr></table></figure>

<p>模型类: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> User {
    <span class="keyword">private</span> String <span class="keyword">long</span> userId;
    <span class="keyword">private</span> String username;
    <span class="keyword">private</span> String password;
    <span class="keyword">private</span> String sec;
    <span class="keyword">private</span> String birthday;
    <span class="keyword">private</span> String education;
    <span class="keyword">private</span> String phone;
    <span class="keyword">private</span> String interest;
    <span class="keyword">private</span> String path;
    <span class="keyword">private</span> String filename;
    <span class="keyword">private</span> String remark;
}
</pre></td></tr></table></figure>

<p>业务层:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">interface</span> UserService {
    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();
    <span class="keyword">public</span> User <span class="title">login</span>(String username, String password){
        <span class="keyword">return</span> userdao.login(username, password);
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">ActionSupport</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; {</span>
    <span class="keyword">private</span> UserService UserService = <span class="keyword">new</span> UserServiceImpl();
    <span class="keyword">private</span> User model = <span class="keyword">new</span> User();
    @Override <span class="keyword">public</span> User getModel(){<span class="keyword">return</span> model;}
    <span class="keyword">public</span> String login(){
        User user = userService.login(user.getUsername(), user.getPassword);
        <span class="keyword">if</span>(user==<span class="keyword">null</span>) {
            <span class="keyword">this</span>.addActioinError(<span class="string">"用户名或者密码错误"</span>)
            <span class="keyword">return</span> <span class="string">"input"</span>; <span class="comment">// 跳到错误页面</span>
        }
        <span class="keyword">return</span> <span class="string">"home"</span>;
    }
}
</pre></td></tr></table></figure>

<p>struts-login.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"login"</span> <span class="attribute">namespace</span>=<span class="value">""</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"loginAction_*"</span> <span class="attribute">method</span>=<span class="value">"{1}"</span> <span class="attribute">class</span>=<span class="value">"UserAction"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"input"</span>&gt;</span> login.jsp <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">显示层</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- home.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">frameset</span>&gt;</span>
    <span class="tag">&lt;<span class="title">frame</span> <span class="attribute">src</span>=<span class="value">"forwardAction_forward.action?method-top"</span> <span class="attribute">name</span>=<span class="value">"topFrame"</span> <span class="attribute">scrolling</span>=<span class="value">"NO"</span> <span class="attribute">noresize</span>=<span class="value">""</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">frame</span>&gt;</span>
    <span class="comment">&lt;!-- ...脑补... --&gt;</span>
<span class="tag">&lt;/<span class="title">frameset</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> ForwardAction {
    <span class="keyword">private</span> String method;
    <span class="keyword">public</span> String <span class="title">forward</span>() {
        <span class="comment">// 配置 struts-forwards.xml</span>
        <span class="comment">// result name=top =&gt; top.jsp</span>
        <span class="comment">// result name=left =&gt; left.jsp</span>
        <span class="comment">// result name=bottom =&gt; bottom.jsp</span>
        <span class="comment">// result name=right =&gt; welcome.jsp</span>
        <span class="keyword">return</span> method;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- struts-login --&gt;</span>
<span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"home"</span>&gt;</span> WEB-INF/frame/home.jsp <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
</pre></td></tr></table></figure>

<p>左侧的树是利用登陆一个框架 dTree 框架</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">&lt;!-- left.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"dtree.css"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>/&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"dtree.js"</span>&gt;</span><span class="javascript"> </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"txt/javascript"</span>&gt;</span><span class="javascript">
d = <span class="keyword">new</span> dTree(<span class="string">'d'</span>)
d.add(<span class="number">0</span>, -<span class="number">1</span>, <span class="string">'系统菜单树'</span>); <span class="comment">// 设置树的父节点</span>
<span class="comment">// 第一个参数: 为该节点的 id</span>
<span class="comment">// 第二个参数: 父节点</span>
<span class="comment">// 三: 节点的名称</span>
<span class="comment">// 四: 链接到的页面</span>
<span class="comment">// 六: 需要显示的 frame</span>
d.add(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'用户管理'</span>, userAction_showAllUser.action<span class="string">', '</span><span class="string">', '</span>right<span class="string">');
d.add(3, 2, '</span>员工管理<span class="string">', '</span>list.jsp<span class="string">', '</span><span class="string">', right'</span>);
document.add(d);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// UserAction</span>
<span class="keyword">public</span> String <span class="title">showAllUser</span>() {
    List&lt;User&gt; userList = userService.getAllUser();
    ActionContext.getContext().put(<span class="string">"userList"</span>, userList);
    <span class="keyword">return</span> <span class="string">"list.jsp"</span>; <span class="comment">// 添加struts-user.xml, 修改 user/list.jsp, 迭代userList</span>
}
<span class="comment">// UserService</span>
<span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span>() {
    userdao.getAllUser();
}
</pre></td></tr></table></figure>

<h2 id="-">添加用户</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// UserAction</span>
<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> File upload; <span class="comment">// 该属性用于文件上传</span>
<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String uploadFileName;
<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String uploadContentType;
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUI</span>(){
    <span class="keyword">return</span> <span class="string">"add.jsp"</span>
}
<span class="keyword">public</span> String <span class="title">add</span>(){
    String path = UploadUtils.saveUploadFile(upload);
    getModel.setPath(path);
    getModel.setFilename(uploadFileName);
    userService.addUser(getModel);
    
}

<span class="comment">// userService</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span>(User user){
    userDao.saveUser(user);
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// list.jsp</span>
<span class="function"><span class="keyword">function</span> <span class="title">addUser</span><span class="params">()</span>{</span>
    window.location.href=<span class="string">"UserAction_addUI"</span>;
}
</pre></td></tr></table></figure>

<h2 id="-">修改客户信息</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="comment">// list.jsp: &lt;s:a action="userAction_showUserByID?userId=%{userId}"&gt;修改&lt;/s:a&gt;</span>
<span class="comment">// 注意 在struts2标签中, 不能跟 el 表达式</span>
<span class="comment">// 在html标签中 不能加 ognl 表达式</span>
<span class="comment">// Useraction</span>
<span class="keyword">private</span> String[] interest; <span class="comment">// 用来回显爱好</span>
<span class="keyword">public</span> String showUserByID {
   User user =  userService.getUserById(getModel.getUserId());
   interest = user.getInterest().split(<span class="string">","</span>);
   ActionContext.getContext().getValueStack().push(user);
   <span class="keyword">return</span> <span class="string">"updateUI"</span>;
}
<span class="keyword">public</span> String <span class="title">updateUser</span>(){
    userService.updateUser(model);
    <span class="keyword">return</span> <span class="string">"list.jsp"</span>;
}

<span class="comment">// UserService</span>
<span class="keyword">public</span> User <span class="title">getUserById</span>(Serializable id){
    <span class="keyword">return</span> userDao.getUserById();
}
</pre></td></tr></table></figure>

<h3 id="interests-">interests 的回显</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// UserAction</span>

<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String[] ids; <span class="comment">// 用来存储 页面上 checkboxlist</span>
<span class="comment">// 在代码中 处理 ids, 加入到 userAction中</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day31-struts拾遗]]></title>
    <link href="http://zhpooer.github.io/2014/05/17/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day31-struts%E6%8B%BE%E9%81%97/"/>
    <id>http://zhpooer.github.io/2014/05/17/传智播客day31-struts拾遗/</id>
    <published>2014-05-17T01:04:32.000Z</published>
    <updated>2014-05-28T07:24:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ognl-">ognl 详解</h1>
<p>OGNL：Object Graph Navigation Language</p>
<ul>
<li><p>OGNL不仅可以调用属性，还可以调用普通方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 表达式可以调get和set,可以调方法,可以按索引取数组内容 （打印a）--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">'"abcdefg".toCharArray()[0]'</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- ognl表达式中：context代表contextMap （打印对应的value）--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#context['com.opensymphony.xwork2.ActionContext.locale']"</span>/&gt;</span>
<span class="comment">&lt;!-- 打印11111111111111111，直接量，直接写的值,H表示大数据？ --&gt;</span>
<span class="comment">&lt;!-- 111B  表示BigDecimal类型    1111H表示BigInteger --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"11111111111111111H"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>OGNL获取属性等</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="vbscript">&lt;%
<span class="built_in">request</span>.setAttribute(<span class="string">"str"</span>, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>});
%&gt;</span>
<span class="tag">&lt;<span class="title">s:debug</span>&gt;</span><span class="tag">&lt;/<span class="title">s:debug</span>&gt;</span>
<span class="comment">&lt;!-- OGNL中可以使用伪属性  .length（以下打印3） --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.str.length"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.str['length']"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.str['len'+'gth']"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>链式表达式(Chained Subexpressions)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 链式表达式，#this表示前面的110H.intValue() --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"110H.intValue().(#this&lt;112?#this*2:#this/2)"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>访问静态资源, 取得静态常量，用@进行间隔，加小括号表示静态方法，不加小括号就是代表取get方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 使用静态资源，需要打开静态常量开关struts.ognl.allowStaticMethodAccess --&gt;</span>
<span class="comment">&lt;!-- 表示Integer中的MAX_VALUE常量 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"@java.lang.Integer@MAX_VALUE"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- 表示使用System类中的currentTimeMillis()静态方法 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"@java.lang.System@currentTimeMillis()"</span>/&gt;</span><span class="tag">&lt;<span class="title">hr</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>集合对象操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="xml"><span class="comment">&lt;!--{'a','b','c'} 创建了一个List集合  --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"{'a','b','c'}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- value省略，打印a b c --&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
<span class="comment">&lt;!-- 打印class java.util.ArrayList --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"{'a','b','c'}.class"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>

<span class="comment">&lt;!-- 打印集合 --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#{'a':'aa','b':'bb'}"</span>&gt;</span>
<span class="comment">&lt;!-- 打印a:aa  b:bb --&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>:<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"value"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- in 表达式 --&gt;</span>
<span class="comment">&lt;!-- EL表达式在Struts2中已经被改写了：原有功能保持不变。只是在四大域范围内找不到的话，EL表达式就变成了OGNL表达式 --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#{'eat':'吃饭','sleep':'睡觉','study':'学习'}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"hobby"</span> &lt;<span class="attribute">s:property</span> <span class="attribute">value</span>=<span class="value">"key in {'java','sleep','study'}?'checked=\"</span><span class="value">checked\"':''"</span>/&gt;</span> value="${key}"/&gt;${value}
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span></span>
</pre></td></tr></table></figure>
</li>
<li><p>投影查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"products.{name}"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:property</span>&gt;</span> <span class="comment">&lt;!-- 只要name属性 --&gt;</span>
<span class="comment">&lt;!-- 遍历集合, 只要价格大于 1500的--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"products.{?#this.price&gt;1500}"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:property</span>&gt;</span>
<span class="comment">&lt;!-- 遍历集合, 第一个符合--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"products.{^#this.price&gt;1500}"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:property</span>&gt;</span>
<span class="comment">&lt;!-- 遍历集合, 最后一个符合--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"products.{$#this.price&gt;1500}"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:property</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>类型转换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 打印[0, 2, 4, 6, 8] --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"(5).{#this*2}"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">”#{'name':'wzt','age':30,'gender':'male'}.{#key}”</span>/&gt;</span>发现什么都没有输出
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#{'name':'wzt','age':30,'gender':'male'}.{#this}"</span>/&gt;</span>有输出。把Map转为了Value
<span class="comment">&lt;!-- 打印 [wzt, 30, male]--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#{'name':'wzt','age':30,'gender':'male'}.{#this}"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- 打印当前日期 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"new java.util.Date()"</span>/&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<p>技巧：如果不确定是不是OGNL表达式，那么加上%{abc}，那么abc就是一个OGNL表达式而不是字符串了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="xml"><span class="tag"><span class="value">&lt;s:form action="</span><span class="value">RegUser"</span> <span class="attribute">namespace</span>=<span class="value">"/user"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">key</span>=<span class="value">"hello"</span> <span class="attribute">label</span>=<span class="value">"用户名"</span> <span class="attribute">name</span>=<span class="value">"username"</span> &gt;</span><span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">label</span>=<span class="value">"昵称"</span> <span class="attribute">name</span>=<span class="value">"nick"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:password</span> <span class="attribute">label</span>=<span class="value">"密码"</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:password</span>&gt;</span>
    爱好：
    <span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"hobbies"</span> <span class="attribute">var</span>=<span class="value">"me"</span>&gt;</span>
        <span class="comment">&lt;!-- 如果要把一个字符串当做OGNL表达式对待，请使用%{}包括起来 --&gt;</span>
        <span class="tag">&lt;<span class="title">s:checkbox</span> <span class="attribute">name</span>=<span class="value">"hobby"</span> <span class="attribute">fieldValue</span>=<span class="value">"%{key}"</span> <span class="attribute">label</span>=<span class="value">"%{value}"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:checkbox</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
    <span class="tag">&lt;<span class="title">hr</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:checkboxlist</span> <span class="attribute">list</span>=<span class="value">"hobbies"</span> <span class="attribute">name</span>=<span class="value">"hobby"</span> <span class="attribute">listKey</span>=<span class="value">"key"</span> <span class="attribute">listValue</span>=<span class="value">"value"</span> <span class="attribute">label</span>=<span class="value">"新爱好"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:checkboxlist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:radio</span> <span class="attribute">list</span>=<span class="value">"#{'male':'男','female':'女'}"</span> <span class="attribute">name</span>=<span class="value">"gender"</span> <span class="attribute">label</span>=<span class="value">"性别"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:radio</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:submit</span> <span class="attribute">value</span>=<span class="value">"注册"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:submit</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span></span>
</pre></td></tr></table></figure>

<h1 id="-">防止表单重复提交</h1>
<p>可以利用 interceptor, 防止重复提交</p>
<ol>
<li>在输入表单中加入<s:token/>标签</li>
<li>在要防止重复提交的动作配置中加入token拦截器</li>
<li>提交会出错，需要配置一个结果</li>
<li>如果在返回的页面中要显示错误消息提示，使用s:actionErrors</li>
<li>要覆盖默认的提示，请在国际消息资源文件中加入struts.messages.invalid.token=你的提示信息</li>
</ol>
<p>加入 token 拦截器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"addUser"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"addUser"</span>&gt;</span>
     <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"token"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
     <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="comment">&lt;!-- 第一个结果视图是invalid.token --&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"invalid.token"</span>&gt;</span>/regist.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">&lt;!-- form.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">s:form</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:token</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:token</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">s:submit</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>

<span class="comment">&lt;!-- error.jsp, 显示错误信息 --&gt;</span>
<span class="tag">&lt;<span class="title">s:actionerror</span>&gt;</span><span class="tag">&lt;/<span class="title">s:actionerror</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">更改校验失败视图</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> UserAction{
    <span class="comment">// 如果这个方法校验失败,默认视图是"input", 可以修改为 "loginInput"</span>
    @InputConfig(resultName=<span class="string">"loginInput"</span>)
    <span class="keyword">public</span> String <span class="title">login</span>(){}
}
</pre></td></tr></table></figure>

<h1 id="-jfreechart-">使用标准插件--JFreeChart使用</h1>
<p>导入 jfreechart.jar包</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChartAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
    <span class="keyword">private</span> JFreeChart chart;
    <span class="keyword">public</span> JFreeChart <span class="title">getChart</span>() {
        <span class="keyword">return</span> chart;
    }
    <span class="keyword">public</span> String <span class="title">execute</span>() <span class="keyword">throws</span> Exception {
        ValueAxis xAxis = <span class="keyword">new</span> NumberAxis(<span class="string">"年度"</span>);
        ValueAxis yAxis = <span class="keyword">new</span> NumberAxis(<span class="string">"产值"</span>);
        XYSeries xySeries = <span class="keyword">new</span> XYSeries(<span class="string">"绿豆"</span>);
        xySeries.add(<span class="number">0</span>,<span class="number">300</span>);
        xySeries.add(<span class="number">1</span>,<span class="number">200</span>);
        xySeries.add(<span class="number">2</span>,<span class="number">400</span>);
        xySeries.add(<span class="number">3</span>,<span class="number">500</span>);
        xySeries.add(<span class="number">4</span>,<span class="number">600</span>);
        xySeries.add(<span class="number">5</span>,<span class="number">500</span>);
        xySeries.add(<span class="number">6</span>,<span class="number">800</span>);
        xySeries.add(<span class="number">7</span>,<span class="number">1000</span>);
        xySeries.add(<span class="number">8</span>,<span class="number">1100</span>);
        XYSeriesCollection xyDataset = <span class="keyword">new</span> XYSeriesCollection(xySeries);
        XYPlot xyPlot = <span class="keyword">new</span> XYPlot(xyDataset,xAxis,yAxis,<span class="keyword">new</span> StandardXYItemRenderer(StandardXYItemRenderer.SHAPES_AND_LINES));
        chart = <span class="keyword">new</span> JFreeChart(xyPlot);
        <span class="keyword">return</span> SUCCESS;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"showchart"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.ChartAction"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"chart"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"height"</span>&gt;</span>400<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
              <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"width"</span>&gt;</span>600<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="comment">&lt;!-- jsp页面 --&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
上传成功！<span class="tag">&lt;<span class="title">br</span>/&gt;</span>
  <span class="tag">&lt;<span class="title">s:url</span> <span class="attribute">action</span>=<span class="value">"showchart"</span> <span class="attribute">var</span>=<span class="value">"url"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:url</span>&gt;</span>
  <span class="tag">&lt;<span class="title">img</span> <span class="attribute">alt</span>=<span class="value">"图图"</span> <span class="attribute">src</span>=<span class="value">"${url}"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</pre></td></tr></table></figure>

<p>使用插件,必须要先知道插件的用途,一般只要组织数据就好了,没必要深究.</p>
<h1 id="-url-rest-">伪装URL地址(REST)</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> String <span class="title">showAll</span>(){
    <span class="keyword">return</span> SUCCESS;
}
<span class="keyword">public</span> String <span class="title">queryOne</span>(){
    <span class="comment">//根据id的值，调用serivce，找到那个用户</span>
    List&lt;User&gt; us = getUsers();
    <span class="keyword">for</span>(User u:us){
        <span class="keyword">if</span>(id.equals(u.getId())){
            System.<span class="keyword">out</span>.println(u);
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.devMode"</span> <span class="attribute">value</span>=<span class="value">"true"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.action.extension"</span> <span class="attribute">value</span>=<span class="value">"html"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.enable.SlashesInActionNames"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!--     &lt;constant name="struts.mapper.alwaysSelectFullNamespace" value="true"&gt;&lt;/constant&gt; --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.ognl.allowStaticMethodAccess"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"default"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"showAll"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"showAll"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>/list.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"users/*"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"queryOne"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"id"</span>&gt;</span>{1}<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<p>通过 <code>${pageContext.request.contextPath}/users/${id}.html</code> 访问</p>
<h1 id="-">异常处理</h1>
<p>如果发生错误, 要第一时间将错误转换成自定义异常错误抛出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlException</span> <span class="keyword">extends</span> <span class="title">Exception</span>{</span>
}
</pre></td></tr></table></figure>

<p>通过拦截器, 获取自定义异常</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptioinInterceptor</span> <span class="keyword">extends</span> <span class="title">AbstractInterceptor</span>{</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> String <span class="title">intercept</span>(ActionInvocation ai) {
        <span class="keyword">try</span> {
            <span class="keyword">return</span> ai.invoke();
        } <span class="keyword">catch</span>(MySqlException e) {
            ActionSupport action = ai.getAction();
            action.addActionError(<span class="string">""</span>);
            <span class="keyword">return</span> <span class="string">"error"</span>;
        }
    }
}
</pre></td></tr></table></figure>

<p>可以设置全局错误页面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 在package中设置 --&gt;</span>
<span class="tag">&lt;<span class="title">global-exception-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">exception-mapping</span> <span class="attribute">result</span>=<span class="value">"error"</span> <span class="attribute">exception</span>=<span class="value">"java.lang.Exception"</span>&gt;</span> <span class="tag">&lt;/<span class="title">exception-mapping</span>&gt;</span>
<span class="tag">&lt;/<span class="title">global-exception-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数式编程手记]]></title>
    <link href="http://zhpooer.github.io/2014/05/16/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%89%8B%E8%AE%B0/"/>
    <id>http://zhpooer.github.io/2014/05/16/函数式编程手记/</id>
    <published>2014-05-16T07:28:50.000Z</published>
    <updated>2014-05-16T09:03:22.000Z</updated>
    <content type="html"><![CDATA[<p>历数我学习计算机语言的经历, 也算是略通八国语言的&#39;牛&#39;人啊, 什么汇编、c语言、java,
命令语言、函数式语言、面向对象编程, 统统都学习接触过.
用&quot;物竞天择, 用进废退&quot;这句话来形容现在的我, 真是最合适不过了, 这会儿回想起我最熟悉,
且能马上上手的语言就只有 Java 和 Scala -- 难道是因为工作中一直在用吗?
每当想起<code>倚天屠龙记</code>中张无忌和张三丰的对话, &quot;你忘了吗?&quot;, &quot;我已经全忘了!&quot;, &quot;好, 你的神功已经大成了!&quot;, 真实心有戚戚焉.</p>
<p>不过, 这些语言的具体细节可能会忘, 但是一些语言某些编程模式, 总会给我留下一些印象.
至于编程思想, 呵呵, 像我这种半路出家当码农的人, 还没有研究到这么深刻的地步.
而近两三年, 关于&quot;函数式编程&quot;的讨论甚嚣尘上. 而我在学习各种语言时, &quot;函数式编程&quot;时不时会从各个角落冒出来.
但是什么是&quot;函数式编程&quot;, 它和&quot;面向对象编程&quot;是什么关系, 我不了解. 所以乘今天有空闲的时间, 来研究研究吧.</p>
<p>至于如何研究, 我就不班门弄斧了, 还是看看大神们是怎么理解函数式编程的.
我把从谷歌大神那搜到的关于函数编程的文章列出来, 由浅入深, 希望对想了解这方面东西的人有帮助. </p>
<ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank">阮一峰的网络日志 函数式编程初探</a>:
讲述的是最基本的函数式知识, 浅显易懂</p>
</li>
<li><p><a href="http://coolshell.cn/articles/10822.html" target="_blank">CoolShell 函数式编程</a>:
用 Python 把命令式和函数式做了比较, 例子形象生动, 深入浅出.</p>
</li>
<li><p><a href="http://www.cnblogs.com/kym/archive/2011/03/07/1976519.html" target="_blank">博客园 函数式编程扫盲篇</a>:
对函数式的各种特点做了总结</p>
</li>
<li><p><a href="https://www.byvoid.com/blog/why-functional-programming" target="_blank">BYVoid 函数式程序设计为什么至关重要</a> : 
这是篇论文, 对函数式的语法做了代码上的解析, 用的是 Heskell 语法, 从建模一步步到实用(数值微分, 积分), 不明觉厉之</p>
</li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/bb669144.aspx" target="_blank">msdn Functional Programming vs. Imperative Programming</a>:
英文, 心有余, 力已不足, 马克之.</p>
</li>
</ul>
<p>最后附上神作 <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank">SICP</a>, 暂不能读, 心向往之.</p>
<p>最最后, <strong>见贤思齐</strong>, <a href="http://www.ruanyifeng.com/blog/2012/04/hu_shih.html" target="_blank">阮一峰 胡适的三个主义</a></p>
<blockquote>
<p>生命本没有意义，你要给它什么意义，它就有什么意义。<br>与其终日冥想人生有何意义，不如试用此生做点有意义的事。</p>
</blockquote>
]]></content>
    
    
      <category term="笔记" scheme="http://zhpooer.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[scala文档翻译-Future&Promise]]></title>
    <link href="http://zhpooer.github.io/2014/05/15/scala%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-future&promise/"/>
    <id>http://zhpooer.github.io/2014/05/15/scala文档翻译-future&promise/</id>
    <published>2014-05-15T01:44:38.000Z</published>
    <updated>2014-05-18T03:33:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">拔</h1>
<p>上课无聊, 刚好看scala文档, 遂翻译之, 晚上回来在网上找到已经有人做过了, 且翻译的比我好(-.-!!!),
但已经翻译了一半, 兴致也不错, 那就当练习英语好了(真吊丝啊).</p>
<p>不过 Scala 2.11关于 <code>Macro</code> 和 <code>Reflect</code>的内容很没有人下手, 窃喜之. 哈哈, 我的征途是星辰大海!!!</p>
<p><a href="http://docs.scala-lang.org/overviews/core/futures.html" target="_blank">原文连接</a></p>
<p><a href="https://code.csdn.net/DOC_Scala/chinese_scala_offical_document/file/Futures-and-Promises-cn.md#anchor_0" target="_blank">已有译文连接</a></p>
<h1 id="introduction">Introduction</h1>
<p>Futures 为并发提供了许多非阻塞(non-blocking)和有效率的操作. 它的概念很简单, 一个 <code>Future</code> 就是一系列的还没有发生的操作或运算(一个运算占位符).
事实上, <code>Future</code> 的中的运算会被并行地执行, 而运行结果可以被延迟得到. 这样就可以更快地 非阻塞地 异步地 并发地执行复合并行任务.</p>
<p>实际上, future 和 promises 的非阻塞操作是利用回调函数替换掉经典的阻塞操作.
为了简化回调操作和语法的理解, Scala 提供了提供了组合子, 如  <code>flatMap</code>, <code>foreach</code> 和 <code>filter</code>,
利用这些调用可以组合 future 进行非阻塞的操作. 如果必要的话, futures 也提供了阻塞操作(虽然这并不值得提倡).</p>
<h1 id="futures">Futures</h1>
<p>一个 <code>Future</code> 是一个持有(holding)一个值的对象, 但是这个值在有些时候是取不到的. 这个值常常是一些运算的执行结果:</p>
<ol>
<li>如果这个运算还没有完成, 这个 Future 还没有完成(is not completed)</li>
<li>如果这个运算最终得到一个值, 或在执行的过程中抛出了异常(exception), 这个 Future 执行完成(completed)</li>
</ol>
<p>执行完成(Completion)的表现为下面给两种情况中的任意一种情况:</p>
<ol>
<li>当一个 Future 成功的得到一个值, 那么这个 Future 执行完成.</li>
<li>当一个 Future 在运算的时候抛出到一个异常(exception), 这个 Future 因为异常而失败了.</li>
</ol>
<p>一个 Future 只能被赋值(assigned)一次. 一旦一个 Future 对象(object)(Future内部对象?)被赋值或得到一个异常,
那么它就是不可变的(immutable), 也就是说不能被重新赋值</p>
<p>创建一个 future 对象(object)最简单的方法是调用 <code>future</code> 方法, 它会启动一个异步的运算,
然后返回一个指向这次运行的结果的 future. 一旦这个 future 执行完成, 就可以得到这次运算结果.</p>
<p><code>Future[T]</code> 是一个表示 future 对象(objects)的类型(type).
然而, <code>future</code>是一个生成和调度异步运算的方法, 它返回一个代表<em>将要得到</em>(will)运算结果的 future 对象.</p>
<p>这个特性将通过一个案例展示.</p>
<p>假设我们要调用一个虚构(hypothetical)的 API 从一个社交网络得到一个给定用户的好友列表.
我们将会打开一个新的会话(session),然后发送请求(request)去获取一个特殊用户的的好友列表:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>import scala<span class="preprocessor">.concurrent</span>._
import ExecutionContext<span class="preprocessor">.Implicits</span><span class="preprocessor">.global</span>
val session = socialNetwork<span class="preprocessor">.createSessionFor</span>(<span class="string">"user"</span>, credentials)
val f: Future[List[Friend]] = future {
    session<span class="preprocessor">.getFriends</span>()
}
</pre></td></tr></table></figure>

<p>上边这段代码中, 我们首先导入(import)了 <code>scala.concurrent</code> 包中的内容, 使得 <code>Future</code>
类型和 <code>future</code>构造器可见.对于第二个导入,我们将在稍后解释.</p>
<p>接着, 我们用一个虚构的方法<code>createSessionFor</code>初始化了 session 变量, 我们将用它来给服务端发送请求.
为了得到一个用户的好友列表, 需要通过网络发送一个请求, 这需要花费很长的时间.
这些操作被封装(illustrated)在 <code>getFriends</code>方法, 它返回 <code>List[Friend]</code>.
为了更好地利用CPU资源直到请求返回, 我们不应该阻塞接下来的程序, 所以这些操作(computation)应该被异步的执行(scheduled).
<code>future</code>方法并发地执行了给定的运算代码块(computation block), 这样就可以发送请求(request)给服务端, 并且等待响应(response)</p>
<p>一旦服务器响应, 好友列表(list of friends)可以从 future <code>f</code>中得到.</p>
<p>一次不成功的操作(attempt)将会得到一个异常(exception). 在下面的例子中, <code>session</code> 没有正常初始化,
所以 <code>futrue</code>代码块在执行时, 将会抛出 <code>NullPointerException</code>. futrue <code>f</code> 将会执行失败(failed).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">val</span> session = <span class="keyword">null</span>
<span class="keyword">val</span> f: Future[List[Friend]] = future {
  session.getFriends
}
</pre></td></tr></table></figure>

<p><code>import ExecutionContext.Implicits.global</code>,
这行代码导入(import)了全局默认执行环境(default global execution context).
执行环境(execution context)会执行被提交过来的任务, 你也可以认为执行环境是线程池(thread pools).
它们(execution context)对 <code>future</code> 方法非常重要, 因为它们决定了(handle)什么时候以及怎样异步的执行运算.
你也可以定义自己的执行环境, 用来使用 <code>future</code>, 但是对于上面的代码来说, 导入默认的执行空间就已经够用了.</p>
<p>上面的例子是基于一个虚构的社交网络 API, 它需要通过网络发送请求和等待响应.
你也可以尝试一些其他的关于异步运算的操作. 假设你有一个文本文件(text file),
你想从中找到一个单词第一次出现的位置. 等从硬盘上读取这个文件时候, 这个操作可能会阻塞,
所以可以和剩下的代码块并发地执行.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>val firstOccurrence: Future[Int] = future {
  val source = scala<span class="preprocessor">.io</span><span class="preprocessor">.Source</span><span class="preprocessor">.fromFile</span>(<span class="string">"myText.txt"</span>)
  source<span class="preprocessor">.toSeq</span><span class="preprocessor">.indexOfSlice</span>(<span class="string">"myKeyword"</span>)
}
</pre></td></tr></table></figure>

<h2 id="callbacks">Callbacks</h2>
<p>我们现在知道了如何区启动以个异步的计算得到一个新的 future 值,
但是我们还不知道如何去得到这个已经就位的结果, 现在我们可以对它做一些操作了.
我们通常只对运算的结果感兴趣, 但不包括它的副作用(side-effect).</p>
<p>在许多 future 的实践中, 一旦 future 的使用者对其结果感兴趣, 它会阻塞
它自己的运算知道 future 的值就位--以至于用future的值执行他自己的运算.
虽然 Scala <code>Future</code> 允许这样的操作(我们接下来会讲到),
但是从性能的角度来看, 还有一个完全非阻塞的方式, 那就是注册 future 的回调方法(callback).
一旦future的值就绪, 这个回调方法会被异步的执行.
如果当注册回调函数(callback)时, future的值已经就绪, 那么回调函数将会被异步地执行, 或者
在相同的线程中同步(sequentially)地执行.</p>
<p>最常用的注册回调方法的方式是用 <code>onComplete</code> 方法, 它的传入一个类型为 <code>Try[T] =&gt; U</code> 的回调函数.
如果 future 执行成功, 那么回调函数会接收到一个类型为 <code>Success[T]</code> 的值,
否则会接收到一个类型为 <code>Failure[T]</code> 的值.</p>
<p><code>Try[T]</code> 类似于 <code>Option[T]</code> 或者 <code>Either[T,S]</code>, 它是可以持有某种类型的单子(monad).
而现在, 它已经被设计成持有一个值(value) 或者一个异常对象(throwable object)的类型.
而一个 <code>Option[T]</code>对象, 不是代表一个值(<code>Some[T]</code>), 就是代码没有值(<code>None</code>),
<code>Try[T]</code>则表示, 当执行成功时, 它是<code>Success[T]</code>, 当执行失败时抛出错误时, 它就是 <code>Failure[T]</code>.
<code>Failure[T]</code> 不像 <code>None</code>, 它存储了许多关于为什么得不到最终值的信息.
同时你也可以认为 <code>Try[T]</code> 是 <code>Either[Throwable, T]</code>的特殊版本.</p>
<p>回到我们刚才的社交网络的例子, 假设我们想要拉取(fetch)自己近期的一些帖子, 并显示在屏幕上.
我们会调用 <code>getRecentPosts</code> 方法, 它会返回一个近期关于帖子的列表 <code>List[String]</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="reserved">import</span> scala.util.{Success, Failure}

val <span class="attribute">f</span>: Future[List[String]] = future {
  session.getRecentPosts
}
f onComplete {
  <span class="reserved">case</span> Success<span class="function"><span class="params">(posts)</span> =&gt;</span> <span class="keyword">for</span> (post &lt;- posts) println(post)
  <span class="reserved">case</span> Failure<span class="function"><span class="params">(t)</span> =&gt;</span> println(<span class="string">"An error has occured: "</span> + t.getMessage)
}
</pre></td></tr></table></figure>

<p><code>onComplete</code> 方法通常都要处理成功(successfull)和失败(failed)两种运算结果.
如果要单单处理成功的结果, <code>onSuccess</code> 就可以出马了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>val f: Future[<span class="keyword">List</span>[<span class="keyword">String</span>]] = future <span class="list">{
  session.getRecentPosts
}</span>
f onSuccess <span class="list">{
  case posts =&gt; for (post &lt;- posts) println(post)
}</span>
</pre></td></tr></table></figure>

<p>同样可以用<code>onFailure</code>来处理运算失败的结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>val f: Future[<span class="keyword">List</span>[String]] = future {
  session.getRecentPosts
}
f onFailure {
  <span class="keyword">case</span> t =&gt; println(<span class="string">"An error has occured: "</span> + t.getMessage)
}
f onSuccess {
  <span class="keyword">case</span> posts =&gt; <span class="keyword">for</span> (post &lt;- posts) println(post)
}
</pre></td></tr></table></figure>

<p>只有 future执行失败时, <code>onFailure</code> 回调才会被执行, 因此, 它包含了一个异常(exception).</p>
<p>如果回调函数只定义了要处理某个特殊的异常类型, 只有当这个异常出现时,
<code>onFailure</code>方法才会触发这个回调(利用偏函数(partial functions)的<code>isDefinedAt</code>) 方法.
下面例子中, 注册的<code>onFailure</code> 回调方法将永远都不会被触发:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val f = future {
  <span class="number">2</span> / <span class="number">0</span>
}
f onFailure {
  <span class="keyword">case</span> npe: NullPointerException =&gt;
    println(<span class="string">"I'd be amazed if this printed out."</span>)
}
</pre></td></tr></table></figure>

<p>回到我们之前关于查找单词第一个出现位置的案例, 你也许想要在屏幕输出这个单词的位置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>val firstOccurrence: Future[Int] = future {
  val source = scala<span class="preprocessor">.io</span><span class="preprocessor">.Source</span><span class="preprocessor">.fromFile</span>(<span class="string">"myText.txt"</span>)
  source<span class="preprocessor">.toSeq</span><span class="preprocessor">.indexOfSlice</span>(<span class="string">"myKeyword"</span>)
}
firstOccurrence onSuccess {
  case idx =&gt; println(<span class="string">"The keyword first appears at position: "</span> + idx)
}
firstOccurrence onFailure {
  case t =&gt; println(<span class="string">"Could not process file: "</span> + t<span class="preprocessor">.getMessage</span>)
}
</pre></td></tr></table></figure>

<p><code>onComplete</code>, <code>onSuccess</code>, <code>onFailure</code> 方法返回的类型是 <code>Unit</code>,
这就意味着这些方法的调用不能被链式调用(chained).
这样的设计是刻意为之, 因为链式调用也许暗示着按照一定的顺序注册回调函数
(那么就可以无序地在同一个futre中注册回调函数)</p>
<p>也就是说, 我们现在可以讨论回调函数<em>什么时候</em>会被调用.
因为这些回调函数需要 future 中的值, 所以直到 future 执行完成后, 它们才会被调用.
然而, 也不能保证调用它们(callback)的线程是完成 futre 的线程或者创造回调函数的线程.
反而, 当 future 执行完毕后, 在一定时间内回调函数会被一些其他线程执行.
也就是说回调函数最终会被执行.</p>
<p>更进一步的说, 回调函数被执行的顺序不是固定的, 甚至在多次运行的同一个应用程序中.
实际上, 回调函数会不会被一个接一个地调用, 而是会被并行(concurrently)的执行.
这就意味着在下面的例子中, totalA 的值就不确定是表示大写<code>a</code>的数量还是表示小写<code>a</code>的数量.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="property">@volatile</span> <span class="reserved">var</span> totalA = <span class="number">0</span>
val text = future {
  <span class="string">"na"</span> * <span class="number">16</span> + <span class="string">"BATMAN!!!"</span>
}
text onSuccess {
  <span class="reserved">case</span> txt<span class="function"> =&gt;</span> totalA += txt.count(_ == <span class="string">'a'</span>)
}
text onSuccess {
  <span class="reserved">case</span> txt<span class="function"> =&gt;</span> totalA += txt.count(_ == <span class="string">'A'</span>)
}
</pre></td></tr></table></figure>

<p>在上面的例子中, 两个回调函数可能一个一个顺序执行, 那么 <code>totalA</code> 的值就为18.
然而, 它们也可能并发的执行, 所以 <code>totalA</code> 的值不是16就是2,
只是因为 <code>+=</code> 不是原子性操作(atomic operation)(它由读和写两部分组成)</p>
<p>考虑到表述的完整性, 回调函数的使用的语法如下:</p>
<ol>
<li>在 future 中注册一个 <code>onComplete</code> 回调, future 执行完成后, 回调函数最终会被执行.</li>
<li>用注册 <code>onComplete</code> 的语法, 注册一个 <code>onSuccess</code> 或 <code>onFailure</code>,
它们只会在 future 执行成功或执行失败分别调用.</li>
<li>在一个已经执行完成的 future 中, 注册回调函数, 这个回调函数最终还是会被调用.</li>
<li>在 future 中注册多个回调函数的情况下, 它们的执行顺序不是固定的.
实际上, 回调函数会被并发地执行. 然而, 特定的 <code>ExecutionContext</code> 实现可能会按明确的顺序来执行.</li>
<li>如果一些回调函数抛出了异常, 其他回调函数会不受影响, 继续执行.</li>
<li>在某些情况下, 有些回调函数永远不会结束(可能包含了无限循环), 其他的回调函数就可能不会被执行到.
在这种情况下, 一个潜在的阻塞回调必须使用 <code>blocking</code> 构造函数(下面有介绍)</li>
<li>一旦执行, 回调函数将会从 future 中移除, 这样方便垃圾回收器回收. </li>
</ol>
<h2 id="functional-composition-and-for-comprehensions">Functional Composition and For-Comprehensions</h2>
<p>尽管前面介绍的回调机制已经足够把 future 的结果和后继计算结合起来.
然而在有时候回调机制并不易于使用, 且会造成冗余的代码.
我们可以通过一个案例来说明. 假使我们有一个 关于货币交易系统的API.
假设这适合的点, 我们想买入美元. 我们先展示一下如何用回调来进行这个操作.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>val rateQuote = future {
    connection.getCurrentValue(USD)
}
rateQuote onSuccess { <span class="keyword">case</span> quote =&gt;
    val purchase = future {
        <span class="keyword">if</span> (isProfitable(quote)) connection.buy(amount, quote)
        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"not profitable"</span>)
    }
    purchase onSuccess {
        <span class="keyword">case</span> _ =&gt; println(<span class="string">"Purchased "</span> + amount + <span class="string">" USD"</span>)
    }
}
</pre></td></tr></table></figure>

<p>一开始我们创建一个获取货币交易的 future <code>rateQuote</code>.
当从服务端得到数据, future 执行成功后, 计算执行操作才会进入 <code>onSuccess</code> 回调,
这时, 我们开始决定买还是不买. 因此我们创建了另一个 future <code>purchase</code>,
用来在可盈利的情况下做出购买决定, 然后向服务器发出请求.
最后, 一旦购买完成, 我们会在标准输出中打印一条通知消息.</p>
<p>这确实是可以行的, 但是由两点原因是这种方法并不方便.
其一, 我们不得不使用 <code>onSuccess</code>, 且在其中嵌套调用 <code>purchase</code> future.
假设, 我们要在 <code>purchase</code> 执行完成后卖出一些货币.
这时我们不得不在<code>onSuccess</code>回调中重复这个模式, 从而使代码过度嵌套, 冗长且难以理解.</p>
<p>其二, future <code>purchase</code> 没有在其余代码的范围内, 它只能在<code>onSuccess</code>回调内部响应.
这就意味着其他部分的程序是取不到 <code>purchase</code> future,
也不能注册其他的 <code>onSuccess</code> 回调函数, 比如说卖掉些货币.</p>
<p>基于这两个原因, futures 提供了组合器(combinators)使之具有了更加易用的组合形式.
<code>map</code>是最基础的组合器之一, 当给定一个 future 和一个映射函数(mapping function)来出来future的值,
映射方法会产生一个新的future, 一旦最初的 future 成功地执行, 新的future会通过该返回值完成计算.
你能够像理解容器(collections)的map一样来理解future的map.</p>
<p>让我们用 <code>map</code> 组合子来重写上面的一个案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>val rateQuote = future {
  connection.getCurrentValue(USD)
}

val purchase = rateQuote map { quote =&gt; 
  <span class="keyword">if</span> (isProfitable(quote)) connection.buy(amount, quote)
  <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"not profitable"</span>)
}

purchase onSuccess {
  <span class="keyword">case</span> _ =&gt; println(<span class="string">"Purchased "</span> + amount + <span class="string">" USD"</span>)
}
</pre></td></tr></table></figure>

<p>通过对<code>rateQuote</code>使用 <code>map</code>, 我们减少了一次 <code>onSuccess</code>回调, 更重要的是避免了嵌套调用.
如果我们现在决定要卖掉一些其他货币, 就可以再次对 <code>purchase</code> 使用 <code>map</code>了.</p>
<p>但是如果 <code>isProfitable</code> 返回 <code>false</code>, 因此引起了一个异常, 那怎么办呢?
在这种情况下, <code>purchase</code> 会因为异常而失败. 更进一步地说, 如果连接服务器失败,
使得 <code>getCurrentValue</code> 抛错, 最终使 <code>rateQuote</code> 失败了呢?
在这种情况下, 我们将不能获得值去使用map, 以至于 <code>purchase</code> 自动地以和<code>rateQuote</code>相同的异常
而执行失败.</p>
<p>总之, 如果最初的 future 执行成功了, 那么返回的值将会和 map 函数一起执行成功.
如果 map 函数抛出了异常, 那么 future 就会带着该异常而失败.
如果最初的future以异常结束, 那么那个返回的future也会以同样的失败结束.
这种异常传导机制会适用于其他组合子(combinators).</p>
<p>这种设计也同样被用于for语法(for-comprehensions).
所以, futrues 同样也有 <code>flatMap</code>, <code>filter</code> 和 <code>foreach</code> 组合子.
<code>flatMap</code> 方法传入一个函数, 它把值映射到一个新的 future <code>g</code>, 一旦 <code>g</code>执行完成, 就返回一个
future.</p>
<p>假设我们想把一些美元换成瑞士法郎(CHF). 我们要拉取两个货币的报价,
接着根据两个报价来决定如何购买. 下面是一个在for-comprehensions中使用<code>flatMap</code>和<code>withFilter</code>的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">val</span> usdQuote = future { connection.getCurrentValue(USD) }
<span class="keyword">val</span> chfQuote = future { connection.getCurrentValue(CHF) }

<span class="keyword">val</span> purchase = <span class="keyword">for</span> {
  usd &lt;- usdQuote
  chf &lt;- chfQuote
  <span class="keyword">if</span> isProfitable(usd, chf)
} <span class="keyword">yield</span> connection.buy(amount, chf)

purchase onSuccess {
  <span class="keyword">case</span> _ =&gt; println(<span class="string">"Purchased "</span> + amount + <span class="string">" CHF"</span>)
}
</pre></td></tr></table></figure>

<h2 id="projections">Projections</h2>
<h2 id="extending-futures">Extending Futures</h2>
<h1 id="blocking">Blocking</h1>
<h1 id="exceptions">Exceptions</h1>
<h1 id="promises">Promises</h1>
<h1 id="utilities">Utilities</h1>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="翻译" scheme="http://zhpooer.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day30-struts响应数据]]></title>
    <link href="http://zhpooer.github.io/2014/05/15/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day30-struts%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/"/>
    <id>http://zhpooer.github.io/2014/05/15/传智播客day30-struts响应数据/</id>
    <published>2014-05-15T01:01:10.000Z</published>
    <updated>2014-05-28T02:21:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="struts2-">Struts2 上传下载</h1>
<p>企业常用文件上传技术: jspSmartUpload(JSP model时代), fileupload(apache commons), servlet3.0 集成文件上传</p>
<h2 id="-">文件上传</h2>
<p>真正干活的是 <code>FileUploadInterceptor</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:file</span> <span class="attribute">name</span>=<span class="value">"resource"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:file</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadAction</span> {</span>
<span class="comment">// 如果是多个文件上传, 那么就用定义数组, 如果 File[] resource;</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> File resource;    <span class="comment">// 得到文件</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String resourceContentType; <span class="comment">// 得到文件类型 MIME</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String resourceFileName; <span class="comment">// 得到文件的名称</span>
    <span class="keyword">public</span> String <span class="title">execution</span>(){
        String bashPath = ServletContext.getServletContext().getRealPath(<span class="string">"WEB-INF/upload"</span>);
        File dir = <span class="keyword">new</span> File(bashPaht+subPath);
        dir.mkdirs();
        String path  = dir + UUIDName();
        FileUtils.copyFile(resource, <span class="keyword">new</span> File(dir)); <span class="comment">// common-io</span>
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</pre></td></tr></table></figure>

<p>配置上传文件信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 上传出错后, 可以配置input视图 --&gt;</span>
<span class="comment">&lt;!-- 设置全局, 文件上传的最大值, 默认大小为2M, 超出大小后, actionError --&gt;</span>
<span class="comment">&lt;!-- 错误信息提示 可以根据 struts-messages.properties 来设置 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.multipart.maxSize"</span> <span class="attribute">value</span>=<span class="value">"2097152"</span>&gt;</span> <span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 配置解析技术, jakara或pell  --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.multipart.parser"</span> <span class="attribute">value</span>=<span class="value">"cos"</span>&gt;</span> <span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="tag">&lt;<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span>
        <span class="comment">&lt;!-- 设置局部  --&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fileUpload.maximumSize"</span>&gt;</span>2097152<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fileUpload.allowedExtensions"</span>&gt;</span>txt,doc,pdf <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="comment">&lt;!-- 可以在web.xml中查看, mime类型 --&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fileUpload.allowedTypes"</span>&gt;</span>application/msword <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">文件的下载</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre>// http://contextPath/download.action&filename=xx.mp3
/*
<span class="tag">&lt;<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"stream"</span>&gt;</span>
        <span class="comment">&lt;!-- 指定下载的文件流  --&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"inputName"</span>&gt;</span> inputStream <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"ContentType"</span>&gt;</span>${contentType}<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="comment">&lt;!-- 解析下载文件名字  --&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"contentDisposition"</span>&gt;</span> <span class="comment">&lt;!-- 浏览器打开方式 --&gt;</span>
            attachment;filename=%{#fileName}.txt
        <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
*/
public class DownloadAction {
    @BeanProperty private InputStream InputStream;
    public String download(){
        String fileName = "";
        String filePath = "";
        String agent = ServletContext.getRequest().getHeader("user-agent");
        String encoded = encodeDownloadFilename(filename, agent);
        // 附件乱码问题,(IE和其他浏览器: URL编码, 火狐: Base64编码)
        ActionContext.getContext().put("fileName", encoded);
        inputStream = new FileInputStream(filePath + fileName);
    }
    // 根据下载文件动态获取 MIME 文件类型
    public String getContentType(){
        return ServletActionContext.getServletContext().getMimeType(filename);
    }
    
    /*
	 * 下载文件时，针对不同浏览器，进行附件名的编码
	 * @param filename 下载文件名
	 * @param agent 客户端浏览器
	 * @return 编码后的下载附件名
	 * @throws IOException
	 */
     public String encodeDownloadFilename(String filename, String agent) throws IOException{
        if(agent.contains("Firefox")){ // 火狐浏览器
            filename = "=?UTF-8?B?"+new BASE64Encoder().encode(filename.getBytes("utf-8"))+"?=";
        }else{ // IE及其他浏览器
            filename = URLEncoder.encode(filename,"utf-8");
        }
        return filename;
    }
}
</pre></td></tr></table></figure>

<h1 id="-struts2-">访问 struts2 静态资源</h1>
<p>文档中介绍了，可以把静态资源放到org.apache.struts2.static或者template包中，
可以直接访问，例如 访问template.aaa中的bbb.css，则
<code>http://localhost:8080/day22_03_strutsStatics/struts/aaa/bbb.css</code></p>
<p>或者自己对静态资源访问的地址进行设置，在web.xml中设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 则访问com.itheima.statics中的资源ccc.css，的地址为 --&gt;</span>
<span class="comment">&lt;!-- http://localhost:8080/day22_03_strutsStatics/struts/ccc.css --&gt;</span>
<span class="tag">&lt;<span class="title">filter</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>
    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>packages<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>com.itheima.statics<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="struts2-">struts2 数据存储和显示</h1>
<p>OGNL是Object Graphic Navigation Language(对象图导航语言)的缩写，
它是一个开源项目.Struts2框架使用OGNL作为默认的表达式语言。</p>
<ul>
<li>xwork 提供 OGNL表达式 </li>
<li>ognl-3.0.5.jar</li>
</ul>
<p>OGNL 是一种比EL 强大很多倍的语言 </p>
<p>OGNL 提供五大类功能 </p>
<ol>
<li>支持对象方法调用，如xxx.doSomeSpecial();</li>
<li>支持类静态的方法调用和值访问</li>
<li>访问OGNL上下文（OGNL context）和ActionContext: (重点 操作ValueStack值栈)</li>
<li>支持赋值操作和表达式串联</li>
<li>操作集合对象。</li>
</ol>
<h2 id="-">方法调用</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="vbscript">&lt;%@taglib uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span>
<span class="comment">&lt;!-- 通过 s:property 标签操作 ognl 表达式 --&gt;</span>
<span class="comment">&lt;!-- 实例方法 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"'hellof world'.length()"</span>/&gt;</span>
<span class="comment">&lt;!-- 静态方法 --&gt;</span>
<span class="comment">&lt;!-- @[类全名（包括包路径）]@[方法名]  --&gt;</span>
<span class="comment">&lt;!--  使用 静态方法调用 必须 设置 struts.ognl.allowStaticMethodAccess=true --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"@java.lang.String@format('您好,%s','小明')"</span>/&gt;</span>
</pre></td></tr></table></figure>

<h2 id="ognl-context">OGNL Context</h2>
<p>什么是值栈(ValueStack)?</p>
<pre><code>接口, 是struts2 提供的一个接口, 实现类是`OgnlValueStack`,
OGNL 是从值栈中获取数据的, 每个Action实例都有一个ValueStack 对象(一次请求,一个ValueStack对象)
在其中保存当前Action对象保存名为 &#39;struts.valueStack&#39;的请求属性中, request中
</code></pre><p>值栈的内部结构?</p>
<pre><code>值栈由两部分组成 

ObjectStack: Struts  把动作和相关对象压入 ObjectStack(List) 中

ContextMap: Struts 把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中
    Struts 会把下面这些映射压入 ContextMap 中
    parameters: 该 Map 中包含当前请求的请求参数
    request: 该 Map 中包含当前 request 对象中的所有属性
    session: 该 Map 中包含当前 session 对象中的所有属性
    application:该 Map 中包含当前 application  对象中的所有属性
    attr: 该 Map 按如下顺序来检索某个属性: request, session, application
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ServletActionContext<span class="preprocessor">.getRequest</span>()<span class="preprocessor">.getAttribute</span>(<span class="string">"struts.valueStack"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>OGNL表达式, 访问root中数据时 不需要 &#39;#&#39;,
访问 request、 session、application、 attr、 parameters 对象数据 必须写  <code>#</code></p>
<p>值栈对象的创建, ValueStack 和 ActionContext 是什么关系?</p>
<pre><code>值栈对象 是请求时 创建的 
doFilter中`prepare.createActionContext(request, response)`
    * 创建ActionContext 对象过程中，创建 值栈对象ValueStack 
    * ActionContext对象 对 ValueStack对象 有引用的(在程序中 通过 ActionContext 获得 值栈对象)
Dispatcher类 serviceAction 方法中 将值栈对象保存到 request范围
    request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, proxy.getInvocation().getStack());
</code></pre><h3 id="valuestack">ValueStack</h3>
<p>解决 Action 向 JSP 传递数据的问题</p>
<ul>
<li>在struts2中所有的数据都在 ValueStack 中(核心)</li>
<li>ValueStack里面有两个东西，一个是根,就是CompoundRoot，这是一个List集合，还有一个contextMap</li>
<li>ValueStack 的生命周期是一次请求, 被存在 request 域<code>&quot;struts.ValueStack&quot;</code>中</li>
<li>获得 ValueStack 有三种方式<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
    <span class="keyword">public</span> String <span class="title">testValueStack</span>() {
        ValueStack vs1 = ActionContext.getContext().getValueStack();
        ValueStack vs2 = ServletActionContext.getContext().getValueStack();
        ValueStack vs3 = ServletActionContext.getRequest().getAttribute(<span class="string">"struts.ValueStack"</span>);
        <span class="keyword">return</span> <span class="string">""</span>;
    }
}
</pre></td></tr></table></figure>

</li>
</ul>
<h3 id="valuestack-">ValueStack中常用方法详解</h3>
<p>对值栈的操作, 主要是对 root 的操作</p>
<ul>
<li><code>pop</code> 把栈顶的remove</li>
<li><code>push</code> 放到栈顶</li>
<li><code>peek</code>获取栈顶</li>
<li><p><code>set</code> 往根栈里面放东西，如果栈顶是Map，则直接放进去，
如果不是Map，则建一个Map放进去, set方法不能设置栈顶的普通JavaBean对象的属性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>vs.set(<span class="string">"p"</span>, <span class="string">"pp"</span>);//向栈顶压入一个<span class="keyword">Map</span>(如果栈顶就是一个<span class="keyword">Map</span>，直接使用了)。<span class="keyword">map</span>中的元素的key是p，value是pp
</pre></td></tr></table></figure>
</li>
<li><p><code>setValue</code> 设置值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>//相当于从栈顶依次查找谁有setItheima(<span class="string">"牛13"</span>), 都没有则报错。不会去大Map中找
vs<span class="preprocessor">.setValue</span>(<span class="string">"itheima"</span>, <span class="string">"牛13"</span>)<span class="comment">;</span>
vs<span class="preprocessor">.setValue</span>(<span class="string">"date"</span>, <span class="number">18</span>)<span class="comment">;//某个对象的属性</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>findValue(String expr)</code>, 如果expr以#开头，从contextMap中取。
如果不加#，先从根栈找属性，没有找到。则从contextMap中，作为key来找了</p>
</li>
<li><code>findString</code> 如果找的是Date对象，内部会转换成String对象<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>ac<span class="preprocessor">.put</span>(<span class="string">"now"</span>, new Date())<span class="comment">;</span>
obj = vs<span class="preprocessor">.findValue</span>(<span class="string">"#now"</span>)<span class="comment">;</span>
<span class="keyword">out</span><span class="preprocessor">.write</span>(obj+<span class="string">" "</span>+obj<span class="preprocessor">.getClass</span>()<span class="preprocessor">.getName</span>())<span class="comment">;</span>
//类型转换器把java<span class="preprocessor">.util</span><span class="preprocessor">.Date</span>---&gt;java<span class="preprocessor">.lang</span><span class="preprocessor">.String</span>.确定表达式返回值就是String类型的才能用
String str = vs<span class="preprocessor">.findString</span>(<span class="string">"#now"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="-">值栈在开发中应用</h2>
<p>主流应用: 值栈 解决 Action 向 JSP 传递 数据问题 </p>
<p>Action 向JSP 传递数据处理结果 ，结果数据有两种形式 </p>
<ul>
<li><p>消息 String类型数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 针对某一个字段错误信息(常用于表单校验)</span>
<span class="keyword">this</span>.addFieldError(<span class="string">"msg"</span>, <span class="string">"字段错误信息"</span>);
<span class="comment">// 普通错误信息，不针对某一个字段 登陆失败</span>
<span class="keyword">this</span>.addActionError(<span class="string">"Action全局错误信息"</span>);
<span class="comment">// 通用消息</span>
<span class="keyword">this</span>.addActionMessage(<span class="string">"Action的消息信息"</span>);

<span class="comment">// 在jsp中使用 struts2提供标签 显示消息信息</span>
<span class="comment">// &lt;s:fielderror fieldName="msg"/&gt;</span>
<span class="comment">// &lt;s:actionerror/&gt;</span>
<span class="comment">// &lt;s:actionmessage/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>数据(复杂类型数据), 使用值栈<code>valueStack.push(products)</code></p>
</li>
</ul>
<p>哪些数据默认会放入到值栈?</p>
<ul>
<li>每次请求，访问Action对象 会被压入值栈, <code>DefaultActionInvocation</code> 的 init方法 <code>stack.push(action);</code></li>
<li>Action如果想传递数据给 JSP，只有将数据保存到成员变量，并且提供get方法就可以了</li>
<li>如果Action 实现ModelDriven接口，值栈默认栈顶对象 就是model对象<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 在拦截器中 ，将model对象 压入了 值栈 stack.push(model); --&gt;</span>
<span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"modelDriven"</span> <span class="attribute">class</span>=<span class="value">"com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor"</span>/&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="el-">EL 访问值栈的数据</h2>
<p>struts对<code>Request</code>对象进行了包装, 重写request的 <code>getAttribute</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Object <span class="keyword">attribute</span> = super.getAttribute(s);
<span class="comment">// 访问request范围的数据时，如果数据找不到，去值栈中找 </span>
<span class="keyword">if</span> (<span class="keyword">attribute</span> == null) {
    <span class="keyword">attribute</span> = stack.findValue(s);
}
</pre></td></tr></table></figure>

<ul>
<li>request 对象 具备访问值栈数据的能力(查找root的数据)</li>
</ul>
<h2 id="struts2-ognl-">struts2显示(ognl)</h2>
<p>ognl: struts2的标签, 把 valueStack 中的数据显示到页面上</p>
<p>常见符号 <code>#</code> <code>%</code> <code>$</code></p>
<ul>
<li><p><code>%</code>的使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 用法一： 结合struts2 表单表单使用， 通过%通知struts，
     %{}中内容是一个OGNL表达式，进行解析  --&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"%{#request.username}"</span>/&gt;</span>
<span class="comment">&lt;!-- 用法二： 设置ognl表达式不解析 %{'ognl表达式'} --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"%{'#request.username'}"</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>$</code>的使用 </p>
<ul>
<li><p>用法一: 用于在国际化资源文件中，引用OGNL表达式 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 在properties文件 msg=欢迎您, ${#request.username} --&gt;</span>
 <span class="comment">&lt;!-- 自动将值栈的username 结合国际化配置信息显示  --&gt;</span>
<span class="tag">&lt;<span class="title">s:i18n</span> <span class="attribute">name</span>=<span class="value">"messages"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:text</span> <span class="attribute">name</span>=<span class="value">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:text</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:i18n</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>用法二 ：在Struts 2配置文件中，引用OGNL表达式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 在Action 提供 getContentType方法 --&gt;</span>
<span class="comment">&lt;!-- 读取值栈中contentType数据,在Action提供 getContentType --&gt;</span>
<span class="comment">&lt;!-- 因为Action对象会被压入值栈,contentType是Action属性,从值栈获得 --&gt;</span>
<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"contentType"</span>&gt;</span>${contentType}<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>结论: <code>#</code>用于写ognl表达式获取数据,<code>%</code> 控制ognl表达式是否解析,
<code>$</code> 用于配置文件获取值栈的数据 </p>
<h3 id="-">调试</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 导入标签,位置在 struts2-core/META-INF --&gt;</span>
<span class="vbscript">&lt;%@taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span>%&gt;</span>

<span class="comment">&lt;!-- 超级链接, 显示ValueStack中的内容 --&gt;</span>
<span class="tag">&lt;<span class="title">s:debug</span>/&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-valuestack-">访问 valuestack 中的数据</h3>
<p>可通过<code>&lt;s:property/&gt;</code> 标签访问栈顶元素及其栈中所有对象的属性,</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 对象栈, 栈中元素: Person{name="zhang", pid=1L},
Person2{nickname=zhang2, pid=2L}
如果不写value属性, 则输出对象栈的栈顶元素全部 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> /&gt;</span> <span class="comment">&lt;!-- 输出: Person@1245af --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: zhang --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"nickname"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: zhang2 --&gt;</span>
<span class="comment">&lt;!-- 如果对象栈中特有相同属性对象, 则访问最先找到的对象的属性 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"pid"</span>/&gt;</span>  <span class="comment">&lt;!--  输出: 1 --&gt;</span>

<span class="comment">&lt;!-- 将map放入对象栈中 --&gt;</span>
<span class="comment">&lt;!-- valueStack.set("key", "value1"); --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>  <span class="comment">&lt;!--  输出: value1 --&gt;</span>
</pre></td></tr></table></figure>

<p>访问Map栈中的值,通过<code>&lt;property value=&quot;#key&quot;/&gt;</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 键值对放入 map 栈中 --&gt;</span>
<span class="comment">&lt;!-- ActionContext().getContext().put("key", "value1") --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#key"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: value1 --&gt;</span>

<span class="comment">&lt;!-- 访问Request域中的数据 --&gt;</span>
<span class="comment">&lt;!-- ServletActionContext.getRequest().setAttribute("key", "value2") --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.key"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: value2 --&gt;</span>

<span class="comment">&lt;!-- person = Person{name=zhang, id=3L}
ServletActionContext.getRequest().setAttribute("person", person) --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.person.name"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: zhang --&gt;</span>
</pre></td></tr></table></figure>

<h3 id="struts-">struts标签库</h3>
<h4 id="property-">property 标签用法</h4>
<p><code>&lt;s:property&gt;</code>标签用于输出某个OGNL表达式的值，并进行HTML和XML实体转换,<br>可以认为其内部使用的是ValueStack对象的findString()方法.<br>如果没有设置value属性，则输出ValueStack栈顶的对象,<br>等效于输出“top”这个特殊的OGNL表达式，”top”表示栈顶的对象.<br>如果采用不加#前缀的方式输出Context中的某个键值对,<br>这个对象必须是String类型，以此可以说明该标签内部调用的是ValueStack.findString()方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"[0].top"</span>/&gt;</span>   <span class="comment">&lt;!-- [0].top 第一个元素对象, [1].top第二个元素对象 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"[1].name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- 取栈顶第二个对象中的name值  --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- 相当于ValueStack.findString() --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"top.name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- top代表栈顶对象,取栈顶对象中的name值  --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- 取栈顶对象 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">default</span>=<span class="value">"木有"</span> <span class="attribute">value</span>=<span class="value">"abc"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- 表示如果没有abc这个属性,则返回default的木有 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"'&lt;hr/&gt;'"</span> <span class="attribute">escape</span>=<span class="value">"false"</span>/&gt;</span><span class="comment">&lt;!-- escape默认的是ture,表示打印&lt;hr/&gt; --&gt;</span>

<span class="comment">&lt;!--请求url:  url?a=hello  --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#parameters.a[0]"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: hello --&gt;</span>

<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#session.key"</span>/&gt;</span>

<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#application.key"</span>/&gt;</span>

<span class="comment">&lt;!-- ServletActionContext.getServletContext().setAttribute("key", "value2") --&gt;</span>
<span class="comment">&lt;!-- 从 request session application 域中依次查找--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#attr.key"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: value2 --&gt;</span>
</pre></td></tr></table></figure>

<h3 id="ognl-">ognl 数组输出</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment">&lt;!-- p1=Person{name=乙, pid=1L} --&gt;</span>
<span class="comment">&lt;!-- p2=Person{name=甲, pid=2L} --&gt;</span>
<span class="comment">&lt;!-- p3=Person{name=丙, pid=3L} --&gt;</span>
<span class="comment">&lt;!-- personlist = ArrayList(p1, p2, p3) --&gt;</span>
<span class="tag">&lt;<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">th</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span> name <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span> id <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">th</span>&gt;</span>
    <span class="comment">&lt;!-- 迭代输出集合(Collection), 数组, Map
    value 指向valueStack中要遍历的集合当前正在迭代的元素会放到栈顶
    var 指向当前遍历的元素, 放在Map栈中
    status 指向当前元素的遍历信息, 有方法
    getIndex(), isLast(), getCount(), isEven(), isOdd(), isFirst()
    begin 开始位置
    step 步长
    end 结束位置
    --&gt;</span>
    <span class="comment">&lt;!-- 方式一, 把数据放在Map栈中 --&gt;</span>
    <span class="comment">&lt;!-- ActionContext.getContext().put("personList", personList) --&gt;</span>
    <span class="comment">&lt;!-- p 在根栈, 和 map栈都放一份--&gt;</span>
    <span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#personList"</span> <span class="attribute">var</span>=<span class="value">"p"</span> <span class="attribute">status</span>=<span class="value">"st"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">class</span>=<span class="value">"&lt;s:property value="</span><span class="value">#st.odd?'even':'odd'"</span>/&gt;</span>"&gt;
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#p.pid"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
    
    <span class="comment">&lt;!-- 方式二, 把数据放在Map栈中 --&gt;</span>
    <span class="comment">&lt;!-- 如果value值不写, 则默认迭代对象栈栈顶元素
        valueStack.push(personList)--&gt;</span>
    <span class="tag">&lt;<span class="title">s:iterator</span>&gt;</span>
        <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"pid"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>b
        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">其他容器的迭代</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="comment">&lt;!-- p1=Person{name=乙, pid=1L} --&gt;</span>
<span class="comment">&lt;!-- p2=Person{name=甲, pid=2L} --&gt;</span>
<span class="comment">&lt;!-- p3=Person{name=丙, pid=3L} --&gt;</span>

<span class="comment">&lt;!-- 迭代输出Map栈中的map --&gt;</span>
<span class="comment">&lt;!-- personMap = Map("person1" -&gt; p1, "person2" -&gt; p2, "perseon3" -&gt; p3) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("map", personMap) --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#request.map"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"value.name"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- 迭代输出Map栈中的Set --&gt;</span>
<span class="comment">&lt;!-- personSet = Set(p1, p2, p3) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("set", personSet) --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#request.set"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"pid"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- 迭代输出Map栈中的List&lt;Map&lt;String, Person&gt;&gt; --&gt;</span>
<span class="comment">&lt;!-- listMap = List(Map("person1"-&gt;p1, "person2"-&gt;p2)) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("listMap", listMap) --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#request.listMap"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:iterator</span>&gt;</span>            <span class="comment">&lt;!-- map 被放入对象栈栈顶 --&gt;</span>
        <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"value.name"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- 迭代输出map栈中的Map&lt;String, List&lt;Person&gt;&gt; --&gt;</span>
<span class="comment">&lt;!-- 看官可以脑补, 关键点: 迭代时, 当前迭代对象会被放到栈顶, 所以不用声明 iterator.value --&gt;</span>

<span class="comment">&lt;!-- 输出 List&lt;Map&lt;String, List&lt;Person&gt;&gt;&gt;, 看官亦可脑补 --&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">其他标签</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="comment">&lt;!-- &lt;s:set&gt;标签用于将某个值存入指定范围域中，
通常用于将一个复杂的ognl表达式用一个简单的变量来进行引用。 --&gt;</span>
<span class="comment">&lt;!-- scope属性：指定变量被放置的范围，该属性可以接受
application、session、request、 page或action。该属性的默认值为action --&gt;</span>
<span class="comment">&lt;!-- 给 request 域中的键值对取别名 --&gt;</span>
<span class="tag">&lt;<span class="title">s:set</span> <span class="attribute">value</span>=<span class="value">"#request.request_username"</span> <span class="attribute">var</span>=<span class="value">"newname"</span> <span class="attribute">scope</span>=<span class="value">"request"</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:set</span> <span class="attribute">value</span>=<span class="value">"%{'张三'}"</span> <span class="attribute">var</span>=<span class="value">"newname"</span> <span class="attribute">scope</span>=<span class="value">"request"</span>&gt;</span>/
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.newname"</span>/&gt;</span>

<span class="comment">&lt;!-- 将request域的元素压入对象栈, 并在用完之后, 从对象栈中删除初--&gt;</span>
<span class="tag">&lt;<span class="title">s:push</span> <span class="attribute">value</span>=<span class="value">"#request.request_username"</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">s:property</span>/&gt;</span> <span class="comment">&lt;!--因为是在栈顶也可以用 s:property 读取元素--&gt;</span>
<span class="tag">&lt;/<span class="title">s:push</span>&gt;</span>

<span class="comment">&lt;!-- Var:赋值给变量的值。放置在request作用域中。
     如果没有设置该属性，对象被设置到栈顶。 --&gt;</span>
<span class="tag">&lt;<span class="title">s:bean</span> <span class="attribute">name</span>=<span class="value">"className"</span> <span class="attribute">var</span>=<span class="value">"myperson"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:param</span> <span class="attribute">name</span>=<span class="value">"pid"</span> <span class="attribute">value</span>=<span class="value">"#request.pid"</span>/&gt;</span>
    <span class="comment">&lt;!--因为是在栈顶也可以用 s:property 读取元素--&gt;</span>
<span class="tag">&lt;/<span class="title">s:bean</span>&gt;</span>

<span class="tag">&lt;<span class="title">s:if</span> <span class="attribute">test</span>=<span class="value">"#person.pid&lt;3"</span>&gt;</span> 小于三 <span class="tag">&lt;/<span class="title">s:if</span>&gt;</span>
<span class="tag">&lt;<span class="title">s:elseif</span> <span class="attribute">test</span>=<span class="value">"#person.pid&gt;3"</span>&gt;</span> 大于三 <span class="tag">&lt;/<span class="title">s:esleif</span>&gt;</span>
<span class="tag">&lt;<span class="title">s:else</span> <span class="attribute">test</span>=<span class="value">"#person.pid==3"</span>&gt;</span> 等于三 <span class="tag">&lt;/<span class="title">s:esle</span>&gt;</span>

<span class="comment">&lt;!-- 编码转义 --&gt;</span>
<span class="tag">&lt;<span class="title">s:url</span> <span class="attribute">action</span>=<span class="value">""</span> <span class="attribute">namespace</span>=<span class="value">"/"</span> &gt;</span>
    <span class="tag">&lt;<span class="title">s:param</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">"%{'good'}"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:param</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:url</span>&gt;</span>

<span class="comment">&lt;!-- 是一个链接, 可以对中文进行转义 --&gt;</span>
<span class="tag">&lt;<span class="title">s:a</span> <span class="attribute">action</span>=<span class="value">""</span> <span class="attribute">namespace</span>=<span class="value">""</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:param</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">"%{'test'}"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:param</span>&gt;</span>    
<span class="tag">&lt;/<span class="title">s:a</span>&gt;</span>

<span class="comment">&lt;!-- 为值栈中的数据进行赋值 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"price=1000, name='冰箱"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:property</span>&gt;</span>
</pre></td></tr></table></figure>

<h4 id="ui-">ui标签</h4>
<p>struts2 除了支持JSP之外，支持两种模板技术 Velocity (扩展名 .vm ),
Freemarker (扩展名 .ftl)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">&lt;!--
    action 为提交form表单时的url
    method 默认为post
--&gt;</span>
<span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">action</span>=<span class="value">""</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">method</span>=<span class="value">""</span> <span class="attribute">theme</span>=<span class="value">"xhtml"</span>&gt;</span>
   <span class="comment">&lt;!-- struts 解析后, 会自动插入表格标签,
       所以插入 &lt;table&gt; &lt;tr&gt; &lt;tr&gt; 标签时, 会与其发生冲突
       可以通过设置在struts.xml中 struts.ui.theme 为simple, 来避免冲突
       --&gt;</span>
    <span class="tag">&lt;<span class="title">s:label</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">for</span>=<span class="value">"password"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">label</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:password</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">showpassword</span>=<span class="value">""</span> <span class="attribute">lable</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:hidden</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:submit</span> <span class="attribute">type</span>=<span class="value">"submit|button|image "</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:reset</span> <span class="attribute">type</span>=<span class="value">"input|button"</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:texterea</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">cols</span>=<span class="value">""</span> <span class="attribute">rows</span>=<span class="value">""</span> <span class="attribute">lable</span>=<span class="value">""</span>/&gt;</span>

<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">&lt;!-- p1=Person{name=乙, pid=1L} --&gt;</span>
<span class="comment">&lt;!-- p2=Person{name=甲, pid=2L} --&gt;</span>
<span class="comment">&lt;!-- p3=Person{name=丙, pid=3L} --&gt;</span>
<span class="comment">&lt;!-- personlist = ArrayList(p1, p2, p3) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("personList", personList) --&gt;</span>
<span class="comment">&lt;!--
     listKey 为option中的value
     listValue 为option中的标签内容
     headerKey 表示第一个option中的value
     headerValue 表示第一个option标签中的内容
--&gt;</span>
<span class="tag">&lt;<span class="title">s:select</span> <span class="attribute">list</span>=<span class="value">"#personList"</span> <span class="attribute">listKey</span>=<span class="value">"pid"</span> <span class="attribute">listValue</span>=<span class="value">"name"</span> <span class="attribute">headerKey</span>=<span class="value">""</span> <span class="attribute">headerValue</span>=<span class="value">""</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:checkboxlist</span> <span class="attribute">list</span>=<span class="value">"#personList"</span> <span class="attribute">listValue</span>=<span class="value">"name"</span> <span class="attribute">listKey</span>=<span class="value">"pid"</span> <span class="attribute">name</span>=<span class="value">"pid"</span>/&gt;</span>


<span class="comment">&lt;!-- 在文本框中把person中的name属性进行回显 --&gt;</span>
<span class="comment">&lt;!-- person = Person{name="test" pid=1L} --&gt;</span>

<span class="comment">&lt;!-- ActionContext.getContext.put("person", person) --&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"%{#person.name}"</span>/&gt;</span> <span class="comment">&lt;!--输出: test --&gt;</span>

<span class="comment">&lt;!-- valueStack().push(person), 放入对象栈,
     可以不加value, 根据name属性进行回显
     s:textfield, s:textarea, s:password 都可以用--&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"name"</span> /&gt;</span> <span class="comment">&lt;!--输出: test --&gt;</span>

<span class="comment">&lt;!-- TestAction{ @Beanproperty aa}
action = new testAction(); action.setAa("test2");
--&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"aa"</span> /&gt;</span> <span class="comment">&lt;!--输出: test2--&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="struts" scheme="http://zhpooer.github.io/tags/struts/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day29-struts拦截器]]></title>
    <link href="http://zhpooer.github.io/2014/05/14/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day29-struts%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://zhpooer.github.io/2014/05/14/传智播客day29-struts拦截器/</id>
    <published>2014-05-14T03:09:51.000Z</published>
    <updated>2014-05-28T07:15:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="struts-">Struts的工作原理及核心过滤器</h1>
<p>StrutsPrepareAndExecuteFilter过滤器其实是包含2部分的</p>
<ol>
<li>StrutsPrepareFilter:做准备</li>
<li>StrutsExecuteFilter：进入Struts2的核心处理。
如果是Struts2的请求就会进入该过滤器，处理完后，不放行（由结果类负责显示）。
如果是非Struts2的请求，比如默认jsp的请求，直接放行。</li>
</ol>
<p>如果用不到其他过滤器，配置StrutsPrepareAndExecuteFilter即可;
如果用到其他过滤器，还需要使用Struts2准备好的环境，
使用<code>StrutsPrepareFilter</code>，<code>StrutsExecuteFilter</code>个过滤器，其他过滤器放在两者之间.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> struts-prepare <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/* <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>sitemesh <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/* <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> struts-execute <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/* <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<p><img src="/img/struts_core.png" alt="struts core">
showcase: 各种应用的案例，在struts2-showcase里面找各种案例</p>
<h1 id="-">拦截器</h1>
<p>拦截器的使用 ，源自Spring AOP(面向切面编程)思想, 采用 责任链 模式</p>
<ul>
<li>在责任链模式里,很多对象由每一个对象对其下家的引用而连接起来形成一条链。</li>
<li>责任链每一个节点，都可以继续调用下一个节点，也可以阻止流程继续执行</li>
</ul>
<p>拦截器的目的: 如果一个业务逻辑方法中涉及到的逻辑相当复杂,
可以把这些业务分离开, 如 启动日志, 权限检查, 文件上传, 保存用户,
把这四方面全面分开, 实现松耦合</p>
<p>常用struts2 拦截器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 模型驱动 --&gt;</span>
<span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"modelDriven"</span>/&gt;</span>
<span class="comment">&lt;!-- 文件上传 --&gt;</span>
<span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"fileUpload"</span>/&gt;</span>
<span class="comment">&lt;!-- 参数解析封装 --&gt;</span>
<span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"params"</span>&gt;</span>
<span class="comment">&lt;!-- 类型转换错误 --&gt;</span>
<span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"conversionError"</span>/&gt;</span>
<span class="comment">&lt;!-- 请求参数校验 --&gt;</span>
<span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"validation"</span>&gt;</span>
<span class="comment">&lt;!-- 拦截跳转 input 视图 --&gt;</span>
<span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"workflow"</span>&gt;</span>
</pre></td></tr></table></figure>

<p>意义: 把一些和业务逻辑没有关联的代码放入拦截器, 以实现业务逻辑和其他代码的松耦合</p>
<h2 id="-">拦截器初探</h2>
<p>所有实际开发中，自定义拦截器 只需要 继承 AbstractInterceptor类，
提供 intercept 方法实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorAction</span> <span class="title">extend</span> <span class="title">ActionSupport</span> {</span>
    <span class="keyword">public</span> String <span class="title">saveUser</span>() {
        ActionContext().getContext().put(<span class="string">"message"</span>, <span class="string">"userSaved"</span>);
        <span class="keyword">return</span> <span class="string">"privilege"</span>
    }
}
<span class="comment">// 拦截器</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(){}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(){}
    <span class="keyword">public</span> String <span class="title">intercept</span>(ActionInvocation action) {
         String username = ServletActionContext.getRequest().getParameter(<span class="string">"username"</span>)
         <span class="keyword">if</span>(<span class="string">"admin"</span>.equals(username)) {
             <span class="keyword">return</span> action.invoke();
         } <span class="keyword">else</span> {
             ActionContext().getContext().put(<span class="string">"message"</span>, <span class="string">"权限不足"</span>);
             <span class="keyword">return</span> <span class="string">"privilege"</span>
         }
    }
}
</pre></td></tr></table></figure>

<p>声明拦截器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"privilege"</span> <span class="attribute">class</span>=<span class="value">"cn..**"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="comment">&lt;!-- 声明一个拦截器栈 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"privilegeStack"</span>&gt;</span>
            <span class="comment">&lt;!-- 引用默认拦截器栈 --&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="comment">&lt;!-- 引用自己的连接器 --&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"privilege"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="comment">&lt;!-- 让struts 执行声明的拦截器栈, 和拦截器 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"privilegeStack"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">概念</h2>
<ol>
<li>拦截器, 实现 Interceptor 接口的一个类</li>
<li>拦截器栈, 把很多个拦截器集中在一起</li>
<li>struts有一个默认拦截器栈, 该栈在 <code>struts-default.xml</code> 中声明, 结构为: <figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="comment">&lt;!-- 声明拦截器 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"name1"</span> <span class="attribute">class</span>=<span class="value">""</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"name2"</span> <span class="attribute">class</span>=<span class="value">""</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="comment">&lt;!-- 声明拦截器栈 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span>
            <span class="comment">&lt;!-- 引用拦截器栈 --&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"name1"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"name2"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="comment">&lt;!-- 让struts 内部执行默认的拦截器栈, 和拦截器 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="-">拦截器执行</h2>
<p>执行顺序: 按照拦截器的声明顺序, 从上到下执行, 执行完拦截器以后, 再执行 <code>Action</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"privilegeStack"</span>&gt;</span>
<span class="comment">&lt;!-- 从上到下执行 --&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"privilege"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
</pre></td></tr></table></figure>

<p>一个 pacakge 中可以有</p>
<ol>
<li>结果集</li>
<li>拦截器</li>
<li>action</li>
</ol>
<p>可以通过继承package, 来复用 <code>interceptor</code> 配置信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 声明intercept包,在内部使用公用拦截器 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"intercept"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span> <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="comment">&lt;!-- 复用intercept拦截--&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">extends</span>=<span class="value">"intercept"</span>&gt;</span> <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span> <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">案例: 执行效率统计拦截器</h2>
<p>建立拦截器ElapsedTimeInterceprot实现Interceptor接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">//动作方法及结果处理耗时统计拦截器</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElapsedTimeInterceprot</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> {</span>
    <span class="keyword">public</span> String <span class="title">intercept</span>(ActionInvocation invocation) <span class="keyword">throws</span> Exception {
        <span class="keyword">long</span> beginTime = System.nanoTime();<span class="comment">//纳秒：1毫秒=1000000纳秒</span>
        String result = invocation.invoke();<span class="comment">//放行：拦截前要做的事放在invocation.invoke()之前，拦截后放在之后</span>
        <span class="comment">// 可以获得Action对象</span>
        ActionSupport as =  actioninvocation.getAction();
        as.addFieldError(<span class="string">"some wrong"</span>);
        <span class="comment">//结果处理完毕后执行</span>
        <span class="keyword">long</span> endTime = System.nanoTime();
        System.out.println(invocation.getInvocationContext().getName()+<span class="string">"动作执行耗时："</span>+(endTime-beginTime)+<span class="string">"纳秒"</span>);
        <span class="keyword">return</span> result;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>() {}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>() {}
}
</pre></td></tr></table></figure>

<p>进行配置文件设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.ElapsedTimeInterceprot"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"test1"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.HelloAction1"</span> <span class="attribute">method</span>=<span class="value">"test1"</span>&gt;</span>
        <span class="comment">&lt;!-- 需要获取request，所以必须先执行servletConfig拦截器 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="comment">&lt;!-- 执行耗时统计拦截器 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>/1.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<p>拦截器的扩展，定义拦截器小组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.ElapsedTimeInterceprot"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="comment">&lt;!-- 自己定义一个拦截器小组 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"test1"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.HelloAction1"</span> <span class="attribute">method</span>=<span class="value">"test1"</span>&gt;</span>
        <span class="comment">&lt;!-- 执行自定义的拦截器小组 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>/1.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<p>继续扩展配置设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"mypackage"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span> <span class="attribute">abstract</span>=<span class="value">"true"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.ElapsedTimeInterceprot"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"sessionCheck"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.SessionCheckInterceptors"</span>&gt;</span>
            <span class="comment">&lt;!-- 说明test2动作方法不需要拦截 --&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeMethods"</span>&gt;</span>user<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"sessionCheck"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="comment">&lt;!-- 设置该包中的所有action配置默认拦截器 ，每个包只能指定一个默认拦截器 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">default-interceptor-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">案例: 用户登陆拦截器</h2>
<p>是否登陆拦截器MethodFilterInterceptor(可以配置是否进行拦截excludeMethods属性,如上)</p>
<p>权限判断拦截器继承MethodFilterInterceptor类，这样只对某些方法起作用，而对其他方法不起作用。 (配置文件如上)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">//执行动作方法前检查用户是否已经登录</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionCheckInterceptors</span> <span class="keyword">extends</span> <span class="title">MethodFilterInterceptor</span>{</span>
    <span class="keyword">protected</span> String <span class="title">doIntercept</span>(ActionInvocation invocation) <span class="keyword">throws</span> Exception {
        String result = <span class="string">"login"</span>;<span class="comment">//对应的就是一个结果</span>
        HttpSession session = ServletActionContext.getRequest().getSession();
        User user = (User)session.getAttribute(<span class="string">"user"</span>);
        <span class="keyword">if</span>(user!=<span class="keyword">null</span>)
            <span class="comment">//如果用户有登录，则放行。</span>
            result = invocation.invoke();
        <span class="comment">//如果用户没有登录，则返回结果集。</span>
        <span class="keyword">return</span> result;
    }
}
</pre></td></tr></table></figure>

<p>配置文件需要在结果集中增加一个:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"login"</span>&gt;/login.jsp&lt;/<span class="constant">result</span>&gt;
</pre></td></tr></table></figure>

<h1 id="-">过滤器 和 拦截器</h1>
<p>使用Filter 进行权限控制, 过滤所有web请求(所有web资源访问)</p>
<p>使用拦截器 进行权限控制 ---- 主要拦截对Action访问(不能拦截JSP)</p>
<h1 id="tip">Tip</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">this</span>.addActionError(<span class="string">""</span>);  <span class="comment">// 业务逻辑错误</span>
<span class="keyword">this</span>.addFieldError(<span class="string">""</span>);   <span class="comment">// 验证错误</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="struts" scheme="http://zhpooer.github.io/tags/struts/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day29-struts请求数据处理]]></title>
    <link href="http://zhpooer.github.io/2014/05/14/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day29-struts%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://zhpooer.github.io/2014/05/14/传智播客day29-struts请求数据处理/</id>
    <published>2014-05-14T01:01:10.000Z</published>
    <updated>2014-05-25T13:46:21.000Z</updated>
    <content type="html"><![CDATA[<p>实际场景： 表现层，获得请求参数，将请求参数封装到JavaBean对象，
传递JavaBean对象 给业务层</p>
<h1 id="action-">Action 如何接受请求参数</h1>
<p>struts2 和 MVC 定义关系</p>
<ul>
<li>StrutsPrepareAndExecuteFilter : 控制器</li>
<li>JSP : 视图</li>
<li>Action : 可以作为模型，也可以是控制器 </li>
</ul>
<h2 id="-">属性驱动一</h2>
<p>Action 本身作为model对象，通过成员setter封装</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// 用户名  &lt;input type="text" name="username" /&gt; &lt;br/&gt;</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistAction1</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
	<span class="keyword">private</span> String username;
	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span>(String username) {
		<span class="keyword">this</span>.username = username;
	}
}
</pre></td></tr></table></figure>

<p>问题一： Action封装数据，会不会有线程问题 ？ </p>
<ul>
<li>struts2 Action 是多实例 ，为了在Action封装数据(struts1 Action 是单例的)</li>
</ul>
<p>问题二：在使用第一种数据封装方式，数据封装到Action属性中，不可能将Action对象传递给 业务层</p>
<ul>
<li>需要再定义单独JavaBean ，将Action属性封装到 JavaBean </li>
</ul>
<h2 id="-">属性驱动二</h2>
<p>创建独立model对象，页面通过ognl表达式封装</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">//	用户名  &lt;input type="text" name="user.username" /&gt; &lt;br/&gt; </span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistAction2</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
    <span class="keyword">private</span> User user;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span>(User user) {
	    <span class="keyword">this</span>.user = user;
	}
	<span class="keyword">public</span> User <span class="title">getUser</span>() {
	    <span class="keyword">return</span> user;
	}
}
</pre></td></tr></table></figure>

<p>问题： 谁来完成的参数封装 
<code>&lt;interceptor name=&quot;params&quot; class=&quot;com.opensymphony.xwork2.interceptor.ParametersInterceptor&quot;/&gt;</code></p>
<h2 id="-">模型驱动</h2>
<p>使用ModelDriven接口，对请求数据进行封装(主流)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// 用户名  &lt;input type="text" name="username" /&gt; </span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistAction3</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; {</span>
	<span class="keyword">private</span> User user = <span class="keyword">new</span> User(); <span class="comment">// 必须手动实例化</span>
	<span class="keyword">public</span> User getModel() {
		<span class="keyword">return</span> user;
	}
}
</pre></td></tr></table></figure>

<p>struts2 有很多围绕模型驱动的特性, 为模型驱动提供了更多特性
<code>&lt;interceptor name=&quot;modelDriven&quot; class=&quot;com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor&quot;/&gt;</code></p>
<p>模型驱动只能在Action中指定一个model对象，属性驱动二可以在Action中定义多个model对象 </p>
<h1 id="-">封装复杂类型参数</h1>
<h2 id="collection-">Collection 对象</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre> <span class="comment">// &lt;input type="text" name="products[0].name" /&gt;&lt;br/&gt;</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
	<span class="keyword">private</span> List&lt;Product&gt; products;
	<span class="keyword">public</span> List&lt;Product&gt; <span class="title">getProducts</span>() {
		<span class="keyword">return</span> products;
	}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducts</span>(List&lt;Product&gt; products) {
		<span class="keyword">this</span>.products = products;
	}
}
</pre></td></tr></table></figure>

<h2 id="map-">Map 对象</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// &lt;input type="text" name="map['one'].name" /&gt;&lt;br/&gt;  =======  one是map的键值</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAction2</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
	<span class="keyword">private</span> Map&lt;String, Product&gt; map;
    <span class="keyword">public</span> Map&lt;String, Product&gt; <span class="title">getMap</span>() {
		<span class="keyword">return</span> map;
	}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMap</span>(Map&lt;String, Product&gt; map) {
		<span class="keyword">this</span>.map = map;
	}
}
</pre></td></tr></table></figure>

<h1 id="-">类型转换</h1>
<p>struts2 内部提供大量类型转换器，用来完成数据类型转换问题</p>
<ul>
<li>boolean 和 Boolean</li>
<li>char和 Character</li>
<li>int 和 Integer</li>
<li>long 和 Long</li>
<li>float 和 Float</li>
<li>double 和 Double</li>
<li>Date 可以接收 yyyy-MM-dd格式字符串</li>
<li>数组  可以将多个同名参数，转换到数组中</li>
<li>集合  支持将数据保存到 List 或者 Map 集合</li>
</ul>
<h2 id="-">自定义转换器</h2>
<ol>
<li>实现TypeConverter接口
<code>convertValue(java.util.Map&lt;java.lang.String,java.lang.Object&gt; context, java.lang.Object target, java.lang.reflect.Member member, java.lang.String propertyName, java.lang.Object value, java.lang.Class toType)</code></li>
<li>继承 DefaultTypeConverter
<code>convertValue(java.util.Map&lt;java.lang.String,java.lang.Object&gt; context, java.lang.Object value, java.lang.Class toType)</code></li>
<li>继承 StrutsTypeConverter
<code>convertFromString(java.util.Map context, java.lang.String[] values, java.lang.Class toClass)</code>
<code>convertToString(java.util.Map context, java.lang.Object o)</code></li>
</ol>
<p>当数据类型及数据转换出现错误信息时, 框架自动会转向名称为input的结果集</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 输入 myname, mypassword --&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"user"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
<span class="tag">&lt;<span class="title">s:checkbox</span> <span class="attribute">list</span>=<span class="value">"{'aa', 'bb'}"</span> <span class="attribute">name</span>=<span class="value">"checkbox"</span>/&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> UserConverter extends StrutsTypeConverter {
    <span class="comment">// 从页面到Actioin的转换</span>
    <span class="keyword">public</span> Object <span class="title">convertFromString</span>(Map context, String[] values, Class clazz) {
        String[] tmp = values[<span class="number">0</span>].split(<span class="string">","</span>);
        User user = <span class="keyword">new</span> User();
        user.setUsername(tmp[<span class="number">0</span>]);
        user.setPassword(tmp[<span class="number">1</span>]);
        <span class="keyword">return</span> user;
    }
    <span class="keyword">public</span> String <span class="title">convertToString</span>(Map context, Object o) {
        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User){
            <span class="keyword">return</span> o.toString();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterAction</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> User user;
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String userName;
    <span class="annotation">@BeanProperty</span> pirvate String password;
}
</pre></td></tr></table></figure>

<p>局部类型转换器：要转换的属性所在的类相同的包下, 建立类名-conversion.properties的配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">## 转换的字段名称=验证类全名</span>
birthday=
</pre></td></tr></table></figure>

<p>全局类型转换器设置: 在根目录下建立 xwork-conversion.preperties</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">## 转换后的类型=转换器</span>
User=UserConverter
</pre></td></tr></table></figure>

<h2 id="-">类型转换中错误处理</h2>
<p>通过分析拦截器作用，得知当类型转换出错时，
自动跳转input视图 ，在input视图页面中 <code>&lt;s:fieldError/&gt;</code> 显示错误信息</p>
<p>在Action所在包中，创建 ActionName.properties，
在局部资源文件中配置提示信息 ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">invalid.fieldvalue.属性名 </span>=<span class="string"> 错误信息</span>
</pre></td></tr></table></figure>

<h1 id="-">请求数据有效性校验</h1>
<ol>
<li>客户端数据校验: 通过JavaScript 完成校验()改善用户体验，使用户减少出错)</li>
<li>服务器数据校验, 使用框架内置校验功能(struts2 内置校验功能)</li>
</ol>
<h2 id="-">代码校验</h2>
<p>在服务器端通过编写java代码，完成数据校验</p>
<p>前提：动作类一般要求继承<code>ActionSupport</code></p>
<p>struts.xml配置文件中,对要验证的动作,需要提供name=&quot;input&quot;的结果视图(回显)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"RegUser"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"RegUser"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span>/WEB-INF/pages/main.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span> <span class="attribute">name</span>=<span class="value">"error"</span>&gt;</span>/WEB-INF/pages/commons/error.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="comment">&lt;!-- 出现错误时转向的页面：回显 --&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"input"</span>&gt;</span>/WEB-INF/pages/regist.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<p>针对所有动作进行验证：需要覆盖 <code>public void validate()</code>方法，
方法内部如果不满足要求，调用addFieldError填充信息.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="annotation">@SkipValidation</span><span class="comment">//用在不需要验证的动作方法上</span>
<span class="keyword">public</span> String <span class="title">RegUserUI</span>() {
    <span class="keyword">return</span> SUCCESS;
}
 <span class="comment">//对所有的动作方法进行校验</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span>(){
<span class="comment">//写你的校验代码ActionSupport里面有addFieldError()方法,把错误信息存起来.</span>
    <span class="keyword">if</span>(StringUtils.isEmpty(user.getUsername())){
        addFieldError(<span class="string">"username"</span>, <span class="string">"请输入用户名"</span>);<span class="comment">//向一个Map中存储错误消息。何时返回input视图，是由该Map中有无信息决定的。</span>
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">//针对某个动作方法进行校验 public String regUser(){}</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRegUser</span>() {
    <span class="comment">// 写你的校验代码</span>
    <span class="keyword">if</span> (user.getUsername() == <span class="keyword">null</span> || user.getUsername().equals(<span class="string">""</span>)) {
        addFieldError(<span class="string">"username"</span>, <span class="string">"请输入用户名"</span>);
    }
}
</pre></td></tr></table></figure>

<h2 id="-">配置校验</h2>
<p>XML配置校验(主流) 和 注解配置校验</p>
<p>开发的时候，可以不写验证，后续增加声明式验证，写配置文件即可，编码式验证需要开始就要写</p>
<p>struts2中已经内置一些验证器 <code>com.opensymphony.xwork2.validator.validators.default.xml</code></p>
<ul>
<li>required (必填校验器,要求被校验的属性值不能为null)</li>
<li>requiredstring (必填字符串校验器,要求被校验的属性值不能为null，并且长度大于0,默认情况下会对字符串去前后空格)</li>
<li>stringlength (字符串长度校验器，要求被校验的属性值必须在指定的范围内，否则校验失败,minLength参数指定最小长度，maxLength参数指定最大长度，trim参数指定校验field之前是否去除字符串前后的空格)</li>
<li>regex (正则表达式校验器，检查被校验的属性值是否匹配一个正则表达式，expression参数指定正则表达式，caseSensitive参数指定进行正则表达式匹配时，是否区分大小写,默认值为true)</li>
<li>int(整数校验器，要求field的整数值必须在指定范围内，min指定最小值，max指定最大值)</li>
<li>double(双精度浮点数校验器,要求field的双精度浮点数必须在指定范围内,min指定最小值,max指定最大值)</li>
<li>fieldexpression (字段OGNL表达式校验器,要求field满足一个ognl表达式，expression参数指定ognl表达式,该逻辑表达式基于ValueStack进行求值,返回true时校验通过，否则不通过)</li>
<li>email(邮件地址校验器，要求如果被校验的属性值非空，则必须是合法的邮件地址)</li>
<li>url(网址校验器,要求如果被校验的属性值非空,则必须是合法的url地址)</li>
<li>date(日期校验器,要求field的日期值必须在指定范围内,min指定最小值,max指定最大值)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 打开xwork-core-2.*.jar包中的xwork-validator-1.*.dtd文件,复制表头 --&gt;</span>
<span class="doctype">&lt;!DOCTYPE validators PUBLIC 
          "-//Apache Struts//XWork Validator 1.0//EN"
          "http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd"&gt;</span>
</pre></td></tr></table></figure>

<p>如何使用内置验证器：</p>
<ol>
<li>对所有的动作方法都进行验证：在动作类相同的包中, 添加 <code>动作类名-validation.xml</code>使用。</li>
<li>针对某些动作进行验证：动作类名-动作别名-validation.xml(动作别名指Struts.xml中的action的name))</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE validators PUBLIC 
          "-//Apache Struts//XWork Validator 1.0//EN"
          "http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">validators</span>&gt;</span>
    <span class="comment">&lt;!-- 针对字段的验证：方式一（建议使用）.在一个字段上加上多个验证规则--&gt;</span>
    <span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"username"</span> &gt;</span>
    <span class="comment">&lt;!-- 不能为null或者""字符串, 默认会 trim --&gt;</span>
        <span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"requiredstring"</span>&gt;</span> 
            <span class="tag">&lt;<span class="title">message</span>&gt;</span>用户名是必须的<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">field</span>&gt;</span>
     <span class="comment">&lt;!-- 针对字段的验证：方式二 --&gt;</span>
     <span class="tag">&lt;<span class="title">validator</span> <span class="attribute">type</span>=<span class="value">"requiredstring"</span>&gt;</span>
     <span class="comment">&lt;!-- 校验器中有trim方法,当把这个方法设置为false,那么用户名前后可以有空格 --&gt;</span>
         <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"trim"</span>&gt;</span>false<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
         <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fieldName"</span>&gt;</span>username<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
         <span class="tag">&lt;<span class="title">message</span>&gt;</span>必须的用户名<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">validator</span>&gt;</span>
<span class="tag">&lt;/<span class="title">validators</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="code"><pre><span class="comment">&lt;!-- required  必填校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"required"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">message</span>&gt;</span>性别不能为空!<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- requiredstring  必填字符串校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"requiredstring"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"trim"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
       <span class="tag">&lt;<span class="title">message</span>&gt;</span>用户名不能为空!<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- stringlength：字符串长度校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"stringlength"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"maxLength"</span>&gt;</span>10<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"minLength"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"trim"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
	<span class="tag">&lt;<span class="title">message</span>&gt;</span><span class="cdata">&lt;![CDATA[产品名称应在2-10个字符之间]]&gt;</span><span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- int：整数校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"int"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"min"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"max"</span>&gt;</span>150<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
	<span class="tag">&lt;<span class="title">message</span>&gt;</span>年龄必须在1-150之间<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- date: 日期校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"date"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"min"</span>&gt;</span>1900-01-01<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
	<span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"max"</span>&gt;</span>2050-02-21<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
	<span class="tag">&lt;<span class="title">message</span>&gt;</span>生日必须在${min}到${max}之间<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- url:  网络路径校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"url"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">message</span>&gt;</span>传智播客的主页地址必须是一个有效网址<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- email：邮件地址校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"email"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">message</span>&gt;</span>电子邮件地址无效<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- regex：正则表达式校验器 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"regex"</span>&gt;</span>
     <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"expression"</span>&gt;</span><span class="cdata">&lt;![CDATA[^13\d{9}$]]&gt;</span><span class="tag">&lt;/<span class="title">param</span>&gt;</span>
     <span class="tag">&lt;<span class="title">message</span>&gt;</span>手机号格式不正确!<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>

<span class="comment">&lt;!-- fieldexpression : 字段表达式校验 --&gt;</span>
<span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"fieldexpression"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"expression"</span>&gt;</span><span class="cdata">&lt;![CDATA[(password==repassword)]]&gt;</span><span class="tag">&lt;/<span class="title">param</span>&gt;</span>
       <span class="tag">&lt;<span class="title">message</span>&gt;</span>两次密码输入不一致<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">编写一个自定义校验器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongpasswordFieldValidate</span> <span class="keyword">extends</span> <span class="title">FieldValidatorSupport</span> {</span>
    <span class="comment">//object就是当前执行的动作类的实例</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span>(Object object) <span class="keyword">throws</span> ValidationException {
        String fieldName = getFieldName();
        Object value = getFieldValue(fieldName, object);
        <span class="comment">//验证</span>
        <span class="keyword">if</span>(!(value <span class="keyword">instanceof</span> String)){
            addFieldError(fieldName, object);
        }<span class="keyword">else</span>{
            String s = (String)value;
            <span class="keyword">if</span>(!isStrong(s)){
                addFieldError(fieldName, object);
            }
        }
    }
    <span class="comment">//判断s是否强大</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP1 = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP2 = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP3 = <span class="string">"0123456789"</span>;
    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isStrong</span>(String s) {
        <span class="keyword">boolean</span> ok1 = <span class="keyword">false</span>;
        <span class="keyword">boolean</span> ok2 = <span class="keyword">false</span>;
        <span class="keyword">boolean</span> ok3 = <span class="keyword">false</span>;
        <span class="keyword">int</span> length = s.length();
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(ok1&&ok2&&ok3)
                <span class="keyword">break</span>;
            String character = s.substring(i,i+<span class="number">1</span>);
            <span class="keyword">if</span>(GROUP1.contains(character)){
                ok1 = <span class="keyword">true</span>;
                <span class="keyword">continue</span>;
            }
            <span class="keyword">if</span>(GROUP2.contains(character)){
                ok2 = <span class="keyword">true</span>;
                <span class="keyword">continue</span>;
            }
            <span class="keyword">if</span>(GROUP3.contains(character)){
                ok3 = <span class="keyword">true</span>;
                <span class="keyword">continue</span>;
            }
        }
        <span class="keyword">return</span> ok1&&ok2&&ok3;
    }
}
</pre></td></tr></table></figure>

<p>对自定义的校验器进行配置(validators.xml)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE validators PUBLIC
          "-//Apache Struts//XWork Validator Definition 1.0//EN"
          "http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">validators</span>&gt;</span>
    <span class="tag">&lt;<span class="title">validator</span> <span class="attribute">name</span>=<span class="value">"strongpassword"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.validators.StrongpasswordFieldValidate"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">validators</span>&gt;</span>
</pre></td></tr></table></figure>

<p>使用自定义的校验器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"strongpassword"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">message</span>&gt;</span>密码不够强壮<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">国际化信息显示</h1>
<p>国际化原理同一款软件 可以为不同用户，提供不同语言界面</p>
<p>需要一个语言资源包(很多properties文件，每个properties文件 针对一个国家或者语言 ，通过java程序根据来访者国家语言，自动读取不同properties文件)</p>
<h2 id="-">资源包编写</h2>
<p>properties文件命名: 基本名称<em>语言（小写）</em>国家（大写）.properties</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>// messages_zh_CN<span class="preprocessor">.properties</span> 中国中文
// messages_en_US<span class="preprocessor">.properties</span> 美国英文
ResourceBundle bundle = ResourceBundle<span class="preprocessor">.getBundle</span>(<span class="string">"messages"</span>, Locale<span class="preprocessor">.US</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="struts2-">struts2 框架国际化配置</h2>
<h3 id="-">全局国际化信息文件</h3>
<p>所有Action都可以使用, 最常用</p>
<ul>
<li>properties文件可以在任何包中</li>
<li>需要在struts.xml 中配置全局信息文件位置</li>
</ul>
<p>struts.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- messages.properties 在src根目录 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.custom.i18n.resources"</span> <span class="attribute">value</span>=<span class="value">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- messages.properties 在 cn.itcast.resources 包 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.custom.i18n.resources"</span> <span class="attribute">value</span>=<span class="value">"cn.itcast.resources.messages"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
</pre></td></tr></table></figure>

<p>国际化信息</p>
<pre><code>* 在Action中使用: `this.getText(&quot;msg&quot;);`
* 在jsp中使用: `&lt;s:text name=&quot;msg&quot; /&gt;`
* 在配置文件中(校验xml): `&lt;message key=&quot;agemsg&quot;&gt;&lt;/message&gt;`
</code></pre><h3 id="action-">Action范围信息文件</h3>
<p>只能在某个Action中使用
无需配置, 数据只能在对应Action中使用，在Action类所在包 创建 Action类名.properties</p>
<h3 id="package-">package范围信息文件</h3>
<p>package中所有Action都可以使用</p>
<p>无需配置, 数据对包(包括子包)中的所有Action 都有效 ， 在包中创建 package.properties</p>
<h3 id="-">临时信息文件</h3>
<p>主要在jsp中 引入国际化信息</p>
<p>在jsp指定读取 哪个properties文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">s:i18n</span> <span class="attribute">name</span>=<span class="value">"cn.itcast.struts2.demo7.package"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:text</span> <span class="attribute">name</span>=<span class="value">"customer"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:text</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:i18n</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">动态消息文本</h3>
<p>向信息中传递参数 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// MessageFormat 动态消息文本, required = {0} 错了</span>
<span class="keyword">this</span>.getText(<span class="string">"required"</span>, <span class="keyword">new</span> <span class="built_in">String</span>[] { <span class="string">"用户名"</span> });
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="struts" scheme="http://zhpooer.github.io/tags/struts/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day28-struts入门]]></title>
    <link href="http://zhpooer.github.io/2014/05/12/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day28-struts%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/05/12/传智播客day28-struts入门/</id>
    <published>2014-05-12T01:14:18.000Z</published>
    <updated>2014-05-25T08:46:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">框架概述</h1>
<p>三大框架: 企业主流 JavaEE 开发的一套架构 Struts + Spring + Hibernate</p>
<p>框架是实现了部分功能的代码(半成品), 使用框架简化企业级软件开发</p>
<p>学习框架, 清楚知道框架能做什么, 还有哪些工作需要自己编码实现</p>
<h2 id="struts2">Struts2</h2>
<p>Struts2 是Web层开发框架, 是优秀的MVC框架</p>
<ul>
<li>struts1 、webwork 、jsf 、SpringMVC 都是MVC </li>
</ul>
<p>MVC: 是一种思想, 是一种模式, 分为 Model模型, View视图, Controller控制器</p>
<ul>
<li>MVC由来是Web开发</li>
</ul>
<p>JavaEE软件三层结构: Web层(表现层), 业务逻辑层, 数据持久层 (sun提供JavaEE开发规范)
JavaEE开发强调三层结构, Web层开发注重MVC</p>
<p>由传统 Struts1 和 WebWork 两个经典框架发展而来</p>
<ul>
<li>Struts2 内核 webwork</li>
<li>Xwork提供了很多核心功能：前端拦截机（interceptor），运行时表单属性验证，类型转换，
强大的表达式语言（OGNL – the Object Graph Navigation Language），IoC（Inversion of Control反转控制）容器等</li>
</ul>
<p>Struts2 和 Struts1 关系: 
没有关系， Struts2 全新框架，引入WebWork很多技术和思想，
Struts2 保留Struts1 类似开发流程</p>
<h2 id="-">核心功能</h2>
<ul>
<li>允许POJO（Plain Old Java Objects）对象 作为Action</li>
<li>Action的execute 方法不再与Servlet API耦合，更易测试</li>
<li>支持更多视图技术（JSP、FreeMarker、Velocity）</li>
<li>基于Spring AOP思想的拦截器机制，更易扩展</li>
<li>更强大、更易用输入校验功能</li>
<li>整合Ajax支持</li>
</ul>
<h1 id="strut2-">strut2 快速入门</h1>
<p>Web层框架都会使用前端控制器模式(JavaEE模式)</p>
<ul>
<li>javaWeb 编写的程序, 一次请求对应一个servlet, 此时servlet完成请求处理</li>
<li>使用框架, 所有访问通过 前端控制器, 前端控制器已经实现了部分代码功能(通用代码),
再交给不同 Action 来处理(请求分发), 一次请求, 对应一个Action</li>
</ul>
<p>Struts2 前端控制器: <code>ServletPrepareAndExecuteFilter</code></p>
<ol>
<li><p>编写请求页面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"${contextPath}/hello.action"</span>&gt;</span>访问Strut2<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>web.xml 配置 struts2 前端控制器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>&lt;<span class="built_in">filter</span>&gt;
    &lt;<span class="built_in">filter</span>-name&gt; struts2 &lt;/<span class="built_in">filter</span>-name&gt;
    &lt;<span class="built_in">filter</span>-<span class="keyword">class</span>&gt; org.apache.struts2.dispatcher.ng.<span class="built_in">filter</span>.StrutsPrepareAndExecuteFilter &lt;/<span class="built_in">filter</span>-<span class="keyword">class</span>&gt;
&lt;/<span class="built_in">filter</span>&gt;
&lt;<span class="built_in">filter</span>-mapping&gt;
    &lt;<span class="built_in">filter</span>-name&gt; struts2 &lt;/<span class="built_in">filter</span>-name&gt;
    &lt;url-pattern&gt; /* &lt;/url-pattern&gt;
&lt;/<span class="built_in">filter</span>-mapping&gt;
</pre></td></tr></table></figure>
</li>
<li><p>执行过滤器后, 读取struts配置文件, 将请求分发, 在根目录下创建struts.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"default"</span> <span class="attribute">namespate</span>=<span class="value">"/"</span> <span class="attribute">extends</span>=<span class="value">"struts-defautl"</span>&gt;</span>
   <span class="comment">&lt;!-- 将请求分发 给一个Action  --&gt;</span>
   <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"hello"</span> <span class="attribute">class</span>=<span class="value">"io.zhpooer.HelloAction"</span>&gt;</span>
       <span class="comment">&lt;!-- 将返回字符串与跳转页面绑定  --&gt;</span>
       <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span>
       <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
   <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>HelloAction</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// struts2 处理请求的Action</span>
<span class="keyword">public</span> <span class="keyword">class</span> HelloAction{
    <span class="comment">// 编写 excute 方法, String 类型返回值, 无参数</span>
    <span class="keyword">public</span> String <span class="title">excute</span>(){
        <span class="comment">// 返回字符串来控制页面跳转</span>
        <span class="keyword">return</span> <span class="string">"success"</span>;
    }
}
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="-">运行流程图</h2>
<p>![/img/struts_core.png]
用户请求 -&gt; StrutsPrepareAndExecuteFilter 核心控制器 -&gt;
 Interceptors 拦截器(实现代码功能) -&gt; Action 的execuute -&gt; 结果页面 Result</p>
<ul>
<li>拦截器 在 struts-default.xml 定义</li>
<li>执行拦截器 是 defaultStack 中引用拦截器 </li>
</ul>
<h1 id="struts2-">struts2 常见配置</h1>
<h2 id="-">配置文件的加载顺序</h2>
<p>由核心控制器加载 StrutsPrepareAndExecuteFilter  (预处理，执行过滤) </p>
<ol>
<li>default.properties 该文件保存在 struts2-core-2.3.7.jar 中 org.apache.struts2包里面 (常量的默认值)</li>
<li>struts-default.xml 该文件保存在 struts2-core-2.3.7.jar(Bean、拦截器、结果类型)</li>
<li>struts-plugin.xml 该文件保存在struts-Xxx-2.3.7.jar(在插件包中存在 ，配置插件信息)</li>
<li>struts.xml 该文件是web应用默认的struts配置文件(实际开发中，通常写struts.xml)</li>
<li>struts.properties 该文件是Struts的默认配置文件  (配置常量)</li>
<li>web.xml 该文件是Web应用的配置文件 (配置常量)</li>
</ol>
<p>后加载的文件会覆盖之前加载的文件常量内容</p>
<h2 id="action-">Action配置</h2>
<h3 id="package-">package标签</h3>
<p>必须要为<code>&lt;action&gt;</code>元素 配置<code>&lt;package&gt;</code>元素  (struts2 围绕package进行Action的相关配置)</p>
<p>必须直接或间接地继承自struts-default的包.</p>
<p>作用: 方便管理我们的动作(struts-default是核心配置文件)</p>
<p>属性：</p>
<ul>
<li>abstract：可选值为true|false。说明他是一个抽象包。抽象包中没有action元素的。(默认为false)</li>
<li>name：包名。不能重复。方便管理动作的。</li>
<li>namespace：名称空间</li>
<li>extends：继承什么</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- name 包名称，在struts2的配置文件文件中 包名不能重复 ，name并不是真正包名，只是为了管理Action  --&gt;</span>
<span class="comment">&lt;!-- namespace 和 &lt;action&gt;的name属性，决定 Action的访问路径  （以/开始 ） --&gt;</span>
<span class="comment">&lt;!-- extends 继承哪个包，通常开发中继承 struts-default 包 （struts-default包在 struts-default.xml定义 ） --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"default"</span> <span class="attribute">namespace</span>=<span class="value">"/"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span><span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="action-">action标签</h2>
<ul>
<li><p>name: 必须的, 动作名称</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p2"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="comment">&lt;!-- 只要找不到的action的name，找act4。默认动作名称 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-action-ref</span> <span class="attribute">name</span>=<span class="value">"act4"</span>&gt;</span><span class="tag">&lt;/<span class="title">default-action-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>class：可选的. 默认值是com.opensymphony.xwork2.ActionSupport</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p2"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="comment">&lt;!-- 只要找不到的action的class，找com.opensymphony.xwork2.ActionSupport。默认class --&gt;</span>
    <span class="tag">&lt;<span class="title">default-class-ref</span> <span class="attribute">name</span>=<span class="value">"com.opensymphony.xwork2.ActionSupport"</span>&gt;</span><span class="tag">&lt;/<span class="title">default-class-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>method: 可选. 默认值是 <code>public String execute(){return &quot;success&quot;}</code></p>
</li>
</ul>
<h2 id="result-">result标签</h2>
<p>type：默认值dispatcher. 转发，目标JSP</p>
<p>name：默认值是success.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>&lt;package <span class="property">name</span>=<span class="string">"default"</span> namespace=<span class="string">"/test"</span> extends=<span class="string">"struts-default"</span>&gt;
    &lt;action <span class="property">name</span>=<span class="string">"hello"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.HelloAction"</span> method=<span class="string">"execute"</span>&gt;
        &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"female"</span>&gt;/female.jsp&lt;/<span class="constant">result</span>&gt;
        &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"male"</span>&gt;/male.jsp&lt;/<span class="constant">result</span>&gt;
    &lt;/action&gt;
&lt;/package&gt;
</pre></td></tr></table></figure>

<p>访问包中带有名称空间的动作时：
<code>http://localhost:8080/day22_01_strutsHello/test/hello.action</code>
<code>http://localhost:8080/day22_01_strutsHello/test/aaa/bbb/hello.action</code></p>
<p>动作有搜索顺寻：</p>
<ol>
<li>从/test/aaa/bbb找，不存在</li>
<li>从/test/aaa找，不存在</li>
<li>从/test，找到了</li>
<li>一旦找到就不向上找了</li>
</ol>
<h2 id="-action-action-">默认Action 和 Action的默认处理类</h2>
<p>默认Action ， 解决客户端访问Action不存在的问题 ，
客户端访问Action， Action找不到，默认Action 就会执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;<span class="keyword">default</span>-action-<span class="keyword">ref</span> name=<span class="string">"action元素的name"</span> /&gt;
</pre></td></tr></table></figure>

<p>默认处理类 ，客户端访问Action，已经找到匹配<code>&lt;action&gt;</code>元素，
但是<code>&lt;action&gt;</code>元素没有class属性，执行默认处理类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 在struts-default.xml 配置默认处理类 ActionSupport  --&gt;</span>
<span class="tag">&lt;<span class="title">default-class-ref</span> <span class="attribute">class</span>=<span class="value">"完成类名"</span> /&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">常量配置</h2>
<p>在 struts2-core-*.jar 的<code>org.apache.struts2</code>的 default.properties文件中存在一些内置常量</p>
<p>可以在 struts.properties, struts.xml, web.xml </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="comment">&lt;!-- request.setCharacterEncoding(), 针对post请求参数编码有效 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.i18n.encoding"</span> <span class="attribute">value</span>=<span class="value">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 配置需要struts框架处理的uri的扩展名 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.action.extension"</span> <span class="attribute">value</span>=<span class="value">"do,,action"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 开发模式：打印更多的异常信息。配置文件会自动加载 --&gt;</span>
<span class="comment">&lt;!-- devMode模式是开发模式，开启它则默认开启了struts.i18n.reload、struts.configuration.xml.reload --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.devMode"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 静态资源是不是设皇城, 开发阶段, 修改true --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.server.static.browserCache"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 配置不支持动态方法调用 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.enable.DynamicMethodInvocation"</span> <span class="attribute">value</span>=<span class="value">"false"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 让struts重新加载配置文件，但不会导致web应用重新启动。 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.configuration.xml.reload"</span> <span class="attribute">value</span>=<span class="value">"false"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 指定每次请求到达，重新加载资源文件 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.i18n.reload"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
<span class="comment">&lt;!-- 工厂类, 和spring 整合用 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.objectFactory"</span> <span class="attribute">value</span>=<span class="value">"spring"</span>/&gt;</span>
<span class="comment">&lt;!-- 表达式直接访问static静态方法的开关 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.ognl.allowStaticMethodAccess"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 配置全局国际化消息资源包,value写资源包的基名，多个资源包之间用逗号，分隔--&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.custom.i18n.resources"</span> <span class="attribute">value</span>=<span class="value">"com.itheima.resources.msg"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 更改strutsUI标签的显示样式模板，参考struts2-core-*.jar中的template --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.ui.theme"</span> <span class="attribute">value</span>=<span class="value">"xhtml"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 动作名字里面默认是不允许出现/的,以下常量设置可以出现/ --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.enable.SlashesInActionNames"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 动作名字里面默认是不允许出现/的,如果有名称空间,除了以上常量,还需要打开这个开关 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.mapper.alwaysSelectFullNamespace"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="struts2-">struts2 配置文件分离</h2>
<p>通过 <code>&lt;include file=&quot;struts-part1.xml&quot;/&gt;</code> 将struts2 配置文件 拆分 </p>
<h1 id="action-">Action 的访问</h1>
<p>xwork 是一种标准的命令模式(执行<code>exexute()</code>)</p>
<ol>
<li>Action可以是 POJO (PlainOldJavaObjects)简单的Java对象,
不需要继承任何父类，实现任何接口</li>
<li><p>编写Action 实现Action接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// Action接口中，定义默认五种 逻辑视图名称</span>
<span class="comment">// 五种逻辑视图，解决Action处理数据后，跳转页面</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS = <span class="string">"success"</span>;  <span class="comment">// 数据处理成功 （成功页面）</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NONE = <span class="string">"none"</span>;  <span class="comment">// 页面不跳转  return null; 效果一样</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"error"</span>;  <span class="comment">// 数据处理发送错误 (错误页面)</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INPUT = <span class="string">"input"</span>; <span class="comment">// 用户输入数据有误，通常用于表单数据校验 （输入页面）</span>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN = <span class="string">"login"</span>; <span class="comment">// 主要权限认证 (登陆页面)</span>
</pre></td></tr></table></figure>
</li>
<li><p>编写Action, 继承ActionSupport(推荐), 在Action中使用 表单校验、错误信息设置、读取国际化信息 三个功能</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// 方式二</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAction</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">opensymphony</span>.<span class="title">xwork2</span>.<span class="title">Action</span> {</span>
    <span class="keyword">public</span> String <span class="title">execute</span>(){
        <span class="keyword">return</span> SUCCESS; <span class="comment">// Action 中定义的常量, 匹配配置文件 struts.xml 中的 action.name</span>
    }
}
<span class="comment">// 方式三</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAction</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">opensymphony</span>.<span class="title">xwork2</span>.<span class="title">ActionSupport</span> {</span>
    <span class="keyword">public</span> String <span class="title">execute</span>() { }
}
</pre></td></tr></table></figure>

<h1 id="action-">Action的方法调用</h1>
<ol>
<li><p>在配置 <code>&lt;action&gt;</code> 元素时，没有指定method属性， 默认执行 Action类中 execute方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"request1"</span> <span class="type">class</span>=<span class="string">"cn.itcast.struts2.demo3.RequestAction1"</span> /&gt;
</pre></td></tr></table></figure>
</li>
<li><p>在 <code>&lt;action&gt;</code> 元素内部 添加 method属性，指定执行Action中哪个方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 执行 RegistAction 的regist方法 --&gt;</span>
<span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"regist"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.struts2.demo4.RegistAction"</span> <span class="attribute">method</span>=<span class="value">"regist"</span>/&gt;</span> 
 <span class="comment">&lt;!-- 将多个请求 业务方法 写入到一个Action 类中 --&gt;</span>
 <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"addBook"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.struts2.demo4.BookAction"</span> <span class="attribute">method</span>=<span class="value">"addBook"</span> &gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
 <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"delBook"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.struts2.demo4.BookAction"</span> <span class="attribute">method</span>=<span class="value">"delBook"</span> &gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>使用通配符* ，简化struts.xml配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"${pageContext.request.contextPath }/user/customer_add.action"</span>&gt;</span>添加客户<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"${pageContext.request.contextPath }/user/customer_del.action"</span>&gt;</span>删除客户<span class="tag">&lt;/<span class="title">a</span>&gt;</span>

<span class="comment">&lt;!-- struts.xml --&gt;</span>
<span class="comment">&lt;!-- {1}就是第一个* 匹配内容 --&gt;</span>
<span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"customer_*"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.struts2.demo4.CustomerAction"</span> <span class="attribute">method</span>=<span class="value">"{1}"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>

<span class="comment">&lt;!-- 方式一 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m1/userAction.action 时,默认会调用 UserAction 的 saveUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m1"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"userAction"</span> <span class="attribute">method</span>=<span class="value">"saveUser"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式二 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m2/userAction!deleteUser.action 时,
     会调用 UserAction 的 deleteUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m2"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"userAction"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式三 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m3/a_add.action 或 ${contextPath}/m3/**_add.action 时,
     都会调用 UserAction 的 saveUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m3"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_add"</span> <span class="attribute">method</span>=<span class="value">"saveUser"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式四 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m4/saveUser_add.action 时,
     会调用 UserAction 的 saveUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m4"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_add"</span> <span class="attribute">method</span>=<span class="value">"{1}"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式五 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m5/UserAction_pattern.action 时,
     会调用 UserAction 的 pattern 方法 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m5/PersonAction_pattern.action 时,
     会调用 PersonAction 的 pattern 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m5"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_pattern"</span> <span class="attribute">method</span>=<span class="value">"pattern"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.{1}"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式六 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m6/UserAction_saveUser.action 时,
     会调用 UserAction 的 saveUser 方法, 并返回 saveUser.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m6"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"UserAction_*"</span> <span class="attribute">method</span>=<span class="value">"{1}"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>{1}.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="comment">&lt;!-- 变体 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m6"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_*"</span> <span class="attribute">method</span>=<span class="value">"{2}"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.{1}"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>{2}.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="-">动态方法调用</h2>
<p>访问Action中指定方法，不进行配置</p>
<ul>
<li>在工程中使用 动态方法调用 ，必须保证
<code>struts.enable.DynamicMethodInvocation = true</code> 常量值 为true</li>
<li>在action的访问路径 中 使用 &quot;!方法名&quot;</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 页面 --&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"${pageContext.request.contextPath }/user/product!add.action"</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="comment">&lt;!-- 配置 --&gt;</span>
<span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"product"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.struts2.demo4.ProductAction"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="comment">&lt;!-- 执行 ProductAction 中的 add方法 --&gt;</span>
</pre></td></tr></table></figure>

<h1 id="action-servlet">Action中使用 Servlet</h1>
<ol>
<li><p>使用ActionContext 对象, 解耦合方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>actionContext = ActionContext<span class="preprocessor">.getContext</span>()<span class="comment">;</span>
// 获得所有请求参数Map集合
actionContext<span class="preprocessor">.getParameters</span>()<span class="comment">;</span>
// actionContext<span class="preprocessor">.get</span>(<span class="string">"company"</span>) 对request范围存取数据
actionContext<span class="preprocessor">.put</span>(<span class="string">"company"</span>, <span class="string">"传智播客"</span>)<span class="comment">;</span>
// 获得session数据Map，对Session范围存取数据
actionContext<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
// 获得ServletContext数据Map，对应用访问存取数据
actionContext<span class="preprocessor">.getApplication</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>
</li>
<li><p>ServletActionContext的静态方法可以得到Servlet相关的对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>//用Servlet相关的对象request response servletContext HttpSession
HttpServletRequest request = ServletActionContext<span class="preprocessor">.getRequest</span>()<span class="comment">;</span>
HttpServletResponse response = ServletActionContext<span class="preprocessor">.getResponse</span>()<span class="comment">;</span>
ServletContext sc = ServletActionContext<span class="preprocessor">.getServletContext</span>()<span class="comment">;</span>
HttpSession session = request<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>
</li>
<li><p>使用接口注入的方式，操作Servlet API(耦合)</p>
<p> Action实现如下接口，struts框架则会为其注入相应的Servlet API对象：
 <code>ServletRequestAware</code>, <code>ServletResponseAware</code>, <code>ServletContextAware</code>,
 实现其他对象或者功能，参考拦截器servletConfig</p>
</li>
</ol>
<h1 id="-">基于注解的开发</h1>
<p>注解基于约定, 根据默认规则, 实现无配置文件</p>
<h2 id="-">约定实现</h2>
<ol>
<li>导入jar包  11个jar  +  struts2-convention-plugin-2.3.7.jar</li>
<li>在web.xml 配置前端控制器</li>
<li>编写页面</li>
<li><p>插件中 plugin配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 编写Action类，必须位于 action,actions,struts,struts2 四个包中 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.convention.package.locators"</span> <span class="attribute">value</span>=<span class="value">"action,actions,struts,struts2"</span>/&gt;</span>
<span class="comment">&lt;!-- 以Action结尾 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.convention.action.suffix"</span> <span class="attribute">value</span>=<span class="value">"Action"</span>/&gt;</span>
<span class="comment">&lt;!-- 结果result页面存放位置 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.convention.result.path"</span> <span class="attribute">value</span>=<span class="value">"/WEB-INF/content/"</span>/&gt;</span>

<span class="comment">&lt;!-- Action被扫描后，如何确定Action的访问路径的 ？ --&gt;</span>
<span class="comment">&lt;!-- HelloAction位于直接位于四个扫描包下，namespace是/，Action的name是hello, /hello.action --&gt;</span>
cn.itcast.struts2.HelloAction
<span class="comment">&lt;!-- BookSearchAction 不是直接位于四个扫描包下，namespace是/books, Action的name是book-search --&gt;</span>
<span class="comment">&lt;!-- 访问路径 /books/book-search.action --&gt;</span>
cn.itcast.actions.books.BookSearchAction 
<span class="comment">&lt;!-- 访问 /user/user.action --&gt;</span>
cn.itcast.struts.user.UserAction
<span class="comment">&lt;!-- 访问 /test/login.action --&gt;</span>
cn.itcast.estore.action.test.LoginAction
</pre></td></tr></table></figure>
</li>
<li><p>根据常量配置 结果页面 位于 <code>/WEB-INF/content</code>下</p>
<p> 页面命名规则约定： actionName + resultCode + suffix
 例如： cn.itcast.struts.user.UserAction<br> /user/user.action 返回 SUCCESS<br> 结果页面 /WEB-INF/content/user/user-success.jsp<br> 找不到 /WEB-INF/content/user/user-success.html<br> 找不到 /WEB-INF/content/user/user.jsp  </p>
</li>
</ol>
<h2 id="-">注解实现</h2>
<p>注解开发第一步 基于约定的自动扫描</p>
<p>约定只解决Action访问和结果页面跳转问题</p>
<ul>
<li>在开发中需要为Action指定拦截器，进行更细节result配置</li>
<li>约定不够灵活，注解的功能 是和 xml配置方式 等价的</li>
</ul>
<p><code>&lt;constant name=&quot;struts.convention.classes.reload&quot; value=&quot;false&quot; /&gt;</code> Action类文件重新自动加载</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="annotation">@NameSpace</span>(<span class="string">"/user"</span>)
<span class="annotation">@ParentPackage</span>(<span class="string">"struts-default"</span>)
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
   <span class="comment">// `@ParentPackage` 配置`&lt;package&gt;` 继承哪个包</span>
   <span class="comment">// `@Namespace`  配置包名称空间</span>
   <span class="comment">// 使用 `@Action` 注解配置访问路径  `@Result` 注解 配置结果页面</span>
    <span class="annotation">@Action</span>(value=<span class="string">"login"</span>, results=<span class="annotation">@Result</span>(name=<span class="string">"success"</span>, location=<span class="string">"/index.jsp"</span>))
    <span class="keyword">public</span> String <span class="title">execute</span>(){
        <span class="keyword">return</span> <span class="string">"success"</span>
    }
    <span class="annotation">@Actions</span>(value={
      <span class="annotation">@Action</span>(value=<span class="string">"login"</span>, results=<span class="annotation">@Result</span>(name=<span class="string">"success"</span>, location=<span class="string">"/index.jsp"</span>))
      , <span class="annotation">@Action</span>(value=<span class="string">"login2"</span>, results=<span class="annotation">@Result</span>(name=<span class="string">"success"</span>, location=<span class="string">"/index.jsp"</span>))
    })
    <span class="keyword">public</span> String <span class="title">execute2</span>(){
        <span class="keyword">return</span> <span class="string">"success"</span>
    }
}
</pre></td></tr></table></figure>

<h1 id="-">结果页面的配置</h1>
<p>Action处理请求后， 返回字符串(逻辑视图名), 需要在struts.xml 提供 <code>&lt;result&gt;</code>元素定义结果页面</p>
<p>局部结果页面 和 全局结果页面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"result"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.struts2.demo6.ResultAction"</span>&gt;</span>
    <span class="comment">&lt;!-- 局部结果  当前Action使用 --&gt;</span>
 	<span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span>/demo6/result.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;<span class="title">global-results</span>&gt;</span>
    <span class="comment">&lt;!-- 全局结果 当前包中 所有Action都可以用--&gt;</span>
	<span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span>/demo6/result.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">global-results</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="struts2-">struts2 结果类型</h2>
<ol>
<li>结果类型其实就是一个实现com.opensymphony.xwork2.Result的类，用来输出你想要的结果</li>
<li>在struts-default.xml文件中已经提供了内置的几个结果类型</li>
</ol>
<h3 id="chain">chain</h3>
<p>转发到另一个动作</p>
<p><code>&lt;result-type name=&quot;chain&quot; class=&quot;com.opensymphony.xwork2.ActionChainResult&quot;/&gt;</code></p>
<p>如果转发的动作在一个名称空间中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testChain1"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"chain"</span>&gt;testChain2&lt;/<span class="constant">result</span>&gt;
&lt;/action&gt;
&lt;action <span class="property">name</span>=<span class="string">"testChain2"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"dispatcher"</span>&gt;/<span class="number">2.</span>jsp&lt;<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<p>如果转发的动作不在一个名称空间中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testChain1"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"chain"</span>&gt;</span>
        <span class="comment">&lt;!-- 如果需要转发的动作不在一个名称空间内，则需要进行参数的设置（原理看chain源码） --&gt;</span>
        <span class="comment">&lt;!-- 源码中有setNamespace和setActionName方法，去掉set，第一个字母改小写 --&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"namespace"</span>&gt;</span>/result1<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"actionName"</span>&gt;</span>testChain2<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p2"</span> <span class="attribute">namespace</span>=<span class="value">"/result1"</span> <span class="attribute">extends</span>=<span class="value">"base"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testChain2"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span>&gt;</span>/2.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="dispatcher">dispatcher</h3>
<p><code>&lt;result-type name=&quot;dispatcher&quot; class=&quot;org.apache.struts2.dispatcher.ServletDispatcherResult&quot; default=&quot;true&quot;/&gt;(默认的)</code></p>
<p>请求转发（地址栏不会变）。struts配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testChain2"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span>&gt;</span>/2.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="comment">&lt;!-- 这两个设置效果相同 --&gt;</span>
    <span class="comment">&lt;!--
        &lt;result name="success" type="dispatcher"&gt;
            &lt;param name="location"&gt;/2.jsp&lt;result&gt;
        &lt;/result&gt;
    --&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="redirectaction">redirectAction</h3>
<p><code>&lt;result-type name=&quot;redirectAction&quot; class=&quot;org.apache.struts2.dispatcher.ServletActionRedirectResult&quot;/&gt;</code></p>
<p>请求重定向到另一个动作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testRedirect1"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"redirectAction"</span>&gt;testRedirect2&lt;/<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<h3 id="redirect">redirect</h3>
<p><code>&lt;result-type name=&quot;redirect&quot; class=&quot;org.apache.struts2.dispatcher.ServletRedirectResult&quot;/&gt;</code></p>
<p>请求重定向（地址栏会变）.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testRedirect"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"redirect"</span>&gt;/<span class="number">2.</span>jsp&lt;<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<h3 id="stream">stream</h3>
<p><code>&lt;result-type name=&quot;stream&quot; class=&quot;org.apache.struts2.dispatcher.StreamResult&quot;/&gt;</code></p>
<p>结果类型为流，例如用于文件下载(具体原理需要看源码，而源码的核心就是execute方法）
struts.xml的配置(属性参数对应的都是类中的set方法）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testStream"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
    <span class="comment">&lt;!-- 不需要转向或重定向的页面，因为直接下载就可以了 --&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"stream"</span>&gt;</span><span class="comment">&lt;!-- 在文档中拷贝以下参数 --&gt;</span>
    <span class="comment">&lt;!-- 为了能让所有类型的文件都能下载，在Tomcat/conf/web.xml里面搜索bin，找到以下mapping参数 --&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"contentType"</span>&gt;</span>application/octet-stream<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="comment">&lt;!-- 查看Stream对应的类源代码,对应里面的字符串变量，根据这个字符串找输入流--&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"inputName"</span>&gt;</span>imageStream<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="comment">&lt;!-- 消息头的设置，指定下载，且指定下载文件名称 --&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"contentDisposition"</span>&gt;</span>attachment;filename="1.jpg"<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="comment">&lt;!-- 设置缓存的大小 --&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"bufferSize"</span>&gt;</span>1024<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<p>实现文件下载</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> CaptchaAction {
    <span class="comment">//设置一个流，并生成set，get方法。</span>
    <span class="keyword">private</span> InputStream imageStream;
    <span class="keyword">public</span> InputStream <span class="title">getImageStream</span>() {
        <span class="keyword">return</span> imageStream;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageStream</span>(InputStream imageStream) {
        <span class="keyword">this</span>.imageStream = imageStream;
    }
    <span class="keyword">public</span> String <span class="title">download</span>() throws FileNotFoundException{
        <span class="comment">//获得文件的真实路径</span>
        String realPath = ServletActionContext.getServletContext().getRealPath(<span class="string">"/WEB-INF/111.jpg"</span>);
        <span class="comment">//获得文件输入流</span>
        imageStream = <span class="keyword">new</span> FileInputStream(realPath);
        <span class="keyword">return</span> <span class="string">"success"</span>;
    }
    <span class="keyword">public</span> String <span class="title">method1</span>(){
        <span class="keyword">try</span>{
            <span class="comment">//int i=1/0;//人为制造异常，可以让catch转向全局结果集，error.jsp</span>

<span class="keyword">return</span> <span class="string">"success"</span>;
        }<span class="keyword">catch</span>(Exception e){
            <span class="keyword">return</span> <span class="string">"error"</span>;
        }
    }
}
</pre></td></tr></table></figure>

<h3 id="plaintext">plainText</h3>
<p><code>&lt;result-type name=&quot;plainText&quot; class=&quot;org.apache.struts2.dispatcher.PlainTextResult&quot; /&gt;</code></p>
<p>显示指定页面的源代码（不好用，只有java语句才能显示源代码）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testPlanText"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"showPlanText"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"plainText"</span>&gt;/<span class="number">1.</span>jsp&lt;<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<h3 id="-">其他结果类型</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"httpheader"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.dispatcher.HttpHeaderResult"</span>/&gt;
&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"freemarker"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.views.freemarker.FreemarkerResult"</span>/&gt;显示模板。。。需要实验。
&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"velocity"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.dispatcher.VelocityResult"</span>/&gt;显示模板。。。需要实验。
&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"xslt"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.views.xslt.XSLTResult"</span>/&gt;(显示样式？）
</pre></td></tr></table></figure>

<p>如果提供的结果类型不够用，就需要自定义了(注意需要实现Result接口)</p>
<p>自定义完的结果类型，需要先声明，才能使用：（随机验证码图片结果类型，实际应用的案例）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"base"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="comment">&lt;!-- 配置局部结果视图 --&gt;</span>
    <span class="tag">&lt;<span class="title">result-types</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result-type</span> <span class="attribute">name</span>=<span class="value">"captchaResults"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaResults"</span>&gt;</span><span class="tag">&lt;/<span class="title">result-type</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">result-types</span>&gt;</span>
    <span class="comment">&lt;!-- 配置全局结果视图, 只能配置在package里, 但是可以通过继承来使用 --&gt;</span>
    <span class="tag">&lt;<span class="title">global-results</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"error"</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">global-results</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="comment">&lt;!-- 需继承base,因为自定义的局部结果视图配置在base里面,且base继承了核心配置文件 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">namespace</span>=<span class="value">"/results"</span> <span class="attribute">extends</span>=<span class="value">"base"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"captcha"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"genImage"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"captchaResults"</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span>
            <span class="comment">&lt;!-- 调用结果处理类的setter方法，注入参数的值--&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"width"</span>&gt;</span>600<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"height"</span>&gt;</span>400<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="struts" scheme="http://zhpooer.github.io/tags/struts/"/>
    
  </entry>
  
</feed>
