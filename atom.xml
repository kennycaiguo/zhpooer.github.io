<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Poe's World]]></title>
  <subtitle><![CDATA[竹杖芒鞋轻胜马，一蓑烟雨任平生]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhpooer.github.io/"/>
  <updated>2014-05-21T13:34:29.176Z</updated>
  <id>http://zhpooer.github.io/</id>
  
  <author>
    <name><![CDATA[zhpooer]]></name>
    <email><![CDATA[zhpooer@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[传智播客day34-Hibernate性能]]></title>
    <link href="http://zhpooer.github.io/2014/05/21/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day34-hibernate%E6%80%A7%E8%83%BD/"/>
    <id>http://zhpooer.github.io/2014/05/21/传智播客day34-hibernate性能/</id>
    <published>2014-05-21T06:20:20.000Z</published>
    <updated>2014-05-21T08:43:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">懒加载</h1>
<p>懒加载主要解决一个问题: 类, 集合, many-to-one 在什么时候发出sql语句, 加载数据</p>
<h2 id="-">类的懒加载</h2>
<ul>
<li>利用session的load可以产生代理对象</li>
<li>在session.load 方法执行的时候并不发出sql语句</li>
<li>在得到一般属性的时候发出sql语句</li>
<li>只针对一般属性有效果, 针对标示符(id)没有效果<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// 得到一个代理对象
Classes c = (Classes) session<span class="preprocessor">.load</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
c<span class="preprocessor">.getCname</span>()<span class="comment">; // 发出sql语句</span>
c<span class="preprocessor">.getCid</span>()<span class="comment">;// 标识符, 不会发出</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
c<span class="preprocessor">.getDescription</span>()<span class="comment">;  // 如果还没有初始化, 抛错 could not initialize proxy, no session</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="-">集合的懒加载</h2>
<p>lazy 的三个变量:</p>
<ul>
<li>false: 当session.get时, 集合就被加载了</li>
<li>true: 在集合遍历时才被加载</li>
<li>extra: 针对集合做count, min, max, sum等操作</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 设置集合懒加载, 默认为 true,
     extra 更进一步的懒加载中, 如 students.size(), 会执行 select count()...--&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">lazy</span>=<span class="value">"false|true|extra"</span>&gt;</span><span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>// 执行 sql 生成 Classes 对象
// 如果 <span class="operator"><span class="keyword">set</span>.lazy=<span class="keyword">false</span>, 会马上加载集合对象
Classes c = <span class="keyword">session</span>.<span class="keyword">get</span>(Classes.class, <span class="number">1</span>L);</span> 
<span class="operator"><span class="keyword">Set</span> students = classes.getStudents();</span> 
for(Student s:students) {  // 执行sql, 生成 真实 students 对象(集合懒加载)
    s.getSname();
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Classes c = session<span class="preprocessor">.load</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
<span class="keyword">Set</span> students = classes<span class="preprocessor">.getStudents</span>()<span class="comment">; // 执行 sql 生成 Classes 对象</span>
for(Student s:students) {  // 执行sql, 生成 真实 students 对象(集合懒加载)
    s<span class="preprocessor">.getSname</span>()<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h2 id="-">单端关联的懒加载(多对一)</h2>
<p>根据多的端加载一的一端, 就一个数据, 所以无所谓</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 默认值 no-proxy --&gt;</span>
<span class="tag">&lt;<span class="title">many-to-one</span> <span class="attribute">lazy</span>=<span class="value">"false|no-proxy|proxy"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">many-to-one</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">抓取策略</h1>
<ol>
<li>主要是研究 <code>set</code> 集合如何提取数据</li>
<li>在 Classes.hbm.xml 文件中<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 外连接, 默认, 子查询 --&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">fetch</span>=<span class="value">"join|fetch|subselect"</span>&gt;</span><span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-">缓存策略</h1>
<h1 id="hql">HQL</h1>
]]></content>
    
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day33-Hibernate关系传递]]></title>
    <link href="http://zhpooer.github.io/2014/05/20/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day33-hibernate%E5%85%B3%E7%B3%BB%E4%BC%A0%E9%80%92/"/>
    <id>http://zhpooer.github.io/2014/05/20/传智播客day33-hibernate关系传递/</id>
    <published>2014-05-20T07:28:47.000Z</published>
    <updated>2014-05-21T06:18:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hibernate-">Hibernate 关系传递</h1>
<h2 id="-">一对多的单向关联</h2>
<p>可以通过Classes 到 Student, 但不能从 Student 到 Classes.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Classes</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long cid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String cname;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String description;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Set&lt;Student&gt; students; <span class="comment">// Set可以避免重复</span>
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>{</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long sid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String sname;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String description;
}
</pre></td></tr></table></figure>

<p>映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">&lt;!-- Classes.hbm.xml --&gt;</span>
<span class="tag">&lt;<span class="title">hiberante-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Classes"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"cid"</span> <span class="attribute">length</span>=<span class="value">"5"</span> <span class="attribute">type</span>=<span class="value">"long"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">gernerator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">gernerator</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cname"</span> <span class="attribute">length</span>=<span class="value">"20"</span> <span class="attribute">type</span>=<span class="value">"string"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"description"</span> <span class="attribute">length</span>=<span class="value">"100"</span> <span class="attribute">type</span>=<span class="value">"java.lang.String"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- set 元素对应类中的set集合
             通过set元素使classes表和student表建立关联--&gt;</span>
        <span class="comment">&lt;!-- key是通过外键的形式让两张表建立关联  --&gt;</span>
        <span class="comment">&lt;!-- one-to-many 是通络类的形式让两个类建立关联 --&gt;</span>
        <span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"students"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">key</span>&gt;</span> <span class="comment">&lt;!-- 用来描述外键 --&gt;</span>
                <span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"cid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">column</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
            <span class="tag">&lt;<span class="title">one-to-many</span> <span class="attribute">class</span>=<span class="value">"Student"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hiberante-mapping</span>&gt;</span>
<span class="comment">&lt;!-- Student.hbm.xml --&gt;</span>
<span class="tag">&lt;<span class="title">hibernate-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Student"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"sid"</span> <span class="attribute">length</span>=<span class="value">"5"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sname"</span> <span class="attribute">length</span>=<span class="value">"20"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"descscription"</span> <span class="attribute">length</span>=<span class="value">"100"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">执行操作</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
Transaction transaction = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>

Classes classes = new Classes()<span class="comment">;</span>
classes<span class="preprocessor">.setCname</span>(<span class="string">"第八期"</span>)<span class="comment">;</span>
classes<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>
session<span class="preprocessor">.save</span>(classes)<span class="comment">;</span>

Student student = new Student()<span class="comment">;</span>
student<span class="preprocessor">.setSname</span>(<span class="string">"班长"</span>)<span class="comment">;</span>
student<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>
// 如果学生很多, 要执行很多次, 可以用级联(Cascade)来解决
session<span class="preprocessor">.save</span>(student)<span class="comment">;</span>
transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<h3 id="-cascade-">级联(Cascade)</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 配置级联操作,
     save-update: 在保存(save) 或更新(update)班级时,
     也保存(save)和更新(update)学生, 即使学生是临时状态
     delete: 在删除班级的时候, 也删除学生
     all: save-update, delete
     --&gt;</span>
<span class="comment">&lt;!-- inverse 维护关系
             true 不维护(classes 不维护与 student 的关系)
             false 维护
             default false--&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"students"</span> <span class="attribute">cascade</span>=<span class="value">"save-update"</span> <span class="attribute">inverse</span>=<span class="value">"true"</span>&gt;</span>
    <span class="comment">&lt;!-- any --&gt;</span>
<span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</pre></td></tr></table></figure>

<p>在保存 Classes 时, 同时保存 students</p>
<ul>
<li>cascade 通过更新班级 级联保存学生(决定插入学生, 但不决定建立外键关联)</li>
<li>inverse 建立班级和学生之间的关系(决定是不是建立外键关联)<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>Classes classes = new Classes()<span class="comment">;</span>
classes<span class="preprocessor">.setCname</span>(<span class="string">"第八期"</span>)<span class="comment">;</span>
classes<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>

Student student = new Student()<span class="comment">;</span>
student<span class="preprocessor">.setSname</span>(<span class="string">"班长"</span>)<span class="comment">;</span>
student<span class="preprocessor">.setDescription</span>(<span class="string">"很牛"</span>)<span class="comment">;</span>

<span class="keyword">Set</span> students = new HashSet&lt;Student&gt;()<span class="comment">;</span>
students<span class="preprocessor">.add</span>(student)<span class="comment">;</span>
// 建立 classes 和 student 之间的关联
classes<span class="preprocessor">.setStudents</span>(students)<span class="comment">; </span>
// student 还是临时状态对象, 在保存班级的时候同时保存学生
// 进行了级联操作
session<span class="preprocessor">.save</span>(classes)<span class="comment">;</span>

// 删除一个学生
session<span class="preprocessor">.delete</span>(student)<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<p>把一个学生从一个班级转到另一个班级</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// 可以不写, 原因如下
// Classes c1 = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
Classes c2 = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">2</span>L)<span class="comment">;</span>
Student s = session<span class="preprocessor">.get</span>(Student<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
// 会执行数据库删除外键操作, 而随后一句会执行更新外键操作, 就变成 <span class="number">2</span>条 sql 语句
// 所以 第一条可以不写
// c1<span class="preprocessor">.getStudents</span>()<span class="preprocessor">.remove</span>(s)<span class="comment">;</span>
c2<span class="preprocessor">.getStudents</span>()<span class="preprocessor">.add</span>(s)<span class="comment">;</span>
// 因为都是持久化状态, 所以不用 `save` 或 `update`
transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>删除Classes中的所有学生</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Classes classes = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
// 方式一: 效率不高, 因为要先查询
<span class="keyword">Set</span> students = classes<span class="preprocessor">.getStudents</span>()<span class="comment">;</span>
students<span class="preprocessor">.clear</span>()<span class="comment">;</span>
// 方式二
classes<span class="preprocessor">.setStudents</span>(null)<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>删除一个班级</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Classes c = session.<span class="keyword">get</span>(Classes.<span class="keyword">class</span>, <span class="number">5</span>L);
<span class="comment">// 如果 inverse=true, classes不会维护和student的关系, 外键不会删除, 会报错</span>
<span class="comment">// 必须 inverse=false, 或者 cascade=delete(会执行多条"delete * from Student where sid=?"语句)</span>
session.<span class="keyword">delete</span>(c);
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 没有在 hbm.xml 设置 cascade, 就不会执行级联,</span>
<span class="comment">// 如果两个关联的对象中有一个的状态是 临时, 会报错,</span>
<span class="comment">// `TransientObjectException`: object references an unsaved transient instance</span>
Classes classes = <span class="keyword">new</span> Classes();
classes.setCname(<span class="string">"xxx"</span>);
Student student = <span class="keyword">new</span> Student();
classes.getStudents().add(student);
session.save(classes); <span class="comment">//  如果 cascade 不设置, 报错</span>
</pre></td></tr></table></figure>

<p>把 <code>session.save()/update()</code> 一个对象的操作是显示操作,
级联一个对象是一个隐式操作</p>
<h2 id="-">一对多的双向</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- Class Student --&gt;</span>
<span class="comment">&lt;!-- @BeanProperty private Classes classes; --&gt;</span>
<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"student"</span>&gt;</span>
    <span class="comment">&lt;!-- any other property --&gt;</span>
    <span class="tag">&lt;<span class="title">many-to-one</span> <span class="attribute">name</span>=<span class="value">"classes"</span> <span class="attribute">class</span>=<span class="value">"io.zhpooer.Classes"</span> <span class="attribute">column</span>=<span class="value">"cid"</span>/&gt;</span> 
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
</pre></td></tr></table></figure>

<p>一对多涉及到关系操作, 在多的一方操作效率高, 因为多的一方不会执行<code>update</code>外键操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Student student = new Student()<span class="comment">;</span>
Classes classes = session<span class="preprocessor">.get</span>(Classes<span class="preprocessor">.class</span>, <span class="number">3</span>L)<span class="comment">;</span>
classes<span class="preprocessor">.getStudents</span><span class="preprocessor">.add</span>(student)<span class="comment">; // 如果 inverse 为 false 会发出 update外键 语句</span>
student<span class="preprocessor">.setClasses</span>(classes)<span class="comment">;</span>
session<span class="preprocessor">.save</span>(student)<span class="comment">; // 不会发出 update 外键 语句</span>
</pre></td></tr></table></figure>

<h2 id="-">删除关系的错误</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Classes c = session.<span class="keyword">get</span>(Classes.<span class="keyword">class</span>, <span class="number">1</span>L);
Set students = classes.getStudents();
<span class="keyword">for</span>(Student s:students) {
    <span class="comment">// student.setClass(null);   不能解决下面的问题, 因为是 classes 维护着关系</span>
    <span class="comment">// 解决问题思路: students.remove(student);, 但是不能在迭代中删除</span>
    session.<span class="keyword">delete</span>(student); <span class="comment">// 会报错, 因为 student 还关联着 classes</span>
}
</pre></td></tr></table></figure>

<h2 id="-">一对多总结</h2>
<ul>
<li>如果让一的一方维护关系，取决于的因素有<ol>
<li>在一的一方的映射文件中，set元素的inverse属性为default/false</li>
<li>在客户端的代码中，通过一的一方建立关系</li>
<li><code>session.save/update</code>方法是用来操作表的，和操作关系没有关系</li>
</ol>
</li>
<li>怎么样采用级联的方法通过保存一个对象从而保存关联对象<ol>
<li>如果<code>session.save</code>操作的对象是A，这个时候应该看A.hbm.xml,看set元素中cascade是否设置有级联保存</li>
<li>在客户端通过A建立关联</li>
<li>在客户端执行<code>session.save(A)</code></li>
</ol>
</li>
<li>一对多的情况，多的一方维护关系效率比较高<ol>
<li>在多的一方many-to-one中没有inverse属性</li>
<li>在客户端通过多的一方建立关联</li>
</ol>
</li>
</ul>
<h2 id="-">多对多</h2>
<p>学生和课程的关系是多对多</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long sid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String name;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Set&lt;Course&gt; courses;
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Set&lt;Student&gt; students;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Long cid;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> name;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Student"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"sid"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
    <span class="comment">&lt;!-- table 就是用来描述第三张表的 --&gt;</span>
    <span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"courses"</span> <span class="attribute">table</span>=<span class="value">"student_course"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">key</span>&gt;</span>
           <span class="comment">&lt;!-- student_course 通过sid, 与student表建立关联 --&gt;</span>
            <span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"sid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">column</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
        <span class="comment">&lt;!-- colomn 也是描述要链接过去的外键 --&gt;</span>
        <span class="tag">&lt;<span class="title">many-to-many</span> <span class="attribute">class</span>=<span class="value">"Cource"</span> <span class="attribute">column</span>=<span class="value">"cid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">many-to-many</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Course"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"cid"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
    <span class="tag">&lt;<span class="title">set</span> <span class="attribute">name</span>=<span class="value">"students"</span> <span class="attribute">table</span>=<span class="value">"student_course"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">key</span>&gt;</span>
            <span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"cid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">column</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">key</span>&gt;</span>
        <span class="tag">&lt;<span class="title">many-to-many</span> <span class="attribute">class</span>=<span class="value">"Student"</span> <span class="attribute">column</span>=<span class="value">"sid"</span>&gt;</span> <span class="tag">&lt;/<span class="title">many-to-many</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
</pre></td></tr></table></figure>

<p>关系操作:</p>
<ul>
<li>多对多, 谁操作, 效率都一样</li>
<li>解除关系, 把第三张表一行数据删除掉</li>
<li>建立关系, 把第三张表数据增加一行记录</li>
<li>变更关系, 对第三张表 执行update操作, 先删除后增加</li>
</ul>
<p>级联操作: 都是对象针对集合的操作</p>
<h2 id="-">一对一</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 方式一 --&gt;</span>
<span class="tag">&lt;<span class="title">many-to-one</span> <span class="attribute">unique</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">many-to-one</span>&gt;</span>
<span class="comment">&lt;!-- 方式二: 主键关联, person 的主键是外键 --&gt;</span>
<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Person"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"pid"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"foreign"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"property"</span>&gt;</span> address <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
    <span class="tag">&lt;<span class="title">one-to-one</span> <span class="attribute">name</span>=<span class="value">"address"</span> <span class="attribute">constrained</span>=<span class="value">"true"</span> <span class="attribute">class</span>=<span class="value">"Address"</span>&gt;</span><span class="tag">&lt;/<span class="title">one-to-one</span>&gt;</span>
<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="Hibernate" scheme="http://zhpooer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day32-Hibernate入门]]></title>
    <link href="http://zhpooer.github.io/2014/05/20/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day32-hibernate%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/05/20/传智播客day32-hibernate入门/</id>
    <published>2014-05-20T02:45:34.000Z</published>
    <updated>2014-05-21T02:04:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="jdbc-">jdbc的优缺点</h1>
<p>缺点</p>
<ul>
<li>查询代码繁琐</li>
<li>重复性代码特别多(频繁的try catch)</li>
<li>没有数据缓存</li>
<li>sql的移植性不好</li>
</ul>
<p>优点</p>
<ul>
<li>速度快</li>
<li>把控性比较好</li>
</ul>
<h1 id="or-mapping-">OR mapping 优缺点</h1>
<p>优点</p>
<ul>
<li>简单</li>
<li>数据缓存, 一级缓存 二级缓存 查询缓存</li>
<li>可移植性比较好</li>
</ul>
<p>缺点</p>
<ul>
<li>因为sql语句是内部生成的, 程序不可控</li>
<li>如果数据量特别大, 程序不可控</li>
</ul>
<h1 id="ormapping-hibernate">ORmapping 概念 和 Hibernate</h1>
<p>对象关系映射: 让数据库和对象发生关联</p>
<p>通过 <code>*.hbm.xml</code>(映射文件),</p>
<ul>
<li>类与表的对应关系</li>
<li>类上属性的名称和表中的字段的名称的对应关系</li>
<li>类上属性的<em>类型</em>和表中的字段的<em>类型</em>的对应关系</li>
<li>把一对多和多对多的关系转化成面向对象的文件</li>
</ul>
<p>Hibernate的配置文件: 用来连接数据库</p>
<h1 id="hibernate-">hibernate入门案例 保存对象</h1>
<p>Hibernate: 根据客户端代码, 参照映射文件, 生成sql语句,
利用jdbc即使进行数据库操作</p>
<h2 id="-">编写持久化类</h2>
<p>POJO: 持久化类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/*
* 属性不能使用 数据库的关键字 如`table`
* 对象序列化作用, 让对象在网络上传输, 以二进制形式传输
*/</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> <span class="keyword">long</span> pid;
    <span class="annotation">@BeanProperty</span> pirvate String pname;
    <span class="annotation">@BeanProperty</span> pirvate String psex;
    <span class="comment">// 必须要写默认的构造函数, hibernate 查询对象时</span>
    <span class="keyword">public</span> <span class="title">Person</span>(){}
}
</pre></td></tr></table></figure>

<h2 id="-">准备映射文件</h2>
<p><code>Person.hbm.xml</code> 类映射文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">&lt;!-- import hibernate-mapping-3.0.dtd--&gt;</span>
<span class="tag">&lt;<span class="title">hibernate-mapping</span>&gt;</span>
    <span class="comment">&lt;!-- 用来描述一个持久化类  --&gt;</span>
    <span class="comment">&lt;!-- name 类的全名 --&gt;</span>
    <span class="comment">&lt;!-- table 可以不写, 默认值和类名一样 --&gt;</span>
    <span class="comment">&lt;!-- catalog 数据库名称, 一般不写 --&gt;</span>
    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"cn.itcast.Person"</span>&gt;</span>
        <span class="comment">&lt;!-- name 属性名称, 是根据字段, 而不是属性(get, set)--&gt;</span>
        <span class="comment">&lt;!-- column 列的名称 --&gt;</span>
        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"pid"</span> <span class="attribute">length</span>=<span class="value">"5"</span> <span class="attribute">type</span>=<span class="value">"java.lang.Long"</span>&gt;</span>
            <span class="comment">&lt;!-- 主键产生器, 告诉hibernate容器用什么样的方式产生主键 --&gt;</span>
            <span class="tag">&lt;<span class="title">gernerator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">gernerator</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">id</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"pname"</span> <span class="attribute">column</span>=<span class="value">"pname"</span> <span class="attribute">length</span>=<span class="value">"20"</span> <span class="attribute">type</span>=<span class="value">"java.lang.String"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"psex"</span> <span class="attribute">column</span>=<span class="value">"psex"</span> <span class="attribute">length</span>=<span class="value">"10"</span> <span class="attribute">type</span>=<span class="value">"java.lang.String"</span>&gt;</span> <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">准备配置文件</h2>
<p><code>hibernate.cfg.xml</code>, 如果是默认加载, 必须放在根目录下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">Hibernate-configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">session-factory</span>&gt;</span>
        <span class="comment">&lt;!-- 还有其他练级信息 --&gt;</span>
        <span class="comment">&lt;!-- 根据持久化类和映射文件生成表
            validate 只验证, 不创建表
            create-drop 启动创建, 结束删除
            create 每次创建
            update 检查, 如果没有就创建
        --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 显示 hibernate 内部生成的sql语句, 默认false --&gt;</span>
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"show_sql"</span>&gt;</span>true <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
        <span class="comment">&lt;!-- 导入映射文件 --&gt;</span>
        <span class="tag">&lt;<span class="title">mapping</span> <span class="attribute">resource</span>=<span class="value">"cn/itcast/hibernate/sh/domain/Person.hbm.xml"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">session-factory</span>&gt;</span>
<span class="tag">&lt;/<span class="title">Hibernate-configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">测试运行</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Configuration  conf = new Configuration()<span class="comment">;</span>
conf<span class="preprocessor">.configure</span>()<span class="comment">;  // 加载默认配置文件 `/hibernate.cfg.xml`</span>
SessionFactory fac = configuration<span class="preprocessor">.buildSessionFactory</span>()<span class="comment">;</span>
Session sessioin = fac<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
Transaction trans = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
Person p = new Person()<span class="comment">;</span>
p<span class="preprocessor">.setPname</span>(<span class="string">"p"</span>)<span class="comment">;</span>
p<span class="preprocessor">.setPsex</span>(<span class="string">"p"</span>)<span class="comment">;</span>
session<span class="preprocessor">.save</span>(p)<span class="comment">;</span>
trans<span class="preprocessor">.commit</span>()<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<h1 id="hiberante-">hiberante 加载流程分析</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">// 创建 Configuration 对象</span>
Configuration  conf = <span class="built_in">new</span> Configuration();
<span class="comment">// 包括 数据库连接信息 和 加载映射文件</span>
conf.configure();  <span class="comment">// 或 conf.configure("myownconfig");</span>
<span class="comment">// 数据库链接信息, 和映射文件信息, 持久化类信息 封装在 sessionFactory</span>
<span class="comment">// 是一个单例模式,一般情况下 hibernate 应该只有一个数据库连接且线程安全</span>
SessionFactory fac = configuration.buildSessionFactory();
<span class="comment">// 打开一个数据库连接, 进行数据库操作</span>
Session sessioin = fac.openSession();
<span class="comment">// 如果进行查询, 不用开启事务</span>
<span class="comment">// 如果进行cud操作, 要开启事务, 事务是由session开启的</span>
<span class="comment">// 事务不是自动提交的, 必须由session开启, 和当前session绑定</span>
Transaction trans = session.beginTransaction();
Person p = <span class="built_in">new</span> Person();
p.setPname(<span class="string">"p"</span>);
p.setPsex(<span class="string">"p"</span>);
<span class="comment">//  改变对象状态</span>
<span class="comment">// 会根据映射文件, 生成sql语句</span>
session.save(p);
<span class="comment">// 执行sql语句, 提交事务</span>
trans.commit();
<span class="comment">// 关闭数据连接</span>
session.<span class="built_in">close</span>();
</pre></td></tr></table></figure>

<p>得到一个持久化类</p>
<ul>
<li>加载配置文件</li>
<li>在配置文件中加载类映射文件</li>
<li>解析 映射文件中的class标签 name 属性, 找到对应类</li>
</ul>
<p>hibernate错误概览</p>
<ul>
<li><code>Unknown entity</code>, 在映射文件中没有配置该类</li>
<li><code>PropertyNotFound</code>, 映射文件中类字段错误, <code>property name</code> 写错</li>
<li><code>resource not found</code>, 映射文件名没有找到</li>
<li><code>entity class not found</code>, 在配置文件中导入文件映射文件错误, <code>class name</code>写错</li>
</ul>
<h1 id="crud-">CRUD 的操作</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre>public void testQueryPerson(){
    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    List personList = session<span class="preprocessor">.createQuery</span>(<span class="string">"from Person"</span>)<span class="preprocessor">.list</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testQueryPersonById() {
    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    // 按照主键的方式查询数据库表中的记录
    // session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>)<span class="comment">; 会报错, 需要 long 类型</span>
    session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testDeletePerson(){

    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    Transaction transaction = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
    // 方式一: 
    Person person = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.delete</span>(person)<span class="comment">;</span>
    
    // 方式二
    Person person = new Person()<span class="comment">;</span>
    // hibernate 内部会检查标示符(id), 看标示符的值在数据库响应的表中有没有对应的行
    // 和其他属性不相关
    person<span class="preprocessor">.setId</span>(<span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.delete</span>(person)<span class="comment">;</span>
    // 如果删除一个不存在的对象, 会报错: SaleStateException, unexpect row
    transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testUpdatePerson(){
    Session session = sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    Transaction transaction = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
    Person person = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    person<span class="preprocessor">.setPsex</span>(<span class="string">"女"</span>)<span class="comment">;</span>
    session<span class="preprocessor">.update</span>(person)<span class="comment">;</span>
    transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
public void testIdentity(){
    Session session = sessoinFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
    Transaction trans = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
    Person person1 = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
    Person person2 = new Person()<span class="comment">;</span>
    person<span class="preprocessor">.setPid</span>(<span class="number">1</span>L)<span class="comment">;</span>
    session<span class="preprocessor">.update</span>(person2)<span class="comment">; // 报错, 因为Hibernate不允许两个持久化对象持有同一个 标示符</span>
    transaction<span class="preprocessor">.commit</span>()<span class="comment">;</span>
    session<span class="preprocessor">.close</span>()<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h1 id="-">类型匹配</h1>
<p>在Hibernate映射文件中type属性支持两种类型, 一种是 java类型, 另一种hibernate类型,
java类型效率更高</p>
<table>
<thead>
<tr>
<th>hibernate类型</th>
<th>java类型-&gt;数据库类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer, long, short, float, double, character, byte, boolean, yes_no, true_false</td>
<td>java 原始类型到sql的字段类型</td>
</tr>
<tr>
<td>string</td>
<td>java.lang.String 到 VARCHAR(或者 Oracle 的 VARCHAR2)</td>
</tr>
<tr>
<td>date, time, timestamp</td>
<td>java.util.Date 和其子类到 SQL 类型 DATE，TIME 和 TIMESTAMP（或等价类型）的映射</td>
</tr>
</tbody>
</table>
<h1 id="-gernerator-">产生器(Gernerator)</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">gernerator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>&gt;</span> <span class="tag">&lt;/<span class="title">gernerator</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="increment">increment</h2>
<ul>
<li>主键类型必须是数字</li>
<li>主键生成是由hibernate生成的, 程序员不需要干预</li>
<li>效率相对低</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 没有意义, hibernate是根据主键生成器来生成主键的,</span>
<span class="comment"><span class="xmlDocTag">///</span> 在客户端设置主键不一定起作用. </span>
Person p = <span class="keyword">new</span> Person();
p.setId(<span class="number">1</span>L);   
session.save(p);
</pre></td></tr></table></figure>

<h2 id="identity">identity</h2>
<ul>
<li>生成的主键是由数据库完成的</li>
<li>该表必须支持自动增长机制(auto_increment)</li>
<li>效率高</li>
</ul>
<h2 id="assigned">assigned</h2>
<ul>
<li>由程序(手动)设置主键</li>
</ul>
<h2 id="uuid">uuid</h2>
<ul>
<li>UUID是由hibernate内部生成</li>
<li>主键的类型必须是字符串</li>
</ul>
<h1 id="-">对象的状态</h1>
<p>Hibernate中的对象共有三个状态: 临时, 持久化, 托管状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// 临时状态对象</span>
Person p = <span class="built_in">new</span> Person();
<span class="comment">// 持久化状态, 只有在持久化状态, 对象的状态变化才会被Hibernate捕捉</span>
session.save(p);
transaction.commit();
<span class="comment">// 脱管状态</span>
session.<span class="built_in">close</span>();
</pre></td></tr></table></figure>

<p>把一个临时状态对象, 变成持久化状态的方法:</p>
<ul>
<li><code>Session.save</code></li>
<li><code>Session.update</code></li>
</ul>
<p>当<code>Session.get</code>方法得到一个对象的时候, 是不需要再执行<code>Session.update</code>语句的,
因为已经是持久化状态.</p>
<p>当一个对象是持久化对象时, 当进行提交时, 会根据内存中<em>快照</em>看是否需要执行update语句.</p>
<h2 id="-">对象状态变化</h2>
<p><img src="/img/hibernate_state.png" alt="hibernate状态转换"></p>
<p><code>session.clear()</code>, 把所有的对象从session中清空(变成托管对象)</p>
<p><code>session.evict(p)</code>, 把一个对象变成托管状态</p>
<p>一个对象是否是持久化对象是针对某一个session而言的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Session session = sessionFactory<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
Person person = session<span class="preprocessor">.get</span>(Person<span class="preprocessor">.class</span>, <span class="number">1</span>L)<span class="comment">;</span>
sessoin<span class="preprocessor">.close</span>()<span class="comment">;</span>
// person 相对于 session2 来说是临时状态, 所以不会生成sql语句
Sessoin session2 = sessionFactory<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
person<span class="preprocessor">.setName</span>(<span class="string">""</span>)<span class="comment">;</span>
session<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>当 <code>transaction.commit()</code> 时, Hibernate 会检查session,</p>
<ul>
<li>如果一个对象是临时状态对象, session不会管</li>
<li>如果是一个持久化状态对象, 那么先把该对象和快照对比, 来决定是否执行sql update操作</li>
<li>如果是一个没有Id的持久化对象, 则执行save操作</li>
</ul>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="Hibernate" scheme="http://zhpooer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day31-案例]]></title>
    <link href="http://zhpooer.github.io/2014/05/17/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day31-%E6%A1%88%E4%BE%8B/"/>
    <id>http://zhpooer.github.io/2014/05/17/传智播客day31-案例/</id>
    <published>2014-05-17T06:05:42.000Z</published>
    <updated>2014-05-19T11:47:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">项目需求分析</h1>
<p>模块:</p>
<ol>
<li>登陆模块</li>
<li>用户模块的搭建</li>
</ol>
<p>框架的搭建:</p>
<ul>
<li>页面用 JSP, 放在 WEB-INF 下</li>
<li>后台: struts2 + jdbc</li>
<li>后台的分层<ul>
<li>action</li>
<li>service</li>
<li>dao</li>
</ul>
</li>
<li>struts2的配置文件<ul>
<li><code>struts.xml</code>, <code>struts-login.xml</code>, <code>struts-user.xml</code></li>
<li>简单样式, 开发模式为 true</li>
</ul>
</li>
<li>数据库: DBUtils 封装数据库的链接</li>
</ul>
<h1 id="-">代码</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- login.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">action</span>=<span class="value">"LoginAction_login.action"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">cssClass</span>=<span class="value">"text"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">cssClass</span>=<span class="value">"text"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:submit</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">struts</span>&gt;</span>
    <span class="tag">&lt;<span class="title">constants</span> <span class="attribute">name</span>=<span class="value">"struts.devMode"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">constants</span> <span class="attribute">name</span>=<span class="value">"struts.ui.theme"</span> <span class="attribute">value</span>=<span class="value">"simple"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">file</span>=<span class="value">"struts/struts-user.xml"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">file</span>=<span class="value">"struts-login.xml"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">struts</span>&gt;</span>
</pre></td></tr></table></figure>

<p>移动脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> s_user (
    userID <span class="keyword">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,
    username <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    password <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    sex <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    birthday <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    education <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    telephone <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    interest <span class="keyword">varchar</span>(<span class="number">50</span>) <span class="keyword">null</span>,
    path <span class="keyword">varchar</span>(<span class="number">500</span>) <span class="keyword">null</span>,
    filename <span class="keyword">varchar</span>(<span class="number">100</span>) <span class="keyword">null</span>,
    remark <span class="keyword">varchar</span>(<span class="number">500</span>) <span class="keyword">null</span>,
    <span class="keyword">primary</span> <span class="keyword">key</span>(userID)
);</span>
<span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> s_user (userID, username, password) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">"admin"</span>, <span class="string">"admin"</span>);</span>
</pre></td></tr></table></figure>

<p>持久层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// cn.itcast.dao</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> {</span>
    <span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span>();
    <span class="keyword">public</span> User <span class="title">getUserById</span>(Serializable id);
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span>(User user);
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span>(Serializable id);
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span>(User user);
    <span class="keyword">public</span> User <span class="title">login</span>(String username, String password);
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> {</span>}
</pre></td></tr></table></figure>

<p>模型类: </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> User {
    <span class="keyword">private</span> String <span class="keyword">long</span> userId;
    <span class="keyword">private</span> String username;
    <span class="keyword">private</span> String password;
    <span class="keyword">private</span> String sec;
    <span class="keyword">private</span> String birthday;
    <span class="keyword">private</span> String education;
    <span class="keyword">private</span> String phone;
    <span class="keyword">private</span> String interest;
    <span class="keyword">private</span> String path;
    <span class="keyword">private</span> String filename;
    <span class="keyword">private</span> String remark;
}
</pre></td></tr></table></figure>

<p>业务层:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">interface</span> UserService {
    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();
    <span class="keyword">public</span> User <span class="title">login</span>(String username, String password){
        <span class="keyword">return</span> userdao.login(username, password);
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">ActionSupport</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; {</span>
    <span class="keyword">private</span> UserService UserService = <span class="keyword">new</span> UserServiceImpl();
    <span class="keyword">private</span> User model = <span class="keyword">new</span> User();
    @Override <span class="keyword">public</span> User getModel(){<span class="keyword">return</span> model;}
    <span class="keyword">public</span> String login(){
        User user = userService.login(user.getUsername(), user.getPassword);
        <span class="keyword">if</span>(user==<span class="keyword">null</span>) {
            <span class="keyword">this</span>.addActioinError(<span class="string">"用户名或者密码错误"</span>)
            <span class="keyword">return</span> <span class="string">"input"</span>; <span class="comment">// 跳到错误页面</span>
        }
        <span class="keyword">return</span> <span class="string">"home"</span>;
    }
}
</pre></td></tr></table></figure>

<p>struts-login.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"login"</span> <span class="attribute">namespace</span>=<span class="value">""</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"loginAction_*"</span> <span class="attribute">method</span>=<span class="value">"{1}"</span> <span class="attribute">class</span>=<span class="value">"UserAction"</span>&gt;</span>
       <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"input"</span>&gt;</span> login.jsp <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">显示层</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- home.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">frameset</span>&gt;</span>
    <span class="tag">&lt;<span class="title">frame</span> <span class="attribute">src</span>=<span class="value">"forwardAction_forward.action?method-top"</span> <span class="attribute">name</span>=<span class="value">"topFrame"</span> <span class="attribute">scrolling</span>=<span class="value">"NO"</span> <span class="attribute">noresize</span>=<span class="value">""</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">frame</span>&gt;</span>
    <span class="comment">&lt;!-- ...脑补... --&gt;</span>
<span class="tag">&lt;/<span class="title">frameset</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> ForwardAction {
    <span class="keyword">private</span> String method;
    <span class="keyword">public</span> String <span class="title">forward</span>() {
        <span class="comment">// 配置 struts-forwards.xml</span>
        <span class="comment">// result name=top =&gt; top.jsp</span>
        <span class="comment">// result name=left =&gt; left.jsp</span>
        <span class="comment">// result name=bottom =&gt; bottom.jsp</span>
        <span class="comment">// result name=right =&gt; welcome.jsp</span>
        <span class="keyword">return</span> method;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- struts-login --&gt;</span>
<span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"home"</span>&gt;</span> WEB-INF/frame/home.jsp <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
</pre></td></tr></table></figure>

<p>左侧的树是利用登陆一个框架 dTree 框架</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">&lt;!-- left.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"dtree.css"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>/&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"dtree.js"</span>&gt;</span><span class="javascript"> </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"txt/javascript"</span>&gt;</span><span class="javascript">
d = <span class="keyword">new</span> dTree(<span class="string">'d'</span>)
d.add(<span class="number">0</span>, -<span class="number">1</span>, <span class="string">'系统菜单树'</span>); <span class="comment">// 设置树的父节点</span>
<span class="comment">// 第一个参数: 为该节点的 id</span>
<span class="comment">// 第二个参数: 父节点</span>
<span class="comment">// 三: 节点的名称</span>
<span class="comment">// 四: 链接到的页面</span>
<span class="comment">// 六: 需要显示的 frame</span>
d.add(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'用户管理'</span>, userAction_showAllUser.action<span class="string">', '</span><span class="string">', '</span>right<span class="string">');
d.add(3, 2, '</span>员工管理<span class="string">', '</span>list.jsp<span class="string">', '</span><span class="string">', right'</span>);
document.add(d);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// UserAction</span>
<span class="keyword">public</span> String <span class="title">showAllUser</span>() {
    List&lt;User&gt; userList = userService.getAllUser();
    ActionContext.getContext().put(<span class="string">"userList"</span>, userList);
    <span class="keyword">return</span> <span class="string">"list.jsp"</span>; <span class="comment">// 添加struts-user.xml, 修改 user/list.jsp, 迭代userList</span>
}
<span class="comment">// UserService</span>
<span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span>() {
    userdao.getAllUser();
}
</pre></td></tr></table></figure>

<h2 id="-">添加用户</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// UserAction</span>
<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> File upload; <span class="comment">// 该属性用于文件上传</span>
<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String uploadFileName;
<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String uploadContentType;
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUI</span>(){
    <span class="keyword">return</span> <span class="string">"add.jsp"</span>
}
<span class="keyword">public</span> String <span class="title">add</span>(){
    String path = UploadUtils.saveUploadFile(upload);
    getModel.setPath(path);
    getModel.setFilename(uploadFileName);
    userService.addUser(getModel);
    
}

<span class="comment">// userService</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span>(User user){
    userDao.saveUser(user);
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// list.jsp</span>
<span class="function"><span class="keyword">function</span> <span class="title">addUser</span><span class="params">()</span>{</span>
    window.location.href=<span class="string">"UserAction_addUI"</span>;
}
</pre></td></tr></table></figure>

<h2 id="-">修改客户信息</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="comment">// list.jsp: &lt;s:a action="userAction_showUserByID?userId=%{userId}"&gt;修改&lt;/s:a&gt;</span>
<span class="comment">// 注意 在struts2标签中, 不能跟 el 表达式</span>
<span class="comment">// 在html标签中 不能加 ognl 表达式</span>
<span class="comment">// Useraction</span>
<span class="keyword">private</span> String[] interest; <span class="comment">// 用来回显爱好</span>
<span class="keyword">public</span> String showUserByID {
   User user =  userService.getUserById(getModel.getUserId());
   interest = user.getInterest().split(<span class="string">","</span>);
   ActionContext.getContext().getValueStack().push(user);
   <span class="keyword">return</span> <span class="string">"updateUI"</span>;
}
<span class="keyword">public</span> String <span class="title">updateUser</span>(){
    userService.updateUser(model);
    <span class="keyword">return</span> <span class="string">"list.jsp"</span>;
}

<span class="comment">// UserService</span>
<span class="keyword">public</span> User <span class="title">getUserById</span>(Serializable id){
    <span class="keyword">return</span> userDao.getUserById();
}
</pre></td></tr></table></figure>

<h3 id="interests-">interests 的回显</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// UserAction</span>

<span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String[] ids; <span class="comment">// 用来存储 页面上 checkboxlist</span>
<span class="comment">// 在代码中 处理 ids, 加入到 userAction中</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day31-struts拾遗]]></title>
    <link href="http://zhpooer.github.io/2014/05/17/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day31-struts%E6%8B%BE%E9%81%97/"/>
    <id>http://zhpooer.github.io/2014/05/17/传智播客day31-struts拾遗/</id>
    <published>2014-05-17T01:04:32.000Z</published>
    <updated>2014-05-21T11:37:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ognl-">ognl 详解</h1>
<p>OGNL：Object Graph Navigation Language</p>
<ul>
<li><p>OGNL不仅可以调用属性，还可以调用普通方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 表达式可以调get和set,可以调方法,可以按索引取数组内容 （打印a）--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">'"abcdefg".toCharArray()[0]'</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- ognl表达式中：context代表contextMap （打印对应的value）--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#context['com.opensymphony.xwork2.ActionContext.locale']"</span>/&gt;</span>
<span class="comment">&lt;!-- 打印11111111111111111，直接量，直接写的值,H表示大数据？ --&gt;</span>
<span class="comment">&lt;!-- 111B  表示BigDecimal类型    1111H表示BigInteger --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"11111111111111111H"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>OGNL获取属性等</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="vbscript">&lt;%
<span class="built_in">request</span>.setAttribute(<span class="string">"str"</span>, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>});
%&gt;</span>
<span class="tag">&lt;<span class="title">s:debug</span>&gt;</span><span class="tag">&lt;/<span class="title">s:debug</span>&gt;</span>
<span class="comment">&lt;!-- OGNL中可以使用伪属性  .length（以下打印3） --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.str.length"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.str['length']"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.str['len'+'gth']"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>链式表达式(Chained Subexpressions)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 链式表达式，#this表示前面的110H.intValue() --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"110H.intValue().(#this&lt;112?#this*2:#this/2)"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>访问静态资源, 取得静态常量，用@进行间隔，加小括号表示静态方法，不加小括号就是代表取get方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 使用静态资源，需要打开静态常量开关struts.ognl.allowStaticMethodAccess --&gt;</span>
<span class="comment">&lt;!-- 表示Integer中的MAX_VALUE常量 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"@java.lang.Integer@MAX_VALUE"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- 表示使用System类中的currentTimeMillis()静态方法 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"@java.lang.System@currentTimeMillis()"</span>/&gt;</span><span class="tag">&lt;<span class="title">hr</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>集合对象操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="xml"><span class="comment">&lt;!--{'a','b','c'} 创建了一个List集合  --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"{'a','b','c'}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- value省略，打印a b c --&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
<span class="comment">&lt;!-- 打印class java.util.ArrayList --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"{'a','b','c'}.class"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>

<span class="comment">&lt;!-- 打印集合 --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#{'a':'aa','b':'bb'}"</span>&gt;</span>
<span class="comment">&lt;!-- 打印a:aa  b:bb --&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>:<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"value"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- in 表达式 --&gt;</span>
<span class="comment">&lt;!-- EL表达式在Struts2中已经被改写了：原有功能保持不变。只是在四大域范围内找不到的话，EL表达式就变成了OGNL表达式 --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#{'eat':'吃饭','sleep':'睡觉','study':'学习'}"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"hobby"</span> &lt;<span class="attribute">s:property</span> <span class="attribute">value</span>=<span class="value">"key in {'java','sleep','study'}?'checked=\"</span><span class="value">checked\"':''"</span>/&gt;</span> value="${key}"/&gt;${value}
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span></span>
</pre></td></tr></table></figure>
</li>
<li><p>投影查询</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 打印fengjie=fengjie --&gt;</span>
${name}=<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- 打印[10, 6, 4, 0] --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"{5,3,2,0}.{#this*2}"</span>/&gt;</span>
<span class="comment">&lt;!-- 打印[5, 3, 2] --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"{5,3,2,0}.{?#this*2}"</span>/&gt;</span>
<span class="comment">&lt;!-- 打印 [5] --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"{5,3,2,0}.{^#this*2}"</span>/&gt;</span>
<span class="comment">&lt;!-- 打印 [2] --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"{5,3,2,0}.{$#this*2}"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>类型转换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 打印[0, 2, 4, 6, 8] --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"(5).{#this*2}"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">”#{'name':'wzt','age':30,'gender':'male'}.{#key}”</span>/&gt;</span>发现什么都没有输出
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#{'name':'wzt','age':30,'gender':'male'}.{#this}"</span>/&gt;</span>有输出。把Map转为了Value
<span class="comment">&lt;!-- 打印 [wzt, 30, male]--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#{'name':'wzt','age':30,'gender':'male'}.{#this}"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- 打印当前日期 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"new java.util.Date()"</span>/&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<p>技巧：如果不确定是不是OGNL表达式，那么加上%{abc}，那么abc就是一个OGNL表达式而不是字符串了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">action</span>=<span class="value">"RegUser"</span> <span class="attribute">namespace</span>=<span class="value">"/user"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">key</span>=<span class="value">"hello"</span> <span class="attribute">label</span>=<span class="value">"用户名"</span> <span class="attribute">name</span>=<span class="value">"username"</span> &gt;</span><span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">label</span>=<span class="value">"昵称"</span> <span class="attribute">name</span>=<span class="value">"nick"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:password</span> <span class="attribute">label</span>=<span class="value">"密码"</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:password</span>&gt;</span>
    爱好：
    <span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"hobbies"</span> <span class="attribute">var</span>=<span class="value">"me"</span>&gt;</span>
        <span class="comment">&lt;!-- 如果要把一个字符串当做OGNL表达式对待，请使用%{}包括起来 --&gt;</span>
        <span class="tag">&lt;<span class="title">s:checkbox</span> <span class="attribute">name</span>=<span class="value">"hobby"</span> <span class="attribute">fieldValue</span>=<span class="value">"%{key}"</span> <span class="attribute">label</span>=<span class="value">"%{value}"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:checkbox</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
    <span class="tag">&lt;<span class="title">hr</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:checkboxlist</span> <span class="attribute">list</span>=<span class="value">"hobbies"</span> <span class="attribute">name</span>=<span class="value">"hobby"</span> <span class="attribute">listKey</span>=<span class="value">"key"</span> <span class="attribute">listValue</span>=<span class="value">"value"</span> <span class="attribute">label</span>=<span class="value">"新爱好"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:checkboxlist</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:radio</span> <span class="attribute">list</span>=<span class="value">"#{'male':'男','female':'女'}"</span> <span class="attribute">name</span>=<span class="value">"gender"</span> <span class="attribute">label</span>=<span class="value">"性别"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:radio</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:submit</span> <span class="attribute">value</span>=<span class="value">"注册"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:submit</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="struts-ognl-">struts 配置文件中的 ognl 表达式</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- request.setAttribute("uri", "test") --&gt;</span>
<span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"test"</span>&gt;</span>
%{#request.uri}.jsp
<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">表单校验</h1>
<p>普通式的开发，用声明式的，细致的控制，用编程式的验证</p>
<h2 id="-">编程式验证</h2>
<p>用代码，表达式的方式</p>
<p>前提：动作类一般要求继承<code>ActionSupport</code></p>
<p>struts.xml配置文件中,对要验证的动作,需要提供name=&quot;input&quot;的结果视图(回显)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"RegUser"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"RegUser"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span>/WEB-INF/pages/main.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span> <span class="attribute">name</span>=<span class="value">"error"</span>&gt;</span>/WEB-INF/pages/commons/error.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="comment">&lt;!-- 出现错误时转向的页面：回显 --&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"input"</span>&gt;</span>/WEB-INF/pages/regist.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<p>针对所有动作进行验证：需要覆盖 <code>public void validate()</code>方法，
方法内部如果不满足要求，调用addFieldError填充信息.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="annotation">@SkipValidation</span><span class="comment">//用在不需要验证的动作方法上</span>
<span class="keyword">public</span> String <span class="title">RegUserUI</span>() {
    <span class="keyword">return</span> SUCCESS;
}
 <span class="comment">//对所有的动作方法进行校验</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span>(){
<span class="comment">//写你的校验代码ActionSupport里面有addFieldError()方法,把错误信息存起来.</span>
    <span class="keyword">if</span>(StringUtils.isEmpty(user.getUsername())){
        addFieldError(<span class="string">"username"</span>, <span class="string">"请输入用户名"</span>);<span class="comment">//向一个Map中存储错误消息。何时返回input视图，是由该Map中有无信息决定的。</span>
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">//针对某个动作方法进行校验 public String regUser(){}</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRegUser</span>() {
    <span class="comment">// 写你的校验代码</span>
    <span class="keyword">if</span> (user.getUsername() == <span class="keyword">null</span> || user.getUsername().equals(<span class="string">""</span>)) {
        addFieldError(<span class="string">"username"</span>, <span class="string">"请输入用户名"</span>);
    }
}
</pre></td></tr></table></figure>

<h2 id="-">声明式验证</h2>
<p>开发的时候，可以不写验证，后续增加声明式验证，
写配置文件即可，编码式验证需要开始就要写</p>
<p>struts2中已经内置一些验证器 <code>com.opensymphony.xwork2.validator.validators.default.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 打开xwork-core-2.*.jar包中的xwork-validator-1.*.dtd文件,复制表头 --&gt;</span>
<span class="doctype">&lt;!DOCTYPE validators PUBLIC 
          "-//Apache Struts//XWork Validator 1.0//EN"
          "http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd"&gt;</span>
</pre></td></tr></table></figure>

<p>如何使用内置验证器：</p>
<ol>
<li>对所有的动作方法都进行验证：在动作类相同的包中, 添加 <code>动作类名-validation.xml</code>使用。</li>
<li>针对某些动作进行验证：动作类名-动作别名-validation.xml(动作别名指Struts.xml中的action的name))</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE validators PUBLIC 
          "-//Apache Struts//XWork Validator 1.0//EN"
          "http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">validators</span>&gt;</span>
    <span class="comment">&lt;!-- 针对字段的验证：方式一（建议使用）.在一个字段上加上多个验证规则--&gt;</span>
    <span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"username"</span> &gt;</span>
    <span class="comment">&lt;!-- 不能为null或者""字符串, 默认会 trim --&gt;</span>
        <span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"requiredstring"</span>&gt;</span> 
            <span class="tag">&lt;<span class="title">message</span>&gt;</span>用户名是必须的<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">field</span>&gt;</span>
     <span class="comment">&lt;!-- 针对字段的验证：方式二.
     &lt;validator type="requiredstring"&gt;
     &lt;!-- 校验器中有trim方法,当把这个方法设置为false,那么用户名前后可以有空格 --&gt;</span>
         <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"trim"</span>&gt;</span>false<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
         <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fieldName"</span>&gt;</span>username<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
         <span class="tag">&lt;<span class="title">message</span>&gt;</span>必须的用户名<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">validator</span>&gt;</span>--&gt;
     <span class="comment">&lt;!-- 在使用配置文件的時候,只使用一种配置方式 --&gt;</span>
     <span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span>
         <span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"strongpassword"</span>&gt;</span>
             <span class="tag">&lt;<span class="title">message</span>&gt;</span>密码不够强壮<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
         <span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">field</span>&gt;</span>
<span class="tag">&lt;/<span class="title">validators</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">案例: 表单验证</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 标签标示在此显示错误信息 --&gt;</span>
<span class="comment">&lt;!-- 里面的属性标示显示该属性的错误信息,如果不写就显示所有错误信息 --&gt;</span>
<span class="tag">&lt;<span class="title">s:fielderror</span> <span class="attribute">fieldName</span>=<span class="value">"password"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">action</span>=<span class="value">"RegUser"</span> <span class="attribute">namespace</span>=<span class="value">"/user"</span>&gt;</span>
    <span class="comment">&lt;!-- requiredLabel="true"表示在用户名旁边加 *(单纯加*,没有其他作用)； requiredPosition="left"表示 * 在左边 --&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">key</span>=<span class="value">"hello"</span> <span class="attribute">label</span>=<span class="value">"用户名"</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">requiredLabel</span>=<span class="value">"true"</span> <span class="attribute">requiredPosition</span>=<span class="value">"left"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">label</span>=<span class="value">"昵称"</span> <span class="attribute">name</span>=<span class="value">"nick"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:password</span> <span class="attribute">label</span>=<span class="value">"密码"</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:password</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">ActionSupport</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; {</span>
    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();
    <span class="keyword">private</span> Map&lt;String, String&gt; hobbies = <span class="keyword">new</span> HashMap&lt;String, String&gt;();
    <span class="keyword">public</span> Map&lt;String, String&gt; getHobbies() {
        hobbies.put(<span class="string">"eat"</span>, <span class="string">"吃饭"</span>);
        hobbies.put(<span class="string">"sleep"</span>, <span class="string">"睡觉"</span>);
        hobbies.put(<span class="string">"study"</span>, <span class="string">"学java"</span>);
        <span class="keyword">return</span> hobbies;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> setHobbies(Map&lt;String, String&gt; hobbies) {
        <span class="keyword">this</span>.hobbies = hobbies;
    }
    <span class="keyword">public</span> String RegUser() {
        <span class="keyword">try</span> {
            System.out.println(user);
            <span class="comment">// 调用service，保存数据</span>
            System.out.println(<span class="string">"调用后台service，保存数据到数据库中"</span>);
            <span class="keyword">return</span> SUCCESS;
        } <span class="keyword">catch</span> (Exception e) {
            e.printStackTrace();
            <span class="keyword">return</span> ERROR;
        }
    }
    @SkipValidation<span class="comment">//用在不需要验证的动作方法上</span>
    <span class="keyword">public</span> String RegUserUI() {
        <span class="keyword">return</span> SUCCESS;
    }
     <span class="comment">//对所有的动作方法进行校验</span>
<span class="comment">//     public void validate(){</span>
<span class="comment">//     //写你的校验代码</span>
<span class="comment">//         if(StringUtils.isEmpty(user.getUsername())){</span>
<span class="comment">//             addFieldError("username", "请输入用户名");//向一个Map中存储错误消息。何时返回input视图，是由该Map中有无信息决定的。</span>
<span class="comment">//         }</span>
<span class="comment">//     }</span>
    <span class="comment">//针对某个动作方法进行校验</span>
<span class="comment">//    public void validateRegUser() {</span>
<span class="comment">//        // 写你的校验代码</span>
<span class="comment">//        if (user.getUsername() == null || user.getUsername().equals("")) {</span>
<span class="comment">//            addFieldError("username", "请输入用户名");</span>
<span class="comment">//        }</span>
<span class="comment">//    }</span>
    <span class="keyword">public</span> User getModel() {
        <span class="keyword">return</span> user;
    }
}
</pre></td></tr></table></figure>

<p>使用声明式校验器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">validators</span>&gt;</span>
    <span class="comment">&lt;!-- 针对字段的验证：方式一（建议使用）.在一个字段上加上多个验证规则--&gt;</span>
    <span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"username"</span> &gt;</span>
        <span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"requiredstring"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">message</span>&gt;</span>用户名是必须的<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">field</span>&gt;</span>
     <span class="comment">&lt;!-- 针对字段的验证：方式二.
     &lt;validator type="requiredstring"&gt;
     &lt;!-- 校验器中有trim方法,当把这个方法设置为false,那么用户名前后可以有空格 --&gt;</span>
         <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"trim"</span>&gt;</span>false<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
         <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fieldName"</span>&gt;</span>username<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
         <span class="tag">&lt;<span class="title">message</span>&gt;</span>必须的用户名<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
     <span class="tag">&lt;/<span class="title">validator</span>&gt;</span>--&gt;
     <span class="comment">&lt;!-- 在使用配置文件的時候,只使用一种配置方式 --&gt;</span>
<span class="tag">&lt;/<span class="title">validators</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">编写一个自定义校验器</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongpasswordFieldValidate</span> <span class="keyword">extends</span> <span class="title">FieldValidatorSupport</span> {</span>
    <span class="comment">//object就是当前执行的动作类的实例</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span>(Object object) <span class="keyword">throws</span> ValidationException {
        String fieldName = getFieldName();
        Object value = getFieldValue(fieldName, object);
        <span class="comment">//验证</span>
        <span class="keyword">if</span>(!(value <span class="keyword">instanceof</span> String)){
            addFieldError(fieldName, object);
        }<span class="keyword">else</span>{
            String s = (String)value;
            <span class="keyword">if</span>(!isStrong(s)){
                addFieldError(fieldName, object);
            }
        }
    }
    <span class="comment">//判断s是否强大</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP1 = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP2 = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP3 = <span class="string">"0123456789"</span>;
    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isStrong</span>(String s) {
        <span class="keyword">boolean</span> ok1 = <span class="keyword">false</span>;
        <span class="keyword">boolean</span> ok2 = <span class="keyword">false</span>;
        <span class="keyword">boolean</span> ok3 = <span class="keyword">false</span>;
        <span class="keyword">int</span> length = s.length();
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++){
            <span class="keyword">if</span>(ok1&&ok2&&ok3)
                <span class="keyword">break</span>;
            String character = s.substring(i,i+<span class="number">1</span>);
            <span class="keyword">if</span>(GROUP1.contains(character)){
                ok1 = <span class="keyword">true</span>;
                <span class="keyword">continue</span>;
            }
            <span class="keyword">if</span>(GROUP2.contains(character)){
                ok2 = <span class="keyword">true</span>;
                <span class="keyword">continue</span>;
            }
            <span class="keyword">if</span>(GROUP3.contains(character)){
                ok3 = <span class="keyword">true</span>;
                <span class="keyword">continue</span>;
            }
        }
        <span class="keyword">return</span> ok1&&ok2&&ok3;
    }
}
</pre></td></tr></table></figure>

<p>对自定义的校验器进行配置(validators.xml)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE validators PUBLIC
          "-//Apache Struts//XWork Validator Definition 1.0//EN"
          "http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">validators</span>&gt;</span>
    <span class="tag">&lt;<span class="title">validator</span> <span class="attribute">name</span>=<span class="value">"strongpassword"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.validators.StrongpasswordFieldValidate"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">validators</span>&gt;</span>
</pre></td></tr></table></figure>

<p>使用自定义的校验器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">field-validator</span> <span class="attribute">type</span>=<span class="value">"strongpassword"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">message</span>&gt;</span>密码不够强壮<span class="tag">&lt;/<span class="title">message</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">field-validator</span>&gt;</span>
<span class="tag">&lt;/<span class="title">field</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">防止表单重复提交</h1>
<p>可以利用 interceptor, 防止重复提交</p>
<ol>
<li>在输入表单中加入<s:token/>标签</li>
<li>在要防止重复提交的动作配置中加入token拦截器</li>
<li>提交会出错，需要配置一个结果</li>
<li>如果在返回的页面中要显示错误消息提示，使用s:actionErrors</li>
<li>要覆盖默认的提示，请在国际消息资源文件中加入struts.messages.invalid.token=你的提示信息</li>
</ol>
<p>加入 token 拦截器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"addUser"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"addUser"</span>&gt;</span>
     <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"token"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
     <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="comment">&lt;!-- 第一个结果视图是invalid.token --&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"invalid.token"</span>&gt;</span>/regist.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">&lt;!-- form.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">s:form</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:token</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:token</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">s:submit</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>

<span class="comment">&lt;!-- error.jsp, 显示错误信息 --&gt;</span>
<span class="tag">&lt;<span class="title">s:actionerrors</span>&gt;</span><span class="tag">&lt;/<span class="title">s:actionerrors</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">国际化显示中文信息</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 引入token的资源文件 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.custom.i18n.resources"</span> <span class="attribute">value</span>=<span class="value">"io.zhpooer.token"</span>&gt;</span> <span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="preprocessor">## 默认的国际化文件在org.message.struts2.struts-message.properties</span>
<span class="preprocessor">## io.zhpooer.token.properties</span>
struts<span class="preprocessor">.messages</span><span class="preprocessor">.invalid</span><span class="preprocessor">.token</span>=已经提交过了
struts<span class="preprocessor">.messages</span><span class="preprocessor">.error</span><span class="preprocessor">.content</span><span class="preprocessor">.type</span><span class="preprocessor">.not</span><span class="preprocessor">.allowed</span>=不允许上传的文件类型
</pre></td></tr></table></figure>

<h1 id="-">文件上传</h1>
<p>真正干活的是 <code>FileUploadInterceptor</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:file</span> <span class="attribute">name</span>=<span class="value">"resource"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:file</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadAction</span> {</span>
<span class="comment">// 如果是多个文件上传, 那么就用定义数组, 如果 File[] resource;</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> File resource;    <span class="comment">// 得到文件</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String resourceContentType; <span class="comment">// 得到文件类型 MIME</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String resourceFileName; <span class="comment">// 得到文件的名称</span>
    <span class="keyword">public</span> String <span class="title">execution</span>(){
        String bashPath = ServletContext.getServletContext().getRealPath(<span class="string">"WEB-INF/upload"</span>);
        File dir = <span class="keyword">new</span> File(bashPaht+subPath);
        dir.mkdirs();
        String path  = dir + UUIDName();
        FileUtils.copyFile(resource, <span class="keyword">new</span> File(dir)); <span class="comment">// common-io</span>
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</pre></td></tr></table></figure>

<p>配置上传文件信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 文件上传的最大值, 默认大小为2M--&gt;</span>
<span class="comment">&lt;!-- &lt;constant name="struts.multipart.maxSize" value="2097152"&gt; &lt;/constant&gt; --&gt;</span>
<span class="tag">&lt;<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fileUpload.maximumSize"</span>&gt;</span>2097152<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fileUpload.allowedExtensions"</span>&gt;</span>txt,doc,pdf <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="comment">&lt;!-- 可以在web.xml中查看, mime类型 --&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"fileUpload.allowedTypes"</span>&gt;</span>application/msword <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="-">文件的下载</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="comment">/*
&lt;action&gt;
    &lt;result type="stream"&gt;
        &lt;param name="inputName"&gt; inputStream &lt;/param&gt;
        &lt;param name="contentDisposition"&gt;
            attachment;filename=%{#fileName}.txt
        &lt;/param&gt;
    &lt;/result&gt;
&lt;/action&gt;
*/</span>
<span class="keyword">public</span> <span class="keyword">class</span> DownloadAction {
    @BeanProperty <span class="keyword">private</span> InputStream InputStream;
    <span class="keyword">public</span> String <span class="title">download</span>(){
        String fileName = <span class="string">""</span>;
        String filePath = <span class="string">""</span>;
        String encoded = URLEnocoder.encode(fileName, <span class="string">""</span>utf-<span class="number">8</span>);
        ActionContext.getContext().put(<span class="string">"fileName"</span>, encoded);
        inputStream = <span class="keyword">new</span> FileInputStream(filePath + fileName);
    }
}
</pre></td></tr></table></figure>

<h1 id="-">类型转换</h1>
<p>当数据类型及数据转换出现错误信息时, 框架自动会转向名称为input的结果集</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 输入 myname, mypassword --&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"user"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
<span class="tag">&lt;<span class="title">s:checkbox</span> <span class="attribute">list</span>=<span class="value">"{'aa', 'bb'}"</span> <span class="attribute">name</span>=<span class="value">"checkbox"</span>/&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> UserConverter extends StrutsTypeConverter {
    <span class="comment">// 从页面到Actioin的转换</span>
    <span class="keyword">public</span> Object <span class="title">convertFromString</span>(Map context, String[] values, Class clazz) {
        String[] tmp = values[<span class="number">0</span>].split(<span class="string">","</span>);
        User user = <span class="keyword">new</span> User();
        user.setUsername(tmp[<span class="number">0</span>]);
        user.setPassword(tmp[<span class="number">1</span>]);
        <span class="keyword">return</span> user;
    }
    <span class="keyword">public</span> String <span class="title">convertToString</span>(Map context, Object o) {
        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User){
            <span class="keyword">return</span> o.toString();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterAction</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> User user;
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String userName;
    <span class="annotation">@BeanProperty</span> pirvate String password;
}
</pre></td></tr></table></figure>

<p>局部类型转换器：要转换的属性所在的类相同的包下, 建立类名-conversion.properties的配置文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">## 转换的字段名称=验证类全面</span>
birthday=
</pre></td></tr></table></figure>

<p>全局类型转换器设置: 在根目录下建立 xwork-conversion.preperties</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">## 转换后的类型=转换器</span>
User=UserConverter
</pre></td></tr></table></figure>

<h1 id="-jfreechart-">使用标准插件--JFreeChart使用</h1>
<p>导入 jfreechart.jar包</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChartAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
    <span class="keyword">private</span> JFreeChart chart;
    <span class="keyword">public</span> JFreeChart <span class="title">getChart</span>() {
        <span class="keyword">return</span> chart;
    }
    <span class="keyword">public</span> String <span class="title">execute</span>() <span class="keyword">throws</span> Exception {
        ValueAxis xAxis = <span class="keyword">new</span> NumberAxis(<span class="string">"年度"</span>);
        ValueAxis yAxis = <span class="keyword">new</span> NumberAxis(<span class="string">"产值"</span>);
        XYSeries xySeries = <span class="keyword">new</span> XYSeries(<span class="string">"绿豆"</span>);
        xySeries.add(<span class="number">0</span>,<span class="number">300</span>);
        xySeries.add(<span class="number">1</span>,<span class="number">200</span>);
        xySeries.add(<span class="number">2</span>,<span class="number">400</span>);
        xySeries.add(<span class="number">3</span>,<span class="number">500</span>);
        xySeries.add(<span class="number">4</span>,<span class="number">600</span>);
        xySeries.add(<span class="number">5</span>,<span class="number">500</span>);
        xySeries.add(<span class="number">6</span>,<span class="number">800</span>);
        xySeries.add(<span class="number">7</span>,<span class="number">1000</span>);
        xySeries.add(<span class="number">8</span>,<span class="number">1100</span>);
        XYSeriesCollection xyDataset = <span class="keyword">new</span> XYSeriesCollection(xySeries);
        XYPlot xyPlot = <span class="keyword">new</span> XYPlot(xyDataset,xAxis,yAxis,<span class="keyword">new</span> StandardXYItemRenderer(StandardXYItemRenderer.SHAPES_AND_LINES));
        chart = <span class="keyword">new</span> JFreeChart(xyPlot);
        <span class="keyword">return</span> SUCCESS;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"showchart"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.ChartAction"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"chart"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"height"</span>&gt;</span>400<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
              <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"width"</span>&gt;</span>600<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="comment">&lt;!-- jsp页面 --&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
上传成功！<span class="tag">&lt;<span class="title">br</span>/&gt;</span>
  <span class="tag">&lt;<span class="title">s:url</span> <span class="attribute">action</span>=<span class="value">"showchart"</span> <span class="attribute">var</span>=<span class="value">"url"</span>&gt;</span><span class="tag">&lt;/<span class="title">s:url</span>&gt;</span>
  <span class="tag">&lt;<span class="title">img</span> <span class="attribute">alt</span>=<span class="value">"图图"</span> <span class="attribute">src</span>=<span class="value">"${url}"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</pre></td></tr></table></figure>

<p>使用插件,必须要先知道插件的用途,一般只要组织数据就好了,没必要深究.</p>
<h1 id="-url-rest-">伪装URL地址(REST)</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">public</span> String <span class="title">showAll</span>(){
    <span class="keyword">return</span> SUCCESS;
}
<span class="keyword">public</span> String <span class="title">queryOne</span>(){
    <span class="comment">//根据id的值，调用serivce，找到那个用户</span>
    List&lt;User&gt; us = getUsers();
    <span class="keyword">for</span>(User u:us){
        <span class="keyword">if</span>(id.equals(u.getId())){
            System.<span class="keyword">out</span>.println(u);
        }
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.devMode"</span> <span class="attribute">value</span>=<span class="value">"true"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.action.extension"</span> <span class="attribute">value</span>=<span class="value">"html"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.enable.SlashesInActionNames"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!--     &lt;constant name="struts.mapper.alwaysSelectFullNamespace" value="true"&gt;&lt;/constant&gt; --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.ognl.allowStaticMethodAccess"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"default"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"showAll"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"showAll"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>/list.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"users/*"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.UserAction"</span> <span class="attribute">method</span>=<span class="value">"queryOne"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"id"</span>&gt;</span>{1}<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<p>通过 <code>${pageContext.request.contextPath}/users/${id}.html</code> 访问</p>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数式编程手记]]></title>
    <link href="http://zhpooer.github.io/2014/05/16/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%89%8B%E8%AE%B0/"/>
    <id>http://zhpooer.github.io/2014/05/16/函数式编程手记/</id>
    <published>2014-05-16T07:28:50.000Z</published>
    <updated>2014-05-16T09:03:22.000Z</updated>
    <content type="html"><![CDATA[<p>历数我学习计算机语言的经历, 也算是略通八国语言的&#39;牛&#39;人啊, 什么汇编、c语言、java,
命令语言、函数式语言、面向对象编程, 统统都学习接触过.
用&quot;物竞天择, 用进废退&quot;这句话来形容现在的我, 真是最合适不过了, 这会儿回想起我最熟悉,
且能马上上手的语言就只有 Java 和 Scala -- 难道是因为工作中一直在用吗?
每当想起<code>倚天屠龙记</code>中张无忌和张三丰的对话, &quot;你忘了吗?&quot;, &quot;我已经全忘了!&quot;, &quot;好, 你的神功已经大成了!&quot;, 真实心有戚戚焉.</p>
<p>不过, 这些语言的具体细节可能会忘, 但是一些语言某些编程模式, 总会给我留下一些印象.
至于编程思想, 呵呵, 像我这种半路出家当码农的人, 还没有研究到这么深刻的地步.
而近两三年, 关于&quot;函数式编程&quot;的讨论甚嚣尘上. 而我在学习各种语言时, &quot;函数式编程&quot;时不时会从各个角落冒出来.
但是什么是&quot;函数式编程&quot;, 它和&quot;面向对象编程&quot;是什么关系, 我不了解. 所以乘今天有空闲的时间, 来研究研究吧.</p>
<p>至于如何研究, 我就不班门弄斧了, 还是看看大神们是怎么理解函数式编程的.
我把从谷歌大神那搜到的关于函数编程的文章列出来, 由浅入深, 希望对想了解这方面东西的人有帮助. </p>
<ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank">阮一峰的网络日志 函数式编程初探</a>:
讲述的是最基本的函数式知识, 浅显易懂</p>
</li>
<li><p><a href="http://coolshell.cn/articles/10822.html" target="_blank">CoolShell 函数式编程</a>:
用 Python 把命令式和函数式做了比较, 例子形象生动, 深入浅出.</p>
</li>
<li><p><a href="http://www.cnblogs.com/kym/archive/2011/03/07/1976519.html" target="_blank">博客园 函数式编程扫盲篇</a>:
对函数式的各种特点做了总结</p>
</li>
<li><p><a href="https://www.byvoid.com/blog/why-functional-programming" target="_blank">BYVoid 函数式程序设计为什么至关重要</a> : 
这是篇论文, 对函数式的语法做了代码上的解析, 用的是 Heskell 语法, 从建模一步步到实用(数值微分, 积分), 不明觉厉之</p>
</li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/bb669144.aspx" target="_blank">msdn Functional Programming vs. Imperative Programming</a>:
英文, 心有余, 力已不足, 马克之.</p>
</li>
</ul>
<p>最后附上神作 <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" target="_blank">SICP</a>, 暂不能读, 心向往之.</p>
<p>最最后, <strong>见贤思齐</strong>, <a href="http://www.ruanyifeng.com/blog/2012/04/hu_shih.html" target="_blank">阮一峰 胡适的三个主义</a></p>
<blockquote>
<p>生命本没有意义，你要给它什么意义，它就有什么意义。<br>与其终日冥想人生有何意义，不如试用此生做点有意义的事。</p>
</blockquote>
]]></content>
    
    
      <category term="笔记" scheme="http://zhpooer.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[scala文档翻译-Future&Promise]]></title>
    <link href="http://zhpooer.github.io/2014/05/15/scala%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-future&promise/"/>
    <id>http://zhpooer.github.io/2014/05/15/scala文档翻译-future&promise/</id>
    <published>2014-05-15T01:44:38.000Z</published>
    <updated>2014-05-18T03:33:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">拔</h1>
<p>上课无聊, 刚好看scala文档, 遂翻译之, 晚上回来在网上找到已经有人做过了, 且翻译的比我好(-.-!!!),
但已经翻译了一半, 兴致也不错, 那就当练习英语好了(真吊丝啊).</p>
<p>不过 Scala 2.11关于 <code>Macro</code> 和 <code>Reflect</code>的内容很没有人下手, 窃喜之. 哈哈, 我的征途是星辰大海!!!</p>
<p><a href="http://docs.scala-lang.org/overviews/core/futures.html" target="_blank">原文连接</a></p>
<p><a href="https://code.csdn.net/DOC_Scala/chinese_scala_offical_document/file/Futures-and-Promises-cn.md#anchor_0" target="_blank">已有译文连接</a></p>
<h1 id="introduction">Introduction</h1>
<p>Futures 为并发提供了许多非阻塞(non-blocking)和有效率的操作. 它的概念很简单, 一个 <code>Future</code> 就是一系列的还没有发生的操作或运算(一个运算占位符).
事实上, <code>Future</code> 的中的运算会被并行地执行, 而运行结果可以被延迟得到. 这样就可以更快地 非阻塞地 异步地 并发地执行复合并行任务.</p>
<p>实际上, future 和 promises 的非阻塞操作是利用回调函数替换掉经典的阻塞操作.
为了简化回调操作和语法的理解, Scala 提供了提供了组合子, 如  <code>flatMap</code>, <code>foreach</code> 和 <code>filter</code>,
利用这些调用可以组合 future 进行非阻塞的操作. 如果必要的话, futures 也提供了阻塞操作(虽然这并不值得提倡).</p>
<h1 id="futures">Futures</h1>
<p>一个 <code>Future</code> 是一个持有(holding)一个值的对象, 但是这个值在有些时候是取不到的. 这个值常常是一些运算的执行结果:</p>
<ol>
<li>如果这个运算还没有完成, 这个 Future 还没有完成(is not completed)</li>
<li>如果这个运算最终得到一个值, 或在执行的过程中抛出了异常(exception), 这个 Future 执行完成(completed)</li>
</ol>
<p>执行完成(Completion)的表现为下面给两种情况中的任意一种情况:</p>
<ol>
<li>当一个 Future 成功的得到一个值, 那么这个 Future 执行完成.</li>
<li>当一个 Future 在运算的时候抛出到一个异常(exception), 这个 Future 因为异常而失败了.</li>
</ol>
<p>一个 Future 只能被赋值(assigned)一次. 一旦一个 Future 对象(object)(Future内部对象?)被赋值或得到一个异常,
那么它就是不可变的(immutable), 也就是说不能被重新赋值</p>
<p>创建一个 future 对象(object)最简单的方法是调用 <code>future</code> 方法, 它会启动一个异步的运算,
然后返回一个指向这次运行的结果的 future. 一旦这个 future 执行完成, 就可以得到这次运算结果.</p>
<p><code>Future[T]</code> 是一个表示 future 对象(objects)的类型(type).
然而, <code>future</code>是一个生成和调度异步运算的方法, 它返回一个代表<em>将要得到</em>(will)运算结果的 future 对象.</p>
<p>这个特性将通过一个案例展示.</p>
<p>假设我们要调用一个虚构(hypothetical)的 API 从一个社交网络得到一个给定用户的好友列表.
我们将会打开一个新的会话(session),然后发送请求(request)去获取一个特殊用户的的好友列表:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>import scala<span class="preprocessor">.concurrent</span>._
import ExecutionContext<span class="preprocessor">.Implicits</span><span class="preprocessor">.global</span>
val session = socialNetwork<span class="preprocessor">.createSessionFor</span>(<span class="string">"user"</span>, credentials)
val f: Future[List[Friend]] = future {
    session<span class="preprocessor">.getFriends</span>()
}
</pre></td></tr></table></figure>

<p>上边这段代码中, 我们首先导入(import)了 <code>scala.concurrent</code> 包中的内容, 使得 <code>Future</code>
类型和 <code>future</code>构造器可见.对于第二个导入,我们将在稍后解释.</p>
<p>接着, 我们用一个虚构的方法<code>createSessionFor</code>初始化了 session 变量, 我们将用它来给服务端发送请求.
为了得到一个用户的好友列表, 需要通过网络发送一个请求, 这需要花费很长的时间.
这些操作被封装(illustrated)在 <code>getFriends</code>方法, 它返回 <code>List[Friend]</code>.
为了更好地利用CPU资源直到请求返回, 我们不应该阻塞接下来的程序, 所以这些操作(computation)应该被异步的执行(scheduled).
<code>future</code>方法并发地执行了给定的运算代码块(computation block), 这样就可以发送请求(request)给服务端, 并且等待响应(response)</p>
<p>一旦服务器响应, 好友列表(list of friends)可以从 future <code>f</code>中得到.</p>
<p>一次不成功的操作(attempt)将会得到一个异常(exception). 在下面的例子中, <code>session</code> 没有正常初始化,
所以 <code>futrue</code>代码块在执行时, 将会抛出 <code>NullPointerException</code>. futrue <code>f</code> 将会执行失败(failed).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">val</span> session = <span class="keyword">null</span>
<span class="keyword">val</span> f: Future[List[Friend]] = future {
  session.getFriends
}
</pre></td></tr></table></figure>

<p><code>import ExecutionContext.Implicits.global</code>,
这行代码导入(import)了全局默认执行环境(default global execution context).
执行环境(execution context)会执行被提交过来的任务, 你也可以认为执行环境是线程池(thread pools).
它们(execution context)对 <code>future</code> 方法非常重要, 因为它们决定了(handle)什么时候以及怎样异步的执行运算.
你也可以定义自己的执行环境, 用来使用 <code>future</code>, 但是对于上面的代码来说, 导入默认的执行空间就已经够用了.</p>
<p>上面的例子是基于一个虚构的社交网络 API, 它需要通过网络发送请求和等待响应.
你也可以尝试一些其他的关于异步运算的操作. 假设你有一个文本文件(text file),
你想从中找到一个单词第一次出现的位置. 等从硬盘上读取这个文件时候, 这个操作可能会阻塞,
所以可以和剩下的代码块并发地执行.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>val firstOccurrence: Future[Int] = future {
  val source = scala<span class="preprocessor">.io</span><span class="preprocessor">.Source</span><span class="preprocessor">.fromFile</span>(<span class="string">"myText.txt"</span>)
  source<span class="preprocessor">.toSeq</span><span class="preprocessor">.indexOfSlice</span>(<span class="string">"myKeyword"</span>)
}
</pre></td></tr></table></figure>

<h2 id="callbacks">Callbacks</h2>
<p>我们现在知道了如何区启动以个异步的计算得到一个新的 future 值,
但是我们还不知道如何去得到这个已经就位的结果, 现在我们可以对它做一些操作了.
我们通常只对运算的结果感兴趣, 但不包括它的副作用(side-effect).</p>
<p>在许多 future 的实践中, 一旦 future 的使用者对其结果感兴趣, 它会阻塞
它自己的运算知道 future 的值就位--以至于用future的值执行他自己的运算.
虽然 Scala <code>Future</code> 允许这样的操作(我们接下来会讲到),
但是从性能的角度来看, 还有一个完全非阻塞的方式, 那就是注册 future 的回调方法(callback).
一旦future的值就绪, 这个回调方法会被异步的执行.
如果当注册回调函数(callback)时, future的值已经就绪, 那么回调函数将会被异步地执行, 或者
在相同的线程中同步(sequentially)地执行.</p>
<p>最常用的注册回调方法的方式是用 <code>onComplete</code> 方法, 它的传入一个类型为 <code>Try[T] =&gt; U</code> 的回调函数.
如果 future 执行成功, 那么回调函数会接收到一个类型为 <code>Success[T]</code> 的值,
否则会接收到一个类型为 <code>Failure[T]</code> 的值.</p>
<p><code>Try[T]</code> 类似于 <code>Option[T]</code> 或者 <code>Either[T,S]</code>, 它是可以持有某种类型的单子(monad).
而现在, 它已经被设计成持有一个值(value) 或者一个异常对象(throwable object)的类型.
而一个 <code>Option[T]</code>对象, 不是代表一个值(<code>Some[T]</code>), 就是代码没有值(<code>None</code>),
<code>Try[T]</code>则表示, 当执行成功时, 它是<code>Success[T]</code>, 当执行失败时抛出错误时, 它就是 <code>Failure[T]</code>.
<code>Failure[T]</code> 不像 <code>None</code>, 它存储了许多关于为什么得不到最终值的信息.
同时你也可以认为 <code>Try[T]</code> 是 <code>Either[Throwable, T]</code>的特殊版本.</p>
<p>回到我们刚才的社交网络的例子, 假设我们想要拉取(fetch)自己近期的一些帖子, 并显示在屏幕上.
我们会调用 <code>getRecentPosts</code> 方法, 它会返回一个近期关于帖子的列表 <code>List[String]</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="reserved">import</span> scala.util.{Success, Failure}

val <span class="attribute">f</span>: Future[List[String]] = future {
  session.getRecentPosts
}
f onComplete {
  <span class="reserved">case</span> Success<span class="function"><span class="params">(posts)</span> =&gt;</span> <span class="keyword">for</span> (post &lt;- posts) println(post)
  <span class="reserved">case</span> Failure<span class="function"><span class="params">(t)</span> =&gt;</span> println(<span class="string">"An error has occured: "</span> + t.getMessage)
}
</pre></td></tr></table></figure>

<p><code>onComplete</code> 方法通常都要处理成功(successfull)和失败(failed)两种运算结果.
如果要单单处理成功的结果, <code>onSuccess</code> 就可以出马了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>val f: Future[<span class="keyword">List</span>[<span class="keyword">String</span>]] = future <span class="list">{
  session.getRecentPosts
}</span>
f onSuccess <span class="list">{
  case posts =&gt; for (post &lt;- posts) println(post)
}</span>
</pre></td></tr></table></figure>

<p>同样可以用<code>onFailure</code>来处理运算失败的结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>val f: Future[<span class="keyword">List</span>[String]] = future {
  session.getRecentPosts
}
f onFailure {
  <span class="keyword">case</span> t =&gt; println(<span class="string">"An error has occured: "</span> + t.getMessage)
}
f onSuccess {
  <span class="keyword">case</span> posts =&gt; <span class="keyword">for</span> (post &lt;- posts) println(post)
}
</pre></td></tr></table></figure>

<p>只有 future执行失败时, <code>onFailure</code> 回调才会被执行, 因此, 它包含了一个异常(exception).</p>
<p>如果回调函数只定义了要处理某个特殊的异常类型, 只有当这个异常出现时,
<code>onFailure</code>方法才会触发这个回调(利用偏函数(partial functions)的<code>isDefinedAt</code>) 方法.
下面例子中, 注册的<code>onFailure</code> 回调方法将永远都不会被触发:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val f = future {
  <span class="number">2</span> / <span class="number">0</span>
}
f onFailure {
  <span class="keyword">case</span> npe: NullPointerException =&gt;
    println(<span class="string">"I'd be amazed if this printed out."</span>)
}
</pre></td></tr></table></figure>

<p>回到我们之前关于查找单词第一个出现位置的案例, 你也许想要在屏幕输出这个单词的位置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>val firstOccurrence: Future[Int] = future {
  val source = scala<span class="preprocessor">.io</span><span class="preprocessor">.Source</span><span class="preprocessor">.fromFile</span>(<span class="string">"myText.txt"</span>)
  source<span class="preprocessor">.toSeq</span><span class="preprocessor">.indexOfSlice</span>(<span class="string">"myKeyword"</span>)
}
firstOccurrence onSuccess {
  case idx =&gt; println(<span class="string">"The keyword first appears at position: "</span> + idx)
}
firstOccurrence onFailure {
  case t =&gt; println(<span class="string">"Could not process file: "</span> + t<span class="preprocessor">.getMessage</span>)
}
</pre></td></tr></table></figure>

<p><code>onComplete</code>, <code>onSuccess</code>, <code>onFailure</code> 方法返回的类型是 <code>Unit</code>,
这就意味着这些方法的调用不能被链式调用(chained).
这样的设计是刻意为之, 因为链式调用也许暗示着按照一定的顺序注册回调函数
(那么就可以无序地在同一个futre中注册回调函数)</p>
<p>也就是说, 我们现在可以讨论回调函数<em>什么时候</em>会被调用.
因为这些回调函数需要 future 中的值, 所以直到 future 执行完成后, 它们才会被调用.
然而, 也不能保证调用它们(callback)的线程是完成 futre 的线程或者创造回调函数的线程.
反而, 当 future 执行完毕后, 在一定时间内回调函数会被一些其他线程执行.
也就是说回调函数最终会被执行.</p>
<p>更进一步的说, 回调函数被执行的顺序不是固定的, 甚至在多次运行的同一个应用程序中.
实际上, 回调函数会不会被一个接一个地调用, 而是会被并行(concurrently)的执行.
这就意味着在下面的例子中, totalA 的值就不确定是表示大写<code>a</code>的数量还是表示小写<code>a</code>的数量.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="property">@volatile</span> <span class="reserved">var</span> totalA = <span class="number">0</span>
val text = future {
  <span class="string">"na"</span> * <span class="number">16</span> + <span class="string">"BATMAN!!!"</span>
}
text onSuccess {
  <span class="reserved">case</span> txt<span class="function"> =&gt;</span> totalA += txt.count(_ == <span class="string">'a'</span>)
}
text onSuccess {
  <span class="reserved">case</span> txt<span class="function"> =&gt;</span> totalA += txt.count(_ == <span class="string">'A'</span>)
}
</pre></td></tr></table></figure>

<p>在上面的例子中, 两个回调函数可能一个一个顺序执行, 那么 <code>totalA</code> 的值就为18.
然而, 它们也可能并发的执行, 所以 <code>totalA</code> 的值不是16就是2,
只是因为 <code>+=</code> 不是原子性操作(atomic operation)(它由读和写两部分组成)</p>
<p>考虑到表述的完整性, 回调函数的使用的语法如下:</p>
<ol>
<li>在 future 中注册一个 <code>onComplete</code> 回调, future 执行完成后, 回调函数最终会被执行.</li>
<li>用注册 <code>onComplete</code> 的语法, 注册一个 <code>onSuccess</code> 或 <code>onFailure</code>,
它们只会在 future 执行成功或执行失败分别调用.</li>
<li>在一个已经执行完成的 future 中, 注册回调函数, 这个回调函数最终还是会被调用.</li>
<li>在 future 中注册多个回调函数的情况下, 它们的执行顺序不是固定的.
实际上, 回调函数会被并发地执行. 然而, 特定的 <code>ExecutionContext</code> 实现可能会按明确的顺序来执行.</li>
<li>如果一些回调函数抛出了异常, 其他回调函数会不受影响, 继续执行.</li>
<li>在某些情况下, 有些回调函数永远不会结束(可能包含了无限循环), 其他的回调函数就可能不会被执行到.
在这种情况下, 一个潜在的阻塞回调必须使用 <code>blocking</code> 构造函数(下面有介绍)</li>
<li>一旦执行, 回调函数将会从 future 中移除, 这样方便垃圾回收器回收. </li>
</ol>
<h2 id="functional-composition-and-for-comprehensions">Functional Composition and For-Comprehensions</h2>
<p>尽管前面介绍的回调机制已经足够把 future 的结果和后继计算结合起来.
然而在有时候回调机制并不易于使用, 且会造成冗余的代码.
我们可以通过一个案例来说明. 假使我们有一个 关于货币交易系统的API.
假设这适合的点, 我们想买入美元. 我们先展示一下如何用回调来进行这个操作.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>val rateQuote = future {
    connection.getCurrentValue(USD)
}
rateQuote onSuccess { <span class="keyword">case</span> quote =&gt;
    val purchase = future {
        <span class="keyword">if</span> (isProfitable(quote)) connection.buy(amount, quote)
        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"not profitable"</span>)
    }
    purchase onSuccess {
        <span class="keyword">case</span> _ =&gt; println(<span class="string">"Purchased "</span> + amount + <span class="string">" USD"</span>)
    }
}
</pre></td></tr></table></figure>

<p>一开始我们创建一个获取货币交易的 future <code>rateQuote</code>.
当从服务端得到数据, future 执行成功后, 计算执行操作才会进入 <code>onSuccess</code> 回调,
这时, 我们开始决定买还是不买. 因此我们创建了另一个 future <code>purchase</code>,
用来在可盈利的情况下做出购买决定, 然后向服务器发出请求.
最后, 一旦购买完成, 我们会在标准输出中打印一条通知消息.</p>
<p>这确实是可以行的, 但是由两点原因是这种方法并不方便.
其一, 我们不得不使用 <code>onSuccess</code>, 且在其中嵌套调用 <code>purchase</code> future.
假设, 我们要在 <code>purchase</code> 执行完成后卖出一些货币.
这时我们不得不在<code>onSuccess</code>回调中重复这个模式, 从而使代码过度嵌套, 冗长且难以理解.</p>
<p>其二, future <code>purchase</code> 没有在其余代码的范围内, 它只能在<code>onSuccess</code>回调内部响应.
这就意味着其他部分的程序是取不到 <code>purchase</code> future,
也不能注册其他的 <code>onSuccess</code> 回调函数, 比如说卖掉些货币.</p>
<p>基于这两个原因, futures 提供了组合器(combinators)使之具有了更加易用的组合形式.
<code>map</code>是最基础的组合器之一, 当给定一个 future 和一个映射函数(mapping function)来出来future的值,
映射方法会产生一个新的future, 一旦最初的 future 成功地执行, 新的future会通过该返回值完成计算.
你能够像理解容器(collections)的map一样来理解future的map.</p>
<p>让我们用 <code>map</code> 组合子来重写上面的一个案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>val rateQuote = future {
  connection.getCurrentValue(USD)
}

val purchase = rateQuote map { quote =&gt; 
  <span class="keyword">if</span> (isProfitable(quote)) connection.buy(amount, quote)
  <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"not profitable"</span>)
}

purchase onSuccess {
  <span class="keyword">case</span> _ =&gt; println(<span class="string">"Purchased "</span> + amount + <span class="string">" USD"</span>)
}
</pre></td></tr></table></figure>

<p>通过对<code>rateQuote</code>使用 <code>map</code>, 我们减少了一次 <code>onSuccess</code>回调, 更重要的是避免了嵌套调用.
如果我们现在决定要卖掉一些其他货币, 就可以再次对 <code>purchase</code> 使用 <code>map</code>了.</p>
<p>但是如果 <code>isProfitable</code> 返回 <code>false</code>, 因此引起了一个异常, 那怎么办呢?
在这种情况下, <code>purchase</code> 会因为异常而失败. 更进一步地说, 如果连接服务器失败,
使得 <code>getCurrentValue</code> 抛错, 最终使 <code>rateQuote</code> 失败了呢?
在这种情况下, 我们将不能获得值去使用map, 以至于 <code>purchase</code> 自动地以和<code>rateQuote</code>相同的异常
而执行失败.</p>
<p>总之, 如果最初的 future 执行成功了, 那么返回的值将会和 map 函数一起执行成功.
如果 map 函数抛出了异常, 那么 future 就会带着该异常而失败.
如果最初的future以异常结束, 那么那个返回的future也会以同样的失败结束.
这种异常传导机制会适用于其他组合子(combinators).</p>
<p>这种设计也同样被用于for语法(for-comprehensions).
所以, futrues 同样也有 <code>flatMap</code>, <code>filter</code> 和 <code>foreach</code> 组合子.
<code>flatMap</code> 方法传入一个函数, 它把值映射到一个新的 future <code>g</code>, 一旦 <code>g</code>执行完成, 就返回一个
future.</p>
<p>假设我们想把一些美元换成瑞士法郎(CHF). 我们要拉取两个货币的报价,
接着根据两个报价来决定如何购买. 下面是一个在for-comprehensions中使用<code>flatMap</code>和<code>withFilter</code>的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">val</span> usdQuote = future { connection.getCurrentValue(USD) }
<span class="keyword">val</span> chfQuote = future { connection.getCurrentValue(CHF) }

<span class="keyword">val</span> purchase = <span class="keyword">for</span> {
  usd &lt;- usdQuote
  chf &lt;- chfQuote
  <span class="keyword">if</span> isProfitable(usd, chf)
} <span class="keyword">yield</span> connection.buy(amount, chf)

purchase onSuccess {
  <span class="keyword">case</span> _ =&gt; println(<span class="string">"Purchased "</span> + amount + <span class="string">" CHF"</span>)
}
</pre></td></tr></table></figure>

<h2 id="projections">Projections</h2>
<h2 id="extending-futures">Extending Futures</h2>
<h1 id="blocking">Blocking</h1>
<h1 id="exceptions">Exceptions</h1>
<h1 id="promises">Promises</h1>
<h1 id="utilities">Utilities</h1>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="翻译" scheme="http://zhpooer.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day30-struts拦截器]]></title>
    <link href="http://zhpooer.github.io/2014/05/15/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day30-struts%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://zhpooer.github.io/2014/05/15/传智播客day30-struts拦截器/</id>
    <published>2014-05-15T01:09:51.000Z</published>
    <updated>2014-05-20T02:00:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">拦截器</h1>
<p>拦截器的目的: 如果一个业务逻辑方法中涉及到的逻辑相当复杂,
可以把这些业务分离开, 如 启动日志, 权限检查, 文件上传, 保存用户,
把这四方面全面分开, 实现松耦合</p>
<p>意义: 把一些和业务逻辑没有关联的代码放入拦截器, 以实现业务逻辑和其他代码的松耦合</p>
<h2 id="-">拦截器初探</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorAction</span> <span class="title">extend</span> <span class="title">ActionSupport</span> {</span>
    <span class="keyword">public</span> String <span class="title">saveUser</span>() {
        ActionContext().getContext().put(<span class="string">"message"</span>, <span class="string">"userSaved"</span>);
        <span class="keyword">return</span> <span class="string">"privilege"</span>
    }
}
<span class="comment">// 拦截器</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(){}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(){}
    <span class="keyword">public</span> String <span class="title">intercept</span>(ActionInvocation action) {
         String username = ServletActionContext.getRequest().getParameter(<span class="string">"username"</span>)
         <span class="keyword">if</span>(<span class="string">"admin"</span>.equals(username)) {
             <span class="keyword">return</span> action.invoke();
         } <span class="keyword">else</span> {
             ActionContext().getContext().put(<span class="string">"message"</span>, <span class="string">"权限不足"</span>);
             <span class="keyword">return</span> <span class="string">"privilege"</span>
         }
    }
}
</pre></td></tr></table></figure>

<p>声明拦截器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"privilege"</span> <span class="attribute">class</span>=<span class="value">"cn..**"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="comment">&lt;!-- 声明一个拦截器栈 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"privilegeStack"</span>&gt;</span>
            <span class="comment">&lt;!-- 引用默认拦截器栈 --&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="comment">&lt;!-- 引用自己的连接器 --&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"privilege"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="comment">&lt;!-- 让struts 执行声明的拦截器栈, 和拦截器 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"privilegeStack"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">概念</h2>
<ol>
<li>拦截器, 实现 Interceptor 接口的一个类</li>
<li>拦截器栈, 把很多个拦截器集中在一起</li>
<li>struts有一个默认拦截器栈, 该栈在 <code>struts-default.xml</code> 中声明, 结构为: <figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="comment">&lt;!-- 声明拦截器 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"name1"</span> <span class="attribute">class</span>=<span class="value">""</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"name2"</span> <span class="attribute">class</span>=<span class="value">""</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="comment">&lt;!-- 声明拦截器栈 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span>
            <span class="comment">&lt;!-- 引用拦截器栈 --&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"name1"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"name2"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="comment">&lt;!-- 让struts 内部执行默认的拦截器栈, 和拦截器 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="-">拦截器执行</h2>
<p>执行顺序: 按照拦截器的声明顺序, 从上到下执行, 执行完拦截器以后, 再执行 <code>Action</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"privilegeStack"</span>&gt;</span>
<span class="comment">&lt;!-- 从上到下执行 --&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"privilege"</span>&gt;</span> <span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
</pre></td></tr></table></figure>

<p>一个 pacakge 中可以有</p>
<ol>
<li>结果集</li>
<li>拦截器</li>
<li>action</li>
</ol>
<p>可以通过继承package, 来复用 <code>interceptor</code> 配置信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 声明intercept包,在内部使用公用拦截器 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"intercept"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span> <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="comment">&lt;!-- 复用intercept拦截--&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">extends</span>=<span class="value">"intercept"</span>&gt;</span> <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span> <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">案例: 执行效率统计拦截器</h2>
<p>建立拦截器ElapsedTimeInterceprot实现Interceptor接口</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">//动作方法及结果处理耗时统计拦截器</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElapsedTimeInterceprot</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> {</span>
    <span class="keyword">public</span> String <span class="title">intercept</span>(ActionInvocation invocation) <span class="keyword">throws</span> Exception {
        <span class="keyword">long</span> beginTime = System.nanoTime();<span class="comment">//纳秒：1毫秒=1000000纳秒</span>
        String result = invocation.invoke();<span class="comment">//放行：拦截前要做的事放在invocation.invoke()之前，拦截后放在之后</span>
        <span class="comment">//结果处理完毕后执行</span>
        <span class="keyword">long</span> endTime = System.nanoTime();
        System.out.println(invocation.getInvocationContext().getName()+<span class="string">"动作执行耗时："</span>+(endTime-beginTime)+<span class="string">"纳秒"</span>);
        <span class="keyword">return</span> result;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>() {}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>() {}
}
</pre></td></tr></table></figure>

<p>进行配置文件设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.ElapsedTimeInterceprot"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"test1"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.HelloAction1"</span> <span class="attribute">method</span>=<span class="value">"test1"</span>&gt;</span>
        <span class="comment">&lt;!-- 需要获取request，所以必须先执行servletConfig拦截器 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="comment">&lt;!-- 执行耗时统计拦截器 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>/1.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<p>拦截器的扩展，定义拦截器小组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.ElapsedTimeInterceprot"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="comment">&lt;!-- 自己定义一个拦截器小组 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"test1"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.HelloAction1"</span> <span class="attribute">method</span>=<span class="value">"test1"</span>&gt;</span>
        <span class="comment">&lt;!-- 执行自定义的拦截器小组 --&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>/1.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<p>继续扩展配置设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"mypackage"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span> <span class="attribute">abstract</span>=<span class="value">"true"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">interceptors</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.ElapsedTimeInterceprot"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor</span> <span class="attribute">name</span>=<span class="value">"sessionCheck"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.interceptors.SessionCheckInterceptors"</span>&gt;</span>
            <span class="comment">&lt;!-- 说明test2动作方法不需要拦截 --&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"excludeMethods"</span>&gt;</span>test2<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor</span>&gt;</span>
        <span class="tag">&lt;<span class="title">interceptor-stack</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"defaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"elapsedTime"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
            <span class="tag">&lt;<span class="title">interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"sessionCheck"</span>&gt;</span><span class="tag">&lt;/<span class="title">interceptor-ref</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">interceptor-stack</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">interceptors</span>&gt;</span>
    <span class="comment">&lt;!-- 设置该包中的所有action配置默认拦截器 ，每个包只能指定一个默认拦截器 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-interceptor-ref</span> <span class="attribute">name</span>=<span class="value">"myDefaultStack"</span>&gt;</span><span class="tag">&lt;/<span class="title">default-interceptor-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">案例: 用户登陆拦截器</h2>
<p>是否登陆拦截器MethodFilterInterceptor(可以配置是否进行拦截excludeMethods属性,如上)</p>
<p>权限判断拦截器继承MethodFilterInterceptor类，这样只对某些方法起作用，而对其他方法不起作用。 (配置文件如上)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">//执行动作方法前检查用户是否已经登录</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionCheckInterceptors</span> <span class="keyword">extends</span> <span class="title">MethodFilterInterceptor</span>{</span>
    <span class="keyword">protected</span> String <span class="title">doIntercept</span>(ActionInvocation invocation) <span class="keyword">throws</span> Exception {
        String result = <span class="string">"login"</span>;<span class="comment">//对应的就是一个结果</span>
        HttpSession session = ServletActionContext.getRequest().getSession();
        User user = (User)session.getAttribute(<span class="string">"user"</span>);
        <span class="keyword">if</span>(user!=<span class="keyword">null</span>)
            <span class="comment">//如果用户有登录，则放行。</span>
            result = invocation.invoke();
        <span class="comment">//如果用户没有登录，则返回结果集。</span>
        <span class="keyword">return</span> result;
    }
}
</pre></td></tr></table></figure>

<p>配置文件需要在结果集中增加一个:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"login"</span>&gt;/login.jsp&lt;/<span class="constant">result</span>&gt;
</pre></td></tr></table></figure>

<h2 id="-">属性驱动</h2>
<p>在Action中声明一些属性, 这些属性能够获取表单中的值</p>
<p>在浏览器提交一个url请求时, 先创建一个action, 并且把action放入对象栈中,
这个时候action的属性会出现在对象栈中,
然后经过一个拦截器ParametersInterceptor拦截器,</p>
<ol>
<li>获取页面上的表单中的name和value值</li>
<li>把上述name和value的值封装成一个map</li>
<li>根据 valueStack.setValue(name, value); 把页面上的值放到页面栈中</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">&lt;!-- form.jsp --&gt;</span>
<span class="comment">&lt;!-- 提交表单后, action重新返回form.jsp, username会被设为 "aaa"
     也可以回显表单元素如 property.username 和 property.password
--&gt;</span>
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"{contextPath}/PropertyDriveAction_actionMethod"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"username"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:password</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:password</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"phone"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:textfield</span>&gt;</span>
    
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">name</span>=<span class="value">"username"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">name</span>=<span class="value">"phone"</span>&gt;</span> <span class="tag">&lt;/<span class="title">s:property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyDiveActionAction</span> {</span>
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String useranme;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String password;
    <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String phone;
    <span class="keyword">public</span> String <span class="title">actionMethod</span>(){
       println(username); <span class="comment">// 可以得到 表单元素</span>
       println(password);
       println(phone);
       ActontionContext().getContext().getValueStack().setParameter(<span class="string">"username"</span>, <span class="string">"aaa"</span>);
       <span class="keyword">return</span> <span class="string">"form.jsp"</span>;
    }
}
</pre></td></tr></table></figure>

<h3 id="tip">Tip</h3>
<p>属性驱动了利用了对象栈, 可以利用 <code>valueStack.setValue/setParameter</code>
方法给对象中的属性赋值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>person = Person{name=hello}<span class="comment">;</span>
valueStack<span class="preprocessor">.push</span>(person)<span class="comment">;</span>
valueStack<span class="preprocessor">.setValue</span>(<span class="string">"name"</span>, <span class="string">"hello2"</span>)<span class="comment">;</span>
assert(person<span class="preprocessor">.name</span> == <span class="string">"hello2"</span>)
</pre></td></tr></table></figure>

<h2 id="-">模型驱动</h2>
<ol>
<li>创建一个javabean, javabean中的属性和页面中表单的name属性的内容保持一致</li>
<li>在Action中声明一个接口 ModelDriven<Person></li>
<li>在action中声明一个属性 <code>model = new Person</code></li>
<li>在action中重写 <code>getModel(){return model;}</code>, 返回 model 对象</li>
</ol>
<p>原理, 经历两个拦截器</p>
<ol>
<li>ModelDrivenIntercetper<ol>
<li>得到action</li>
<li>由action强制转化成ModelDriver</li>
<li>由<code>ModelDriver.getModel()</code> 获取模型对象</li>
<li>把模型对象放入栈顶</li>
</ol>
</li>
<li>ParameterInterceptor, 把form表单的数据封装到相应的对象栈中的属性</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Person {
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> String password;
    <span class="keyword">private</span> String phone;
}
<span class="keyword">public</span> ModelDriverAction extends ActionSuppoet implements ModelDriven&lt;Person&gt; {
    <span class="keyword">private</span> Person model = <span class="keyword">new</span> Person();
    <span class="keyword">public</span> Person <span class="title">getModel</span>() {
       <span class="keyword">return</span> <span class="keyword">this</span>.model;
    }
    <span class="keyword">public</span> String <span class="title">testModel</span>(){
        println(model.getName()); <span class="comment">// 可以打印出</span>
        println(model.getPassword());
        println(model.getPhone());
        <span class="keyword">return</span> <span class="string">""</span>;
    }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="struts" scheme="http://zhpooer.github.io/tags/struts/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day29-struts深入]]></title>
    <link href="http://zhpooer.github.io/2014/05/14/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day29-struts2%E6%B7%B1%E5%85%A5/"/>
    <id>http://zhpooer.github.io/2014/05/14/传智播客day29-struts2深入/</id>
    <published>2014-05-14T01:01:10.000Z</published>
    <updated>2014-05-20T01:55:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="struts-">Struts的工作原理及核心过滤器</h1>
<p>StrutsPrepareAndExecuteFilter过滤器其实是包含2部分的</p>
<ol>
<li>StrutsPrepareFilter:做准备</li>
<li>StrutsExecuteFilter：进入Struts2的核心处理。
如果是Struts2的请求就会进入该过滤器，处理完后，不放行（由结果类负责显示）。
如果是非Struts2的请求，比如默认jsp的请求，直接放行。</li>
</ol>
<p>如果用不到其他过滤器，配置StrutsPrepareAndExecuteFilter即可;
如果用到其他过滤器，还需要使用Struts2准备好的环境，
使用<code>StrutsPrepareFilter</code>，<code>StrutsExecuteFilter</code>个过滤器，其他过滤器放在两者之间.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> struts-prepare <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/* <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>sitemesh <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/* <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> struts-execute <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/* <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<p><img src="/img/struts_core.png" alt="struts core">
showcase: 各种应用的案例，在struts2-showcase里面找各种案例</p>
<h2 id="-struts2-">访问 struts2 静态资源</h2>
<p>文档中介绍了，可以把静态资源放到org.apache.struts2.static或者template包中，
可以直接访问，例如 访问template.aaa中的bbb.css，则
<code>http://localhost:8080/day22_03_strutsStatics/struts/aaa/bbb.css</code></p>
<p>或者自己对静态资源访问的地址进行设置，在web.xml中设置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 则访问com.itheima.statics中的资源ccc.css，的地址为 --&gt;</span>
<span class="comment">&lt;!-- http://localhost:8080/day22_03_strutsStatics/struts/ccc.css --&gt;</span>
<span class="tag">&lt;<span class="title">filter</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>
    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>packages<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>com.itheima.statics<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="action-">Action的模式</h1>
<ul>
<li>action 是多实例的, 每请求一次, 将会创建一个对象</li>
<li>不存在线程安全问题</li>
</ul>
<h2 id="-">自动注入</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>&lt;form&gt;
    &lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"text"</span> name=<span class="string">"address.city"</span>/&gt;
    &lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> <span class="keyword">value</span>=<span class="string">"吃饭"</span>/&gt;
    &lt;input <span class="class"><span class="keyword">type</span>=</span><span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> <span class="keyword">value</span>=<span class="string">"睡觉"</span>/&gt;
&lt;/form&gt;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
     <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> Address address;
     <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String[] hobby;
     <span class="annotation">@Override</span> <span class="keyword">public</span> String <span class="title">execute</span>(){
         println(address.getCity());
         println(hobby); <span class="comment">// struts2 会自动注入</span>
     }
}
</pre></td></tr></table></figure>

<h2 id="-servlet-">在动作类中获取 servlet 相关对象引用</h2>
<ol>
<li><p>ServletActionContext的静态方法可以得到Servlet相关的对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>//用Servlet相关的对象request response servletContext HttpSession
HttpServletRequest request = ServletActionContext<span class="preprocessor">.getRequest</span>()<span class="comment">;</span>
HttpServletResponse response = ServletActionContext<span class="preprocessor">.getResponse</span>()<span class="comment">;</span>
ServletContext sc = ServletActionContext<span class="preprocessor">.getServletContext</span>()<span class="comment">;</span>
HttpSession session = request<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>
</li>
<li><p>实现ServletRequestAware接口，struts2框架就会把request对象注入进来，通过拦截器servletConfig。</p>
<p> Action实现如下接口，struts框架则会为其注入相应的Servlet API对象：
<code>ServletRequestAware</code>, <code>ServletResponseAware</code>, <code>ServletContextAware</code>, 实现其他对象或者功能，参考拦截器servletConfig。</p>
</li>
</ol>
<h1 id="struts2-">struts2 数据存储和显示</h1>
<p>在 servlet 中, 把数据放在<em>*request, session, application</em>域中,
在页面上利用el表达式来解决数据的存储和显示</p>
<p>OGNL表达式就是针对一个称之为OGNL根对象和一个称为OGNL Context的Map对象进行操作的语言。</p>
<p>OGNL表达式可以寻址Context内部的对象和直接调用根对象的属性或方法。</p>
<h2 id="-">获取域数据</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>ActionContext ac = ActionContext<span class="preprocessor">.getContext</span>()<span class="comment">;</span>
ac<span class="preprocessor">.put</span>(<span class="string">"p"</span>, <span class="string">"request Scope"</span>)<span class="comment">; // 相当于 req.setAttribute("", "")</span>
Map applicationMap = ac<span class="preprocessor">.getApplication</span>()
applicationMap<span class="preprocessor">.put</span>(<span class="string">"p"</span>, <span class="string">"application scope"</span>)<span class="comment">;  // servletContext.setAttribute();</span>
Map sessionMap = ac<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
sessionMap<span class="preprocessor">.put</span>(<span class="string">"p"</span>, <span class="string">"session scope"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="valuestack">ValueStack</h2>
<ul>
<li>在struts2中所有的数据都在 ValueStack 中</li>
<li>ValueStack里面有两个东西，一个是根,就是CompoundRoot，这是一个List集合，还有一个contextMap</li>
<li>ValueStack 的生命周期是一次请求, 被存在 request 域<code>&quot;struts.ValueStack&quot;</code>中</li>
<li>获得 ValueStack 有三种方式<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueStackAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> {</span>
    <span class="keyword">public</span> String <span class="title">testValueStack</span>() {
        ValueStack vs1 = ActionContext.getContext().getValueStack();
        ValueStack vs2 = ServletActionContext.getContext().getValueStack();
        ValueStack vs3 = ServletActionContext.getRequest().getAttribute(<span class="string">"struts.ValueStack"</span>);
        <span class="keyword">return</span> <span class="string">""</span>;
    }
}
</pre></td></tr></table></figure>

</li>
</ul>
<h3 id="valuestack-">ValueStack 结构分析</h3>
<p>OGNL是从一个称之为根栈和contextMap中取数据</p>
<ul>
<li><p>CompoundRoot就是根的类型。它是List。一般称之为根栈.取对象的某个属性，OGNL表达式不需要加任何东西，直接写属性即可</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 取得valueStack 中name的值,从上往下找--&gt;</span>
name:<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
<span class="comment">&lt;!-- 打印的结果是name这个字符串 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"'name'"</span>/&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>OGNL中的contextMap：key和value. 使用#开头，表示从Context里面取数据。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;s:property <span class="keyword">value</span>=<span class="string">"#session.p"</span>/&gt;
</pre></td></tr></table></figure>
</li>
<li><p>ActionContext常用的方法(Map)</p>
<ul>
<li><code>put()</code>方法和<code>get()</code>方法就是往该Context Map对象中添加数据和取数据。</li>
<li><code>getApplication()</code>得到application域中的所有attribute的map对象;</li>
<li><code>getSession()</code>得到代表session域中的所有attribute的map对象；</li>
<li><code>getParameters()</code>得到代表所有请求参数的map对象；</li>
<li><code>getLocale()</code>()得到当前用户的Locale信息，是综合了session中保存的Locale与浏览器请求消息中的Locale的结果。</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>ActionContext ac <span class="subst">=</span> ActionContext<span class="built_in">.</span>getContext();
<span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>,Object<span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span> ac<span class="built_in">.</span>getSession();
out<span class="built_in">.</span>write((<span class="built_in">String</span>)<span class="built_in">map</span><span class="built_in">.</span>get(<span class="string">"p"</span>));
ValueStack vs <span class="subst">=</span> ac<span class="built_in">.</span>getValueStack();
<span class="built_in">String</span> s <span class="subst">=</span> (<span class="built_in">String</span>)((<span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>,Object<span class="subst">&gt;</span>)vs<span class="built_in">.</span>getContext()<span class="built_in">.</span>get(<span class="string">"session"</span>))<span class="built_in">.</span>get(<span class="string">"p"</span>);
ac<span class="built_in">.</span>put(<span class="string">"username"</span>, <span class="string">"cll"</span>);<span class="comment">//向contextMap中放数据</span>
s <span class="subst">=</span> (<span class="built_in">String</span>)ac<span class="built_in">.</span>get(<span class="string">"username"</span>);<span class="comment">//取数据</span>
</pre></td></tr></table></figure>

<p>ServletActionContext类继承了ActionContext类，它额外再提供了一些方便的方法，主要是直接返回Servlet有关的API，
例如，返回HttpServletRequest和HttpServletResponse等，它内部还是调用ActionContext内部保存的那个OGNL Context Map对象。</p>
<h3 id="valuestack-">ValueStack中常用方法详解</h3>
<ul>
<li><code>pop</code> 把栈顶的remove</li>
<li><code>push</code> 放到栈顶</li>
<li><code>peek</code>获取栈顶</li>
<li><p><code>set</code> 往根栈里面放东西，如果栈顶是Map，则直接放进去，
如果不是Map，则建一个Map放进去, set方法不能设置栈顶的普通JavaBean对象的属性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>vs.set(<span class="string">"p"</span>, <span class="string">"pp"</span>);//向栈顶压入一个<span class="keyword">Map</span>(如果栈顶就是一个<span class="keyword">Map</span>，直接使用了)。<span class="keyword">map</span>中的元素的key是p，value是pp
</pre></td></tr></table></figure>
</li>
<li><p><code>setValue</code> 设置值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>//相当于从栈顶依次查找谁有setItheima(<span class="string">"牛13"</span>), 都没有则报错。不会去大Map中找
vs<span class="preprocessor">.setValue</span>(<span class="string">"itheima"</span>, <span class="string">"牛13"</span>)<span class="comment">;</span>
vs<span class="preprocessor">.setValue</span>(<span class="string">"date"</span>, <span class="number">18</span>)<span class="comment">;//某个对象的属性</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>findValue(String expr)</code>, 如果expr以#开头，从contextMap中取。
如果不加#，先从根栈找属性，没有找到。则从contextMap中，作为key来找了</p>
</li>
<li><code>findString</code> 如果找的是Date对象，内部会转换成String对象<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>ac<span class="preprocessor">.put</span>(<span class="string">"now"</span>, new Date())<span class="comment">;</span>
obj = vs<span class="preprocessor">.findValue</span>(<span class="string">"#now"</span>)<span class="comment">;</span>
<span class="keyword">out</span><span class="preprocessor">.write</span>(obj+<span class="string">" "</span>+obj<span class="preprocessor">.getClass</span>()<span class="preprocessor">.getName</span>())<span class="comment">;</span>
//类型转换器把java<span class="preprocessor">.util</span><span class="preprocessor">.Date</span>---&gt;java<span class="preprocessor">.lang</span><span class="preprocessor">.String</span>.确定表达式返回值就是String类型的才能用
String str = vs<span class="preprocessor">.findString</span>(<span class="string">"#now"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="struts2-ognl-">struts2显示(ognl)</h2>
<p>ognl: struts2的标签, 把 valueStack 中的数据显示到页面上</p>
<h3 id="-">调试</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 导入标签,位置在 struts2-core/META-INF --&gt;</span>
<span class="vbscript">&lt;%@taglib prefix=<span class="string">"s"</span> uri=<span class="string">"/struts-tags"</span>%&gt;</span>

<span class="comment">&lt;!-- 超级链接, 显示ValueStack中的内容 --&gt;</span>
<span class="tag">&lt;<span class="title">s:debug</span>/&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-valuestack-">访问 valuestack 中的数据</h3>
<p>可通过<code>&lt;s:property/&gt;</code> 标签访问栈顶元素及其栈中所有对象的属性,</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 对象栈, 栈中元素: Person{name="zhang", pid=1L},
Person2{nickname=zhang2, pid=2L}
如果不写value属性, 则输出对象栈的栈顶元素全部 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> /&gt;</span> <span class="comment">&lt;!-- 输出: Person@1245af --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: zhang --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"nickname"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: zhang2 --&gt;</span>
<span class="comment">&lt;!-- 如果对象栈中特有相同属性对象, 则访问最先找到的对象的属性 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"pid"</span>/&gt;</span>  <span class="comment">&lt;!--  输出: 1 --&gt;</span>

<span class="comment">&lt;!-- 将map放入对象栈中 --&gt;</span>
<span class="comment">&lt;!-- valueStack.set("key", "value1"); --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>  <span class="comment">&lt;!--  输出: value1 --&gt;</span>
</pre></td></tr></table></figure>

<p>访问Map栈中的值,通过<code>&lt;property value=&quot;#key&quot;/&gt;</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 键值对放入 map 栈中 --&gt;</span>
<span class="comment">&lt;!-- ActionContext().getContext().put("key", "value1") --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#key"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: value1 --&gt;</span>

<span class="comment">&lt;!-- 访问Request域中的数据 --&gt;</span>
<span class="comment">&lt;!-- ServletActionContext.getRequest().setAttribute("key", "value2") --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.key"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: value2 --&gt;</span>

<span class="comment">&lt;!-- person = Person{name=zhang, id=3L}
ServletActionContext.getRequest().setAttribute("person", person) --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.person.name"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: zhang --&gt;</span>
</pre></td></tr></table></figure>

<h4 id="property-">property 标签用法</h4>
<p><code>&lt;s:property&gt;</code>标签用于输出某个OGNL表达式的值，并进行HTML和XML实体转换，
可以认为其内部使用的是ValueStack对象的findString()方法。
如果没有设置value属性，则输出ValueStack栈顶的对象，
等效于输出“top”这个特殊的OGNL表达式，”top”表示栈顶的对象。
如果采用不加#前缀的方式输出Context中的某个对象，
这个对象必须是String类型，以此可以说明该标签内部调用的是ValueStack.findString()方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- 相当于ValueStack.findString() --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"top.name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- top代表栈顶对象,取栈顶对象中的name值  --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- 取栈顶对象 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"[1].name"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- [1]表示砍掉1个.再取第一个的name属性,后面的不管 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">default</span>=<span class="value">"木有"</span> <span class="attribute">value</span>=<span class="value">"abc"</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span><span class="comment">&lt;!-- 表示如果没有abc这个属性,则返回default的木有 --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"'&lt;hr/&gt;'"</span> <span class="attribute">escapeHtml</span>=<span class="value">"false"</span>/&gt;</span><span class="comment">&lt;!-- escapeHtml默认的是ture,表示打印&lt;hr/&gt; --&gt;</span>

<span class="comment">&lt;!--请求url:  url?a=hello  --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#parameters.a[0]"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: hello --&gt;</span>

<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#session.key"</span>/&gt;</span>

<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#application.key"</span>/&gt;</span>

<span class="comment">&lt;!-- ServletActionContext.getServletContext().setAttribute("key", "value2") --&gt;</span>
<span class="comment">&lt;!-- 从 request session application 域中依次查找--&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#attr.key"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: value2 --&gt;</span>
</pre></td></tr></table></figure>

<h3 id="ognl-">ognl 的方法调用</h3>
<p>支持方法调用, 也可以支持静态方法调用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- person = Person{name=zhang, id=3L}
     ServletActionContext.getRequest().setAttribute("person", person) --&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#request.person.getName()"</span>/&gt;</span> <span class="comment">&lt;!-- 输出: shang --&gt;</span>
</pre></td></tr></table></figure>

<h3 id="ognl-">ognl 数组输出</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="comment">&lt;!-- p1=Person{name=乙, pid=1L} --&gt;</span>
<span class="comment">&lt;!-- p2=Person{name=甲, pid=2L} --&gt;</span>
<span class="comment">&lt;!-- p3=Person{name=丙, pid=3L} --&gt;</span>
<span class="comment">&lt;!-- personlist = ArrayList(p1, p2, p3) --&gt;</span>
<span class="tag">&lt;<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">th</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span> name <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span> id <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">th</span>&gt;</span>
    <span class="comment">&lt;!-- 迭代输出集合(Collection), 数组, Map
    value 指向valueStack中要遍历的集合当前正在迭代的元素会放到栈顶
    var 指向当前遍历的元素, 放在Map栈中
    status 指向当前元素的遍历信息, 有方法
    getIndex(), isLast(), getCount(), isEven(), isOdd(), isFirst()
    begin 开始位置
    step 步长
    end 结束位置
    --&gt;</span>
    <span class="comment">&lt;!-- 方式一, 把数据放在Map栈中 --&gt;</span>
    <span class="comment">&lt;!-- ActionContext.getContext().put("personList", personList) --&gt;</span>

    <span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#personList"</span> <span class="attribute">var</span>=<span class="value">"p"</span> <span class="attribute">status</span>=<span class="value">"st"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">class</span>=<span class="value">"&lt;s:property value="</span><span class="value">#st.odd?'even':'odd'"</span>/&gt;</span>"&gt;
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"#p.pid"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
    
    <span class="comment">&lt;!-- 方式二, 把数据放在Map栈中 --&gt;</span>
    <span class="comment">&lt;!-- 如果value值不写, 则默认迭代对象栈栈顶元素
        valueStack.push(personList)--&gt;</span>
    <span class="tag">&lt;<span class="title">s:iterator</span>&gt;</span>
        <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;<span class="title">td</span>&gt;</span> <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"pid"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">td</span>&gt;</span>b
        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">其他容器的迭代</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="comment">&lt;!-- p1=Person{name=乙, pid=1L} --&gt;</span>
<span class="comment">&lt;!-- p2=Person{name=甲, pid=2L} --&gt;</span>
<span class="comment">&lt;!-- p3=Person{name=丙, pid=3L} --&gt;</span>

<span class="comment">&lt;!-- 迭代输出Map栈中的map --&gt;</span>
<span class="comment">&lt;!-- personMap = Map("person1" -&gt; p1, "person2" -&gt; p2, "perseon3" -&gt; p3) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("map", personMap) --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#map"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"value.name"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- 迭代输出Map栈中的Set --&gt;</span>
<span class="comment">&lt;!-- personSet = Set(p1, p2, p3) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("set", personSet) --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#set"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"name"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"pid"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- 迭代输出Map栈中的List&lt;Map&lt;String, Person&gt;&gt; --&gt;</span>
<span class="comment">&lt;!-- listMap = List(Map("person1"-&gt;p1, "person2"-&gt;p2)) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("listMap", listMap) --&gt;</span>
<span class="tag">&lt;<span class="title">s:iterator</span> <span class="attribute">value</span>=<span class="value">"#listMap"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:iterator</span>&gt;</span>            <span class="comment">&lt;!-- map 被放入对象栈栈顶 --&gt;</span>
        <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"key"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">value</span>=<span class="value">"value.name"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>
<span class="tag">&lt;/<span class="title">s:iterator</span>&gt;</span>

<span class="comment">&lt;!-- 迭代输出map栈中的Map&lt;String, List&lt;Person&gt;&gt; --&gt;</span>
<span class="comment">&lt;!-- 看官可以脑补, 关键点: 迭代时, 当前迭代对象会被放到栈顶, 所以不用声明 iterator.value --&gt;</span>

<span class="comment">&lt;!-- 输出 List&lt;Map&lt;String, List&lt;Person&gt;&gt;&gt;, 看官亦可脑补 --&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">其他操作标签</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">&lt;!-- &lt;s:set&gt;标签用于将某个值存入指定范围域中，
通常用于将一个复杂的ognl表达式用一个简单的变量来进行引用。 --&gt;</span>
<span class="comment">&lt;!-- scope属性：指定变量被放置的范围，该属性可以接受
application、session、request、 page或action。该属性的默认值为action --&gt;</span>
<span class="comment">&lt;!-- 给 request 域中的键值对取别名 --&gt;</span>
<span class="tag">&lt;<span class="title">s:set</span> <span class="attribute">value</span>=<span class="value">"#request.request_username"</span> <span class="attribute">var</span>=<span class="value">"newname"</span> <span class="attribute">scope</span>=<span class="value">"request"</span>/&gt;</span>
<span class="tag">&lt;<span class="title">s:property</span> <span class="attribute">valut</span>=<span class="value">"#request.newname"</span>/&gt;</span>

<span class="comment">&lt;!-- 将request域的元素压入对象栈, 并在用完之后, 从对象栈中删除初--&gt;</span>
<span class="tag">&lt;<span class="title">s:push</span> <span class="attribute">value</span>=<span class="value">"#request.request_username"</span>&gt;</span> 
    <span class="tag">&lt;<span class="title">s:property</span>/&gt;</span> <span class="comment">&lt;!--因为是在栈顶也可以用 s:property 读取元素--&gt;</span>
<span class="tag">&lt;/<span class="title">s:push</span>&gt;</span>

<span class="comment">&lt;!-- Var:赋值给变量的值。放置在request作用域中。
     如果没有设置该属性，对象被设置到栈顶。 --&gt;</span>
<span class="tag">&lt;<span class="title">s:bean</span> <span class="attribute">name</span>=<span class="value">"className"</span> <span class="attribute">var</span>=<span class="value">"myperson"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">s:param</span> <span class="attribute">name</span>=<span class="value">"pid"</span> <span class="attribute">value</span>=<span class="value">"#request.pid"</span>/&gt;</span>
    <span class="comment">&lt;!--因为是在栈顶也可以用 s:property 读取元素--&gt;</span>
<span class="tag">&lt;/<span class="title">s:bean</span>&gt;</span>

<span class="tag">&lt;<span class="title">s:if</span> <span class="attribute">test</span>=<span class="value">"#person.pid&lt;3"</span>&gt;</span> 小于三 <span class="tag">&lt;/<span class="title">s:if</span>&gt;</span>
<span class="tag">&lt;<span class="title">s:elseif</span> <span class="attribute">test</span>=<span class="value">"#person.pid&gt;3"</span>&gt;</span> 大于三 <span class="tag">&lt;/<span class="title">s:esleif</span>&gt;</span>
<span class="tag">&lt;<span class="title">s:else</span> <span class="attribute">test</span>=<span class="value">"#person.pid==3"</span>&gt;</span> 等于三 <span class="tag">&lt;/<span class="title">s:esle</span>&gt;</span>
</pre></td></tr></table></figure>

<h4 id="ui-">ui标签</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">&lt;!--
    action 为提交form表单时的url
    method 默认为post
--&gt;</span>
<span class="tag">&lt;<span class="title">s:form</span> <span class="attribute">action</span>=<span class="value">""</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">method</span>=<span class="value">""</span>&gt;</span>
   <span class="comment">&lt;!-- struts 解析后, 会自动插入表格标签,
       所以插入 &lt;table&gt; &lt;tr&gt; &lt;tr&gt; 标签时, 会与其发生冲突
       可以通过设置在struts.xml中 struts.ui.theme 为simple, 来避免冲突
       --&gt;</span>
    <span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">label</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:password</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">showpassword</span>=<span class="value">""</span> <span class="attribute">lable</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:hidden</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:submit</span> <span class="attribute">type</span>=<span class="value">"submit|button|image "</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:reset</span> <span class="attribute">type</span>=<span class="value">"input|button"</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">name</span>=<span class="value">""</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">s:texterea</span> <span class="attribute">name</span>=<span class="value">""</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">cols</span>=<span class="value">""</span> <span class="attribute">rows</span>=<span class="value">""</span> <span class="attribute">lable</span>=<span class="value">""</span>/&gt;</span>

<span class="tag">&lt;/<span class="title">s:form</span>&gt;</span>
</pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">&lt;!-- p1=Person{name=乙, pid=1L} --&gt;</span>
<span class="comment">&lt;!-- p2=Person{name=甲, pid=2L} --&gt;</span>
<span class="comment">&lt;!-- p3=Person{name=丙, pid=3L} --&gt;</span>
<span class="comment">&lt;!-- personlist = ArrayList(p1, p2, p3) --&gt;</span>
<span class="comment">&lt;!-- ActionContext.getContext().put("personList", personList) --&gt;</span>
<span class="comment">&lt;!--
     listKey 为option中的value
     listValue 为option中的标签内容
     headerKey 表示第一个option中的value
     headerValue 表示第一个option标签中的内容
--&gt;</span>
<span class="tag">&lt;<span class="title">s:select</span> <span class="attribute">list</span>=<span class="value">"#personList"</span> <span class="attribute">listKey</span>=<span class="value">"pid"</span> <span class="attribute">listValue</span>=<span class="value">"name"</span> <span class="attribute">headerKey</span>=<span class="value">""</span> <span class="attribute">headerValue</span>=<span class="value">""</span>/&gt;</span>
<span class="tag">&lt;<span class="title">checkboxlist</span> <span class="attribute">list</span>=<span class="value">"#personList"</span> <span class="attribute">listValue</span>=<span class="value">"name"</span> <span class="attribute">listKey</span>=<span class="value">"pid"</span> <span class="attribute">name</span>=<span class="value">"pid"</span>/&gt;</span>


<span class="comment">&lt;!-- 在文本框中把person中的name属性进行回显 --&gt;</span>
<span class="comment">&lt;!-- person = Person{name="test" pid=1L} --&gt;</span>

<span class="comment">&lt;!-- ActionContext.getContext.put("person", person) --&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"%{#person.name}"</span>/&gt;</span> <span class="comment">&lt;!--输出: test --&gt;</span>

<span class="comment">&lt;!-- valueStack().push(person), 放入对象栈,
     可以不加value, 根据name属性进行回显
     s:textfield, s:textarea, s:password 都可以用--&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"name"</span> /&gt;</span> <span class="comment">&lt;!--输出: test --&gt;</span>

<span class="comment">&lt;!-- TestAction{ @Beanproperty aa}
action = new testAction(); action.setAa("test2");
--&gt;</span>
<span class="tag">&lt;<span class="title">s:textfield</span> <span class="attribute">name</span>=<span class="value">"aa"</span> /&gt;</span> <span class="comment">&lt;!--输出: test2--&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="struts" scheme="http://zhpooer.github.io/tags/struts/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day28-struts入门]]></title>
    <link href="http://zhpooer.github.io/2014/05/12/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day28-struts%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/05/12/传智播客day28-struts入门/</id>
    <published>2014-05-12T01:14:18.000Z</published>
    <updated>2014-05-19T12:43:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="servlet-">Servlet 缺点</h1>
<ol>
<li>写一个 servelt 需要在 web.xml 中配置8行, 如果一个系统中servlet很多, 会导致
web.xml中文件中的内容多多</li>
<li>在项目中很多人编辑一个 web.xml 文件会出现文件冲突</li>
<li>在一个 servlet 中方法的入口只有一个, 如果在一个 servlet 中写很多方法, 这些方法
应该传递参数, 根据每次请求参数不一致来判断执行哪个方法</li>
<li>servlet 中的方法都有两个参数 request,response,这两个参数具有严重的容器依赖性,
所以在servlet不能单独测试</li>
<li>如果在表单中的元素很多, 在servlet 中要想获取表单的数据,
那么在servlet的方法必须调用大量的 <code>request.getParameter()</code></li>
<li>在一个servlet属性中声明一个数据, 会存在线程安全问题</li>
</ol>
<p>优点: 因为是最底层的mvc, 所以效率比较高</p>
<p>很多项目中对servlet 进行了重构, 重构目标是:</p>
<ol>
<li>更有利于团队协作开发</li>
<li>把servlet的缺点一次进行修改</li>
</ol>
<h1 id="-servlet">重构 Servlet</h1>
<p>在 web.xml 文件中只写一个servlet, 中控servlet</p>
<p>model 层为action</p>
<p>在中控 servlet 中利用java 的反射机制动态调用该action</p>
<h2 id="-">重构效果</h2>
<p>只写一个servlet</p>
<p>只需要在 web.xml 配置一个 servlet</p>
<h2 id="-">步骤</h2>
<ul>
<li><p>创建一个servlet</p>
<p>  需求: 访问 <code>http://localhost:8080/userAction.action</code>, 调用 <code>UserAction.execute()</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>ActionListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
<span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>...<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-parttern</span>&gt;</span>*.actions<span class="tag">&lt;/<span class="title">url-parttern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>写一个监听器</p>
<p>  写一个监听器, 在该监听器中写一个Map, map中的key存放url的action中的部分: userAction, 
  value 存放对应类的字符串形式, 把该map放入到application域中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span>(ServletContextEvent e) {
        e.getSevletContext().setAttribute(<span class="string">"actions"</span>, <span class="keyword">null</span>);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span>(ServletContextEvent e) {
       Map map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();
       map.put(<span class="string">"userAction"</span>, <span class="string">"cn.itcast.Action.UserAction"</span>);
       e.getSevletContext().setAttribute(<span class="string">"actions"</span>, map);
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>中控 servlet 执行</p>
<ol>
<li>把url中的urserAction做一个解析</li>
<li>提取 application 域中的map, 根据 userAction key, 找到value</li>
<li>执行 <code>UserAction.execute(request, response)</code></li>
</ol>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp){
        String fullActionName = req.getRequestURI().subString(req.getContextPath().length); <span class="comment">// userAction.action</span>
        String actionName = fullActionName.replace(<span class="string">"^(.*)\\.action"</span>, <span class="string">"$1"</span>);
        Map actionMap = getServletContext().getAttribute(<span class="string">"actions"</span>);
        String actionClassName = actionMap.get(actoinName);
        String clazz = Class.forName(actionClassName);
        Method m = clazz.getMethod(<span class="string">"execute"</span>, HttpServletRequest.class, HttpServletResponse.class);
        String result = method.invoke(clazz.newInstance(), req, resp); <span class="comment">// 返回要转发地址</span>
        req.getRequestDispatcher(result).forward(req, resp);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span>(req, resp) { doGet(req, resp); }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> {</span>
    <span class="keyword">public</span> string <span class="title">execute</span>(HttpServletRequest res, HttpServletResponse resp) {
        <span class="keyword">return</span> <span class="string">"index.jsp"</span>;
    }
}
</pre></td></tr></table></figure>

<h1 id="servlet-">Servlet 进化史</h1>
<ol>
<li>03-05, mvc框架是 servlet</li>
<li>apache 的 struts1,实现松耦合 , 没由解决容器依赖性问题</li>
<li>webwork, 让action没有任何容器依赖性, 把文件上传, 检验工作和保存用户的工作松耦合</li>
<li>struts 和 webwork整合成struts2</li>
</ol>
<h1 id="struts-helloworld">Struts HelloWorld</h1>
<p>导入包:</p>
<ul>
<li>freemarker, 模板</li>
<li>ognl, 表达式, 为了显示存储在数据, 功能类似于el表达式</li>
<li>struts2-core, struts核心包</li>
<li>xworks-core, web-work核心包</li>
</ul>
<ol>
<li><p>编写Web.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>&lt;<span class="built_in">filter</span>&gt;
    &lt;<span class="built_in">filter</span>-name&gt;struts2 &lt;/<span class="built_in">filter</span>-name&gt;
    &lt;<span class="built_in">filter</span>-<span class="keyword">class</span>&gt;
        org.apache.struts2.dispatcher.ng.<span class="built_in">filter</span>.strutsPrepareAndExecuteFilter
    &lt;/<span class="built_in">filter</span>-<span class="keyword">class</span>&gt;
&lt;/<span class="built_in">filter</span>&gt;
&lt;<span class="built_in">filter</span>-mapping&gt;
    &lt;<span class="built_in">filter</span>-name&gt;struts2 &lt;/<span class="built_in">filter</span>-name&gt;
    &lt;url-pattern&gt;/* &lt;/url-pattern&gt;
&lt;/<span class="built_in">filter</span>-mapping&gt;
</pre></td></tr></table></figure>
</li>
<li><p>编写Action</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> HelloWorldAction {
    <span class="keyword">public</span> String <span class="title">execute</span>(){
        println(<span class="string">"hello"</span>)
        <span class="keyword">return</span> <span class="string">"index"</span>;
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>写配置文件, 在src下面写一个 struts.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">struts</span>&gt;</span>
    <span class="comment">&lt;!-- package 功能是用来管理 action 的, 一般情况下package是针对模块划分的 --&gt;</span>
    <span class="comment">&lt;!-- name 为 package 的名称, 是唯一的 --&gt;</span>
    <span class="comment">&lt;!-- extends 实际上是把 package 中 name为 *struts-default* 包中所有的功能继承下来 --&gt;</span>
    <span class="comment">&lt;!-- namespace 设置访问的相对路径, 和 配置 action 转向到jsp页面时的查找路径--&gt;</span>
    <span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"helloworld"</span> <span class="attribute">namespace</span>=<span class="value">"/"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"helloworldAction"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.action.HelloWorldAction"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"index"</span>&gt;</span> index.jsp <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
            <span class="comment">&lt;!-- same as below --&gt;</span>
            <span class="comment">&lt;!-- &lt;result name="index"&gt; --&gt;</span>
            <span class="comment">&lt;!--     &lt;param name="location"&gt;index.jsp &lt;/param&gt; --&gt;</span>
            <span class="comment">&lt;!-- &lt;/result&gt; --&gt;</span>
        <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="tag">&lt;/<span class="title">struts</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="struts2-">struts2 好处</h2>
<p>web.xml 中只有一个过滤器, 不用繁琐的配置</p>
<p>action就是一个简单的javabean, 与servlet容器没有任何依赖</p>
<p>多出了一个struts.xml, 配置Action的行为</p>
<h1 id="-">配置文件解析</h1>
<p>在struts过滤器初始化时, 加载了几个配置文件
<code>struts-default.xml(在struts2核心包的根目录下)</code> <code>struts.xml(供程序员使用)</code> <code>struts-plugins.xml</code></p>
<p>struts 先加载 <code>struts-default.xml</code>, 后加载 <code>struts.xml</code>, 如果出现相同元素, 后加载覆盖先加载</p>
<p><code>package</code> 分模块管理action,</p>
<ul>
<li>属性 <code>name</code>, 包名字, 值唯一</li>
<li><p>属性 <code>extends</code>, 用法 <code>extends=&quot;struts-default&quot;</code>,
把 package 中 name为 <em>struts-default</em> 包中所有的功能继承下来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 继承了 helloworld --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"childOfHello"</span> <span class="attribute">extends</span>=<span class="value">"helloworld"</span> <span class="attribute">namespace</span>=<span class="value">"/"</span> <span class="attribute">abstract</span>=<span class="value">"false"</span>&gt;</span> <span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>abstract：可选值为true|false。说明他是一个抽象包。抽象包中没有action元素的。(默认为false)</p>
</li>
<li>属性<code>namespace</code>, 与url相关,  如果 <code>namespace=&quot;/base&quot;</code>,
则要访问 <code>${contextPath/base/helloWorldaction.action}</code>, 但是 <code>${contextPath/base/a/helloWorldAction.action}</code>也能访问<ul>
<li>查找规则, 先在 <code>/base/a</code> 下找, 然后在 <code>/base</code> 下找</li>
<li>如果<code>Action.execute()</code>返回了<code>&quot;index&quot;</code>, 则struts 会找根据配置文件在<code>/base/</code>文件夹下查找<code>index.jsp</code></li>
</ul>
</li>
<li>标签 <code>&lt;result name=&quot;name&quot; type=&quot;&quot;&gt;&lt;/result&gt;</code>, 结果集<ol>
<li><code>Action.execute</code> 返回一个字符串, 返回的字符串要和struts的配置文件中的<code>result</code>标签的<code>name</code>属性值匹配</li>
<li><code>name</code>属性, 可以省略, 默认为 <em>&quot;success&quot;</em></li>
<li><code>type</code>属性, 结果集类型, 可省略, 默认为值为 &quot;dispatcher&quot;, 在<code>struts-default.xml</code> 定义 <code>&lt;result-type name=&quot;dispatcher&quot;/&gt;</code></li>
</ol>
</li>
<li><code>include</code> 标签, 保证可以存在很多个 struts 配置文件<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">struts</span>&gt;</span> <span class="tag">&lt;<span class="title">include</span> <span class="attribute">file</span>=<span class="value">"included-struts.xml"</span>/&gt;</span> <span class="tag">&lt;/<span class="title">struts</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="-2">配置文件解析2</h2>
<h3 id="package-">package标签</h3>
<p>必须直接或间接地继承自struts-default的包.</p>
<p>作用: 方便管理我们的动作(struts-default是核心配置文件)</p>
<p>属性：</p>
<ul>
<li>abstract：可选值为true|false。说明他是一个抽象包。抽象包中没有action元素的。(默认为false)</li>
<li>name：包名。不能重复。方便管理动作的。</li>
<li>namespace：名称空间</li>
<li>extends：继承什么</li>
</ul>
<h3 id="action-">action标签</h3>
<ul>
<li><p>name: 必须的, 动作名称</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p2"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="comment">&lt;!-- 只要找不到的action的name，找act4。默认动作名称 --&gt;</span>
    <span class="tag">&lt;<span class="title">default-action-ref</span> <span class="attribute">name</span>=<span class="value">"act4"</span>&gt;</span><span class="tag">&lt;/<span class="title">default-action-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>class：可选的。默认值是com.opensymphony.xwork2.ActionSupport</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p2"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="comment">&lt;!-- 只要找不到的action的class，找com.opensymphony.xwork2.ActionSupport。默认class --&gt;</span>
    <span class="tag">&lt;<span class="title">default-class-ref</span> <span class="attribute">name</span>=<span class="value">"com.opensymphony.xwork2.ActionSupport"</span>&gt;</span><span class="tag">&lt;/<span class="title">default-class-ref</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>method: 可选. 默认值是<code>public String execute(){return &quot;success&quot;}</code></p>
</li>
</ul>
<h3 id="result-">result标签</h3>
<p>type：默认值dispatcher。转发，目标JSP</p>
<p>name：默认值是success。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>&lt;package <span class="property">name</span>=<span class="string">"default"</span> namespace=<span class="string">"/test"</span> extends=<span class="string">"struts-default"</span>&gt;
    &lt;action <span class="property">name</span>=<span class="string">"hello"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.HelloAction"</span> method=<span class="string">"execute"</span>&gt;
        &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"female"</span>&gt;/female.jsp&lt;/<span class="constant">result</span>&gt;
        &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"male"</span>&gt;/male.jsp&lt;/<span class="constant">result</span>&gt;
    &lt;/action&gt;
&lt;/package&gt;
</pre></td></tr></table></figure>

<p>访问包中带有名称空间的动作时：</p>
<ul>
<li><code>http://localhost:8080/day22_01_strutsHello/test/hello.action</code></li>
<li><code>http://localhost:8080/day22_01_strutsHello/test/aaa/bbb/hello.action</code></li>
</ul>
<p>动作有搜索顺寻：</p>
<ol>
<li>从/test/aaa/bbb找，不存在</li>
<li>从/test/aaa找，不存在</li>
<li>从/test，找到了</li>
<li>一旦找到就不向上找了</li>
</ol>
<h2 id="struts2-">struts2 结果类型</h2>
<ol>
<li>结果类型其实就是一个实现com.opensymphony.xwork2.Result的类，用来输出你想要的结果</li>
<li>在struts-default.xml文件中已经提供了内置的几个结果类型</li>
</ol>
<h3 id="chain">chain</h3>
<p>转发到另一个动作</p>
<p><code>&lt;result-type name=&quot;chain&quot; class=&quot;com.opensymphony.xwork2.ActionChainResult&quot;/&gt;</code></p>
<p>如果转发的动作在一个名称空间中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testChain1"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"chain"</span>&gt;testChain2&lt;/<span class="constant">result</span>&gt;
&lt;/action&gt;
&lt;action <span class="property">name</span>=<span class="string">"testChain2"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"dispatcher"</span>&gt;/<span class="number">2.</span>jsp&lt;<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<p>如果转发的动作不在一个名称空间中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testChain1"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"chain"</span>&gt;</span>
        <span class="comment">&lt;!-- 如果需要转发的动作不在一个名称空间内，则需要进行参数的设置（原理看chain源码） --&gt;</span>
        <span class="comment">&lt;!-- 源码中有setNamespace和setActionName方法，去掉set，第一个字母改小写 --&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"namespace"</span>&gt;</span>/result1<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"actionName"</span>&gt;</span>testChain2<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p2"</span> <span class="attribute">namespace</span>=<span class="value">"/result1"</span> <span class="attribute">extends</span>=<span class="value">"base"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testChain2"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span>&gt;</span>/2.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="dispatcher">dispatcher</h3>
<p><code>&lt;result-type name=&quot;dispatcher&quot; class=&quot;org.apache.struts2.dispatcher.ServletDispatcherResult&quot; default=&quot;true&quot;/&gt;(默认的)</code></p>
<p>请求转发（地址栏不会变）。struts配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testChain2"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"dispatcher"</span>&gt;</span>/2.jsp<span class="tag">&lt;<span class="title">result</span>&gt;</span>
    <span class="comment">&lt;!-- 这两个设置效果相同 --&gt;</span>
    <span class="comment">&lt;!--
        &lt;result name="success" type="dispatcher"&gt;
            &lt;param name="location"&gt;/2.jsp&lt;result&gt;
        &lt;/result&gt;
    --&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="redirectaction">redirectAction</h3>
<p><code>&lt;result-type name=&quot;redirectAction&quot; class=&quot;org.apache.struts2.dispatcher.ServletActionRedirectResult&quot;/&gt;</code></p>
<p>请求重定向到另一个动作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testRedirect1"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"redirectAction"</span>&gt;testRedirect2&lt;/<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<h3 id="redirect">redirect</h3>
<p><code>&lt;result-type name=&quot;redirect&quot; class=&quot;org.apache.struts2.dispatcher.ServletRedirectResult&quot;/&gt;</code></p>
<p>请求重定向（地址栏会变）.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testRedirect"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"download"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"redirect"</span>&gt;/<span class="number">2.</span>jsp&lt;<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<h3 id="stream">stream</h3>
<p><code>&lt;result-type name=&quot;stream&quot; class=&quot;org.apache.struts2.dispatcher.StreamResult&quot;/&gt;</code></p>
<p>结果类型为流，例如用于文件下载(具体原理需要看源码，而源码的核心就是execute方法）
struts.xml的配置(属性参数对应的都是类中的set方法）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"testStream"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"download"</span>&gt;</span>
    <span class="comment">&lt;!-- 不需要转向或重定向的页面，因为直接下载就可以了 --&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span> <span class="attribute">type</span>=<span class="value">"stream"</span>&gt;</span><span class="comment">&lt;!-- 在文档中拷贝以下参数 --&gt;</span>
    <span class="comment">&lt;!-- 为了能让所有类型的文件都能下载，在Tomcat/conf/web.xml里面搜索bin，找到以下mapping参数 --&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"contentType"</span>&gt;</span>application/octet-stream<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="comment">&lt;!-- 查看Stream对应的类源代码,对应里面的字符串变量，根据这个字符串找输入流--&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"inputName"</span>&gt;</span>imageStream<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="comment">&lt;!-- 消息头的设置，指定下载，且指定下载文件名称 --&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"contentDisposition"</span>&gt;</span>attachment;filename="1.jpg"<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="comment">&lt;!-- 设置缓存的大小 --&gt;</span>
       <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"bufferSize"</span>&gt;</span>1024<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<p>实现文件下载</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> CaptchaAction {
    <span class="comment">//设置一个流，并生成set，get方法。</span>
    <span class="keyword">private</span> InputStream imageStream;
    <span class="keyword">public</span> InputStream <span class="title">getImageStream</span>() {
        <span class="keyword">return</span> imageStream;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageStream</span>(InputStream imageStream) {
        <span class="keyword">this</span>.imageStream = imageStream;
    }
    <span class="keyword">public</span> String <span class="title">download</span>() throws FileNotFoundException{
        <span class="comment">//获得文件的真实路径</span>
        String realPath = ServletActionContext.getServletContext().getRealPath(<span class="string">"/WEB-INF/111.jpg"</span>);
        <span class="comment">//获得文件输入流</span>
        imageStream = <span class="keyword">new</span> FileInputStream(realPath);
        <span class="keyword">return</span> <span class="string">"success"</span>;
    }
    <span class="keyword">public</span> String <span class="title">method1</span>(){
        <span class="keyword">try</span>{
            <span class="comment">//int i=1/0;//人为制造异常，可以让catch转向全局结果集，error.jsp</span>

<span class="keyword">return</span> <span class="string">"success"</span>;
        }<span class="keyword">catch</span>(Exception e){
            <span class="keyword">return</span> <span class="string">"error"</span>;
        }
    }
}
</pre></td></tr></table></figure>

<h3 id="plain">plain</h3>
<p><code>&lt;result-type name=&quot;plainText&quot; class=&quot;org.apache.struts2.dispatcher.PlainTextResult&quot; /&gt;</code></p>
<p>显示指定页面的源代码（不好用，只有java语句才能显示源代码）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;action <span class="property">name</span>=<span class="string">"testPlanText"</span> <span class="type">class</span>=<span class="string">"com.itheima.action.CaptchaAction"</span> method=<span class="string">"showPlanText"</span>&gt;
    &lt;<span class="constant">result</span> <span class="property">name</span>=<span class="string">"success"</span> type=<span class="string">"plainText"</span>&gt;/<span class="number">1.</span>jsp&lt;<span class="constant">result</span>&gt;
&lt;/action&gt;
</pre></td></tr></table></figure>

<h3 id="-">其他结果类型</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"httpheader"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.dispatcher.HttpHeaderResult"</span>/&gt;
&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"freemarker"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.views.freemarker.FreemarkerResult"</span>/&gt;显示模板。。。需要实验。
&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"velocity"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.dispatcher.VelocityResult"</span>/&gt;显示模板。。。需要实验。
&lt;result-<span class="class"><span class="keyword">type</span> <span class="title">name</span>=</span><span class="string">"xslt"</span> <span class="keyword">class</span>=<span class="string">"org.apache.struts2.views.xslt.XSLTResult"</span>/&gt;(显示样式？）
</pre></td></tr></table></figure>

<p>如果提供的结果类型不够用，就需要自定义了(注意需要实现Result接口)</p>
<p>自定义完的结果类型，需要先声明，才能使用：（随机验证码图片结果类型，实际应用的案例）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"base"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span>
    <span class="comment">&lt;!-- 配置局部结果视图 --&gt;</span>
    <span class="tag">&lt;<span class="title">result-types</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result-type</span> <span class="attribute">name</span>=<span class="value">"captchaResults"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaResults"</span>&gt;</span><span class="tag">&lt;/<span class="title">result-type</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">result-types</span>&gt;</span>
    <span class="comment">&lt;!-- 配置全局结果视图, 只能配置在package里, 但是可以通过继承来使用 --&gt;</span>
    <span class="tag">&lt;<span class="title">global-results</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"error"</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">global-results</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="comment">&lt;!-- 需继承base,因为自定义的局部结果视图配置在base里面,且base继承了核心配置文件 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">namespace</span>=<span class="value">"/results"</span> <span class="attribute">extends</span>=<span class="value">"base"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"captcha"</span> <span class="attribute">class</span>=<span class="value">"com.itheima.action.CaptchaAction"</span> <span class="attribute">method</span>=<span class="value">"genImage"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"captchaResults"</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span>
            <span class="comment">&lt;!-- 调用结果处理类的setter方法，注入参数的值--&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"width"</span>&gt;</span>600<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"height"</span>&gt;</span>400<span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="-">全局结果类型</h3>
<p>当很多提交请求跳转到相同的页面，这个时候，
这个页面就可以成为全局的页面。在struts2中提供了全局页面的配置方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 这个配置必须写在action配置的上面。dtd约束的规定。 --&gt;</span>
<span class="comment">&lt;!-- 配置全局结果视图, 只能配置在package里, 但是可以通过继承来复用 --&gt;</span>
<span class="tag">&lt;<span class="title">global-results</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">name</span>=<span class="value">"success"</span>&gt;</span> success.jsp <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">global-results</span>&gt;</span>
</pre></td></tr></table></figure>

<h1 id="struts-">struts中存在一些内置常量</h1>
<p>在struts2-core-*.jar的org.apache.struts2的default.properties文件中存在一些内置常量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="comment">&lt;!-- request.setCharacterEncoding(), 针对post请求参数编码有效 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.i18n.encoding"</span> <span class="attribute">value</span>=<span class="value">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 配置需要struts框架处理的uri的扩展名 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.action.extension"</span> <span class="attribute">value</span>=<span class="value">"do,,action"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 开发模式：打印更多的异常信息。配置文件会自动加载 --&gt;</span>
<span class="comment">&lt;!-- devMode模式是开发模式，开启它则默认开启了struts.i18n.reload、struts.configuration.xml.reload --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.devMode"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 静态资源是不是设皇城, 开发阶段, 修改true --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.server.static.browserCache"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 配置不支持动态方法调用 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.enable.DynamicMethodInvocation"</span> <span class="attribute">value</span>=<span class="value">"false"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 让struts重新加载配置文件，但不会导致web应用重新启动。 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.configuration.xml.reload"</span> <span class="attribute">value</span>=<span class="value">"false"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 指定每次请求到达，重新加载资源文件 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.i18n.reload"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
<span class="comment">&lt;!-- 工厂类, 和spring 整合用 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.objectFactory"</span> <span class="attribute">value</span>=<span class="value">"spring"</span>/&gt;</span>
<span class="comment">&lt;!-- 表达式直接访问static静态方法的开关 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.ognl.allowStaticMethodAccess"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 配置全局国际化消息资源包,value写资源包的基名，多个资源包之间用逗号，分隔--&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.custom.i18n.resources"</span> <span class="attribute">value</span>=<span class="value">"com.itheima.resources.msg"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 更改strutsUI标签的显示样式模板，参考struts2-core-*.jar中的template --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.ui.theme"</span> <span class="attribute">value</span>=<span class="value">"xhtml"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 动作名字里面默认是不允许出现/的,以下常量设置可以出现/ --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.enable.SlashesInActionNames"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
<span class="comment">&lt;!-- 动作名字里面默认是不允许出现/的,如果有名称空间,除了以上常量,还需要打开这个开关 --&gt;</span>
<span class="tag">&lt;<span class="title">constant</span> <span class="attribute">name</span>=<span class="value">"struts.mapper.alwaysSelectFullNamespace"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">constant</span>&gt;</span>
</pre></td></tr></table></figure>

<p>常量可以在下面多个文件中进行定义，struts2加载常量的搜索顺序如下，后面的设置可以覆盖前面的设置：</p>
<ul>
<li>default.properties文件</li>
<li>struts-default.xml</li>
<li>struts-plugin.xml</li>
<li>struts.xml</li>
<li>struts.properties（为了与webwork向后兼容而提供）</li>
<li>web.xml</li>
</ul>
<p>包含配置(<include>):在struts.xml文件这，使用<include>属性来包含其他配置文件，需要放在<struts>下,<package>外</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;<span class="built_in">include</span> <span class="built_in">file</span>=<span class="string">"struts-mobile.xml"</span>&gt;&lt;/<span class="built_in">include</span>&gt;
</pre></td></tr></table></figure>

<h1 id="struts-action-">struts Action 初始化</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 方式一</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAction</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">opensymphony</span>.<span class="title">xwork2</span>.<span class="title">Action</span> {</span>
    <span class="keyword">public</span> String <span class="title">execute</span>(){
        <span class="keyword">return</span> SUCCESS; <span class="comment">// Action 中定义的常量, 匹配配置文件 struts.xml 中的 action.name</span>
    }
}
<span class="comment">// 方式二</span>
<span class="comment">// 封装了一些常用功能, 如国际化 表单验证 等功能</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAction</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">opensymphony</span>.<span class="title">xwork2</span>.<span class="title">ActionSupport</span> {</span>
    <span class="keyword">public</span> String <span class="title">execute</span>() { }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 方式三 --&gt;</span>
<span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"anyName"</span>&gt;</span> <span class="comment">&lt;!-- 没有写 class, 默认执行 com.opensymphony.xwork2.ActionSupport --&gt;</span>
    <span class="tag">&lt;<span class="title">result</span>&gt;</span> index.jsp <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="action-">Action 依赖注入</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> Action extends <span class="title">ActionSupport</span>(){
   <span class="annotation">@BeanProperty</span> <span class="keyword">private</span> String message;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">action</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"message"</span>&gt;</span> auto insert into <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">result</span> <span class="attribute">type</span>=<span class="value">"redirect"</span>&gt;</span>/7.jsp?msg=${message} <span class="tag">&lt;/<span class="title">result</span>&gt;</span>
<span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="comment">&lt;!-- 7.jsp: ${param.msg} --&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">通配符映射</h2>
<p>在配置文件的 Action 标签中, 可以配置 action 被执行行为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 方式一 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m1/userAction.action 时,默认会调用 UserAction 的 saveUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m1"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"userAction"</span> <span class="attribute">method</span>=<span class="value">"saveUser"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式二 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m2/userAction!deleteUser.action 时,
     会调用 UserAction 的 deleteUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m2"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"userAction"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式三 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m3/a_add.action 或 ${contextPath}/m3/**_add.action 时,
     都会调用 UserAction 的 saveUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m3"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_add"</span> <span class="attribute">method</span>=<span class="value">"saveUser"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式四 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m4/saveUser_add.action 时,
     会调用 UserAction 的 saveUser 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m4"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_add"</span> <span class="attribute">method</span>=<span class="value">"{1}"</span> <span class="attribute">class</span>=<span class="value">"**.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式五 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m5/UserAction_pattern.action 时,
     会调用 UserAction 的 pattern 方法 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m5/PersonAction_pattern.action 时,
     会调用 PersonAction 的 pattern 方法 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m5"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_pattern"</span> <span class="attribute">method</span>=<span class="value">"pattern"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.{1}"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>

<span class="comment">&lt;!-- 方式六 --&gt;</span>
<span class="comment">&lt;!-- 访问 ${contextPath}/m6/UserAction_saveUser.action 时,
     会调用 UserAction 的 saveUser 方法, 并返回 saveUser.jsp --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m6"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"UserAction_*"</span> <span class="attribute">method</span>=<span class="value">"{1}"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.UserAction"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>{1}.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
<span class="comment">&lt;!-- 变体 --&gt;</span>
<span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"method"</span> <span class="attribute">namespace</span>=<span class="value">"/m6"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"*_*"</span> <span class="attribute">method</span>=<span class="value">"{2}"</span> <span class="attribute">class</span>=<span class="value">"cn.itcast.{1}"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">result</span>&gt;</span>{2}.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">action</span>&gt;</span>
<span class="tag">&lt;/<span class="title">package</span>&gt;</span>
</pre></td></tr></table></figure>

<p><strong>通配的程度越高, 匹配的范围越大, 越容易出问题</strong></p>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="struts" scheme="http://zhpooer.github.io/tags/struts/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day27-estore4]]></title>
    <link href="http://zhpooer.github.io/2014/05/11/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day27-estore4/"/>
    <id>http://zhpooer.github.io/2014/05/11/传智播客day27-estore4/</id>
    <published>2014-05-11T01:01:06.000Z</published>
    <updated>2014-05-11T07:39:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">订单的删除</h1>
<p>在订单未付款的状态下, 用户可以去取消订单
注意在 OrderService 要加入事务控制, 参考 <a href="/2014/04/26/传智播客day20-orm简介/#-">orm简介</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="comment">// OrderCancelServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp) {
    <span class="comment">// 获取要取消的订单</span>
    String orderid = req.getParameter(<span class="string">"orderid"</span>);
    orderService.cancelOrder(orderid);
    resp.sendRedirect(<span class="string">"/orderSearch"</span>);
}

<span class="comment">// OrderService</span>
<span class="keyword">public</span> <span class="keyword">class</span> OrderService {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelOrder</span>(String orderid){
        orderDao.deleteOrderItem(orderid);
        orderDao.deleteOrder(orderid);
    }
}

<span class="comment">// OrderDao </span>
<span class="keyword">public</span> <span class="keyword">class</span> OrderDao {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOrder</span>(String orderid) {
        String sql = <span class="string">"delete from orderitem where order_id=?"</span>;
        queryRunner.update(conn, sql, orderid);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOrderItem</span>(String orderid) {
        String sql = <span class="string">"delete from orders where id=?"</span>;
        queryRunner.update(conn, sql, orderid);
    }
}
</pre></td></tr></table></figure>

<h1 id="-">定时清理未支付订单(任务调度)</h1>
<p>监听器 Listener</p>
<p>定时器</p>
<ol>
<li><code>java.util.Timer</code> 结合 <code>java.util.TimerTask</code></li>
<li><code>java.util.concurrent.ScheduledExcutorService</code></li>
<li><code>Quantz</code> <strong>框架</strong></li>
</ol>
<p>功能需求: 用户生成订单后,  有效支付时间24小时, 如果24小时不支付,
系统自动清理订单</p>
<h2 id="-">启动定时任务</h2>
<p><code>ServletContextListener</code> 中启动定时任务</p>
<p><code>Timer</code> API</p>
<ul>
<li><p><code>Timer.schedule(TimerTask task, Date firstTime, long period)</code></p>
</li>
<li><p><code>Timer.schedule(TimerTask task, long delay, long period)</code></p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="comment">// cn.itcast.estore.web.Listener</span>
<span class="comment">// 清理24小时未付款的订单</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCleanListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span>{</span>
    Timer timer = <span class="keyword">null</span>;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(){
        Timer timer = <span class="keyword">new</span> timer();
        timer.schedule(<span class="keyword">new</span> TimerTask(){
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(){
                orderService.cleanUnPayOrders();
            }
        }, <span class="number">0</span>, <span class="number">1000</span>l*<span class="number">60</span>*<span class="number">30</span>); <span class="comment">// 每隔30分钟执行一次, 加上 L 防止越界</span>
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(){
        <span class="keyword">if</span>(timer!=<span class="keyword">null</span>) timer.cancel();
    }
}

<span class="comment">// OrderService</span>
<span class="keyword">public</span> <span class="keyword">void</span> OrderService {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUnPayOrders</span>() {
        <span class="comment">//查询所有订单</span>
        List&lt;Order&gt; orders = orderDao.findAllOrders();
        <span class="keyword">for</span>(Order order : orders) {
            <span class="keyword">if</span>(order.getPayState == <span class="number">0</span> && System.currentTimeMillis()-order.getCreatetime().getTime() &gt;= <span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>) {
                cancelOrder(order.getId());
            }
        }
    }
}
</pre></td></tr></table></figure>

<h1 id="-">系统权限管理</h1>
<ol>
<li>URL 级别权限控制</li>
<li>方法级别权限控制 (一次请求会执行多个方法, 注解+动态代理+反射)</li>
</ol>
<p>引入配置文件进行权限控制</p>
<ul>
<li>系统用户 admin, normal</li>
<li>存在三种页面: 未登录可以访问, user 可以访问, admin 可以访问</li>
<li><p>配置两个文件</p>
<ul>
<li><p><code>admin.conf</code> 需要管理员才能访问</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>/active
/addCart
/delcartProduct
/orderAdd
/orderCancel
/pay
/updateCarrtProductNum
/cart<span class="preprocessor">.jsp</span>
/order_add<span class="preprocessor">.jsp</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>user.conf</code> 用户才能访问</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>/orderCancel
/order<span class="preprocessor">.jsp</span>
/product_add<span class="preprocessor">.jsp</span>
</pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>通过过滤器来进行权限控制</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivilegeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> {</span>
    <span class="keyword">private</span> List&lt;String&gt; adminPaths = <span class="keyword">new</span> ArrayList&lt;String&gt;;
    <span class="keyword">private</span> List&lt;String&gt; userPath = <span class="keyword">new</span> ArrayList&lt;String&gt;;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(FilterConfig filterConfig) {
        String adminFile = filterConfig.getServletContext().getRealPath(<span class="string">"/WEB-INF/classes/admin.conf"</span>);
        String userFile = getClass().getResource(<span class="string">"/user.conf"</span>).getFile();
        BufferedReader  r1 = <span class="keyword">new</span> BufferedReader(FileReader(adminFile));
        BufferedReader  r2 = <span class="keyword">new</span> BufferedReader(FileReader(userFile));
        <span class="keyword">while</span>((tmp=r1.readLine())!=<span class="keyword">null</span>) {
            adminPaths.add(tmp);
        }
        r1.close();
        <span class="keyword">while</span>((tmp=r2.readLine())!=<span class="keyword">null</span>) {
            userPaths.add(tmp);
        }
        user.close();
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(req, resp, chain) {
        <span class="comment">// 字段访问资源路径是不是在admin.con或者user.con配置,</span>
        String uri = req.getRequestURI();
        String reqPath = uri.subString(req.getContextPath().length);
        <span class="comment">// 如果 存在于 admin 或者 user 需要登陆, 获取当前登陆 角色,</span>
        <span class="comment">// 判断对应访问是否包含当前资源访问路径</span>
        <span class="keyword">if</span>(adminPaths.contains(reqPath) || userPaths.contains(reqPath)){
            User user = req.getSession().getAttribute(<span class="string">"user"</span>);
            <span class="keyword">if</span>(user==<span class="keyword">null</span>){
                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"权限不足, 请先登陆"</span>);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span>(user.getRole().equals(<span class="string">"admin"</span>)) {
                    <span class="keyword">if</span>(adminPaths.contains(reqPath)){
                        chain.doFilter(req, resp);
                    } <span class="keyword">else</span> {
                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"权限不足"</span>);
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span>(user.getRole().equals(<span class="string">"user"</span>)) {
                    <span class="keyword">if</span>(userPath.contains(reqPath)){
                        chain.doFilter(req, resp);
                    } <span class="keyword">else</span> {
                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"权限不足"</span>);
                    }
                }
            }
        } <span class="keyword">else</span> {
            <span class="comment">// 如果不存在, 不需要登陆, 直接放行</span>
            chain.doFiler(req, resp);            
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(){
    }
}
</pre></td></tr></table></figure>

</li>
</ul>
<h1 id="-">异常页面的编写</h1>
<p>Servlet : 配置web.xml 指定的异常处理页面</p>
<p>JSP: <code>&lt;%@page errorPage=&quot;...&quot;%&gt;</code>, 解决 500</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">&lt;!-- web.xml 配置异常处理 --&gt;</span>
<span class="tag">&lt;<span class="title">error-page</span>&gt;</span>
    <span class="tag">&lt;<span class="title">error-code</span>&gt;</span> 500 <span class="tag">&lt;/<span class="title">error-code</span>&gt;</span>
    <span class="tag">&lt;<span class="title">location</span>&gt;</span>/500.jsp <span class="tag">&lt;/<span class="title">location</span>&gt;</span>
<span class="tag">&lt;/<span class="title">error-page</span>&gt;</span>
<span class="tag">&lt;<span class="title">error-page</span>&gt;</span>
    <span class="tag">&lt;<span class="title">error-code</span>&gt;</span> 404 <span class="tag">&lt;/<span class="title">error-code</span>&gt;</span>
    <span class="tag">&lt;<span class="title">location</span>&gt;</span>/404.jsp <span class="tag">&lt;/<span class="title">location</span>&gt;</span>
<span class="tag">&lt;/<span class="title">error-page</span>&gt;</span>
</pre></td></tr></table></figure>

<ul>
<li><p>404.jsp, 自动跳转到系统主页面</p>
<ol>
<li><code>response.setHeader(&quot;refresh&quot;, &quot;时间(秒);url=/&quot;);</code></li>
<li><code>&lt;meta&gt;</code> 标签<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"refresh"</span> <span class="attribute">content</span>=<span class="value">"200;url=www.google.com"</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>500页面, 在错误页面, 获取 异常 信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;<span class="variable">%page</span> isErrorPage=<span class="string">"true"</span><span class="variable">%&gt;</span>

&lt;<span class="variable">%=</span>exception.getClass().getName()<span class="variable">%&gt;</span>
&lt;<span class="variable">%=</span>exception.getMessage()<span class="variable">%&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
<h1 id="-">日志记录</h1>
<p>在软件开发时 或者 项目后期运维时, 用户系统信息记录到指定的文件中</p>
<ul>
<li>用户调试</li>
<li>根据日志信息修复系统Bug</li>
</ul>
<h2 id="-">日志技术选型</h2>
<ul>
<li>JDK Logging, <code>java.util.logging</code></li>
<li>Log4j 日志技术, Apache后来运维, 第三方日志框架, <code>log4j1.x</code>和<code>log2.x</code><ul>
<li>主流: log4j1.2.x</li>
</ul>
</li>
<li>commons-logging(Apache), JCL, 主要是为了统一不同的日志实现框架<ul>
<li>commons-logging + log4j</li>
<li>commons-logging + jdk loggin</li>
<li>开发人员只需要学习 commongs-logging 接口, 就集成不同日志实现技术(最新的struts2, spring 使用 commons-logging)</li>
</ul>
</li>
<li>slf4j (Simple Logging Facade for Java), 作用类似 commons-logging, 起到同一日志接口实现<ul>
<li>Hibernate 使用 slf4j 日志接口</li>
</ul>
</li>
</ul>
<h2 id="-log4j">日志实现技术 log4j</h2>
<p>区分: 日志技术和 System.out</p>
<ul>
<li>System.out将信息打印到控制台, 有些服务器, 将控制台所有信息记录日志文件</li>
<li>日志技术, 向日志文件记录日志, 分等级记录, 通过控制等级, 控制不同级别日志输出</li>
</ul>
<h2 id="-log4j">编写Log4j</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="annotation">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> test不写日志文件() {
    <span class="comment">// 1. 需要创建日志记录器</span>
    Logger logger = Logger.getLogger(<span class="keyword">this</span>.getClass());
    <span class="comment">// 2. 指定记录器的输出源(日志输出到哪里去)</span>
    BasicConfigurator.configure(); <span class="comment">//将日志输出到控制台</span>
    <span class="comment">// 3. 记录日志(提供6个日志级别)</span>
    <span class="comment">// 在输出日志时, 只会输出比指定日志级别更高日志级别</span>
    logger.setLevel(Level.ERROR);
    <span class="comment">// 默认日志级别是Debug</span>
    <span class="comment">// fatal error warn</span>
    <span class="comment">// info debug trace</span>
    logger.debug(<span class="string">"调试信息"</span>);
}
</pre></td></tr></table></figure>

<h2 id="-log4j-">编写Log4j配置文件</h2>
<ul>
<li>xml 格式: log4j.xml</li>
<li>properties 格式: log4j.properties(最常见)<ul>
<li>在src下新建 log4j.properties 配置文件</li>
<li>配置记录器 logger (采用那个输出源, 疏忽日志级别)</li>
<li>配置输出源 Appender (输出到哪里)<ul>
<li>org.apache.log4j.ConsoleAppender(控制台) </li>
<li>org.apache.log4j.FileAppender(文件) </li>
<li>org.apache.log4j.DailyRollingFileAppender (每天产生一个日志文件) </li>
<li>org.apache.log4j.RollingFileAppender (文件到达指定大小时产生一个新文件) </li>
<li>org.apache.log4j.WriterAppender (将日志信息以流格式发送到任何地方) </li>
</ul>
</li>
<li>配置布局 layouts (输出格式)<ul>
<li>org.apache.log4j.HTMLLayout （以HTML表格形式布局）</li>
<li>org.apache.log4j.PatternLayout （可以灵活地指定布局模式）<ul>
<li>%m 输出代码中指定的消息</li>
<li>%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</li>
<li>%r 输出自应用启动到输出该log信息耗费的毫秒数</li>
<li>%c 输出所属的类目，通常就是所在类的全名</li>
<li>%t 输出产生该日志事件的线程名</li>
<li>%n 输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n”</li>
<li>%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921</li>
<li>%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)基本应用</li>
</ul>
</li>
<li>org.apache.log4j.SimpleLayout （包含日志信息的级别和信息字符串）</li>
<li>org.apache.log4j.TTCCLayout （包含日志产生的时间、线程、类别等信息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>log4j<span class="preprocessor">.rootLogger</span>(默认记录级别) = DEBUG, A1 <span class="preprocessor"># 输出级别 + 输出源...</span>
log4j<span class="preprocessor">.logger</span>.包名(包记录级别) = 输出级别 , 输出源<span class="number">1</span> , 输出源<span class="number">2</span>

<span class="preprocessor"># appender</span>
log4j<span class="preprocessor">.appender</span><span class="preprocessor">.A</span>1 = org<span class="preprocessor">.apache</span><span class="preprocessor">.log</span>4j<span class="preprocessor">.ConsoleAppender</span>

<span class="preprocessor"># layout</span>
<span class="preprocessor"># log4j.appender.输出源名称.layout = 布局实现类</span>
log4j<span class="preprocessor">.appender</span><span class="preprocessor">.A</span>1<span class="preprocessor">.layout</span> = org<span class="preprocessor">.apache</span><span class="preprocessor">.log</span>4j<span class="preprocessor">.PatternLayout</span> <span class="preprocessor"># 使用</span>
<span class="preprocessor"># 自定义输出格式</span>
log4j<span class="preprocessor">.appender</span><span class="preprocessor">.A</span>1<span class="preprocessor">.layout</span><span class="preprocessor">.ConversionPattern</span> = %-<span class="number">4</span>r [%t] %-<span class="number">5</span>p %c %<span class="built_in">x</span> - %m%n

<span class="preprocessor"># 输出到文件</span>
log4j<span class="preprocessor">.appender</span><span class="preprocessor">.FILE</span> = org<span class="preprocessor">.apache</span><span class="preprocessor">.log</span>4j<span class="preprocessor">.FileAppender</span>
log4j<span class="preprocessor">.appender</span><span class="preprocessor">.FILE</span><span class="preprocessor">.File</span> = /var/log
</pre></td></tr></table></figure>

<h1 id="-log4j">在项目代码中配置 Log4j</h1>
<ol>
<li><p>定义记录器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = Logger.getLogger(OrderService.class);
</pre></td></tr></table></figure>
</li>
<li><p>在程序中使用六个级别方法, 记录日志<br>常用级别: ERROR, WARN, INFO, DEBUG</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>LOG<span class="preprocessor">.error</span>(e<span class="preprocessor">.getMessage</span>(), e)<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-todo">项目TODO</h1>
<ul>
<li>分页控制, 提取标签</li>
<li>配置多个tomcat运行, 集群处理(Apache + tomcat)</li>
<li>缓存优化, 静态缓存</li>
<li>Tomcat配置 gzip 压缩<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">Connector</span> <span class="attribute">compress</span>=<span class="value">"on"</span> <span class="attribute">compressableMimeType</span>=<span class="value">"text/html, text/css"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">Connector</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ul>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day26-estore3]]></title>
    <link href="http://zhpooer.github.io/2014/05/09/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day26-estore3/"/>
    <id>http://zhpooer.github.io/2014/05/09/传智播客day26-estore3/</id>
    <published>2014-05-09T01:05:29.000Z</published>
    <updated>2014-05-09T10:34:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">修改购物车</h1>
<p>解决页面 中数字显示, 保留位数问题</p>
<p>服务器Java代码解决方案<code>java.text.NumberFormat</code></p>
<p>页面中解决方案: jstl 提供的 fmt 标签库 (用于国际化显示, 和格式化显示)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="vbscript">&lt;%@ taglib uri=<span class="string">"....jstl/fmt"</span> frefix=<span class="string">"c"</span> %&gt;</span>
<span class="tag">&lt;<span class="title">fmt:formatNumber</span> <span class="attribute">value</span>=<span class="value">"${0.111111}"</span> <span class="attribute">maxFractionDigits</span>=<span class="value">"2"</span>
                  <span class="attribute">minFractionDigits</span>=<span class="value">"2"</span> /&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">修改购物车商品数量</h2>
<p>修改数量后, 通过 js 的 blur 事件, 提交请求给服务器,
服务器根据请求修改购物车中的商品数量</p>
<ol>
<li>为页面添加 onblur 事件, 函数接受商品编号和修改后的数量</li>
<li>判断修改后的数量, 必须为正整数(不能是字母, 负数, 小数, 允许为0)</li>
<li>提交请求给服务器, 根据商品编号, 修改 Session 的购物车对象商品对应的数量.
如果修改后的数量为0, 删除购物商品</li>
<li>修改数量后, 回到购物车页面</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">"${entry.value}"</span>
       <span class="attribute">onblur</span>=<span class="value">"changeBuyNum(${entry.key.id}, ${entry.key.pnum}, this.value);"</span>/&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="function"><span class="keyword">function</span> <span class="title">changeBuyNum</span><span class="params">(id, maxnum, num)</span>{</span>
    <span class="comment">// 对修改后的合法性, 进行校验</span>
    <span class="keyword">var</span> regex = <span class="regexp">/^[0-9]+$/</span>
    <span class="keyword">if</span>(regex.test(num)) {
        <span class="keyword">if</span>(num&gt;maxnum) {
            <span class="comment">// 存货不足</span>
            alert(<span class="string">"商品库存数量不能草果库存数量"</span>)
        } <span class="keyword">else</span> {
            window.locatioin.href=<span class="string">"${pageContext.request.contextPath}/"</span> + 
            +<span class="string">"upldateCartItem?id="</span> + id + <span class="string">"&num="</span>  + num
        }
    } <span class="keyword">else</span> {
        alert(<span class="string">"请输入正确格式"</span>)
    }
}
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="comment">// UpdateCartItemServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp){
    <span class="keyword">int</span> id = Integer.parseInt(req.getParameter(<span class="string">"id"</span>));
    <span class="keyword">int</span> num = Integer.parseInt(req.getParameter(<span class="string">"num"</span>));
    
    <span class="comment">// 从session获取购物车对象</span>
    Map cart = req.getSession.getAttribute(<span class="string">"cart"</span>);
    
    <span class="comment">// 服务器校验商品数量(根据id查询商品数量)</span>
    ProductService productService = <span class="keyword">new</span> ProductService();
    <span class="keyword">int</span> num = productService.findProductNumById(id);
    <span class="keyword">if</span>(num&gt;pnum) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"库存不足"</span>);
    }

    <span class="comment">// 修改数量</span>
    Product product = <span class="keyword">new</span> Product();
    product.setId(id);
    <span class="keyword">if</span>(num==<span class="number">0</span>){
        cart.remove(product);
    } <span class="keyword">else</span> {
        cart.put(product, num); <span class="comment">// key不会覆盖, value覆盖</span>
    }
    resp.sendRedirect(<span class="string">"/cart.jsp"</span>);
}

<span class="comment">// ProductService</span>
<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findProductNumById</span>(<span class="keyword">int</span> id){
    <span class="keyword">return</span> productDao.findProductNumById(id);
}

<span class="comment">// ProductDao</span>
<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findProductNumById</span>(<span class="keyword">int</span> id){
    String sql = <span class="string">"select pnum from project where id = ?"</span>;
    <span class="keyword">return</span> queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler(<span class="string">"pnum"</span>), id);
}
</pre></td></tr></table></figure>

<h2 id="-">商品删除</h2>
<ol>
<li>在页面中显示购物车信息时, 每个商品后, 提供删除按钮</li>
<li>点击删除按钮, 将不需要购买商品编号, 发送到服务器</li>
<li>根据商品编号, 从Session的cart对象, 移除商品<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"deleteCartItem?id=${entry.key.id}"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">// DelCartItemServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(){
    <span class="keyword">int</span> id = req.getParameter(<span class="string">"id"</span>);
    Map cart = req.getSession().getAttribute(<span class="string">"cart"</span>);

    Product product = <span class="keyword">new</span> Product();
    product.setId(id);

    <span class="comment">// 因为重写的hashCode和equals</span>
    cart.remove(product);
    <span class="comment">// 跳转回购物车页面</span>
    resp.sendRedirect(<span class="string">"/cart.jsp"</span>);
}
</pre></td></tr></table></figure>

<h1 id="-">订单生成</h1>
<p>在购物车选好后, 点击结算按钮, 跳转到订单生成页面</p>
<ol>
<li>在生成订单页面中, 生成真实的页面信息, 参考 cart.jsp 实现</li>
<li>产生订单</li>
</ol>
<p>分析数据变化:</p>
<ul>
<li>Order订单表: 存放订单整体信息(总金额, 创建时间, 支付状态, 收货人信息)</li>
<li>OrderItem 订单项目表, 存放每个商品购买几件</li>
</ul>
<p>生成订单页面, 需要提交收货人信息 和 订单总金额 到服务器<br>订单总金额用<code>&lt;input type=&#39;hidden&#39; value=&quot;totalprice&quot; name=&quot;totalprice&quot;/&gt;</code>来存放</p>
<h2 id="-">服务器代码</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="comment">// OrderAddServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> doGet(){
    <span class="comment">// 将请求数据封装到model对象中</span>
    Order <span class="keyword">order</span> = <span class="keyword">new</span> Order();
    BeanUtils.populate(<span class="keyword">order</span>, req.getParameter());

    <span class="comment">// 生成订单号</span>
    DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);
    String id = <span class="string">"estore_"</span> + dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">"_"</span> + UUID;
    <span class="keyword">order</span>.setId(id);

    <span class="keyword">order</span>.sestPaystate(<span class="number">0</span>);
    <span class="keyword">order</span>.setCreateTime(<span class="keyword">new</span> TimeStamp(System.currentTimeMillis()));

    User user = req.getSession().getAttribute(<span class="string">"user"</span>);
    <span class="keyword">order</span>.setUser_id(user.getId());

    List&lt;OrderItem&gt; orderItems = <span class="keyword">new</span> ArrayList&lt;OrderItem&gt;();
    <span class="comment">// 封转订单项项目</span>
    Map cart = req.getSession.getAttribute(<span class="string">"cart"</span>);
    <span class="keyword">for</span> (entry &lt;- cart.entrySet()) {
        OrderItem orderItem = <span class="keyword">new</span> OrderItem();
        orderItem.setOrder_id(orderid);
        orderItem.setProduct_id(entry.getKey().getId());
        orderItem.setBuynum(entry.getValue);
        orderItems.add(orderItem);
    }
    orderService.addOrder(<span class="keyword">order</span>, orderItems);

    req.getSession().removeAttribue(<span class="string">"cart"</span>);
}

<span class="comment">// OrderServiceImpl</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">OrderService</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> addOrder(Order <span class="keyword">order</span> , List&lt;OrderItem&gt; orderItems){
        orderDao.insert(<span class="keyword">order</span>, orderItems);
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDaoImpl</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">OrderDao</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> insert(Order <span class="keyword">order</span> , List&lt;OrderItem&gt; orderItems){
        String orderSql = <span class="string">"insert into orders values(?...)"</span>;
        queryRunner.update(conn, orderSql, <span class="keyword">order</span>.getId);
        <span class="comment">// 保存订单项数据</span>
        String orderitemSql = <span class="string">"insert into orderitem values(?,?,?)"</span>
        List&lt;Order []&gt; argList = <span class="keyword">new</span> ArrayList&lt;Order[]&gt;();
        <span class="keyword">for</span>(OrderItem orderItem : orderItems){
            <span class="comment">// 用 batch, 先将参数保存到二维数组</span>
            Object[] orderitemArgs = {orderItem.getOrder_id(), orderItem.getProduct_id(), any}
            argList.add(orderitemArgs);
        }
        <span class="comment">// 将多种参数, 一次提交给服务器, 提高效率</span>
        QueryRunner.update(conn, orderitemSql, argList.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>][]));
    }
}
</pre></td></tr></table></figure>

<p>tips: <code>Connection.setSavePoint()</code> 以及 <code>Connection.commit()</code> 要放在 错误处理里</p>
<h3 id="tips-">tips: 回滚点</h3>
<p>回滚点, 可以在事务执行过程中进行记录, 从而在回滚事物的时候, 不会滚到事务最开始,
而回滚到指定保存点.</p>
<p>主流场景: 大规模批量插入数据.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>Connection conn = <span class="keyword">null</span>;
Savepoint savepoint = <span class="keyword">null</span>;
<span class="keyword">try</span>{
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">1000000</span>; i++) {
        <span class="comment">// 每1000条, 发送一次</span>
        String sql = <span class="string">""</span>;
        Statement statement.addBatch(sql);
        <span class="keyword">if</span>(i%<span class="number">1000</span>==<span class="number">0</span>){
        <span class="comment">// 1000条发送一次, 清除缓存</span>
            statement.excuteBatch();
            statement.clearBatch();
            savepoint = connn.setSavePoint();
        }
        <span class="comment">// 如果插入1000条没有问题保存一个回滚点</span>
    }
} <span class="keyword">catch</span> {
    conn.rollback(savepoint);
} <span class="keyword">finally</span> {
    conn.commit();
}
</pre></td></tr></table></figure>

<h1 id="-">订单查询</h1>
<p>点击订单查看功能按钮, 在服务器端将订单信息输出, 显示页面</p>
<ul>
<li>管理员显示所有人的订单</li>
<li>用户显示自己的订单</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="comment">// OrderSearchServlet</span>
<span class="keyword">public</span> <span class="literal">void</span> doGet(req, resp) {
    <span class="comment">// 从Session中获取用户登陆信息</span>
    User user <span class="subst">=</span> req<span class="built_in">.</span>getSession()<span class="built_in">.</span>getAttribute(<span class="string">"user"</span>);
    <span class="built_in">List</span><span class="subst">&lt;</span><span class="keyword">Order</span><span class="subst">&gt;</span> orders <span class="subst">=</span> orderService<span class="built_in">.</span>showOrders(user);
    req<span class="built_in">.</span>setAttribute(<span class="string">"orders"</span>, orders);
    req<span class="built_in">.</span>getRequestDispatcher(<span class="string">"orders.jsp"</span>)<span class="built_in">.</span>forward(req, resp);
}
<span class="comment">// OrderService</span>
<span class="keyword">public</span> <span class="built_in">List</span><span class="subst">&lt;</span><span class="keyword">Order</span><span class="subst">&gt;</span> showOrders(User user) {
    <span class="keyword">if</span>(user<span class="built_in">.</span>getRole()<span class="built_in">.</span><span class="keyword">equals</span>(<span class="string">"normal"</span>)){
        <span class="comment">// 普通用户</span>
        <span class="keyword">return</span> orderDao<span class="built_in">.</span>findOrdersByUser(user<span class="built_in">.</span>getId());
    } <span class="keyword">else</span> <span class="keyword">if</span>(user<span class="built_in">.</span>getRole()<span class="built_in">.</span><span class="keyword">equals</span>(<span class="string">"admin"</span>)){
        <span class="comment">// 管理员</span>
        <span class="keyword">return</span> orderDao<span class="built_in">.</span>findAllOrders();
    }
}
<span class="comment">// OrderDao</span>
<span class="keyword">public</span> <span class="built_in">List</span><span class="subst">&lt;</span><span class="keyword">Order</span><span class="subst">&gt;</span> findAllOrders(){
    <span class="built_in">String</span> sql <span class="subst">=</span> <span class="string">"select * from order"</span>
    <span class="comment">// 其余代码 参照 findOrdersByUser</span>
}
<span class="keyword">public</span> <span class="built_in">List</span><span class="subst">&lt;</span><span class="keyword">Order</span><span class="subst">&gt;</span> findOrdersByUser(int id){
    <span class="built_in">String</span> sql <span class="subst">=</span> <span class="string">"select * from order where user_id = ?"</span>
    <span class="built_in">List</span><span class="subst">&lt;</span><span class="keyword">Order</span><span class="subst">&gt;</span> orders <span class="subst">=</span> queryRunner<span class="built_in">.</span>query(conn, sql, <span class="literal">new</span> BeanListHandler<span class="subst">&lt;&gt;</span>(), id);

    <span class="comment">// 根据用户id, 查询用户信息</span>
    sql <span class="subst">=</span> <span class="string">"select * from user where id=?"</span>;
    for(<span class="keyword">order</span> <span class="subst">&lt;-</span> orders){
        <span class="built_in">String</span> nickname <span class="subst">=</span> queryRunner<span class="built_in">.</span>query(sql, <span class="literal">new</span> ScalarHandler(<span class="string">"nickname"</span>), <span class="keyword">order</span><span class="built_in">.</span>getUser_id());
        <span class="keyword">order</span><span class="built_in">.</span>setNickname(nickname);
        <span class="comment">// 订单关联订单项, 查询订单项</span>
        <span class="built_in">String</span> sql2 <span class="subst">=</span> <span class="string">"select * from orderitem where order_id=?"</span>;
        <span class="built_in">List</span><span class="subst">&lt;</span>OrderItem<span class="subst">&gt;</span> orderItems <span class="subst">=</span> queryRunner<span class="built_in">.</span>query(conn, sql2, <span class="literal">new</span> BeanListHandler<span class="subst">&lt;&gt;</span>(), <span class="keyword">order</span><span class="built_in">.</span>getId);
        <span class="keyword">order</span><span class="built_in">.</span>setOrderItems(orderItems);
        <span class="comment">// 查询每个订单项 关联商品信息</span>
        for(OrderItem orderItem : orderItems) {
            <span class="built_in">String</span> sql4 <span class="subst">=</span> <span class="string">"select * from product where id=?"</span>;
            Product product <span class="subst">=</span> queryRunner<span class="built_in">.</span>query(conn, sql4, <span class="literal">new</span> BeanHandler(), orderItem<span class="built_in">.</span>getProduct_id);
            orderItem<span class="built_in">.</span>setProduct(product);
        }
    }
    <span class="keyword">return</span> orders;
}
</pre></td></tr></table></figure>

<h1 id="-">在线支付</h1>
<ul>
<li>支付方案一: 网站直接与银行对接<ul>
<li>服务器根据银行的接入规范, 生成银行需要的数据, 然后通知用户浏览器重定向到银行,
并把这些数据发给银行, 以完成支付</li>
<li>缺点, 网站需要针对不同银行开发不同的支付程序, 且银行规范一旦发生变动, 网站也要跟着改</li>
</ul>
</li>
<li>支付方案二: 网站通过第三方支付公司与银行对接<ul>
<li>用户登陆商城, 选择银行, 只需要根据根据第三方公司的接入规范,
将参数发给第三方支付公司, 再由第三方支付公司, 根据不同银行接入规范, 对接银行</li>
<li>缺点, 网站与第三方支付公司定期资金结算, 资金安全是个大问题,
也收取一定的手续费, 这种支付方案只适合金额在百万以下的公司</li>
</ul>
</li>
</ul>
<h2 id="-">易宝支付</h2>
<p>支付流程</p>
<ol>
<li>商城在易宝网站 商家注册(审核), 易宝提供给商家: 商家编号, 密钥</li>
<li>用户支付流程<ul>
<li>用户选择银行, 获取银行编码</li>
<li>商城根据订单号 金额 银行, 根据第三方公司接入规范,
将参数发送给第三方支付公司(302重定向)</li>
<li>第三方公司转到网银支付页面, 支付</li>
<li>支付完成, 网银重定向到支付公司页面, 支付公司通知商城, 并调用商城的返回页面</li>
</ul>
</li>
</ol>
<p>密钥解决数字签名</p>
<ul>
<li>商城将订单号 金额 callback 商家编号, 发送给支付公司,
支付公司为了验证消息来自商城, 商城将发送数据, 使用商家提供密码,
进行加密获取数字签名；支付公司将发送来的数据, 采用通用密钥也加密一次,
对比两个签名</li>
<li>支付公司在通知商城支付成功, 也要使用数字签名</li>
</ul>
<h2 id="-">编程实现</h2>
<ol>
<li>需要商家编号和加密密钥</li>
<li>在支付的第一步, 选择银行, 发送支付银行id<ul>
<li>修改Order.jsp, 将订单号和金额发送给选择银行的界面</li>
<li>选择好银行, 转到商城 Servlet, 根据第三方接入规范, 加密数据</li>
</ul>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">// PayServlet</span>
<span class="keyword">public</span> <span class="literal">void</span> doGet(req, resp) {
    <span class="built_in">String</span> orderId <span class="subst">=</span> req<span class="built_in">.</span>getParameter(<span class="string">"orderid"</span>);
    <span class="built_in">String</span> money <span class="subst">=</span> req<span class="built_in">.</span>getParameter(<span class="string">"mondey"</span>);
    <span class="built_in">String</span> pd_FrpId <span class="subst">=</span> req<span class="built_in">.</span>getParameter(<span class="string">"pd_FrpId"</span>);

    <span class="comment">// 根据第三方接入, 准备参数</span>
    <span class="built_in">String</span> p0_Cmd <span class="subst">=</span> <span class="string">"Buy"</span>;
    <span class="built_in">String</span> p1_MerId <span class="subst">=</span> <span class="string">"1234566"</span>;

    <span class="comment">// 将所有数据进行数字签名</span>
    <span class="built_in">String</span> key <span class="subst">=</span> <span class="string">""</span>; <span class="comment">// 密钥</span>
    <span class="built_in">String</span> hmac <span class="subst">=</span> PaymentUtil<span class="built_in">.</span>buildHmac(p0_cmd, p1_MerId);

    <span class="comment">// 将所有的数据发送给易宝指定页面</span>
    <span class="comment">// 或跳转到 确认支付页面</span>
    req<span class="built_in">.</span>getRequestDispatcher(<span class="string">""</span>)<span class="built_in">.</span>forward(req, resp);
}
</pre></td></tr></table></figure>

<p>当用户付款后, 第三方支付方重定向(第一次)商城支付结果页面, 提供给用户付款已经
成功提示,(并没有真正收到钱), 当银行通过程序通知第三方支付, 钱已经支付了,
第三方支付通知商城(第二次), 钱到了, 商城修改订单状态</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// CallBackServlet 付款后回调程序</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(){
    <span class="comment">// 校验, 易宝数字签名</span>
    String p0 = req.getParameter(<span class="string">"p0"</span>);
    String hmac = req.getParameter(<span class="string">""</span>);

    <span class="comment">// 将响应数据加密, 校验 hmac</span>
    <span class="keyword">boolean</span> isValid = PaymentUtil.verifyCallback(hmac, ...);
    <span class="keyword">if</span>(isValid) {
        <span class="comment">// 区分两次访问类型</span>
        <span class="keyword">if</span>(r9_BType == <span class="number">1</span>){
            <span class="comment">//银行付款后的友好页面</span>
        } <span class="keyword">else</span> <span class="keyword">if</span>(r9_BType == <span class="number">1</span>) {
            <span class="comment">// 银行已经真正收到钱, 修改订单状态</span>
        }
    } <span class="keyword">else</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数字签名错误"</span>);
    }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day25-estore2]]></title>
    <link href="http://zhpooer.github.io/2014/05/08/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day25-estore2/"/>
    <id>http://zhpooer.github.io/2014/05/08/传智播客day25-estore2/</id>
    <published>2014-05-08T00:52:58.000Z</published>
    <updated>2014-05-08T07:04:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">添加商品功能(图片上传)</h1>
<p>修改 Product_add.jsp</p>
<h2 id="-">文件上传必要知识</h2>
<p>文件上传, HTTP 请求格式, 符合MIME协议(Content-Type, Content-Disposition)</p>
<p>客户端: 请求提交方式必须是POST, 编码格式 multipart/form-data,
上传文件输入框必须提供 name 属性</p>
<p>服务端: 采用 apache commons-fileupload (早期流行技术 jsp smartload),
内置文件上传技术 Part 技术</p>
<p>上传文件问题:</p>
<ul>
<li>文件名乱码问题</li>
<li>上传文件重名问题</li>
<li>大文件上传, 空间占用</li>
</ul>
<h2 id="-">表现层</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="comment">// ProductAddServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp){
    <span class="comment">// 请求是否为文件上传</span>
    <span class="keyword">if</span>(ServletFileUpload.isMultipartContent(req)){
        <span class="comment">// 构造自定义请求参数 Map</span>
        Map parameterMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();
        DiskFileItemFactory fac = <span class="keyword">new</span> DiskFileItemFactory();
        ServletFileUpload sfu = <span class="keyword">new</span> ServletFileUpload(fac);
        List fileItems = sfu.parseRequest(req);
        <span class="keyword">for</span>(f &lt;- fileItems) {
            <span class="keyword">if</span>(f.isFormField()){
                <span class="comment">// 是普通元素</span>
                parameterMap.put(f.getFieldName(), f.getString(<span class="string">"UTF-8"</span>));
            } <span class="keyword">else</span> {
                <span class="comment">// 是上传元素</span>
                <span class="comment">// 上传图片, 唯一文件名字, 目录分散</span>
                InputStream <span class="keyword">in</span> = <span class="keyword">new</span> BufferInputStream(fileItem.getInputStream());
                <span class="comment">// 将图片信息保存到服务器</span>
                <span class="comment">// 商品图片是可以直接访问的, 建立在 WebRoot 下</span>
                String realName = fileItem.geName();
                <span class="comment">//根据真实文件名, 生成唯一文件名 UUID.扩展名</span>
                String filename = UploadUtils.generateRandomFileName(realName);
                String hashDir = UploadUtils.generateRandomDir(filename); <span class="comment">// /E8/A9</span>
                <span class="comment">// 存放文件的绝对路径</span>
                String absoluteDir = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/upload"</span>) + hasDir;
                <span class="keyword">new</span> File(absoluteDir).mkdirs();

                <span class="comment">// 创建文件输出流</span>
                OutputStream <span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(absoluteDir + File.pathSaperate + filename);
                <span class="comment">// apache commonio.jar 拷贝文件 FileUtils.copyFile();</span>
                <span class="comment">// CopyUtils 拷贝文件 apache工具包, 简化下面操作</span>
                OutputStream <span class="keyword">out</span> = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">out</span>);
                <span class="keyword">int</span> b;
                <span class="keyword">while</span>(b=<span class="keyword">in</span>.read()!=-<span class="number">1</span>){
                     <span class="keyword">out</span>.write(b);
                }
                <span class="keyword">in</span>.close();
                <span class="keyword">out</span>.close();
                <span class="comment">// 在浏览器显示图片</span>
                parameterMap.put(<span class="string">"imgurl"</span>, <span class="string">"/upload"</span> + hashDir + <span class="string">"/"</span> + filename);
            }
        }
        <span class="comment">//将那个求取的的数据封装java对象</span>
        Product product = <span class="keyword">new</span> Product();
        BeanUtils.populate(product, parameterMap);
        productService.addProduct(product);
        <span class="comment">// 跳转</span>
    } <span class="keyword">else</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"添加上传, 必须为 multipart/form-data"</span>)
    }
}
</pre></td></tr></table></figure>

<h2 id="-">业务层</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductService</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProduct</span>(Product product);
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProduct</span>(Product product) {
        productDao.insert(product);
    }
}
</pre></td></tr></table></figure>

<h2 id="-">持久层</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDaoImpl</span> <span class="keyword">implements</span> <span class="title">ProductDao</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(Product product){
        String sql = <span class="string">"insert into product values(...);"</span>
        queryRunner.update(conn, sql, product.getName, ...);
    }
}
</pre></td></tr></table></figure>

<h1 id="-">查看商品</h1>
<p>查询所有商品功能, 先访问Servlet, 查询所有商品信息, 保存request对象, 转发, 用 jstl 显示</p>
<p><strong>把页面中的所有相对路径 都换成绝对路径</strong>,
如果 从 1.jsp 转发到 2.jsp, 但是url是 1.jsp, 会产生路径问题</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// ProductSearchServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp) {
    <span class="comment">// 调用业务层, 查询商品集合列表</span>
    List products = products.listAllProducts()
    req.setAttribute(<span class="string">"products"</span>, products)
    <span class="comment">// 将列表通过request对象, 传递给jsp对象</span>
    req.getRequestDispatcher(<span class="string">"/product.jsp"</span>).forward(req,resp);
}

<span class="comment">// ProductService</span>
<span class="keyword">public</span> List <span class="title">listAllProducts</span>(){
    <span class="keyword">return</span> productDao.listAllProducts(); 
}

<span class="comment">// ProductDao</span>
<span class="keyword">public</span> List <span class="title">listAllProducts</span>(){
    String sql = <span class="string">"select * from Product"</span>;
    <span class="keyword">return</span> queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler());
}
</pre></td></tr></table></figure>

<h2 id="-">显示结果数据</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>&lt;c:<span class="keyword">for</span>Each var=<span class="string">"p"</span> items=<span class="string">"<span class="variable">${requestScope.products}</span>"</span>&gt;
    
&lt;/c:<span class="keyword">for</span>Each&gt;
</pre></td></tr></table></figure>

<p>展示列表的图片要使用缩略图</p>
<ul>
<li>使用 img 标签 width 和 height 缩放图片(但是不建议, 浪费带宽)</li>
<li>在上传图片过程中, 对图片缩放(老师工具包PicUtils)</li>
</ul>
<h1 id="-">购物车功能</h1>
<h2 id="-">添加商品到购物车</h2>
<p>在商品列表中点击购买, 将商品加入到购物车, 提示用户商品已经添加到购物车,
继续购物还是查看购物车. (修改product.jsp)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>// 购买链接
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">onclick</span>=<span class="value">"buy(${product.id}, ${procuct.pnum})"</span>&gt;</span>购买<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">(id, pnum)</span>{</span>
    <span class="comment">//判断商品是否有货</span>
    <span class="keyword">if</span>(pnum==<span class="number">0</span>) {
        <span class="comment">// 无货</span>
        alert(<span class="string">"您购买的商品, 已经售罄"</span>);
        <span class="keyword">return</span>;
    }
    <span class="comment">// 递交请求给服务器, 加入购物车</span>
    window.loacation.href = <span class="string">"${pageContext.request.contextPath}/addCart?id="</span> + id;
}
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">// AddCartServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, resp){
    <span class="comment"><span class="xmlDocTag">///</span> 对 product 重写 hashcode 和 equals, 根据id生成</span>
    Map&lt;Product, Integer&gt; cart = req.getSession().getAttribute(<span class="string">"cart"</span>);
    <span class="keyword">if</span>(cart==<span class="keyword">null</span>) cart = <span class="keyword">new</span> HashMap();
    <span class="comment">// 判断是否存在在购物车中</span>
    <span class="keyword">int</span> id = Integer.parseInt(req.getParameter(<span class="string">"id"</span>));
    Product product = <span class="keyword">new</span> Product();
    product.setId(id);
    <span class="keyword">if</span>(cart.contains(product)) {
        cart.put(product, cart.<span class="keyword">get</span>(product) + <span class="number">1</span>);
    } <span class="keyword">else</span> {
        <span class="comment">// 商品没有在购物中, 放入新的商品, 数量为1</span>
        productService.findProduct(id);
        cart.put(p, <span class="number">1</span>);
        <span class="comment">// 调用业务层, 查询完整的商品信息</span>
    }
    req.getSession().setAttribute(<span class="string">"cart"</span>, cart);
    <span class="keyword">out</span>.print(<span class="string">"商品已经加入购物车, 查看购物车, 继续购物"</span>);
}

<span class="comment">// ProductService</span>
<span class="keyword">public</span> Product <span class="title">findProduct</span>(<span class="keyword">int</span> id) {
    <span class="keyword">return</span> productDao.findById(id);
}

<span class="comment">// ProductDao</span>
<span class="keyword">public</span> Product <span class="title">findById</span>(<span class="keyword">int</span> id) {
    String sql = <span class="string">"select * from product where id=?"</span>;
    <span class="keyword">return</span> queryRunner.query(conn,sql, <span class="keyword">new</span> Beanhandler&lt;&gt;(), id)
}
</pre></td></tr></table></figure>

<h2 id="-">查看购物车</h2>
<p>查看购物车, 只要修改 jsp 页面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 计算节省和公花费 --&gt;</span>
<span class="comment">&lt;!-- 定义变量 --&gt;</span>
<span class="tag">&lt;<span class="title">c:set</span> <span class="attribute">var</span>=<span class="value">"saveprice"</span> <span class="attribute">scope</span>=<span class="value">"page"</span> <span class="attribute">value</span>=<span class="value">"0"</span>&gt;</span> <span class="tag">&lt;/<span class="title">c:set</span>&gt;</span>
<span class="tag">&lt;<span class="title">c:set</span> <span class="attribute">var</span>=<span class="value">"totalprice"</span> <span class="attribute">scope</span>=<span class="value">"page"</span> <span class="attribute">value</span>=<span class="value">"0"</span>&gt;</span> <span class="tag">&lt;/<span class="title">c:set</span>&gt;</span>
<span class="comment">&lt;!-- 计算价格 --&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">var</span>=<span class="value">"saveprice"</span> <span class="attribute">scope</span>=<span class="value">"page"</span> <span class="attribute">value</span>=<span class="value">"${saveprice+**}"</span>&gt;</span> <span class="tag">&lt;/<span class="title">set</span>&gt;</span>
<span class="tag">&lt;<span class="title">set</span> <span class="attribute">var</span>=<span class="value">"totalprice"</span> <span class="attribute">scope</span>=<span class="value">"page"</span> <span class="attribute">value</span>=<span class="value">"${totalprice+**}"</span>&gt;</span><span class="tag">&lt;/<span class="title">set</span>&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day24-Estore商城项目]]></title>
    <link href="http://zhpooer.github.io/2014/05/06/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day24-estore%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/"/>
    <id>http://zhpooer.github.io/2014/05/06/传智播客day24-estore商城项目/</id>
    <published>2014-05-06T01:07:03.000Z</published>
    <updated>2014-05-10T12:42:57.000Z</updated>
    <content type="html"><![CDATA[<p>Javaweb 课程 是 Javaee 课程基础, 课程定位网站开发(PHP .NET一样)
<a href="https://github.com/zhpooer/itcast-estore" target="_blank">最终代码</a></p>
<h1 id="-">软件开发流程</h1>
<ol>
<li>调研需求: 售前工程师(需求工程师)配合销售, 第一时间了解客户需求</li>
<li>需求分析: 需求工程师, 需求文档(系统描述项目有哪些功能)</li>
<li><em>制作系统静态页面</em><br>Java工程师, 做系统页面(Jquery easyUI 框架, ExtJS框架)</li>
<li>架构师进行技术选型, 搭建系统架构(资深开发人员, 技术经理)</li>
<li><em>数据库设计</em>(Power Designer)</li>
<li><em>功能开发</em></li>
<li>测试</li>
</ol>
<h1 id="estore-">Estore 商城需求功能分析</h1>
<ul>
<li>导入 Estore 静态页面<ul>
<li>导入项目方式, 不建议 import, 因为 myeclipse 项目, eclipse项目, maven项目,
ant项目, 结构都不一样<ol>
<li>新建 web 项目, estore, J2ee5.0</li>
<li>将demo代码赋值过来, 将源码和配置文件, 复制src, 将页面代码复制到</li>
<li>企业前端工程师(美工)提供静态页面(html)<br>我们要做的是, 就是将html中的静态数据, 连接数据库编程动态数据</li>
<li>部署到Tomcat</li>
</ol>
</li>
</ul>
</li>
<li>功能分析<ol>
<li>注册(验证码, 激活邮件, md5密码加密)</li>
<li>登陆</li>
<li>添加商品(文件上传)</li>
<li>查看商品(条件查询, 分页)</li>
<li>购物车(添加商品到购物车, 查看购物车, 修改购物车中的商品数量)</li>
<li>订单生成</li>
<li>订单查看</li>
<li>在线付款</li>
</ol>
</li>
</ul>
<h1 id="-">技术选型</h1>
<p>前端: JSP(jstl, el) + Servlet(Filter, Listener)</p>
<p>后端: Apache BeanUtils(将请求数据封装到 javabean) + javamail(邮件发送) + Apache FileUpload</p>
<p>数据库: C3P0 + Apache DBUtils + 在线支付 + log4j日志技术</p>
<p>MVC 设计模式(Web项目整体架构) + DAO模式(数据层)</p>
<p>数据库: mysql</p>
<p>Jar包:</p>
<ul>
<li>jstl(jstl.jar, standard.jar)</li>
<li>BeanUtils (beanutils.jar common-logging)</li>
<li>FileUpload (fileupload.jar, io)</li>
<li>Dbutils</li>
<li>c3p0 (c3p0.jar)</li>
<li>mysql驱动</li>
<li>日志(log4j)和javamail后期导入</li>
</ul>
<h1 id="-">目录开发结构</h1>
<p>三层结构: 表现层(web) + 业务层 + 数据层</p>
<p>包名规范: 公司 + 项目组 + 项目代号 + 分层 <code>cn.itcast.estore.*</code></p>
<ul>
<li><code>cn.itcast.estore.web</code>表现层</li>
<li><code>cn.itcast.estore.service</code> 业务层</li>
<li><code>cn.itcast.estore.dao</code> 数据层</li>
<li><code>cn.itcast.estore.utils</code> 工具类</li>
<li><code>cn.itcast.estore.entity</code> 实体</li>
</ul>
<h1 id="-">数据库设计</h1>
<p>Mysql 开发规则: 一个软件项目, 使用一个 database, 对应一个账户</p>
<h2 id="-">新建数据库</h2>
<p>注意编码问题, 配置 my.ini(my.conf) </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'%char%'</span>;</span>
</pre></td></tr></table></figure>

<p>System 系统字符集, 系统决定, 无法修改</p>
<p>Server 服务器字符集,修改 <code>[mysqld] character-set-server=utf-8</code></p>
<p><code>[mysql] default-charactor-set</code> 可以修改:</p>
<ul>
<li>Client 客户端输入字符集</li>
<li>Connection 连接字符集</li>
<li>Results 结果字符集</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">database</span> estore;</span>
<span class="comment">-- 新建用户</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">user</span> angel@<span class="string">'localhost'</span> identified <span class="keyword">by</span> <span class="string">'angel'</span>;</span>
<span class="comment">-- create user angel@'%' 任意连接都可以</span>

<span class="operator"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> estore.* <span class="keyword">to</span> angel@<span class="string">'localhost'</span>;</span>
</pre></td></tr></table></figure>

<h2 id="-">数据库设计</h2>
<p>Power Designer 数据库建模</p>
<p>传统数据库分析设计 E-R实体关系图</p>
<p>涉及到实体: 用户, 商品(类别), 购物车, 订单</p>
<p>三个实体表: 用户表, 订单表, 商品表</p>
<p>用户和订单关系: 在订单表中添加用户编号, 不需要单独建表</p>
<p>订单和商品关系: 中间表(订单号, 商品编号, ) 
<img src="/img/er.png" alt="ER关系图"></p>
<h2 id="-">数据库建表</h2>
<p>建的表不一定和ER表中一样, 如为了代码功能增加, 增加字段(user邮箱激活码)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (
    id <span class="keyword">int</span> auto_increment <span class="keyword">primary</span> <span class="keyword">key</span>,
    email <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,
    password <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    nickname <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    role <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    active <span class="keyword">int</span>,
    activecode <span class="keyword">varchar</span>(<span class="number">255</span>)
)engine=innodb <span class="keyword">default</span> charset=utf-<span class="number">8</span>;</span>

<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> product (
    id <span class="keyword">int</span> auto_increment <span class="keyword">primary</span> <span class="keyword">key</span>,
    name <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    category <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    markedprice <span class="keyword">double</span>,
    estoreprice <span class="keyword">double</span>,
    pnum <span class="keyword">int</span>,
    imgurl <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    description <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>
)engine=innodb <span class="keyword">default</span> charset=utf-<span class="number">8</span>;</span>

<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> orders(
    id <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">primary</span> <span class="keyword">key</span>,
    totalprice <span class="keyword">double</span>,
    receiverinfo <span class="keyword">varchar</span>(<span class="number">255</span>),
    paystate <span class="keyword">int</span>,
    createtime <span class="keyword">timestamp</span>,
    user_id <span class="keyword">int</span>,
    <span class="keyword">constraint</span> user_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(user_id) <span class="keyword">references</span> <span class="keyword">user</span>(id)
)engine=innodb <span class="keyword">default</span> charset=utf-<span class="number">8</span>;</span>

<span class="operator"><span class="keyword">create</span> orderitem(
   order_id <span class="keyword">varchar</span>(<span class="number">255</span>),
   product_id <span class="keyword">int</span>,
   buynum <span class="keyword">int</span>,
   <span class="keyword">constraint</span> order_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(order_id) <span class="keyword">references</span> orders(id),
   <span class="keyword">constraint</span> prodect_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(product_id) <span class="keyword">references</span> product(id)
)engine=innodb <span class="keyword">default</span> charset=utf-<span class="number">8</span>;</span>
</pre></td></tr></table></figure>

<h1 id="-">建立实体类</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> User {
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String email;
    <span class="keyword">private</span> String password;
    <span class="keyword">private</span> String nickname;
    <span class="keyword">private</span> String role;
    <span class="keyword">private</span> <span class="keyword">int</span> active;
    <span class="keyword">private</span> String activecode;
}

<span class="keyword">public</span> <span class="keyword">class</span> Product {
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> String category;
    <span class="keyword">private</span> <span class="keyword">int</span> pnum;
    <span class="keyword">private</span> <span class="keyword">double</span> marketprice;
    <span class="keyword">private</span> doublc estoreprice;
    <span class="keyword">private</span> String imgurl;
    <span class="keyword">private</span> String description;
}

<span class="keyword">public</span> <span class="keyword">class</span> Order{
    <span class="keyword">private</span> String id;
    <span class="keyword">private</span> <span class="keyword">double</span> totalprice;
    <span class="keyword">private</span> String receiverinfo;
    <span class="keyword">private</span> <span class="keyword">int</span> paystate;
    <span class="keyword">private</span> Timestamp createtime;
    <span class="keyword">private</span> Int user_id;
}

<span class="keyword">public</span> <span class="keyword">class</span> OrderItem {
    <span class="keyword">private</span> String order_id;
    <span class="keyword">private</span> <span class="keyword">int</span> product_id;
    <span class="keyword">private</span> <span class="keyword">int</span> buynum
}
</pre></td></tr></table></figure>

<h1 id="-">用户注册功能实现</h1>
<p><img src="/img/register_ui.png" alt="注册页面">
重要知识点: 激活邮件功能</p>
<h2 id="javamail-">JavaMail 技术入门</h2>
<h3 id="-">邮件软件开发的概念</h3>
<ul>
<li><p>邮件服务器和电子邮箱</p>
<p>  必须有专门的计算机, 安装邮件服务程序<br>  电子邮箱: 邮件服务器账户, 使用电子邮箱登录到邮件服务器</p>
</li>
<li><p>邮件传输协议</p>
<p>  SMTP协议: 发送邮件<br>  POP3协议: 接收协议, 下载到本地操作<br>  imap: 接收协议, 网络在线操作邮件, 很多邮件服务器不支持</p>
</li>
<li><p>邮件收发过程</p>
<p>  例如 aa@163.com 向 bb@sina.com 发送邮件</p>
<ol>
<li>aa 使用smtp协议登陆到163发送邮件服务器</li>
<li>发送邮件 163 smtp服务器将邮件投送到 新浪 smtp 服务器</li>
<li>新浪 smtp 服务器 将邮件保存到 bb 信箱</li>
<li>bb使用 pop3 协议 登陆sina 收取邮件服务器</li>
<li>sina 收取服务器 将邮件取出</li>
</ol>
</li>
</ul>
<p>可以用 易邮 在window上新建邮件服务器</p>
<h3 id="mx-a-">MX记录和A记录</h3>
<p>MX记录: 163 SMTP 服务器将信发送给 新浪 SMTP 服务器,
是如何知道 SMTP 服务器地址是什么?
解决 SMTP 服务器可以接受外来的邮件, </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>;; 查询域名
cmd&gt; nslookup 连接到互联网
&gt; <span class="keyword">set</span> <span class="built_in">type</span>=mx
&gt; sina.com
</pre></td></tr></table></figure>

<p>A记录: 个人用户, 使用 smtp 服务器发送邮件, 需要登陆 如果 163smtp 服务器
向 sina stmp 服务器投递邮件, 需不需要登陆? 存在于A记录中的服务器,
可以在向其他 stmp 服务器投递邮件时, 不需要登陆验证</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>;; 查询A记录
cmd&gt; nslookup 连接到互联网
&gt; <span class="keyword">set</span> <span class="built_in">type</span>=a
&gt; <span class="number">163</span>.com
</pre></td></tr></table></figure>

<h3 id="javamail-demo">JavaMail Demo</h3>
<h4 id="-">描述一封邮件</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// 使用javamail API 描述一份邮件内容</span>
Session session <span class="subst">=</span> <span class="built_in">null</span>; <span class="comment">// 代表邮件服务器的一个连接会话</span>
java<span class="built_in">.</span>mail<span class="built_in">.</span>Message msg <span class="subst">=</span> <span class="literal">new</span> MimeMessage(session);  <span class="comment">// 一封邮件</span>
<span class="comment">// 使用message生成RFC822文档要求的邮件内容</span>
msg<span class="built_in">.</span>setFrom(<span class="literal">new</span> InternetAddress(<span class="string">"aa@estore.com"</span>)); <span class="comment">// 发件人</span>
msg<span class="built_in">.</span>setRecipient(RecipientType<span class="built_in">.</span><span class="keyword">TO</span>, <span class="literal">new</span> InternetAddress(<span class="string">"bb@estore.com"</span>)); <span class="comment">// 设置收件人</span>
msg<span class="built_in">.</span>setSubject(<span class="string">"测试邮件"</span>);
msg<span class="built_in">.</span>setText(<span class="string">"简单文字内容"</span>); <span class="comment">// or setContent();</span>
<span class="comment">// 定义复杂内容</span>
msg<span class="built_in">.</span>setContent(<span class="string">"&lt;a href='xxx'&gt;激活&lt;/a&gt;"</span>, <span class="string">"text/html;charset=utf-8"</span>);
</pre></td></tr></table></figure>

<h4 id="-">发送一封邮件</h4>
<p><a href="http://pringles.iteye.com/blog/125196" target="_blank">更加详细的介绍</a></p>
<p>JavaMail 核心类:</p>
<ul>
<li>Message 代表一封邮件</li>
<li>Session 代表连接邮件服务器会话</li>
<li>Transport 用于发送邮件</li>
<li>Store 用于收取邮件</li>
</ul>
<p>发送流程</p>
<ol>
<li>配置smtp邮件服务器, 连接参数</li>
<li>编写邮件 Message</li>
<li>使用Transport 发送邮件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>// 第一步配置 Session 
Properties p = new Properties()<span class="comment">;</span>
p<span class="preprocessor">.setProperty</span>(<span class="string">"mail.smtp.host"</span>, <span class="string">"localhost"</span>)<span class="comment">;</span>
p<span class="preprocessor">.setProperty</span>(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>)<span class="comment">;</span>
p<span class="preprocessor">.put</span>(<span class="string">"mail.smtp.auth"</span>,<span class="string">"true"</span>)<span class="comment">; // 如果是163需要验证, 要加上这句</span>
Session session = Session<span class="preprocessor">.getInstance</span>(p)<span class="comment">;</span>

// 第二步, 编写邮件, 按照上一节代码

// 第三步: 连接服务器发送邮件
Transport transport = session<span class="preprocessor">.getTransport</span>()<span class="comment">;</span>
transport<span class="preprocessor">.connect</span>(<span class="string">"aaa"</span>, <span class="string">"111"</span>)<span class="comment">; // 登陆,连接服务器</span>
transport<span class="preprocessor">.sendMessage</span>(msg, msg<span class="preprocessor">.getRecipient</span>(RecipientType<span class="preprocessor">.TO</span>))<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="-">完成注册</h2>
<p>验证码技术原理: 在页面加载时, 服务器生成验证码,
将其保存在Session, 防止恶意提交</p>
<ol>
<li>register.jsp 所有的表单元素, 添加 name 元素</li>
<li>修改 form 的 Action 地址</li>
<li><p>编写 表现层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>// cn<span class="preprocessor">.itcast</span><span class="preprocessor">.estore</span><span class="preprocessor">.servlet</span><span class="preprocessor">.RegistServlet</span><span class="preprocessor">.java</span>
public void doGet(){
    // 判断密码是否一致
    String password = req<span class="preprocessor">.getParameter</span>(<span class="string">"password"</span>)<span class="comment">;</span>
    String repassword = req<span class="preprocessor">.getParameter</span>(<span class="string">"repassword"</span>)<span class="comment">;</span>
    if(!password<span class="preprocessor">.equals</span>(repassword)){
        request<span class="preprocessor">.setAttribute</span>(<span class="string">"msg"</span>, <span class="string">"两次密码不一致"</span>)<span class="comment">;</span>
        request<span class="preprocessor">.getRequestDispatcher</span>(<span class="string">"/regist.jsp"</span>)<span class="preprocessor">.forward</span>(req, res)<span class="comment">;</span>
    }
    // 判断验证码是否正确
    String checkcode = req<span class="preprocessor">.getParameter</span>(<span class="string">"checkcode"</span>)<span class="comment">; // 用户填写</span>
    String key = req<span class="preprocessor">.getSession</span>()<span class="preprocessor">.getAttribute</span>(<span class="string">"key"</span>)<span class="comment">;</span>
    if(key==null || !checkcode<span class="preprocessor">.equals</span>(key)){
        request<span class="preprocessor">.setAttribute</span>(<span class="string">"msg"</span>, <span class="string">"验证码错误"</span>)<span class="comment">;</span>
        request<span class="preprocessor">.getRequestDispatcher</span>(<span class="string">"/regist.jsp"</span>)<span class="preprocessor">.forward</span>(req, res)<span class="comment">;</span>
    }
    req<span class="preprocessor">.getSession</span>()<span class="preprocessor">.removeAttribute</span>(<span class="string">"key"</span>)<span class="comment">;</span>
    // 用户注册
    // <span class="number">1.</span> 将页面的数据封装到 User 对象, 采用BeanUtils
    User user = new User()<span class="comment">;</span>
    BeanUtils<span class="preprocessor">.populate</span>(user, req<span class="preprocessor">.getParameterMap</span>())<span class="comment">;</span>
    // <span class="number">2.</span> 将封装好的User对象传递给业务层处理
    UserService userService = new UserService()<span class="comment">;</span>
    userService<span class="preprocessor">.regist</span>(user)<span class="comment">;</span>

    res<span class="preprocessor">.setContentType</span>(<span class="string">"text/html;charset=utf-8"</span>)<span class="comment">;</span>
    res<span class="preprocessor">.getWrite</span>()<span class="preprocessor">.write</span>(<span class="string">"请到邮箱去激活"</span>)<span class="comment">;</span>
}
</pre></td></tr></table></figure>
</li>
<li><p>编写业务层</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="comment">// cn.itcast.estore.service</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span>(User user);
}
<span class="comment">// cn.itcast.estore.service.impl</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>{</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span>(User user) {
        <span class="comment">// 1. 生成激活码, 发送激活邮件</span>
        String activeCode = UUID.randomUUID().toString();
        <span class="comment">// 发送邮件, 请参照发送邮件章节</span>
        Message msg = <span class="keyword">new</span> MimeMessage(session);
        msg.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">"admin@estore.com"</span>));
        <span class="comment">// msg.setRecipient(); msg.setSubject();</span>
        msg.setContent(<span class="string">"&lt;h2&gt;欢迎注册&lt;/h2&gt;&lt;a href='"</span>+ activeCode+<span class="string">"' &gt;激活&lt;/a&gt;"</span>);
        <span class="comment">// 2. 将用户信息保存到数据库</span>
        user.setActivecode(activeCode);
        user.setActive(<span class="number">0</span>);
        user.setRole(<span class="string">"user"</span>); <span class="comment">//普通用户</span>
        <span class="comment">// 3. 调用数据层</span>
        userDao.insert(user);
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>编写数据库接口和实现类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// cn.itcast.estore.dao</span>
<span class="keyword">public</span> <span class="keyword">interface</span> UserDAO {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(User user);
}
<span class="comment">// cn.itcast.estore.dao.impl</span>
<span class="keyword">public</span> <span class="keyword">class</span> UserDAOImpl {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(User user){
        <span class="comment">// 1. c3p0获取数据库连接池</span>
        DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();
        <span class="comment">// 2. 插入数据</span>
        QueryRunner qs = <span class="keyword">new</span> QueryRunner(ds);
        String sql = <span class="string">"insert into user values(null, ?, ?, ...)"</span>
        <span class="comment">// 用户的密码用密文保存</span>
        qs.update(sql, MD5Utils.md5(user.getPassword()));
    }
}
</pre></td></tr></table></figure>

</li>
</ol>
<p>乱码问题处理: 请参照之前章节, 重写 <code>getParameterMap()</code> <code>getParameter()</code> <code>getValues()</code></p>
<h3 id="-">注册用户激活</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="comment">// ActiveServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, res){
    String activecode = req.getParameter(<span class="string">"activecode"</span>);
    UserService userService = <span class="keyword">new</span> UserServiceImpl();
    <span class="keyword">int</span> result = userService.active(activecode);
    res.setContentType(<span class="string">"text/html;charset=utf-8"</span>);
    <span class="keyword">if</span>(result == Constants.ACTIVEMAIL_HASACTIVE){
        <span class="keyword">out</span>.print(<span class="string">"账户已经激活"</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (result == Constants.ACTIVEMAIL_INVALIDATEACTIVCOD){
        <span class="keyword">out</span>.println(<span class="string">"激活码无效"</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (result == Constants.ACTIVEMAIL_OK){
        <span class="keyword">out</span>.println(<span class="string">"激活成功"</span>);
    }
}
<span class="comment">// UserService, 返回数字 </span>
<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">active</span>(String activecode){
    <span class="comment">// 判断激活码是由有效</span>
    User user = userDAO.findByActiveCode(activecode);
    <span class="keyword">if</span>(user == <span class="keyword">null</span>) {
        <span class="comment">// 激活码无效</span>
        <span class="keyword">return</span> Constants.ACTIVEMAIL_INVALIDATEACTIVCOD;
    } <span class="keyword">else</span> {
        <span class="comment">// 已经激活</span>
        <span class="keyword">if</span>(user.getActive()==<span class="number">1</span>){
            <span class="keyword">return</span> Constants.ACTIVEMAIL_HASACTIVE;
        } <span class="keyword">else</span> {
            <span class="comment">//需要激活</span>
            userDao.updateActive(user.getId());
            <span class="keyword">return</span> Constants.ACTIVEMAIL_OK;
        }
    }
}

<span class="comment">// userDao</span>
<span class="keyword">public</span> User <span class="title">findByActiveCode</span>(String activecode){
    DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();
    QueryRunner qr = <span class="keyword">new</span> QueryRunner(ds);
    String sql = <span class="string">"select * from user where activecode=?"</span>;
    User user = qr.query(sql, <span class="keyword">new</span> Beanhandler&lt;User&gt;(), activecode);
    <span class="keyword">return</span> user;
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateActive</span>(<span class="keyword">int</span> id){
    DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();
    QueryRunner qr = <span class="keyword">new</span> QueryRunner(ds);
    String sql = <span class="string">"update user set active = 1 where id=?"</span>;
    qr.update(sql, id);
}

<span class="comment">// 存放操作常量</span>
<span class="keyword">public</span> <span class="keyword">class</span> Constants {
    <span class="comment">// 邮件激活的几种情况</span>
    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ACTIVEMAIL_TIMEOUT = <span class="number">0</span>;
    <span class="comment">// 正常</span>
    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ACTIVEMAIL_OK = <span class="number">1</span>;
    <span class="comment">// 已经激活过了</span>
    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ACTIVEMAIL_HASACTIVE = <span class="number">2</span>;
    <span class="comment">// 无效</span>
    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ACTIVEMAIL_INVALIDATEACTIVCOD = <span class="number">3</span>;
}
</pre></td></tr></table></figure>

<h2 id="-">用户登陆功能实现</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="comment">// servlet.LoginServlet</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">doGet</span>(req, res){
    <span class="comment">// 将请求的数据, 封装到user对象中</span>
    User user = <span class="keyword">new</span> User();
    BeanUtils.populate(user, request.getParameterMap());
    <span class="comment">// 调用业务层, 进行登陆</span>
    UserService userService = <span class="keyword">new</span> UserServiceImpl();
    User loginUser = userService.login(User);
    <span class="comment">// 判断登陆是否成功</span>
    <span class="keyword">if</span>(loginUser==<span class="keyword">null</span>){
        <span class="comment">// 失败</span>
        req.setAttribute(<span class="string">"msg"</span>, <span class="string">"用户名或者密码错误"</span>);
        req.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(req, res);
    } <span class="keyword">else</span> {
        <span class="keyword">if</span>(loginUser.getActive()==<span class="number">0</span>){
            req.setAttribute(<span class="string">"msg"</span>, <span class="string">"还没有激活"</span>);
            req.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(req, res);
        } <span class="keyword">else</span> {
            request.getSession().setAttribute(<span class="string">"user"</span>, loginUser);
            res.sendRedirect(req.getConentPath() + <span class="string">"/index.jsp"</span>);
        }
    }
}

<span class="comment">// UserService</span>
<span class="keyword">public</span> User <span class="title">login</span>(User user) {
    UserDao userDao = <span class="keyword">new</span> UserDaoImpl();
    <span class="keyword">return</span> userDao.login(user);
}

<span class="comment">// UserDao</span>
<span class="keyword">public</span> User <span class="title">login</span>(User user) {
    String sql = <span class="string">"select * from user where email=? and password=?"</span>;
    User loginUser = qr.query(sql, <span class="keyword">new</span> Beanhandler&lt;User&gt;(), user.getEmail(), MD5Utiles.encode(user.getPassword()));
    <span class="keyword">return</span> loginUser;
}
</pre></td></tr></table></figure>

<h2 id="-">注销功能</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- Invalidate.jsp --&gt;</span>
<span class="vbscript">&lt;%
    sesssion.invalidate();
    <span class="built_in">response</span>.sendRedirect(<span class="string">"login.jsp"</span>);
%&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">记住用户</h2>
<p>只发生在登陆成功时</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// LoginServlet doGet() 成功登陆后, 添加代码</span>
<span class="keyword">if</span>(req.getParameter(<span class="string">"remember"</span>)!=<span class="keyword">null</span>){
    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"email"</span>, loginUser.getEmail);
    cookie.setPath(<span class="string">"/"</span>);
    cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); <span class="comment">// 一天</span>
    res.addCookie(cookie);
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day23-框架学习基础加强]]></title>
    <link href="http://zhpooer.github.io/2014/05/05/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day23-%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA/"/>
    <id>http://zhpooer.github.io/2014/05/05/传智播客day23-框架学习基础加强/</id>
    <published>2014-05-05T01:04:44.000Z</published>
    <updated>2014-05-05T09:45:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">回顾</h1>
<p>围绕 java5 特性: 泛型技术, 反射技术</p>
<h1 id="-">动态代理</h1>
<h2 id="-">代理模式和装饰者模式的区别</h2>
<p>装饰器模式: java基础IO流, javaWeb request 和 response包装<br>对原有代码功能进行增强</p>
<p>代理模式: 对真实对象访问的<strong>拦截作用</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="class"><span class="keyword">interface</span> <span class="title">DAO</span> {</span> <span class="comment">// 业务接口</span>
    <span class="keyword">void</span> insert();
}
<span class="class"><span class="keyword">class</span> <span class="title">MySQLDAO</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">DAO</span>{</span> <span class="comment">// 业务实现类</span>
    <span class="keyword">public</span> <span class="keyword">void</span> insert(){}
}
</pre></td></tr></table></figure>

<p>装饰模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// 装饰对象</span>
class LogDAO implement DAO {
    <span class="comment">// 传入被装饰对象</span>
    DAO dao;
    <span class="comment">// 构造方法传入</span>
    <span class="keyword">public</span> <span class="title">LogDAO</span>(DAO dao){
        <span class="keyword">this</span>.dao = dao;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(){
        <span class="comment">// 代码增强</span>
        dao.insert(); <span class="comment">// 调用被装饰对象insert()</span>
        <span class="comment">// 代码增强</span>
    }
}
<span class="comment">// 使用</span>
DAO dao = <span class="keyword">new</span> LogDAO(<span class="keyword">new</span> MySQLDAO());
</pre></td></tr></table></figure>

<p>代理模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">DAOProxy</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">DAO</span> {</span>
    <span class="comment">// 被代理对象</span>
    DAO dao;
    <span class="comment">// 构造方法传入被代理对象</span>
    <span class="keyword">public</span> DAOProxy(DAO dao){
        <span class="keyword">this</span>.dao = dao;
    }
    <span class="comment">//可以做代码增强, 和访问拦截</span>
    <span class="keyword">public</span> <span class="keyword">void</span> insert(){
        <span class="comment">// 判断是否具有权限</span>
        <span class="comment">// 代码增强</span>
        <span class="keyword">if</span>(有权限) dao.insert(); <span class="comment">// 调用被装饰对象insert()</span>
        <span class="keyword">else</span> 权限不足
        <span class="comment">// 代码增强</span>
    }
}
</pre></td></tr></table></figure>

<h2 id="-">动态代理</h2>
<p>代理模式(静态代理): 需要开发人员编写代理类</p>
<p>动态代理: 不需要开发人员编写代理类,
代理类在JVM中自动创建(动态构造)<br>Struts2 使用静态代理<br>Spring 使用动态代理</p>
<p>代理对象需要和被代理对象具有相同的业务方法(<em>同一个接口</em>)</p>
<h2 id="-">动态代理的过程</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">interface</span> <span class="title">DAO</span> {</span> <span class="comment">// 业务接口</span>
    <span class="keyword">void</span> insert();
    <span class="keyword">void</span> update();
}
<span class="class"><span class="keyword">class</span> <span class="title">MySQLDAO</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">DAO</span>{</span> <span class="comment">// 业务实现类</span>
    <span class="keyword">public</span> <span class="keyword">void</span> insert(){
        println(<span class="string">"insert"</span>);
    }
    <span class="keyword">public</span> <span class="keyword">void</span> update(){
        println(<span class="string">"update"</span>);
    }
}
</pre></td></tr></table></figure>

<p>在 MysqlDAO 中实现日志记录</p>
<ul>
<li>方式一: 继承代码, 覆盖业务方法, 添加新功能(要求业务对象必须是手动创建)</li>
<li>方式二: 装饰者, 对已经存在的对象进行功能<em>扩展</em></li>
<li><p>方式三: 代理, 对已经存在的对象进行功能<em>扩展</em></p>
<p>  利用 <code>java.reflect.Proxy</code> 类, 提供 <code>newProxyInstance(classLoader, interfaces[], invocation)</code> 方法, 构造动态类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="keyword">final</span> DAO dao = <span class="keyword">new</span> MySQLDAO();
    DAO proxy = Proxy.newProxyInstance(dao.getClass().getClassLoader(),
        dao.getClass().getInterfaces(), <span class="keyword">new</span> invocationHandler {
        Object invoke(Object proxy, Method method, Object[] args){
            Object rs = method.invoke(dao, args);
            <span class="comment">// 代码增强拦截</span>
            log(<span class="string">"调用了方法"</span>);
            <span class="keyword">return</span> rs;
        }
    });
    <span class="comment">// 代理对象内部实现</span>
    $$Proxy implement DAO{
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(){
            handler.invoke(<span class="keyword">this</span>, method, args);
        }
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span>(){
            handler.invoke(<span class="keyword">this</span>, method, args);
        }
    }
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="-">动态代理案例,解决请求中文乱码</h2>
<p>index.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"request"</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"msg"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"request"</span> <span class="attribute">method</span>=<span class="value">"get"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"msg"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodeFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(req, res, chain){
        req.setCharactorEncoding(<span class="string">"utf-8"</span>);
        ServletRequest proxy = Proxy.newProxyInstance(req.getClass().getClassLoader,
            req.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler(){
                <span class="keyword">public</span> Object <span class="title">invoke</span>(Object proxy, Method method, Object[] args){
                   <span class="comment">// 判断清水方式是否为get</span>
                    <span class="keyword">if</span>(req.getMethod().equalsIgnoreCase(<span class="string">"get"</span>)){
                        <span class="keyword">if</span>(method.getName().equals(<span class="string">"getParameter"</span>)){
                            String value = method.invoke(req, args);
                            <span class="keyword">if</span>(value=!<span class="keyword">null</span>) {
                                value = <span class="keyword">new</span> String(value.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"utf-8"</span>);
                            }
                            <span class="keyword">return</span> value;
                        }
                    }
                    <span class="keyword">return</span> method.invoke(req, args);
                }
            });
        chain.doFilter(proxy, res);
    }
}
<span class="keyword">if</span>(req.getMethod().equalsIgnoreCase(<span class="string">"get"</span>)){
    String value = <span class="keyword">super</span>.getParameter(name);
    <span class="keyword">if</span>(value=!<span class="keyword">null</span>){
        value = <span class="keyword">new</span> String(value.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"utf-8"</span>);
    }
    <span class="keyword">return</span> value;
}
</pre></td></tr></table></figure>

<h1 id="-annotation-">注解技术(Annotation)</h1>
<p>注释: 给其他开发人员阅读</p>
<p>注解: 给程序阅读的注释, 取代配置文件</p>
<p>配置文件: 为了代码修改方便, 将经常变化信息, 写入配置文件</p>
<p>注解: 程序内部的配置信息, 出现原因: </p>
<ol>
<li>软件复杂, 配置文件太大</li>
<li>程序中都是接口, 没有实现类, <em>造成程序的可读性越来越差</em><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">List</span> <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList(); <span class="comment">//耦合</span>
<span class="comment">// 解决耦合</span>
<span class="keyword">List</span> <span class="keyword">list</span> = <span class="comment">// 工厂提供实现类, 工厂读取配置文件获取实现类</span>
<span class="comment">// 造成程序的可读性越来越差</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jdk-">JDK常见的注解</h2>
<p>三种基本注解:</p>
<ul>
<li><code>@Override</code>: 重写父类方法, 编译时进行代码检查, 
JDK5 只能用于方法覆盖, JDK6 可以用于方法实现</li>
<li><code>@Desprecated</code>: 表示程序某个方法过时</li>
<li><code>@SuppressWarnings</code>: 抑制文件警告<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">@SuppressWarnings</span>(<span class="string">"all"</span>)
<span class="variable">@SuppressWarnings</span>(<span class="string">"Desprecated"</span>)
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="-">注解在企业开发中的应用</h2>
<p>完整应用步骤</p>
<ol>
<li>定义注解</li>
<li>在目标类或者方法、变量上, 应用注解</li>
<li>在程序运行时, 通过反射技术取解析获得注解中的信息</li>
</ol>
<p>在企业开发中, 最常见的是框架内部已经提供注解,
已经提供解析注解的程序, 只需要将注解应用到代码中.</p>
<h3 id="-">自定义注解</h3>
<p>Java 数据类型: 基本类型, 数组, class, enum, interface, @interface</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// 定义注解</span>
<span class="keyword">public</span> @<span class="keyword">interface</span> PersonInfo {
    <span class="comment">// 作为配置文件的替代</span>
    <span class="comment">// 配置信息是通过属性完成</span>
    String name() <span class="keyword">default</span> <span class="string">"小强"</span>;
    <span class="keyword">int</span> age();
}
</pre></td></tr></table></figure>

<ul>
<li><p>注解支持类型:String, 基本数据类型, enum, Class, 其他注解类型, 以上数据类型 相应的一维数组</p>
</li>
<li><p>特殊注解,</p>
<ul>
<li>在应用注解中, 需要为每个属性赋值</li>
<li>如果只有 <code>value</code> 属性, 可以省略掉 <code>value=</code><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>  <span class="at_rule">@interface<span class="preprocessor"> DBInfo</span>{</span>
     String <span class="function">value()</span>;
  }
  <span class="comment">// 使用</span>
  <span class="at_rule">@<span class="function">DBInfo(<span class="string">"Mysql"</span>)</span></span>
</pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="jdk-">JDK元数据</h3>
<p>修饰注解的注解</p>
<ul>
<li><code>@Retention</code>, 修饰注解的有效范围<ul>
<li><code>RetentionPolicy.SOURCE</code>: 在.java文件中有效, 给编译器使用</li>
<li><code>RetentionPolicy.CLASS</code>: 给类加载器用</li>
<li><code>RetentionPolicy.RUNTIME</code>: 给程序使用</li>
</ul>
</li>
<li><code>@Target</code>: 表示注解可以应用的目标<ul>
<li><code>ElementType.ANNOTATION_TYPE</code></li>
<li><code>ElementType.CONSTTRCTOR</code></li>
<li><code>ElementType.FIELD</code></li>
<li><code>ElementType.Method</code></li>
<li><code>ElementType.LOCAL_VARIABLE</code></li>
<li><code>ElementType.TYPE</code>: 用于类和接口</li>
<li><code>ElementType.PACKAGE</code></li>
<li><code>ElementType.PARAMETER</code></li>
</ul>
</li>
<li><code>@Documented</code>: 生成的注解会被生成到文档</li>
<li><code>@Inherited</code>: 应用了这个注解的类的子类会自动继承注解</li>
</ul>
<h2 id="-">提取注解中的信息</h2>
<p>编写流程: </p>
<ol>
<li>编写注解类</li>
<li>应用注解</li>
<li>提取注解信息, 通过 <code>java.lang.reflect.AnnotatedElement</code>接口,
所有反射接口都实现了他<ul>
<li>拿到注解修饰目标的反射对象</li>
<li>通过 <code>AnnotatedElement</code> 接口提供的API, 操作注解</li>
</ul>
</li>
</ol>
<h3 id="-">案例一 银行转账控制</h3>
<p>需求: 每次最大金额20万</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
<span class="keyword">public</span> @<span class="keyword">interface</span> BankInfo{
    <span class="keyword">double</span> maxmoney();
}
<span class="keyword">public</span> <span class="keyword">class</span> Bankz {
    <span class="comment">// 执行转账</span>
    @BankInfo(maxmoney=<span class="number">200000</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span>(String <span class="keyword">from</span>, String to, <span class="keyword">double</span> money) {
        <span class="comment">// money 最大金额限制是200万元</span>
        <span class="comment">// 1. 传统方式, 读取properties, 最大金额</span>
        <span class="comment">// double maxmoney = Double.parseDouble(bundle.getBundle("bank"));</span>
        Class&lt;Bank&gt; c = Bank.Class;
        Method c = c.getMethod(<span class="string">"transfer"</span>, String.class, String.class, <span class="keyword">double</span>.class);
        <span class="comment">// 判断方法中是否由注解信息</span>
        <span class="keyword">if</span>(c.isAnnotationPresent(BankInfo.class)){
            BankInfo info = method.getAnnotaion(BankInfo.class);
            <span class="keyword">double</span> maxmoney = info.maxmoney();
        }
        <span class="keyword">if</span>(money &lt;= maxmoney)
            println(<span class="string">"正常转账, 从"</span> + <span class="keyword">from</span> + <span class="string">"账户向"</span> + to + <span class="string">"账户转了"</span> + money);
    }
}
</pre></td></tr></table></figure>

<h3 id="-">案例二 获得数据库连接参数</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="comment">// 定义注解</span>
<span class="annotation">@Retentioin</span>(RetentionPolicy.RUNTIME)
<span class="annotation">@Target</span>(ElementType.METHOD)
<span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">JdbcInfo</span> {</span>
    String url();
    String driverClass();
    String username();
    String password();
}
<span class="comment">// 应用注解, 配置注解信息</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConnection</span> {</span>
    <span class="annotation">@JdbcInfo</span>(driverCalss=<span class="string">"com.mysql.jdbc.Driver"</span>, url=<span class="string">"jdbc:mysql:///test"</span>,password=<span class="string">""</span>, user=<span class="string">""</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span>(){
        <span class="comment">// 运行时, 通过反射获取注解信息</span>
        Class cl = JdbcConnection.class;
        Method m = c.getMethod(<span class="string">"connect"</span>);
        <span class="keyword">if</span>(m.isAnnotationPresent(JdbcInfo.class)) {
            JdbcInfo info = m.getAnnotaion(JdbcInfo.class);
            String url = info.url(); <span class="comment">//</span>
            Class.forName(driverClass);
            <span class="comment">// 连接数据库</span>
            Connection conn = DriverManager.getConnection(url, user, password);
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"连接失败"</span>);
        }
    }
}
</pre></td></tr></table></figure>

<h2 id="-">案例综合 权限控制</h2>
<p>基于动态代理和注解对方法级别实现细粒度权限控制</p>
<ul>
<li>粗粒度: URL级别的权限控制<ul>
<li>点击页面中的每个链接, 对应服务器一个URL地址, 一个请求, 一个 Servlet</li>
<li>在过滤器中判断当前登陆用户,是否具有访问url的权限</li>
<li>一次请求, 一次判断</li>
</ul>
</li>
<li>细粒度: 方法级别的权限控制<ul>
<li>每个功能对应一个url, 一个Sevlet, 调用多个业务层 Service, 多个持久层DAO</li>
<li>通过注解信息, 判断用户, 控制方法的访问</li>
<li>一次请求, 多次判断</li>
</ul>
</li>
</ul>
<h3 id="-">编程实现</h3>
<h4 id="-">建立数据库</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> privilege(
    id <span class="keyword">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increament,
    name <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
)
<span class="keyword">insert</span> <span class="keyword">into</span> privilege <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">"添加权限"</span>),(<span class="number">2</span>,<span class="string">"删除权限"</span>), (<span class="number">3</span>, <span class="string">"更改权限"</span>);</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(
    id <span class="keyword">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increament,
    username <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
    password <span class="keyword">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,
)
<span class="keyword">create</span> <span class="keyword">table</span> (
    user_id <span class="keyword">int</span>,
    privilege_id <span class="keyword">int</span>,
    <span class="keyword">constraint</span> user_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(user_id) reference <span class="keyword">user</span>(id),
    <span class="keyword">constraint</span> privilege_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(privilege_id) reference privilege(id),
)</span>
</pre></td></tr></table></figure>

<h4 id="-">代码框架</h4>
<p><img src="/img/privilege_control.png" alt="代码框架"></p>
<h5 id="-">登陆</h5>
<p>Login.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">h1</span>&gt;</span>登陆<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
${errMsg}
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"Login"</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span>
   用户名: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"username"</span>/&gt;</span>
   密码: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"password"</span> <span class="attribute">name</span>=<span class="value">"password"</span>/&gt;</span>
   <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> User{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String username;
    <span class="keyword">private</span> String password;
}
</pre></td></tr></table></figure>

<p>LoginServlet.java</p>
<p>使用 c3p0 和 DBUtil</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>public void doGet(req, res){
    String username = req<span class="preprocessor">.getParameter</span>(<span class="string">"username"</span>)<span class="comment">;</span>
    String password = req<span class="preprocessor">.getParameter</span>(<span class="string">"password"</span>)<span class="comment">;</span>

    DataSource ds = JDBCUtils<span class="preprocessor">.getDataSource</span>()<span class="comment">;</span>
    QueryRunner qr = new QueryRunner(ds)<span class="comment">;</span>
    User u = qr<span class="preprocessor">.query</span>(<span class="string">"select * from user where username=? and password=?"</span>, new BeanHandler&lt;User&gt;(User<span class="preprocessor">.class</span>), username, password)<span class="comment">;</span>
    if(user==null){
        req<span class="preprocessor">.setAttribute</span>(<span class="string">"errMsg"</span>, <span class="string">"密码错误"</span>)<span class="comment">;</span>
        req<span class="preprocessor">.getRequestDispatcher</span>(<span class="string">"login.jsp"</span>)<span class="preprocessor">.forward</span>(req,res)<span class="comment">;</span>
    } else {
        req<span class="preprocessor">.getSession</span>()<span class="preprocessor">.setAttribute</span>(<span class="string">"user"</span>, u)
        res<span class="preprocessor">.sendRedirect</span>(request<span class="preprocessor">.getContextPath</span>()+<span class="string">"main.jsp"</span>)
    }
}
</pre></td></tr></table></figure>

<p>访问页面的每一个链接, 执行Service的各种方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">h1</span>&gt;</span>主页<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">h1</span>&gt;</span>登陆用户: ${user.username}<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/productAdd"</span>&gt;</span>添加商品<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/productDel"</span>&gt;</span>删除商品<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/productUpdate"</span>&gt;</span>修改商品<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"/productQuery"</span>&gt;</span>查询商品<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>

<h5 id="-">实现业务功能</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// producetAddServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, res) {
    service.add();
}
<span class="comment">// producetDelServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, res) {
    service.del();
}
<span class="comment">// producetUpdateServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, res) {
    service.update();
}
<span class="comment">// producetQueryServlet</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(req, res) {
    service.update();
}
</pre></td></tr></table></figure>

<p>ProdectService.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> {</span>
    <span class="annotation">@PrivilegeInfo</span>(<span class="string">"添加商品"</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(){
        prinln(<span class="string">"add"</span>)
    }
    <span class="annotation">@PrivilegeInfo</span>(<span class="string">"删除商品)"</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span>(){
        prinln(<span class="string">"del"</span>)
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span>(){
        prinln(<span class="string">"update"</span>)
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span>(){
        prinln(<span class="string">"query"</span>)
    }
}
</pre></td></tr></table></figure>

<h4 id="-">通过注解和动态代理添加权限控制</h4>
<p>访问目标方法需要权限</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="annotation">@Target</span>(ElementType.METHOD)
<span class="annotation">@Inherited</span>
<span class="keyword">public</span> @<span class="class"><span class="keyword">interface</span> <span class="title">privilege</span> {</span>
    String value();
}
</pre></td></tr></table></figure>

<p>为了实现动态代理, 添加服务接口, 给服务类添加注解</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">interface</span> IProdectService{
    @PrivilegeInfo(<span class="string">"添加商品"</span>)
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>();
    @PrivilegeInfo(<span class="string">"删除商品)"</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span>();
}
<span class="keyword">public</span> <span class="keyword">class</span> ProductService implement IProdectService{
}
</pre></td></tr></table></figure>

<p>动态代理实现权限控制</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="comment">// 在执行 doGet 之前</span>
<span class="keyword">public</span> <span class="title">beforeDoGet</span>(){
    User user = req.getSession().getAttribute(<span class="string">"user"</span>);
    service = ProducetProxyFactory.makeProxy(<span class="keyword">new</span> ProductService, user);
    service.doSome();
}

<span class="keyword">public</span> <span class="keyword">class</span> ProductProxyFactory {
    <span class="comment">// user 当前登陆用户</span>
    <span class="comment">// ProductService 当前业务对象</span>
    <span class="keyword">public</span> <span class="keyword">static</span> IProductService <span class="title">makeProxy</span>(final ProductService ps, User user) {
        Proxy.newProxyInstance(classLoader,
            ps.getClass().getClassLoader(), <span class="keyword">new</span> InvocationHandler(){
                <span class="keyword">public</span>  Object <span class="title">invoke</span>(proxy, method, args){
                    <span class="comment">// 判断用户是否登陆</span>
                    <span class="keyword">if</span>(user==<span class="keyword">null</span>){
                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"用户还没有登陆"</span>);
                    }
                    <span class="comment">// 获取业务方法上的注解信息</span>
                    <span class="keyword">if</span>(method.isAnnotationPresent(PrivilegeInfo.class)) {
                        method.getAnnotaion(PrivilegeInfo.class);
                        String needPrivilege = privilegeInfo.<span class="keyword">value</span>();

                        <span class="comment">// 判断用户数是由具有权限</span>
                        DataSource ds = JDBCUtils.getDataSource();
                        QueryRunner qr = <span class="keyword">new</span> QueryRunner(ds);
                        String sql = <span class="string">"select privilege.* from privilege "</span>
                            + <span class="string">"inner join user_privilege up on privilege.id=up.privilege_id where up.user=?"</span>
                        List&lt;Privilege&gt; privileges = qr.query(sql, <span class="keyword">new</span> BeanListHandler&lt;Privilege&gt;, user.getId);
                        <span class="keyword">for</span>(p &lt;- privileges) {
                            <span class="keyword">if</span>(p.getName().equals(needPrivilege))
                                method.invoke(ps, args);
                        }
                        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"权限不足"</span>);
                    } <span class="keyword">else</span> {
                        <span class="keyword">return</span> method.invoke(ps, args)
                    }
                }
            });
        <span class="keyword">return</span> proxy;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Privilege {
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String name;
}
</pre></td></tr></table></figure>

<h1 id="-">类加载器</h1>
<p>编写.java源码 -&gt; 编译器编译 -&gt; .class 字节码文件 -&gt; ClassLoader 加载.class文件</p>
<p>类加载器负责将.class文件 加载到内存中, 并为之生成 java.lang.Class 对象
<img src="/img/class_loader.png" alt="ClassLoader继承结构图"></p>
<ul>
<li><p>BootStrap 引导类加载器: 负责加载Java的核心类, 是C语言的代码, 负责加载 <code>JRE/lib/rt.jar</code>(所有常用JDK类, 都属于它)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>// ArrayList 位于rt<span class="preprocessor">.jar</span>, 由 BootStrape 加载
ArrayList list = new ArrayList()<span class="comment">;</span>
println(list<span class="preprocessor">.getClass</span>()<span class="preprocessor">.getClassLoader</span>())<span class="comment">;  // 是Null, 因为c语言写的, 没有类</span>
// 打印Bootstrap 加载类路径
URL[] urls=sun<span class="preprocessor">.misc</span><span class="preprocessor">.Launcher</span><span class="preprocessor">.getBootstrapClassPath</span>()<span class="preprocessor">.getURLs</span>()<span class="comment">; </span>
for (int i = <span class="number">0</span><span class="comment">; i &lt; urls.length; i++) { </span>
	System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(urls[i]<span class="preprocessor">.toExternalForm</span>())<span class="comment">; </span>
}
</pre></td></tr></table></figure>
</li>
<li><p>ExtClassLoader 扩展类加载器: 加载 <code>jre/lib/ext/*.jar</code></p>
</li>
<li><p>AppClassLoader (系统)应用类加载器, <code>ClassLoader.getSystemClassLoader()</code> 直接获得 系统类加载器</p>
</li>
</ul>
<h2 id="-">细节</h2>
<blockquote>
<p>面试题: 程序运行时, 加载类, 类不在工程代码中, 是否报错?</p>
</blockquote>
<p>工程代码中由 AppClassLoader 加载, 还有 BootStrap 和 ExtClassLoader 加载类</p>
<blockquote>
<p>类加载器顺序和特性?</p>
</blockquote>
<ol>
<li><p>委托机制: 优先由父类加载器加载,父类加载器找不到类,
子类加载器尝试加载, 如 <code>NoSuchMethodError</code>,
可能说明类加载器已经在之前加载了一个另一个类, 而那个类没有这个方法</p>
</li>
<li><p>全盘负责机制: 一个类被加载, 这个类所依赖和引用的类也会被这个类加载器加载</p>
</li>
</ol>
<blockquote>
<p>自定义类加载器, 不一定是采用委托机制</p>
</blockquote>
<p>所有自定义加载器, 必须继承 ClassLoader, 重写<code>findClass</code></p>
<blockquote>
<p>.class 文件字节码, 如何称为Class对象</p>
</blockquote>
<ol>
<li>通过io流, 读取.class文件, 生成byte数组</li>
<li>调用ClassLoader 提供的 <code>defineClass</code>, 生成 Class 对象</li>
</ol>
<blockquote>
<p>常见错误 <code>java.lang.ClassCassException</code></p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Class c = myClassLoader<span class="preprocessor">.findClass</span>(<span class="string">"java.activition.MimeType"</span>)<span class="comment">;</span>
MimeType mimeType = (mimeType) c<span class="preprocessor">.newInstance</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>MimeType 遵循委托机制, 由父类加载器加载</p>
<p>c.newInstance() 由子类类加载器加载</p>
<p><strong>不同类加载器, 加载同一个类, 也会出现不同Class对象</strong></p>
<h2 id="tomcat-">Tomcat的类加载器</h2>
<p>Jndi: 通过配置, 将一个对象交给tomcat创建和管理, 在程序中目录访问原则,
获取到tomcat中的绑定的对象</p>
<p>Tomcat 类加载器是区别于JVM的加载器的</p>
<p>比传统三个类加载器, 添加 Common 类加载器(Tomcat/lib) 和 WebApp(WEB-INF/classes和lib)类加载器</p>
<p>违背父类委托机制, 优先加载当前工程下类和jar, 再去加载tomcat/lib公共类和jar包, 加载顺序:</p>
<ul>
<li>BootStrap classes of yourt JVM</li>
<li>System class loader classes</li>
<li>/WEB-INFO/calsses</li>
<li>/WEB-INFO/lib/*.jar</li>
<li>$CATALINA_HOME/lib</li>
<li>$CATALINA_HOME/lib/*.jar</li>
</ul>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day22-文件操作和监听器]]></title>
    <link href="http://zhpooer.github.io/2014/04/29/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day22-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://zhpooer.github.io/2014/04/29/传智播客day22-文件操作和监听器/</id>
    <published>2014-04-29T01:02:31.000Z</published>
    <updated>2014-04-29T09:12:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">文件上传</h1>
<ol>
<li>必须提供<code>&lt;input type=&quot;file&quot; name=&quot;&quot;/&gt;</code>的文件上传输入域</li>
<li>表单的提交方式必须是POST方式</li>
<li>设置 <code>&lt;form enctype=&quot;multipart/form-data&quot;&gt;</code></li>
</ol>
<h2 id="-">原理</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">&lt;!-- enctype: 指定请求体正文 --&gt;</span>
<span class="comment">&lt;!-- application/x-www-form-urlencoded(默认) --&gt;</span>
<span class="comment">&lt;!-- 可选值是multipart/form-data --&gt;</span>
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">""</span> <span class="attribute">method</span>=<span class="value">"post"</span> <span class="attribute">enctype</span>=<span class="value">"multipart/form-data"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">name</span>=<span class="value">"text"</span> <span class="attribute">type</span>=<span class="value">"text"</span> /&gt;</span>
     <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"file"</span> <span class="attribute">name</span>=<span class="value">"photo"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
</pre></td></tr></table></figure>

<p>表单的 enctype 不是  <code>application/x-www-form-urlencoded</code>, 传统的获取方式将失效</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// enctype = multipart/form-data</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(){
    ServletInputStream <span class="keyword">in</span> = req.getInputStream();
    <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];
    <span class="keyword">int</span> len = -<span class="number">1</span>;
    <span class="keyword">while</span>(){
        System.ot.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));
    }
    <span class="keyword">in</span>.close()
}
</pre></td></tr></table></figure>

<p>运行结果:
<img src="/img/upload.png" alt="运行结果"></p>
<h2 id="-">编码</h2>
<ul>
<li>搭建环境, 导入 <code>commons-fileupload.jar</code></li>
<li>组件的功能是 实现解析</li>
<li>上传类的功能解析<ul>
<li><code>DiskFileItemFactory</code>: 产生FileItem对象</li>
<li><code>ServletFileUpload</code>: 解析上传的核心类</li>
</ul>
</li>
</ul>
<p><img src="/img/upload_util.png" alt="对象描述"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span>(){
    <span class="comment">// 验证用户提交的数据是不是mutlipart/form-data类型</span>
    boolean isMultiPart = ServletFileUpload.isMultiPartContent(req)
    <span class="comment">// 0. 获取文件上传的真实路径</span>
    String storeDir = getServletContext().getRealPath(<span class="string">""</span>);
    <span class="comment">// 1. 创建产生FileItem的工厂实例</span>
    DiskFileItemFactory fac = <span class="keyword">new</span> DiskFileItemFactory();
    <span class="comment">// 上传过程中要使用缓存, 设置缓存大小, 默认10kb</span>
    <span class="comment">// 如果上传的文件超过10kb, 组建hi采用磁盘临时文件的缓存形式</span>
    fac.setSizeThreadhold(<span class="keyword">int</span> size);
    <span class="comment">// 设置磁盘临时文件的存放目录, 默认是操作系统用户的临时目录</span>
    fac.setRepository(File);
    <span class="comment">// 2. 得到解析请求内容的解析器 ServletFileUpload</span>
    ServletFileUpload sfu = <span class="keyword">new</span> Servlet(fac);
    <span class="comment">// 3. 解析请求内容, 得到很多的FileItem实例</span>
    List&lt;FileItem&gt; items = sfu.parseReqeust(req);
    <span class="comment">// 4. 遍历FileItem的实例</span>
    <span class="keyword">for</span>(FileItem item:items){
        <span class="keyword">if</span>(item.isFormField()){
            <span class="comment">//4.1 如果是普通字段</span>
            String fieldName = item.getFieldName(); <span class="comment">// 字段名</span>
            <span class="comment">// 中文乱码</span>
            String fieldValue = item.getString(<span class="string">"utf-8"</span>);   <span class="comment">// 字段值</span>
        } <span class="keyword">else</span>{
            <span class="comment">//4.2 如果是上传字段</span>
            InputStream <span class="keyword">in</span> = item.getInputStream();
            <span class="comment">// 获取上传的文件名</span>
            String filename = item.getName(); <span class="comment">// 根据浏览器不同传的不同, 有的是全路径名, 有的是名字</span>
            filename = filename.subString(filename.lastIndexOf(<span class="string">"\\"</span>) + <span class="number">1</span>);
            OutputStream <span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(storeDir + <span class="string">"/"</span> + filename);
            
            <span class="keyword">int</span> len = -<span class="number">1</span>;
            <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]
            <span class="keyword">while</span>(){
                <span class="keyword">out</span>.write(b, <span class="number">0</span>, len);
            }
            <span class="keyword">in</span>.close();
            <span class="keyword">out</span>.close();
            item.delete();
        }
    }
}
</pre></td></tr></table></figure>

<h2 id="-">考虑的问题</h2>
<ul>
<li>保证服务器的安全<ul>
<li>把存放文件的目录放在<code>/WEB-INFO</code>下</li>
</ul>
</li>
<li>中文乱码问题<ul>
<li>普通字段的中文乱码<ul>
<li><code>FileItem.getString(&quot;utf-8&quot;)</code></li>
</ul>
</li>
<li>上传的是中文文件名<ul>
<li><code>reqeust.setCharactorEncoding(&quot;utf-8&quot;)</code> 只负责请求体中的</li>
</ul>
</li>
</ul>
</li>
<li>重名文件被覆盖<ul>
<li>把文件名弄成唯一 <code>filename=UUID.randomUUID.toString()</code></li>
</ul>
</li>
<li><p>防止同一个文件夹下的文件太多</p>
<ul>
<li>分不同的目录存储<ol>
<li>按照当前的日期存储文件</li>
<li>按照UUID文件名的hashCode生成目录<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    String dir = makeDir(storeDir, filename); <span class="comment">// 用hashCode计算出一个目录</span>
    <span class="keyword">private</span> String <span class="title">makeDir</span>(String storeDir, String filename) {
        <span class="keyword">int</span> hashCode = filename.hashCode();
        <span class="keyword">int</span> dir1 = hashCode&<span class="number">0xf</span>;
        <span class="keyword">int</span> dir2 = (hashCode&<span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>;
        String dir = <span class="string">"/"</span> + dir1 + <span class="string">"/"</span> + dir2;
        File file = <span class="keyword">new</span> File(dir1, dir2);
        <span class="keyword">if</span>(!file.exists()) file.mkdirs();
        <span class="keyword">return</span> dir;
    }
</pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>限制文件上传的大小</p>
<ul>
<li>限制单个文件的大小<ul>
<li><code>ServletFileUpload.setFileSizeMax(2*1024*1024)</code> 单位是字节,超出时 <code>parseReqeust</code> 会报错
<code>FileUploadBase.FileSizeSizeLimitException</code></li>
</ul>
</li>
<li>限制总文件的大小<ul>
<li><code>ServletFileUpload.setSizeMax(2*1024*1024)</code>, 报错 <code>FileUploadBase.SizeLimitExceededException</code></li>
</ul>
</li>
</ul>
</li>
<li><p>限制上传的文件类型</p>
<ul>
<li>判断文件的扩展名</li>
<li>判断文件的MIME类型(Tomcat/conf/web.xml)<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>  <span class="built_in">String</span> mimeType = item.getContentType();
  <span class="keyword">if</span>(mimeType.startsWith(<span class="string">"image"</span>)) todo();
</pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多文件上传时, 有空的表单项</p>
<ul>
<li>通过检查文件MIME也可以避免</li>
</ul>
</li>
<li>大文件上传时的临时文件问题<ul>
<li>组件对于超出缓存的文件会使用临时文件的形式上传, 上传完毕后. 临时文件不会删除,
造成硬盘空间的浪费. 可以通过 <code>FileItem.delete()</code> 来配置</li>
</ul>
</li>
<li>上传进度指示条(目前做不了, 要用到异步交互ajax)<ul>
<li>注册监听器, 拿到百分比<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>  ServletFileUpload.setProgressListener( <span class="keyword">new</span> ProgressListener(){
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span>(<span class="keyword">long</span> pBytes, <span class="keyword">long</span> pContentLength, <span class="keyword">int</span> pItems) {
          (pBytes + <span class="number">0.0</span>)/pContentLength;
      }
  })
</pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="-">文件的下载</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">// 罗列可下载的资源</span>
<span class="keyword">public</span> <span class="literal">void</span> doGet(){
    <span class="comment">//得到 WEB-INF/files 下的文件</span>
    <span class="built_in">String</span> storeDir <span class="subst">=</span> getServletContext()<span class="built_in">.</span>getRealPath();
    <span class="comment">// 递归遍历所有的文件, 把遍历到的信息封装起来</span>
    <span class="comment">// Map&lt;String,String&gt;.key:UUID, value: 老文件名</span>
    <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>,<span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span> <span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span>();
    treeWalk(<span class="literal">new</span> File(storeDir), <span class="built_in">map</span>)
    <span class="comment">// 把Map封装到request域中</span>
    request<span class="built_in">.</span>setAttribute(<span class="string">"map"</span>, <span class="built_in">map</span>);
    <span class="comment">// 转发到jsp取</span>
    request<span class="built_in">.</span>getRequestDispatcher(<span class="string">"/listFiles.jsp"</span>)<span class="built_in">.</span>forward(req, res);
}
<span class="keyword">public</span> <span class="literal">void</span> treeWalk(File file, <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">String</span><span class="subst">&gt;</span> <span class="built_in">map</span>){
    <span class="keyword">if</span>(file<span class="built_in">.</span>isFile()){
        <span class="built_in">String</span> filename <span class="subst">=</span> file<span class="built_in">.</span>getName();
        <span class="built_in">String</span> oldFileName <span class="subst">=</span> filename<span class="built_in">.</span>subString(filename<span class="built_in">.</span>indexOf(<span class="string">"_"</span>) <span class="subst">+</span> <span class="number">1</span>);
    } <span class="keyword">else</span> {
        File<span class="preprocessor">[</span><span class="preprocessor">]</span><span class="markup"> children = file.listFiles();
        for(File f:children){
            treeWalk(f, map);
        }
    }
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;<span class="title">c:forEach</span> <span class="attribute">items</span>=<span class="value">""</span> <span class="attribute">var</span>=<span class="value">"me"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">c:url</span> <span class="attribute">value</span>=<span class="value">"/servlet/DownloadServlet"</span> <span class="attribute">var</span>=<span class="value">"url"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">c:param</span> <span class="attribute">name</span>=<span class="value">"filename"</span> <span class="attribute">value</span>=<span class="value">"${me.key}"</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">c:param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">c:url</span>&gt;</span>
         ${me.value}&nbsp; nbsp; <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"${url}"</span>&gt;</span>下载<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">c:forEach</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>public void doGet(){
    String realFilename= request<span class="preprocessor">.getParameter</span>(<span class="string">"filename"</span>)<span class="comment">;</span>
    realFilename = new String(realFilename<span class="preprocessor">.getBytes</span>(<span class="string">"ISO8859-1"</span>), <span class="string">"utf-8"</span>)<span class="comment">;</span>

    String storeDir = getServletContext()<span class="preprocessor">.getRealPath</span>()<span class="comment">;</span>
    String dir = makeDir(storeDir, realFilename)<span class="comment">;</span>

    File file = new File(storeDir + dir + <span class="string">"/"</span> + realFilename)<span class="comment">;</span>
    if(file<span class="preprocessor">.exists</span>()){
        InputStream <span class="keyword">in</span> = new FileInputStream(file)<span class="comment">;</span>
        // 截取老文件名, 并进行url编码
        String oldFileName = realFilename<span class="preprocessor">.subString</span>(realFilename<span class="preprocessor">.indexOf</span>(<span class="string">"_"</span>)+<span class="number">1</span>)<span class="comment">;</span>
        oldFileName = URLEncoder<span class="preprocessor">.encode</span>(oldFileName, <span class="string">"utf-8"</span>)<span class="comment">;</span>
        
        response<span class="preprocessor">.setHeader</span>(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + oldFileName)<span class="comment">;</span>
        
        OutputStream <span class="keyword">out</span> = response<span class="preprocessor">.getOutpuStream</span>()<span class="comment">;</span>
        while(){
            <span class="keyword">out</span><span class="preprocessor">.write</span>(b, <span class="number">0</span>, len)<span class="comment">;</span>
        }
        <span class="keyword">out</span><span class="preprocessor">.close</span>()<span class="comment">;</span>
        
        response<span class="preprocessor">.getOutpuStream</span>()<span class="preprocessor">.write</span>(<span class="string">"下载成功"</span>)<span class="comment">;// 重写获得outputStream对象</span>
    } else {
       response<span class="preprocessor">.getOutpuStream</span>()<span class="preprocessor">.write</span>(<span class="string">"下载失败"</span><span class="preprocessor">.getBytes</span>(<span class="string">"utf-8"</span>))<span class="comment">;</span>
    }
}
</pre></td></tr></table></figure>

<h1 id="-">观察者模式</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">// 事件源:发生事件的对象</span>
<span class="comment">// 监听器: 封装事件的接口</span>
<span class="comment">// 事件对象: 封装事件源</span>
Frame f = <span class="keyword">new</span> Frame(<span class="string">"我的窗体"</span>);
f.setSize(<span class="number">400</span>, <span class="number">280</span>);
f.setVisible(<span class="keyword">true</span>);
f.addWindowListener(<span class="keyword">new</span> MyWindowListener());
<span class="class"><span class="keyword">class</span> <span class="title">MyWindowListener</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">WindowAdapter</span> {</span>
    <span class="keyword">public</span> <span class="keyword">void</span> windowsClosing(WindowEvent e){
        Frame f = e.getSource();
        f.dispose();
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="comment">// 事件源</span>
<span class="keyword">public</span> <span class="keyword">class</span> Student {
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> StudentListener listener;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudentListener</span>(){
        <span class="keyword">this</span>.listener = listener;
    }
    <span class="keyword">public</span> <span class="title">Student</span>(String name){}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span>(){
        <span class="keyword">if</span>(<span class="keyword">this</span>.listener!=<span class="keyword">null</span>){
            listener.preStudy();
        }
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span>(){
        <span class="keyword">if</span>(<span class="keyword">this</span>.listener!=<span class="keyword">null</span>){
            listener.preSleep();
        }
    }
}
<span class="comment">// 监听器</span>
<span class="keyword">public</span> <span class="keyword">interface</span> StudentListener{
   <span class="keyword">void</span> preStudy(StudentEvent e);
   <span class="keyword">void</span> preSleep(StudentEvent e);
}
<span class="comment">// 事件对象</span>
<span class="keyword">public</span> <span class="keyword">class</span> StudentEvent{
    <span class="keyword">public</span> <span class="title">StudentEvent</span>(Object source){
        <span class="keyword">this</span>.source = source;
    }
    <span class="keyword">public</span> Object <span class="title">getSource</span>(){
        <span class="keyword">return</span> source;
    }
}
</pre></td></tr></table></figure>

<h1 id="servlet-">Servlet 中的监听器</h1>
<p>Servlet规范中, 提供了8个监听器(接口)</p>
<ul>
<li><p>监听 ServletContext, HttpSession, ServletRequest 三个对象的创建的创建和销毁</p>
<ol>
<li>ServletContextListener: 监听 ServletContext 的创建和销毁的监听器<br>应用启动时执行, 只执行一次<br>应用场景, 完成系统启动时的初始化工作(Spring框架)</li>
<li>HttpSessionListener: 监听 HttpSession 的创建和销毁的监听器<br>一个会话对象, 代表着一个客户端, 可以统计网站的访问量</li>
<li>ServletRequestListener: 监听 ServletReques 的创建和销毁的监听器<br>可以统计每次页面的访问次数</li>
</ol>
</li>
<li><p>监听 ServletContext, HttpSession, ServletRequest 三个对象域中数据变化的监听器</p>
<ol>
<li>ServletContextAttributeListener 监听数据的添加删除修改</li>
<li>HttpSessionAttributeListener 监听数据的添加删除修改<br>统计登陆用户列表</li>
<li>ServletRequestAttributeListener 监听数据的添加删除修改</li>
</ol>
</li>
<li><p>感知型监听器, 这种监听器不需要注册</p>
<ol>
<li><code>javax.servlet.http.HttpSessionBindingListener</code> 谁实现的这个接口, 就能感知自己合适被
HttpSession 绑定和解绑</li>
<li><code>javax.servlet.http.HttpSessionActiveListener</code> 谁实现的这个接口, 就能感知自己合适被
HttpSession 钝化和激活</li>
</ol>
</li>
</ul>
<h2 id="-">具体用法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>public class MyServletContextListener extends ServletContextListener{}
<span class="comment">&lt;!-- web.xml --&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>.../MyServletContextListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
<span class="tag">&lt;<span class="title">listener</span>&gt;</span>
    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>.../MyHttpSessionListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>
<span class="tag">&lt;<span class="title">session-config</span>&gt;</span>
    <span class="tag">&lt;<span class="title">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="title">session-timeout</span>&gt;</span> <span class="comment">&lt;!-- 一分钟后销毁 --&gt;</span>
<span class="tag">&lt;/<span class="title">session-config</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">监听器案例</h2>
<p>在线踢人</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> User{
   <span class="keyword">private</span> String username;
   <span class="keyword">private</span> String password;
}
</pre></td></tr></table></figure>

<p>Login.jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"loginservlet"</span> <span class="attribute">method</span>=<span class="value">"posj"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"username"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"password"</span> <span class="attribute">name</span>=<span class="value">"password"</span>/&gt;</span>
        <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">form</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</pre></td></tr></table></figure>

<p>LoginServlet.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>public void doGet(){
    req<span class="preprocessor">.setCharactorEncoding</span>(<span class="string">"utf-8"</span>)<span class="comment">;</span>
    String user = req<span class="preprocessor">.getParameter</span>(<span class="string">"username"</span>)<span class="comment">;</span>
    String password = req<span class="preprocessor">.getParameter</span>(<span class="string">"password"</span>)<span class="comment">;</span>
    User user = new User()<span class="comment">;</span>
    user<span class="preprocessor">.setUsername</span>(username)<span class="comment">;</span>
    user<span class="preprocessor">.setPassword</span>(password)<span class="comment">;</span>
    request<span class="preprocessor">.getSessioin</span>()<span class="preprocessor">.setAttribute</span>(<span class="string">"user"</span>, user)<span class="comment">;</span>
    res<span class="preprocessor">.sendRedirect</span>(req<span class="preprocessor">.getContexPath</span>())<span class="comment">; // 重定向到主页</span>
}
</pre></td></tr></table></figure>

<p>监听域中数据的变化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">public</span> class OnlineUserListener implement HttpSessionAttributeListener {
    <span class="comment">// 设置登陆标记 </span>
    <span class="comment">// 监听到的目的: 找一个容器 Map&lt;用户名, httpSession&gt; 存起来, 让index.jsp能访问到</span>

    <span class="comment">// 向任何HttpSession域中放东西, 都会经过该方法</span>
    <span class="keyword">public</span> <span class="literal">void</span> attributeAdded(HttpSessionBindingListener e) {
        HttpSession session <span class="subst">=</span> se<span class="built_in">.</span>getSession();
        Object obj <span class="subst">=</span> session<span class="built_in">.</span>getAttribute(<span class="string">"user"</span>);
        <span class="keyword">if</span>(obj<span class="subst">==</span><span class="built_in">null</span>){
            <span class="comment">// 放的标记不是User</span>
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span>(<span class="subst">!</span>(obj instanceof User){
            <span class="keyword">return</span>;
        }
        ServletContext sc <span class="subst">=</span> session<span class="built_in">.</span>getServletContext();
         <span class="comment">//存放登陆用户名和对应HttpSession对象</span>
        <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, HttpSession<span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span> sc<span class="built_in">.</span>getAttribute(<span class="string">"map"</span>);
        <span class="keyword">if</span>(<span class="built_in">map</span><span class="subst">==</span><span class="built_in">null</span>){
             <span class="built_in">map</span> <span class="subst">=</span> Collections<span class="built_in">.</span>synchronizedMap(<span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="built_in">String</span>, HttpSession<span class="subst">&gt;</span>());<span class="comment">// 线程安全的Map</span>
             sc<span class="built_in">.</span>setAttribute(<span class="string">"map"</span>, <span class="built_in">map</span>);
        }
        <span class="built_in">map</span><span class="built_in">.</span>put((User)obj<span class="built_in">.</span>getUsername(), session);
    }
}
</pre></td></tr></table></figure>

<p>index.jsp, 显示当前用户登录的登陆名</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">c:forEach</span> <span class="attribute">items</span>=<span class="value">"applicationScope.map"</span> <span class="attribute">var</span>=<span class="value">"me"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">c:url</span> <span class="attribute">value</span>=<span class="value">"KickServlet"</span> <span class="attribute">name</span>=<span class="value">"url"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">param</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"${me.key}"</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">param</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">c:url</span>&gt;</span>
        ${me.key} &nbsp; <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"${url}"</span>&gt;</span>踢出<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">c:forEach</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
</pre></td></tr></table></figure>

<p>KickServlet.java</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="literal">void</span> doGet(){
    <span class="built_in">String</span> username <span class="subst">=</span> request<span class="built_in">.</span>getParameter(<span class="string">"username"</span>);
    username <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">String</span>(username<span class="built_in">.</span>getBytes(<span class="string">"ISO-8859-1"</span>, <span class="string">"utf-8"</span>))
    ServletContext sc <span class="subst">=</span> getServletContext();
    <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, HttpSession<span class="subst">&gt;</span> <span class="subst">=</span> sc<span class="built_in">.</span>getParameter(<span class="string">"map"</span>);
    <span class="built_in">map</span><span class="built_in">.</span>get(username)<span class="built_in">.</span>invalidate();
    <span class="built_in">map</span><span class="built_in">.</span>remove(username);
    res<span class="built_in">.</span>sendRedirect(rq<span class="built_in">.</span>getContexPath());
}
</pre></td></tr></table></figure>

<h1 id="-">国际化</h1>
<p>程序提供适合来访者阅读习惯的文本, i18n</p>
<h2 id="-">固定文本的国际化</h2>
<p>固定文本写在一个资源包中, 一个资源包可以包括多个 <code>*.properties</code>的文件</p>
<h3 id="-">资源的写法</h3>
<p>文件基名<em>语言</em>国家.properties 语言 国家有一定的编码, ISO来指定(基名一样)</p>
<p>msg_zh_CN.properties 中国大陆</p>
<p>msg_en_US.properties 美利坚</p>
<p>msg_en_UK.properties 大不列颠</p>
<h3 id="-">编码案例</h3>
<p>msg_en_UK.properties
msg_zh_CN.properties</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>// 获取来访者使用的系统的区域位置
ResourceBundle<span class="preprocessor">.getBundle</span>(<span class="string">"cn.itcast.resources.msg"</span>)
rb<span class="preprocessor">.getString</span>(<span class="string">"hello"</span>)

// 读取美国的
Locale l = Locale<span class="preprocessor">.US</span><span class="comment">;</span>
ResourceBundle<span class="preprocessor">.getBundle</span>(<span class="string">"cn.itcast.resources.msg"</span>, l)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="vbscript">&lt;%
Locate l = req.<span class="built_in">getLocale</span>();
ResourceBundle rb = ResourceBundle.getBundle(<span class="string">""</span>, l)
%&gt;</span>
<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">""</span>&gt;</span>
    用户名: <span class="tag">&lt;<span class="title">input</span>/&gt;</span>
    <span class="vbscript">&lt;%= rb.getString(<span class="string">"username"</span>)%&gt;</span>
<span class="tag">&lt;/<span class="title">form</span>&gt;</span>

<span class="comment">&lt;!-- 等价于 --&gt;</span>
<span class="tag">&lt;<span class="title">fmt:setLocal</span> <span class="attribute">value</span>=<span class="value">"pageContext.request.locale"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">fmt:setLocal</span>&gt;</span>
<span class="tag">&lt;<span class="title">fmt:setBundle</span> <span class="attribute">basename</span>=<span class="value">"cn.itcast.resources.msg"</span> <span class="attribute">var</span>=<span class="value">"msg"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">fmt:setBundle</span>&gt;</span>

<span class="tag">&lt;<span class="title">fmt:message</span> <span class="attribute">key</span>=<span class="value">"username"</span> <span class="attribute">bundle</span>=<span class="value">"${msg}"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">fmt:message</span>&gt;</span>
</pre></td></tr></table></figure>

<h2 id="-">时间和日期的格式化</h2>
<p>DateFormat: 用户所有界面的输入都是String, JavaBean: java.util.date</p>
<p><code>Date parse(String s)</code>: 解析字符串成为日期对象</p>
<p><code>String format(Date d)</code>: 把日期对象转换为字符串</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="built_in">Date</span> d <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Date</span>();
DateFormat df <span class="subst">=</span> DateFormat<span class="built_in">.</span>getDateTimeInstance();
df<span class="built_in">.</span>format(d);
<span class="built_in">String</span> s <span class="subst">=</span> <span class="string">"2014-4-29 12:21:11"</span>
<span class="built_in">Date</span> d <span class="subst">=</span> df<span class="built_in">.</span>parse(s);

Locale l <span class="subst">=</span> Locale<span class="built_in">.</span>CHINA;
<span class="built_in">Date</span> d <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Date</span>();
DateFormat df <span class="subst">=</span> DateFormat<span class="built_in">.</span>getDateTimeInstance(DateFormate<span class="built_in">.</span><span class="literal">Full</span>, DateFormat<span class="built_in">.</span><span class="literal">Full</span>, l);
df<span class="built_in">.</span>format(d);
</pre></td></tr></table></figure>

<p>在JSP中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>&lt;fmt:formateDate <span class="keyword">value</span>=<span class="string">"${now}"</span> <span class="class"><span class="keyword">type</span>=</span><span class="string">"both|date|time"</span>&gt;
&lt;/fmt:formateDate&gt;
</pre></td></tr></table></figure>

<h2 id="-">数字的格式化, 货币符号</h2>
<p>NumberFormat: 用户输入的String, JavaBean:Number</p>
<p><code>Number parse(String s)</code>: 解析</p>
<p><code>String (Number s)</code>: 格式化</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Locale l = Locale<span class="preprocessor">.CHINA</span>
int money = <span class="number">10000</span><span class="comment">;</span>
NumberFormat nf = NumberFormat<span class="preprocessor">.getCurrencyFomatter</span>()<span class="comment">;</span>
nf<span class="preprocessor">.format</span>(money)
</pre></td></tr></table></figure>

<h2 id="-">批量国际化</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// String pattern = "At 12:30 pm on jul 3,1998, a hurricance destroyed 99 house and caused $100000 of damage"</span>
<span class="built_in">String</span> pattern = <span class="string">"At {0, time, media} on {1, date, medium} a hurricance destroyed {2} house and caused {3, number, currency} of damage"</span>;

<span class="built_in">Date</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//数据库发生的日期</span>
<span class="built_in">Date</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 日期</span>

int num = <span class="number">99</span>;
int money = <span class="number">100000</span>;

MessageFormat mf = <span class="keyword">new</span> MessageFormat(pattern);
<span class="built_in">String</span> s = mf.format(<span class="keyword">new</span> <span class="built_in">Object</span>[]{time, date, num, money})
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day21-servlet过滤器]]></title>
    <link href="http://zhpooer.github.io/2014/04/28/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day21-servlet%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://zhpooer.github.io/2014/04/28/传智播客day21-servlet过滤器/</id>
    <published>2014-04-28T01:02:59.000Z</published>
    <updated>2014-04-28T09:06:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">过滤器概述</h1>
<p>Filter, 应用中的保安. 利用过滤器来实现对请求和响应的拦截.</p>
<h1 id="-">编写过滤器的步骤</h1>
<ol>
<li><p>编一个类, 实现 javax.servlet.Filter</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDemo1</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">Filter</span> {</span>
    <span class="comment">// 由容器调用, 每次响应和调用都会经过该方法</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest req, ServletResponse, FilterChain chain){
          <span class="comment">// 执行前</span>
          chain.doFilter(req, res); <span class="comment">// 放行,让下一个资源执行</span>
          <span class="comment">// 执行后</span>
    }
    <span class="comment">// 由容器调用, 完成过滤器的初始化</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(FilterConfig config){}
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(){}
}
res.getWriter().write(<span class="string">"Hello"</span>);
</pre></td></tr></table></figure>
</li>
<li><p>配置web.xml,指定哪些资源需要拦截</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">filter</span>&gt;</span>
<span class="comment">&lt;!-- 定义一个过滤器, 并定制名称 --&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>FilterDemo1 <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>...<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>
<span class="comment">&lt;!-- 多个过滤器的拦截的顺序, 由filter-mapping元素出现的顺序决定 --&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>FilterDemo1<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-">过滤器的执行过程</h1>
<p><img src="/img/filter_process.png" alt="过滤器执行过程"></p>
<h2 id="-">生命周期</h2>
<ol>
<li><strong>应用在加载时</strong>会被初始化和初始化</li>
<li>针对用户的每次资源访问, 容器都会调用<code>doFilter</code>方法</li>
<li>应用被卸载或服务器停止时, 会执行<code>destroy</code></li>
</ol>
<h2 id="-">配置过滤器初始化参数</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="title">init</span>(FilterConfig f){
    String <span class="keyword">value</span> = f.getInitParameter(<span class="string">"encoding"</span>);
    Enumeration en = f.getInitParameterNames();
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>&lt;<span class="built_in">filter</span>&gt;
&lt;init-<span class="built_in">param</span>&gt;
    &lt;<span class="built_in">param</span>-name&gt;&lt;/<span class="built_in">param</span>-name&gt;
    &lt;<span class="built_in">param</span>-<span class="built_in">value</span>&gt;&lt;/<span class="built_in">param</span>-<span class="built_in">value</span>&gt;
&lt;/init-<span class="built_in">param</span>&gt;
&lt;/<span class="built_in">filter</span>&gt;
</pre></td></tr></table></figure>

<h1 id="-">过滤器的简单案例</h1>
<h2 id="-">统一字符编码的过滤器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// setCharactorFilter</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest req, ServletResponse, FilterChain chain){
    String encoding = <span class="string">"UTF-8"</span>;
    String <span class="keyword">value</span> = filterConfig.getInitParameter(<span class="string">"encoding"</span>);
    <span class="keyword">if</span>(<span class="keyword">value</span>!=<span class="keyword">null</span>){
        encoding = <span class="string">"utf-8"</span>;
    }
    req.setCharactorEncoding(encoding); <span class="comment">// 只针对POST请求, 对get请求不起作用</span>
    res.setContentType(<span class="string">"text/html;charset="</span> + encoding);
    chain.doFilter(req, res);
}
</pre></td></tr></table></figure>

<h2 id="-nocache-">动态资源缓存过滤器(NoCache)</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest request, ServletResponse response, FilterChain chain){
    HttpServletRequest req;
    HttpServletResponse res;
    <span class="keyword">try</span> {
        req = (HttpServletRequest) request;
        res = (HttpServletRequest) response;
    } <span class="keyword">catch</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"is not a http request"</span>);
    }
    res.setDateHeader(<span class="string">""</span>, -<span class="number">1</span>);
    res.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-Cache"</span>);
    res.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-Cache"</span>);
    chain.doFilter(req, res);
}
</pre></td></tr></table></figure>

<h2 id="-">静态资源缓存过滤器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">init-param</span>&gt;</span>
    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>css <span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>
    <span class="comment">&lt;!-- 单位为小时 --&gt;</span>
    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>1 <span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest request, ServletResponse response, FilterChain chain){
    HttpServletRequest req;
    HttpServletResponse res;
    <span class="keyword">try</span> {
        req = (HttpServletRequest) request;
        res = (HttpServletRequest) response;
    } <span class="keyword">catch</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"is not a http reqest"</span>);
    }
    <span class="keyword">long</span> time = <span class="number">0</span>; <span class="comment">//缓存的时间的偏移量</span>

    String uri = res.getRequestURI(); <span class="comment">// /servlet/index.html</span>

    String extendName = uri.subString(uri.lastIndex(<span class="string">"."</span>) + <span class="number">1</span>);
    <span class="keyword">if</span>(html!=<span class="keyword">null</span> && <span class="string">"html"</span>.equals(extendName)){
        String <span class="keyword">value</span> = filterConfig.getInitParameter(<span class="string">"css"</span>);
        time = Long.parse(<span class="keyword">value</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);
    }
    res.setDateHeader(<span class="string">"Expires"</span>, System.currentTimeMillis()+time);
    chain.doFilter(req, res);
}
</pre></td></tr></table></figure>

<h2 id="-">自动登陆过滤器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="comment">// 用户账号和密码存到Cookie中, 保存形式是 'user_password'</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(ServletRequest request, ServletResponse response, FilterChain chain){
    HttpServletRequest req;
    HttpServletResponse res;
    <span class="keyword">try</span> {
        req = (HttpServletRequest) request;
        res = (HttpServletRequest) response;
    } <span class="keyword">catch</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"is not a http reqest"</span>);
    }

    <span class="comment">// 判断用户是否登陆</span>
    HttpSession session = req.getSession();
    User user = (User)session.getAttribute(<span class="string">"user"</span>);
    <span class="keyword">if</span>(user==<span class="keyword">null</span>){
        Cookie[] cs = req.getCookies();
        <span class="comment">// 找到用户名和密码</span>
        <span class="keyword">for</span>(c &lt;- cs <span class="keyword">if</span> <span class="string">"loginInfo"</span>.equals(c.getName()){
            <span class="comment"><span class="xmlDocTag">///</span> 再次比对用户名和密码</span>
            String username = c.getValue().split(<span class="string">"\\_"</span>)[<span class="number">0</span>];
            String password = c.getValue().split(<span class="string">"\\_"</span>)[<span class="number">1</span>];
            <span class="keyword">if</span>(password==password){
                User u = <span class="keyword">new</span> User();
                u.setUsername(username);
                u.setPassword(password);
                req.getSession().setAttribute(<span class="string">"user"</span>, u);
            }
            <span class="keyword">break</span>;
        }
    }
    chain.doFilter(req, res);
}
</pre></td></tr></table></figure>

<h3 id="-">用户密码加密</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span>(String s){
    MessageDigest md = MessageDigest.getInstance(<span class="string">"md5"</span>);
    <span class="keyword">byte</span> b[] = md.digest(s.getBytes());
    Base64Encoder en = <span class="keyword">new</span> Base64Encoder();
    <span class="keyword">return</span> en.encode(b)
}
<span class="comment">//  cookie中不能存中文 , 可以用base64编码</span>
<span class="keyword">new</span> Base64Encoder().encode(s.getBytes());
</pre></td></tr></table></figure>

<h1 id="-">过滤器的高级配置</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="comment">&lt;!-- 设置用户请求时, 什么时候执行过滤 --&gt;</span>
    <span class="comment">&lt;!-- 默认就是request --&gt;</span>
    <span class="tag">&lt;<span class="title">dispatcher</span>&gt;</span> REQUEST <span class="tag">&lt;/<span class="title">dispatcher</span>&gt;</span> <span class="comment">&lt;!-- 请求阶段 --&gt;</span>
    <span class="tag">&lt;<span class="title">dispatcher</span>&gt;</span> FORWARD <span class="tag">&lt;/<span class="title">dispatcher</span>&gt;</span> <span class="comment">&lt;!-- 转发阶段 --&gt;</span>
    <span class="tag">&lt;<span class="title">dispatcher</span>&gt;</span> INCLUDE <span class="tag">&lt;/<span class="title">dispatcher</span>&gt;</span> <span class="comment">&lt;!-- 动态包含 --&gt;</span>
    <span class="tag">&lt;<span class="title">dispatcher</span>&gt;</span> ERROR <span class="tag">&lt;/<span class="title">dispatcher</span>&gt;</span> <span class="comment">&lt;!-- 出异常时 --&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
</pre></td></tr></table></figure>

<p>注:</p>
<ul>
<li>page指令, errorPage=&quot;*.jsp&quot;, 属于转发方式</li>
<li>web.xml 配置的全局错误提示页面, 是的状态是 ERROR</li>
</ul>
<h1 id="-">过滤器的高级案例</h1>
<h2 id="-">全站中文乱码解决过滤器</h2>
<p>请求: Post Get参数乱码; 响应输出乱码解决过滤器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> doFilter(){
    HttpServletRequest req;
    HttpServletResponse res;
    <span class="keyword">try</span> {
        req = (HttpServletRequest) request;
        res = (HttpServletRequest) response;
    } <span class="keyword">catch</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"is not a http reqest"</span>);
    }
    <span class="comment">// 看服务端有没有配置编码参数</span>
    String encoding = <span class="string">"utf-8"</span>;
    String value = filtercofnig.getInitParameter(<span class="string">"encoding"</span>);
    <span class="keyword">if</span>(value!=<span class="keyword">null</span>){
        encoding = value;
    }
    <span class="comment">// 解决post方式的乱码</span>
    req.setCharactorEncoding(encoding);
    res.setCharactorEncoding(encoding);
    res.setContentType(<span class="string">"text/html;charset="</span> + encoding);
    <span class="comment">// 解决get方式的乱码</span>
    MyHttpServletRequest mrequest = <span class="keyword">new</span> MyHttpServletRequest(request);
    chain.doFilter(mrequest, res);
}
<span class="class"><span class="keyword">class</span> <span class="title">MyHttpServletRequest</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">HttpServletRequestWrapper</span> {</span>
     <span class="keyword">public</span> MyHttpServletRequest(HttpServletRequest req){
         <span class="keyword">super</span>(req);
     }
     <span class="comment">// 只处理get请求编码</span>
     @Override <span class="keyword">public</span> String getParameter(String name) {
         String value = <span class="keyword">super</span>.getParameter(name);
         <span class="keyword">if</span>(value==<span class="keyword">null</span>){
             <span class="keyword">return</span> <span class="keyword">null</span>;
         }

         String method = <span class="keyword">super</span>.getMethod();
         <span class="keyword">if</span>(<span class="string">"get"</span>.equalsIgnoreCase(method)) {
             value = <span class="keyword">new</span> String(value.getBytes(<span class="string">"iso-8859-1"</span>), <span class="keyword">super</span>.getCharactorEncoding());
         }
         <span class="keyword">return</span> value;
     }
}
</pre></td></tr></table></figure>

<h2 id="-">脏话过滤器</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">//必须把字符编码过滤器放在前面</span>
<span class="keyword">public</span> <span class="keyword">void</span> doFilter(){
    HttpServletRequest req;
    HttpServletResponse res;
    <span class="keyword">try</span> {
        req = (HttpServletRequest) request;
        res = (HttpServletRequest) response;
    } <span class="keyword">catch</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"is not a http reqest"</span>);
    }
    DirtyWordsHttpServletRequest dwrequest = <span class="keyword">new</span> DirtyWordsHttpServletRequest(req);
    chain.doFilter(dwrequest, res);
}
<span class="class"><span class="keyword">class</span> <span class="title">DirtyWordsHttpServletRequest</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">HttpServletRequestWrapper</span>{</span>
    <span class="keyword">private</span> String dwords[] = {<span class="string">"xx"</span>, <span class="string">"xxx"</span>};
    <span class="keyword">public</span> String getParameter(String name){
        String value = <span class="keyword">super</span>.getParameter(name);
        <span class="keyword">if</span>(value==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;
        <span class="keyword">for</span>(String s : dwords){
            value = value.replace(s, <span class="string">"*"</span>)
        }
        <span class="keyword">return</span> value;
    }
}
</pre></td></tr></table></figure>

<h2 id="html-">HTML标记过滤器</h2>
<p><code>&lt;</code>换成<code>&amp;lt;</code>, 可以防止代码注入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">HtmlHttpServletRequest</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">HttpServletRequestWrapper</span>{</span>
    <span class="keyword">private</span> String dwords[] = {<span class="string">"xx"</span>, <span class="string">"xxx"</span>};
    <span class="keyword">public</span> String getParameter(String name){
        String value = <span class="keyword">super</span>.getParameter(name);
        <span class="keyword">if</span>(value==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;
        value = filter(value);
        <span class="keyword">return</span> value;
    }
}
</pre></td></tr></table></figure>

<h2 id="-gzip-">全站 GZIP 压缩过滤器</h2>
<p><img src="/img/gzip_filter.png" alt="gzip压缩原理"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(){
    HttpServletRequest req;
    HttpServletResponse res;
    <span class="keyword">try</span> {
        req = (HttpServletRequest) request;
        res = (HttpServletRequest) response;
    } <span class="keyword">catch</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"is not a http reqest"</span>);
    }
    GZIPHttpResponse ghp = <span class="keyword">new</span> GZIPHttpResponse(res);
    chain.doFilter(req, ghp);
    
    ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();
    GZIPOutputStream gout = <span class="keyword">new</span> GZIPOutputStream();
    gout.write(ghp.getBytes());
    gout.close();
    Byte[] ba = bo.toByteArray();
    res.setHeader(<span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>);
    res.setContentLength(o.length); <span class="comment">// 不设置该值时, 浏览器访问Html静态资源会慢</span>
    res.getOutputStream().write(ba);


}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZIPHttpResponse</span> <span class="keyword">extends</span> <span class="title">HttpServletResponseWrapper</span>{</span>
    <span class="keyword">private</span> ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();
    <span class="keyword">private</span> PrintWriter pw = <span class="keyword">null</span>;
    <span class="comment">// 字符流</span>
    <span class="annotation">@Override</span> <span class="keyword">public</span> ServletOutPutStream <span class="title">getOutputStream</span>(){
        <span class="keyword">return</span> <span class="keyword">new</span> GZIPOutputStream(baos);
    }

    <span class="comment">// 字节流</span>
    <span class="annotation">@Override</span> <span class="keyword">public</span> PrintWriter <span class="title">getWriter</span>(){
        <span class="comment">//设置编码, 解决字符编码问题, 所以一定要设置在 字符编码过滤器中, 设置 res.setCharactorEncoding();</span>
        pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(baos, <span class="keyword">super</span>.getCharactorEncoding()));
        <span class="keyword">return</span> pw;
    }

    <span class="keyword">public</span> Byte[] <span class="title">getBytes</span>(){
        <span class="keyword">if</span>(pw!=<span class="keyword">null</span>) pw.flush();
        baos.flush();
        baos.getBytes();
    }
}

class GZIPServletOupStream extends ServletOutPutStream {
    <span class="keyword">private</span> ByteArrayOutputStream baos;
    <span class="keyword">public</span> <span class="title">GZIPServletOupStream</span>( ByteArrayOutputStream baos ){
        <span class="keyword">this</span>.baos = baos;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="keyword">int</span> b) {
        baos.write(b);
    }
}
</pre></td></tr></table></figure>

<p>显示数据用的静态资源需要压缩, 还有<code>JSP</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> GZIPFilter <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span> *.jsp <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> GZIPFilter <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span> *.css <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> GZIPFilter <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span> *.js <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span> GZIPFilter <span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span> *.html <span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>
<span class="comment">&lt;!-- .... --&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day20-ORM简介]]></title>
    <link href="http://zhpooer.github.io/2014/04/26/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day20-orm%E7%AE%80%E4%BB%8B/"/>
    <id>http://zhpooer.github.io/2014/04/26/传智播客day20-orm简介/</id>
    <published>2014-04-26T01:28:23.000Z</published>
    <updated>2014-05-05T02:20:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="orm-">ORM简介</h1>
<p>ORM(Object Relation Mapping):</p>
<ul>
<li>Object : JavaBean对象</li>
<li>Raltion: 关系型数据库</li>
<li>Mapping: 映射(存在在着对应关系)</li>
</ul>
<p>框架: Hibernate、MyBatis(iBatis)、JPA(java持久化框架, 规范)</p>
<p>简单的JDBC框架: 这些框架只是对JDBC操作的简单封装. 比如DBUtils\SpringJDBCTemplate</p>
<h1 id="dbutils-">DBUtils 框架的使用</h1>
<p>Dbutils 是Apache提供的JDBC简单框架</p>
<ul>
<li>QueryRunner</li>
<li><code>int[] batch(String sql, Object[][] params)</code>: 执行批处理</li>
<li>sql: 执行的语句</li>
<li>params: 二维数组,高纬表示执行的语句的条数, 低维表示每条语句的参数</li>
<li>返回每条语句影响到的记录行数</li>
<li><T> T query(String sql, ResultSetHandler<T> rsh)</li>
<li>适合执行sql查询, 把结果封装到JavaBean中</li>
<li><T> T query(String sql, ResultSetHandler<T> rsh, Object... params)</li>
<li>int update(String sql)</li>
<li>执行 insert update delete 语句</li>
<li>int update(String sql, Object... params)</li>
<li>int update(String sql, Object param)</li>
</ul>
<h2 id="bean-">Bean封装</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(
    id <span class="keyword">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>,
    name <span class="keyword">varchar</span>(<span class="number">20</span>),
    birthday <span class="keyword">date</span>
);</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> User{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> Date birthday;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">private</span> QueryRunner qr = <span class="keyword">new</span> QueryRunner(datasource);
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span>(){
    qr.update(<span class="string">"insert into user values(?, ?, ?)"</span>, <span class="number">1</span>, <span class="string">"aaa"</span>, <span class="keyword">new</span> Date());
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span>(){
    qr.update(<span class="string">"update user set name=? where id=?"</span>, <span class="string">"aaa"</span>, <span class="keyword">new</span> Date(), <span class="number">1</span>);
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDel</span>(){
    qr.update(<span class="string">"delete from user where id=?"</span>, <span class="number">1</span>);
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryOne</span>(){
    User u = qr.query(<span class="string">"select * from user where id=1"</span>, <span class="keyword">new</span> BeanHandler&lt;User&gt;(User.class), <span class="number">1</span>);
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery1</span>(){
    User u = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> BeanHandler&lt;User&gt;(User.class));
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMulti</span>(){
    List&lt;User&gt; us = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> ListBeanHandler&lt;User&gt;(User.class));
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span>(){
    Object <span class="keyword">params</span>[][] = <span class="keyword">new</span> Object[<span class="number">10</span>][];
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">params</span>.length;i++){
        <span class="keyword">params</span>[i] = <span class="keyword">new</span> Object[]{i+<span class="number">1</span>, <span class="string">"aaa"</span> + ()i+<span class="number">1</span>), <span class="keyword">new</span> Date()}
    }
    qr.batch(<span class="string">"insert into user values(?,?,?)"</span>, <span class="keyword">params</span>);
}
</pre></td></tr></table></figure>

<h2 id="dbutils-">DBUtils 中的结果处理器详解</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre>
<span class="comment">// 把结果集的第一条记录封装到数组中, 数组中的元素就是每一列的值</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArrayHandler</span>(){
    Object objs[] = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> ArrayHandler());
}

<span class="comment">// 把结果集中的每条记录封装到一个List中, 元素是Object[],</span>
<span class="comment">// 适合查询结果由多条的记录</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArrayListHandler</span>(){
    List&lt;Object[]&gt; list = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> ArrayListHandler());
}

<span class="comment">//把查询结果中的某一列封装到List中</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testColumnListHandler</span>(){
    List&lt;Object&gt; list = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> ColumnListHandler(<span class="string">"name"</span>));
}

<span class="comment">// 把查询结果封装到一个Map中, Map中的key值是你指定的列值</span>
<span class="comment">// value 也是一个Map, map的key是字段名, value是字段值</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKeyedHandler</span>(){
    Map&lt;Object,Map&lt;String,Object&gt;&gt; bmap = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> KeyedHandler(<span class="string">"id"</span>));
}

<span class="comment">// 把结果集中的第一条记录封装到Map中, key是字段名, value是字段值</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapHandler</span>(){
    Map&lt;String, Object&gt; map = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> MapHandler());
}
<span class="comment">// 每个元的代表一条记录, 用Map 封装, key是字段名, value是字段值</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapListHandler</span>(){
    List&lt;Map&lt;String, Object&gt;&gt; list = qr.query(<span class="string">"select * from user"</span>, <span class="keyword">new</span> MapListHandler);
}

<span class="comment">// 单行, 单列</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testScalarHandler</span>(){
    Object list = qr.query(<span class="string">"select count(*) from user"</span>, <span class="keyword">new</span> ScalarHandler(<span class="number">1</span>));
}
</pre></td></tr></table></figure>

<h1 id="threadlocal">ThreadLocal</h1>
<ol>
<li>ThreadLocal 提供了线程局部变量</li>
<li>分析原理</li>
</ol>
<p>ThreadLocal 内部有一个Map, Map的Key是当前线程对象, value是一个Objct对象. <em>模拟</em>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> ThreadLocal&lt;T&gt;{
    <span class="keyword">private</span> Map&lt;Runnable, T&gt; map = <span class="keyword">new</span> HashMap&lt;Runnable, T&gt;();
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(T t){
        map.put(Thread.currentThread(), t); <span class="comment">// 把传入的参数绑定到当前线程上</span>
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(){
        map.remove(Thread.currentThread());
    }
    <span class="keyword">public</span> T <span class="title">get</span>(){
        <span class="keyword">return</span> map.<span class="keyword">get</span>(Thread.currentThread()); <span class="comment">// 获取当前线程绑定的脆响</span>
    }
}
</pre></td></tr></table></figure>

<h1 id="-">真实案例中的事务控制</h1>
<ul>
<li>QueryRunner(DataSource conn) // 这个每条语句执行,都是不同的连接(Connection), 不能在同一个事务中执行语句</li>
<li>QueryRunner()  //因为需要所有语句执行要在同一个事务中执行, 在执行语句时, 要传入(Connection)</li>
</ul>
<blockquote>
<p>DAO层: 只负责数据库的访问, 只有增删改查</p>
<p>事务控制的要求: 一般是业务上的要求, 一个事务就是一个业务, <strong>事务控制</strong>不能在放在DAO</p>
</blockquote>
<h2 id="-">版本一</h2>
<h3 id="dao-">DAO层</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAccontByName</span>(acconntname){
    Account account = qr.query(<span class="string">"select * from account where name=?"</span>, <span class="keyword">new</span> BeanHandler&lt;Account&gt;(Account.class), accountName);
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span>(Account account){
    qr.update(<span class="string">"udpate set "</span>, account.id, account.name)
}
</pre></td></tr></table></figure>

<h3 id="-">业务逻辑</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Connection conn = dataSource<span class="preprocessor">.getConnection</span>()<span class="comment">; // 不好, 在业务层有Dao层 的代码</span>
conn<span class="preprocessor">.setAutoCommit</span>(false)<span class="comment">;</span>
dao<span class="preprocessor">.setConnection</span>(conn)<span class="comment">;</span>
Account sourceAccount = dao<span class="preprocessor">.findAccontByName</span>(sourceAccountName)<span class="comment">;</span>
Account targetAccount = dao<span class="preprocessor">.findAccontByName</span>(targetAccountName)<span class="comment">;</span>

sourceAccount<span class="preprocessor">.setMoney</span>(any)<span class="comment">;</span>
targetAccount<span class="preprocessor">.setMoney</span>(any)<span class="comment">;</span>

dao<span class="preprocessor">.update</span>(sourceAccount)<span class="comment">;</span>
dao<span class="preprocessor">.update</span>(targetAccount)<span class="comment">;</span>
conn<span class="preprocessor">.setAutoCommit</span>(true)<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="-">版本二</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> TransactionManager{
    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Connection</span>(){
        Connecton conn = t1.<span class="keyword">get</span>(); <span class="comment">// 从当前线程上获取</span>
        <span class="keyword">if</span>(conn==<span class="keyword">null</span>){
            conn = dataSource.getConnection(); <span class="comment">// 没有就从池中取一个</span>
            t1.<span class="keyword">set</span>(conn);
        }
        <span class="keyword">return</span> conn;
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTransaction</span>(){
        Connection conn = getConnection();
        conn.setAutoCommit(<span class="keyword">false</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit</span>(){
        Connection conn = getConnection();
        conn.commit();
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span>(){
        Connection conn = getConnection();
        conn.rollback();
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span>(){
        Connection conn = getConnection();
        conn.close();
        t1.remove();  <span class="comment">// 从当前线程解绑, 因为服务器使用了线程池技术</span>
    }
}
</pre></td></tr></table></figure>

<h3 id="-">业务逻辑</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>TransactionManager<span class="preprocessor">.startTransaction</span>()<span class="comment">;</span>
dao<span class="preprocessor">.setConnection</span>(conn)<span class="comment">;</span>
Account sourceAccount = dao<span class="preprocessor">.findAccontByName</span>(sourceAccountName)<span class="comment">;</span>
Account targetAccount = dao<span class="preprocessor">.findAccontByName</span>(targetAccountName)<span class="comment">;</span>

sourceAccount<span class="preprocessor">.setMoney</span>(any)<span class="comment">;</span>
targetAccount<span class="preprocessor">.setMoney</span>(any)<span class="comment">;</span>

dao<span class="preprocessor">.update</span>(sourceAccount)<span class="comment">;</span>
dao<span class="preprocessor">.update</span>(targetAccount)<span class="comment">;</span>
TransactionManager<span class="preprocessor">.commit</span>()<span class="comment">;</span>

TransactionManager<span class="preprocessor">.rollback</span>()<span class="comment">; // catch it</span>
TransactionManager<span class="preprocessor">.release</span>()<span class="comment">; // finally</span>
</pre></td></tr></table></figure>

<h3 id="dao-">DAO层</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAccontByName</span>(acconntname){
    Account account = qr.query(TransactionManager.getConnection(), <span class="string">"select * from account where name=?"</span>, <span class="keyword">new</span> BeanHandler&lt;Account&gt;(Account.class), accountName);
}

<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span>(Account account){
    qr.update(transactionmanager.getconnection(), <span class="string">"udpate set "</span>, account.id, account.name)
}
</pre></td></tr></table></figure>

<h2 id="-">版本三</h2>
<p>提取 service 中的关于 Transaction 的重复代码, 使用<strong>动态代理</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">public</span> Interface BusinessService{
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span>(){}
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> BeanFactory {
<span class="comment">// 返回BusinessService的实现类的代理对象</span>
<span class="comment">// 面向切面编程</span>
    <span class="keyword">public</span> <span class="keyword">static</span> BusinessService <span class="title">getBusinessService</span>(){
    BusinessService s = <span class="keyword">new</span> BusinessService();
    BusinessService proxy = Proxy.newProxyInstancee(
        getClassLoader(), s.getClass().getInterfaces(),
        <span class="keyword">new</span> InvocationHandler() {
            @Override <span class="keyword">public</span> Object <span class="title">invoke</span>() {
                TransactionManager.startTransaction();
                Object rtValue = method.invoke(s, args);
                    TransactionManager.commit();
                    TransactionManager.rollback(); <span class="comment">// try catch</span>
                    TransactionManager.release(); <span class="comment">// finally</span>
                    <span class="keyword">return</span> rtValue;
            }
        });
    }
}
</pre></td></tr></table></figure>

<h1 id="-">多表存取</h1>
<h2 id="-">一对多</h2>
<p>一个客户可以有许多订单</p>
<h3 id="-">模型类</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> customer(
    id <span class="keyword">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>,
    name <span class="keyword">varchar</span>(<span class="number">100</span>)
)
<span class="keyword">create</span> <span class="keyword">table</span> orders(
    id <span class="keyword">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>,
    num <span class="keyword">varchar</span>(<span class="number">100</span>),
    money <span class="keyword">float</span>(<span class="number">8</span>,<span class="number">0</span>),
    customer_id <span class="keyword">int</span>,
    <span class="keyword">constraint</span> customer_id_ref <span class="keyword">foreign</span> <span class="keyword">key</span> (customer_id) referrence customer(id)
)</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Customer {
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> List&lt;Orders&gt; orders = <span class="keyword">new</span> ArrayList&lt;Orders&gt;
}
<span class="keyword">public</span> <span class="keyword">class</span> Orders {
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String num;
    <span class="keyword">private</span> <span class="keyword">float</span> money;
    <span class="keyword">private</span> Customer customer;
}
</pre></td></tr></table></figure>

<h3 id="dao">Dao</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> CustomerDaoImpl{
    <span class="keyword">private</span> QueryRunner rq;
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCustomer</span>(Customer c){
        rq.update(<span class="string">""</span>, c.getId(), c.getName());
        List&lt;Orders&gt; os = c.getOrders();
        <span class="keyword">if</span>(os!=<span class="keyword">null</span>&&os.size()&gt;<span class="number">0</span>){
            <span class="keyword">for</span>(Orders o:os){
                os.update(<span class="string">""</span>, o.getId...);
            }
        }
    }

<span class="comment">// 查询客户时,要不要查询客户拥有的订单? 看需求(Hibernate用的是延迟加载)</span>
    <span class="keyword">public</span> Customer <span class="title">findByCustomerId</span>(<span class="keyword">int</span> id){
        Customer c = rq.query(<span class="string">"select * from customer where id=?"</span>, <span class="keyword">new</span> BeanHandler&lt;Customer&gt;(), id);
        <span class="keyword">if</span>(c!=<span class="keyword">null</span>){
            <span class="comment">// 有查询结果, 查询该客户的订单</span>
            List&lt;Orders&gt; os = qr.query(<span class="string">"select * from orders where customer_id=?"</span>), <span class="keyword">new</span> BeanListHander&lt;Orders&gt;, c.getId());
            c.setOrders(os);
        }
        <span class="keyword">return</span> c;
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> CustomerDaoTest {
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span>(){
        Customer c = <span class="keyword">new</span> Customer();
        c.setId(<span class="number">1</span>);
        c.setName(<span class="string">""</span>);

        Orders o1 = <span class="keyword">new</span> Orders();
        o1.setId(<span class="number">1</span>);
        o1.setNum(<span class="string">"201401"</span>);
        o1.setMoney(<span class="number">1000</span>);
        c.getOrders().add(o1);

        Orders o2 = <span class="keyword">new</span> Orders();
        o2.setId(<span class="number">1</span>);
        o2.setNum(<span class="string">"201401"</span>);
        o2.setMoney(<span class="number">1000</span>);
        c.getOrders().add(o2);
        dao.addCustomer(c);
    }

    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span>(){
        Customer c = dao.findByCustomerId(<span class="number">1</span>);
        List&lt;Orders&gt; os = c.getOrders();
    }
}
</pre></td></tr></table></figure>

<h2 id="-">多对多</h2>
<p>学生和老师的关系是多对多</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> teacher (
    id <span class="keyword">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>,
    name <span class="keyword">varchar</span>(<span class="number">100</span>),
    salary <span class="keyword">float</span>(<span class="number">8</span>,<span class="number">0</span>)
);</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> student(
    id <span class="keyword">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>,
    name <span class="keyword">varchar</span>(<span class="number">100</span>),
    grade <span class="keyword">varchar</span>(<span class="number">100</span>)
);</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> teacher_student(
    t_id <span class="keyword">int</span>,
    s_id <span class="keyword">int</span>,
    <span class="keyword">primary</span> <span class="keyword">key</span>(t_id, s_id),
    <span class="keyword">constraint</span> t_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(t_id) referrences teacher(id),
    <span class="keyword">constraint</span> s_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(s_id) referrences student(id)
);</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Teacher {
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> <span class="keyword">float</span> salary;
    <span class="keyword">private</span> List&lt;Student&gt; studnents = <span class="keyword">new</span> ArrayList();
}
<span class="keyword">public</span> <span class="keyword">class</span> Student{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> String grade;
    <span class="keyword">private</span> List&lt;Teacher&gt; teachers = <span class="keyword">new</span> ArrayList();
}
</pre></td></tr></table></figure>

<h3 id="dao">Dao</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTeacher</span>(){
    <span class="comment">// 保存老师的基本信息</span>
    qr.update(<span class="string">"insert int teacher values(?,?,?)"</span>, t.getId(), t.getName());
    List&lt;Student&gt; sts = t.getStudnets();
    <span class="comment">// 查看学生的信息在不在, 不在才保存</span>
    <span class="keyword">if</span>(students!=<span class="keyword">null</span>&& students.size()&gt;<span class="number">0</span>){
        <span class="keyword">for</span>(Student s:students){
            Student dbs = qr.query(<span class="string">"select * from student where id=?"</span>, BeanHandler(), s.getId());
            <span class="keyword">if</span>(dbs==<span class="keyword">null</span>){
                qr.update(<span class="string">"insert into student values(?,?,?)"</span>);
            }
            qr.update(<span class="string">"insert into teacher_student values(?,?)"</span>, t.getId(), s.getId());
        }
    }
    <span class="comment">// 同时保存老师和学生的关联关系</span>
}
<span class="comment">// 要不要查询老师教过的学员? 看需求</span>
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findTeacherById</span>(<span class="keyword">int</span> id){
    Teacher t = qr.query(<span class="string">"select * from teacher where id=?"</span>, BeanHandler, teacher.getId);
    <span class="keyword">if</span>(t!=<span class="keyword">null</span>){
        <span class="comment">// String sql = "select * from student where id in(select s_id from teacher_student where t_id=?)"; // 子查询</span>
        <span class="comment">// String sql = "select s.* from teacher_student ts, student s where s.id=ts.s.id and ts.t_id=?"; // 隐式内连接</span>
        String sql = <span class="string">"select s.* from teacher_student inner join student s on s.id=ts.s_id where ts.t_id=?"</span>; <span class="comment">// 显式内连接</span>
        List&lt;Student&gt; ss = qr.query(sql, <span class="keyword">new</span> BeanListHander&lt;Student&gt;);
        t.setStudents(ss);
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>public void testAddTeacher(){
    Teacher t1 = new Teacher()<span class="comment">;</span>
    t1<span class="preprocessor">.setId</span>(<span class="number">1</span>)<span class="comment">;</span>
    t1<span class="preprocessor">.setName</span>(<span class="string">"qb"</span>)<span class="comment">;</span>
    t1<span class="preprocessor">.setSalary</span>(<span class="number">10</span>)<span class="comment">;</span>

    Teacher t2 = new Teacher()<span class="comment">;</span>
    t2<span class="preprocessor">.setId</span>(<span class="number">1</span>)<span class="comment">;</span>
    t2<span class="preprocessor">.setName</span>(<span class="string">"wzt"</span>)<span class="comment">;</span>
    t2<span class="preprocessor">.setSalary</span>(<span class="number">10</span>)<span class="comment">;</span>

    Student s1 = new Student()<span class="comment">;</span>
    s1<span class="preprocessor">.setId</span>(<span class="number">1</span>)<span class="comment">;</span>
    s1<span class="preprocessor">.setName</span>(<span class="string">"hcH"</span>)<span class="comment">;</span>
    s1<span class="preprocessor">.setGrade</span>(<span class="string">"A"</span>)<span class="comment">;</span>

    t1<span class="preprocessor">.getStudents</span>()<span class="preprocessor">.add</span>(s1)<span class="comment">;</span>
    t2<span class="preprocessor">.getStudents</span>()<span class="preprocessor">.add</span>(s1)<span class="comment">;</span>
}

public void testQuery(){
    Teacher t = dao<span class="preprocessor">.findTeacherById</span>(<span class="number">1</span>)<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<h2 id="-">一对一</h2>
<p>有主键关联 和外键关联</p>
<p>身份证和公民是一对一</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> person (
    id <span class="keyword">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>,
    name <span class="keyword">varchar</span>(<span class="number">100</span>)
);</span>
<span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> idcard (
    id <span class="keyword">int</span> <span class="keyword">primary</span> <span class="keyword">key</span>,
    num <span class="keyword">varchar</span>(<span class="number">100</span>),
    <span class="keyword">constraint</span> i_id_fk <span class="keyword">foreign</span> <span class="keyword">key</span>(id) <span class="keyword">references</span> person(id)
);</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> Person{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> String name;
    <span class="keyword">private</span> IdCard idCard;
}

<span class="keyword">public</span> <span class="keyword">class</span> IdCard {
    <span class="keyword">private</span> ind id;
    <span class="keyword">private</span> String num;
    <span class="keyword">private</span> Person person;
}
</pre></td></tr></table></figure>

<h2 id="dao-">DAO层</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span>(Person p){
    qr.update(<span class="string">"insert into person values(?,?)"</span>);
    IdCard idcard = p.getIdCard();
    <span class="keyword">if</span>(idcard!=<span class="keyword">null</span>){
        qr.update(<span class="string">"insert into idcard values(?,?)"</span>)
    }
}
<span class="comment">//要不要查对应的身份证, 看需求(建议查)</span>
<span class="keyword">public</span> Person <span class="title">findPersonById</span>(<span class="keyword">int</span> id) {
    Person p = qr.query(<span class="string">"select * from person where id=?"</span>, <span class="keyword">new</span> BeanHandler&lt;Person&gt;, id)
    <span class="keyword">if</span>(p!=<span class="keyword">null</span>){
        IdCard idCard = qr.query(<span class="string">"select * from idcard where id=?"</span>, BeanHandler&lt;IdCard),id)
        p.setIdCard(idcard);
    }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day19-事务和数据库连接池]]></title>
    <link href="http://zhpooer.github.io/2014/04/25/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day19-%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://zhpooer.github.io/2014/04/25/传智播客day19-事务和数据库连接池/</id>
    <published>2014-04-25T03:17:21.000Z</published>
    <updated>2014-04-28T06:34:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-aicd-">事务特性 (AICD)</h1>
<ul>
<li>原子性：处于同一个事务中的多条语句，要么全都成功，要么全都不成成功。</li>
<li>一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态,在事务中的状态不会被保存. 比如转账：转账前a+b=2000，转账后a+b=2000</li>
<li>隔离性：多线程并发时，一个事务不能被其他事务所干扰。</li>
<li>持久性：数据应该被永久性的保存起来。（硬盘，而不是内存）</li>
</ul>
<h2 id="-">事务的隔离性专题</h2>
<p>如果不考虑事务的隔离性，会导致以下不正确的问题:</p>
<ul>
<li>脏读: 指一个事务读到了另外一个事务中未提交的数据</li>
<li>不可重复读: 指一个事务读到了另外一个事务update后（事务提交了）的数据</li>
<li>虚读: 指在一个事务中读到了另外一个事务insert(事务提交了)的数据</li>
</ul>
<p>数据库有四个隔离级别：</p>
<ul>
<li>READ UNCOMMITTED:脏读、不可重复读、虚读都有可能发生。</li>
<li>READ COMMITTED:防止脏读发生；不可重复读、虚读都有可能发生。</li>
<li>REPEATABLE READ:（MySQL默认级别）防止脏读、不可重复读；虚读有可能发生。</li>
<li>SERIALIZABLE:防止脏读、不可重复读、虚读的发生</li>
</ul>
<p>特点：从上到下，隔离级别越高，数据越安全，但是效率越低</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">select</span> @@tx_isolation;</span>		查看当前数据库的隔离级别, 必须在事务中进行操作
<span class="operator"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 四个级别之一;</span>更改当前事务的隔离级别
</pre></td></tr></table></figure>

<h2 id="jdbc-">JDBC 控制事务隔离机制</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>Connection<span class="preprocessor">.TRANSACTION</span>_READ_UNCOMMITTED
Connection<span class="preprocessor">.TRANSACTION</span>_READ_COMMITTED
Connection<span class="preprocessor">.TRANSACTION</span>_REPEATABLE_READ
Connection<span class="preprocessor">.TRANSACTION</span>_SERIALIZABLE

Connection<span class="preprocessor">.setTransactionIsolation</span>(int Level) // 必须放在事务开启之前
</pre></td></tr></table></figure>

<h1 id="-">数据库连接池</h1>
<p>给数据库连接提供缓存, 提供访问效率</p>
<h2 id="-">版本一</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="comment">// cn.itcast.pool.SimpleConnectionPoll</span>
<span class="keyword">public</span> <span class="keyword">static</span> SimpleConnectionPoll{
    <span class="keyword">private</span> List&lt;Connection&gt; pool = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();
    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">10</span>;
    <span class="keyword">public</span> <span class="title">SimpleConnectionPoll</span> () {
        <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to size) {
            Connection conn = JDBCUtil.getConnection();
            pool.add(conn)
        }
    }
}
<span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">getConnection</span>(){
    <span class="keyword">if</span>(pool.size()&gt;<span class="number">0</span>){
        Connection conn = pool.remove(<span class="number">0</span>);
        <span class="keyword">return</span> conn;
    } <span class="keyword">else</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"服务器"</span>);
    }
}
<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span>(Connection conn) {
    pool.add(conn);
}
</pre></td></tr></table></figure>

<h2 id="-">版本二</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">public</span> MyDataSource implements javax.sql.DataSource{
    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Connection&gt; pool = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();
    <span class="keyword">static</span> {
        <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to size) {
            Connection conn = JDBCUtil.getConnection();
            pool.add(conn)
        }
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">synchronized</span>  Connection <span class="title">getConnection</span>() <span class="keyword">throws</span> SQLException{
        <span class="keyword">if</span>(pool.size()&gt;<span class="number">0</span>){
            Connection conn = pool.remove(<span class="number">0</span>);
            <span class="keyword">return</span> conn;
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"服务器"</span>);
        }
    }
}
</pre></td></tr></table></figure>

<p>DataSource 中没有提供 <code>release()</code>, 可以修改 <code>Conneciton</code> 的 <code>close()</code>方法,
让他不要关闭连接, 而是还回池中. </p>
<h2 id="-">方式三、四(装饰器, 适配器模式)</h2>
<h3 id="-">修改已知类的原有功能</h3>
<ul>
<li>继承: 子类可以覆盖父类的方法(现在不合适)</li>
<li><p>装饰器模式:</p>
<ul>
<li>编写一个类, 实现与被包装类相同的接口(具有相同的行为)</li>
<li>定义构造方法, 传入被包装类对象</li>
<li>对于要改写的方法, 书写你的代码即可</li>
<li>对于不要改写的方法, 调用原有类的方法<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConnection</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Connection</span>{</span>
      <span class="keyword">private</span> Connection conn;
      <span class="keyword">private</span> List&lt;Connection&gt; pool;
      <span class="keyword">public</span> <span class="title">MyConnection</span>(Connection conn, List&lt;Connection&gt; pool){
          <span class="keyword">this</span>.conn = conn;
          <span class="keyword">this</span>.pool = pool;
      }
      <span class="annotation">@Override</span>
      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span>() <span class="keyword">throws</span> SQLException {
         pool.add(conn);
      }
  }
  <span class="comment">// DataSource.java</span>
  <span class="keyword">public</span> <span class="keyword">synchronized</span>  Connection <span class="title">getConnection</span>() <span class="keyword">throws</span> SQLException{
      <span class="keyword">if</span>(pool.size()&gt;<span class="number">0</span>){
          Connection conn = pool.remove(<span class="number">0</span>);
          <span class="keyword">return</span> <span class="keyword">new</span> MyConnection(conn, pool);
      } <span class="keyword">else</span> {
          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"服务器"</span>);
      }
  }
</pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>适配器模式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionAdapter</span> <span class="keyword">implements</span> <span class="title">Connection</span> {</span>
    <span class="keyword">private</span> Conneciton conn;
    <span class="keyword">private</span> List&lt;Connection&gt; pool;
    <span class="keyword">public</span> <span class="title">ConnecitonAdapter</span>(Connection conn, List&lt;Connection&gt; poo){
        <span class="keyword">this</span>.conn = conn;
        <span class="keyword">this</span>.pool = pool;
    }
    Override ...<span class="comment">// 跟上一个方式的区别是, 没有重新实现close()方法</span>
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConnection</span> <span class="keyword">extends</span> <span class="title">ConnecitonAdapter</span> {</span>
    <span class="keyword">private</span> Conneciton conn;
    <span class="keyword">private</span> List&lt;Connection&gt; pool;
    <span class="keyword">public</span> <span class="title">ConnecitonAdapter</span>(Connection conn, List&lt;Connection&gt; pool){
        <span class="keyword">super</span>(conn, pool)
        <span class="keyword">this</span>.conn = conn;
        <span class="keyword">this</span>.pool = pool;
    }
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span>() {
        pool.add(conn);
    }
}
</pre></td></tr></table></figure>
</li>
<li><p>动态代理
<code>Proxy.newProxyInstancee(classloader, Class&lt;?&gt;[] interfaces, InvocationHandler)</code></p>
<blockquote>
<p>inerfaces: 代理类实现了那些接口, 和被代理对象一样即可,(双方具有相同的行为)<br>InvacationHandler: 具体怎么代理(策略设计模式)</p>
</blockquote>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">new</span> InvocationHandler(){
    <span class="comment">// 匿名内部类, 实现接口</span>
    <span class="comment">/*
    * Object proxy 代理对象本身的丢向
    * Method mehtod, 当前调用的是哪个方法
    * Object[] args, 当前调用用到的参数
    */</span>
    <span class="keyword">public</span> <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method m, <span class="built_in">Object</span>[] args) {
        <span class="comment">// before method handler</span>
        <span class="comment">// invoke method</span>
        <span class="comment">// after method handler</span>
    }
}
</pre></td></tr></table></figure>

<h2 id="-">方式五 (动态代理)</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="title">getConnection</span>(){
    <span class="keyword">if</span>(pool.size() &gt; <span class="number">0</span>) {
        Connection conn = pool.remove(<span class="number">0</span>);
        Connection proxyConn = (Conneciton) Proxy.newInstance(
            conn.getClass().getClassloader(),
            conn.getClass().getInterfaces(),
            <span class="keyword">new</span> InvocationHandler(){
                 <span class="keyword">public</span> Object <span class="title">invoke</span>(){
                     <span class="keyword">if</span>(<span class="string">"close"</span>.equals(method.getName())){
                         <span class="keyword">return</span> pool.add(conn)
                     } <span class="keyword">else</span>{
                         method.invoke(conn, args);
                     }
                 }
            }
        );
        <span class="keyword">return</span> proxyConn;
    }
}
</pre></td></tr></table></figure>

<h2 id="-">总结</h2>
<ul>
<li>日后尽量使用标准的数据源(一般都带有连接池, 为的就是提高效率)</li>
<li>当用户调用<code>Connection.close()</code>方法, 并不能关闭连接, 而是还回池中</li>
</ul>
<h1 id="-">开源数据源</h1>
<p><code>DataSource</code>, 数据源, 数据源中都包含了数据库连接池的实现</p>
<h2 id="dbcp">DBCP</h2>
<p>简介: APache组织实现. Database Connect Pool</p>
<p>如何使用:</p>
<ul>
<li>拷贝Jar包</li>
<li><p>配置 dbcpconfig.properties, 加入构建路径</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="constant">initialSize</span>=10
<span class="constant">maxActive</span>=50
<span class="constant">maxIdle</span>=20
<span class="constant">minIdle</span>=5
<span class="constant">maxWait</span>=6000 # 单位毫秒
<span class="constant">connectionProperties</span>=useUnicode=true;
<span class="comment"># 可以配置数据库数据隔离特性</span>
</pre></td></tr></table></figure>
</li>
<li><p>建立工具类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> DBCPUtil{
    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;
    <span class="keyword">static</span> {
        <span class="comment">// 读取配置文件</span>
        InputStream <span class="keyword">in</span> = DBCPUtil.class.getClassloader().getResourceAsStream(<span class="string">'properties'</span>);
        Properties props = <span class="keyword">new</span> Properties();
        props.load(<span class="keyword">in</span>);
        dataSource = BasicDataSourceFactory.createDataSource(props);
    }
    <span class="keyword">public</span> <span class="keyword">static</span> Conneciton <span class="title">getConnection</span>(){
        <span class="keyword">return</span> dataSource.getConnection();
    }
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getDataSource</span>(){
        <span class="keyword">return</span> dataSource;
    }
}
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="c3p0">C3P0</h2>
<ul>
<li>拷贝Jar包</li>
<li><p>手工配置C3p0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>private static ComboPooledDataSource ds = new ComboPooledDataSource()<span class="comment">;</span>
ds<span class="preprocessor">.setDriverClass</span>(<span class="string">"com.mysql.jdbc.Driver"</span>)<span class="comment">;</span>
ds<span class="preprocessor">.setJdbcUrl</span>(<span class="string">"jdbc:mysql://localhost:3306/database"</span>)<span class="comment">;</span>
ds<span class="preprocessor">.setUser</span>(<span class="string">""</span>)<span class="comment">;</span>
ds<span class="preprocessor">.setPassword</span>(<span class="string">""</span>)<span class="comment">;</span>
ds<span class="preprocessor">.setMaxPoolSize</span>(<span class="number">40</span>)<span class="comment">;</span>
ds<span class="preprocessor">.setMinPoolSize</span>(<span class="number">5</span>)<span class="comment">;</span>
ds<span class="preprocessor">.setInitialPoolSize</span>(<span class="number">20</span>)<span class="comment">;</span>
ds<span class="preprocessor">.setMaxStatements</span>()<span class="comment">; // 批处理</span>
</pre></td></tr></table></figure>
</li>
<li><p>可以用xml配置<code>c3p0-config.xml</code>, 或<code>c3p0.properties</code>来配置</p>
</li>
</ul>
<h2 id="-tomcat-">获取Tomcat管理的数据源</h2>
<p>Tomcat在启动时,会按照用户的配置, 创建数据源, 并把数据源对象绑定到一个名字上(用的是JNDI).</p>
<p>JNDI: Java Naming and Directory Interface(JDK:javax.naming.*)</p>
<p>相当于window系统的注册表, 是一个Map结构. key是一个由路径和名称组成的字符串,
value就是一个绑定的对象</p>
<h3 id="-tomcat-dbcp-">利用Tomcat管理数据源(dbcp)</h3>
<ol>
<li>数据库连接驱动Jar包, 放到Tomcat的lib文件夹下</li>
<li><p>配置Context, 在应用目录里面的 META-INFO 建立 context.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">context</span>&gt;</span>
    <span class="tag">&lt;<span class="title">resources</span> <span class="attribute">name</span>=<span class="value">"jdbc/day19"</span> <span class="attribute">auth</span>=<span class="value">"Container"</span>
    <span class="attribute">type</span>=<span class="value">"javax.sql.DataSource"</span> <span class="attribute">username</span>=<span class="value">"root"</span>
    <span class="attribute">password</span>=<span class="value">"sorry"</span> <span class="attribute">driverClassName</span>=<span class="value">"com.mysql.jdbc.Driver"</span>
    <span class="attribute">uri</span>=<span class="value">"jdbc:mysql"</span> <span class="attribute">maxActive</span>=<span class="value">"8"</span> <span class="attribute">maxIdle</span>=<span class="value">"4"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">resources</span>&gt;</span>
<span class="tag">&lt;/<span class="title">context</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p>启动Tomcat, 数据源就已经建好了</p>
</li>
<li>在应用中获取数据源, 获取JNDI容器中的数据源<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Context initCtx = new InitialContext()<span class="comment">;</span>
Context envCtx = initCtx<span class="preprocessor">.lookup</span>(<span class="string">"java:comp/env"</span>)<span class="comment">;</span>
Datasource ds = envCtx<span class="preprocessor">.lookup</span>(<span class="string">"jdbc/dya19"</span>)<span class="comment">;</span>
Conneciton conn = ds<span class="preprocessor">.getConnection</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

</li>
</ol>
<h1 id="-">数据库元数据的获取</h1>
<p>元数据: 数据库, 表, 列等定义的信息</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>DatabaseMetaData dmd = conn.getMetaData();
<span class="comment">// 数据库综合信息获取</span>
dmd.getDatabaseProductName();   <span class="comment">// MySQL</span>
dmd.getDatabaseProductVersion();   <span class="comment">// 5.0.18</span>

<span class="comment">// 获取 preparedStateMent 中占位符的语句信息</span>
PreparedStateMent stmp = conn.prepareStateMent(<span class="string">"insert into user values(?,?,?)"</span>)
ParameterMetaData pmd = stmp.getParameterMetaData; <span class="comment">// 得到的是问号的个数</span>
pmd.getParameterCont();    <span class="comment">// 3</span>

<span class="comment">// 结果集元数据信息获取</span>
PreparedStateMent stmp = conn.prepareStateMent(<span class="string">"select * from user"</span>)
ResultSet rs = stmp.excuteQuery();
ResultSetMetaData rsmd = rs.getMetaData();
<span class="keyword">int</span> num = rsmd.getColumnCount();    <span class="comment">// 查询结果有多少列</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++){
    String columnName = rsmd.getColumnName(i+<span class="number">1</span>);
    <span class="keyword">int</span> columnType =  rsmd.getColumnType(i+<span class="number">1</span>);  <span class="comment">// java.sql.Types</span>
}
</pre></td></tr></table></figure>

<h1 id="-">自定义框架</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> User{
    <span class="keyword">private</span> <span class="keyword">int</span> id;
    <span class="keyword">private</span> <span class="keyword">int</span> String ;
    <span class="keyword">private</span> String gender;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> UserDaoImpl{
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span>(User user){
        db.update(<span class="string">"insert into user values(?,?,?))"</span>, <span class="keyword">new</span> Object{user.getId,...})
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span>(User user){
        db.update(<span class="string">"update into user set name=?, gender=? where id=?"</span>, <span class="keyword">new</span> Object{<span class="string">"abc"</span>, <span class="string">"0"</span>, user.getId()})
    }
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delUser</span>(User user){
        db.update(<span class="string">"delete from user where id=?"</span>, <span class="keyword">new</span> Object{user.getId()});
    }
    <span class="keyword">public</span> Object <span class="title">query</span>(){
        db.query(<span class="string">"select * from user where id=?"</span>, <span class="keyword">new</span> Object[]{<span class="number">1</span>},
        <span class="comment">// 可提取一个方法类</span>
            <span class="keyword">new</span> ResultSetHandler(){
                <span class="keyword">public</span> Object <span class="title">handle</span>(ResultSet rs){
                    <span class="keyword">if</span>(rs.next()){
                        ResultSetMetaData rsmd = rs.getMetaData();
                        <span class="keyword">int</span> columnCount = rsmd.getColumnCount();
                        User user = <span class="keyword">new</span> User();
                        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;colmnCount;i++){
                            String fieldName = rsmd.getColumnName(i+<span class="number">1</span>);
                            String fieldValue = rs.getObject(i+<span class="number">1</span>);
                            Field field = User.class.getDeclaredField(fieldName);
                            field.setAccessible(<span class="keyword">true</span>);
                            field.<span class="keyword">set</span>(user, fieldValue);
                        }
                    } <span class="keyword">else</span> {
                        <span class="keyword">return</span> <span class="keyword">null</span>;
                    }
                }
            }
        );
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="comment">// 结果处理策略</span>
<span class="keyword">public</span> Interface ResultSetHandler {
    Object handler(ResultSet rs);
}
<span class="keyword">public</span> <span class="keyword">class</span> DBAssist{
    <span class="keyword">private</span> DataSource ds;
    <span class="keyword">public</span> <span class="title">DBAssist</span>(Datasource ds){
        <span class="keyword">this</span>.ds = ds;
    }
    <span class="comment">// 执行DML语句: insert update delete</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span>(String sql, Object[] <span class="keyword">params</span>){
        Conneciton conn = <span class="keyword">null</span>;
        PreparedStateMent stmt = <span class="keyword">null</span>;
        ResultSet rs = <span class="keyword">null</span>;
        <span class="keyword">try</span>{
            conn = dataSource.getConnection();
            stmt = conn.prepareStateMent(sql);
            ParameterMetaData pmd = stmt.getParameterMetaData();
            <span class="keyword">int</span> paramCount = pmd.getParameterCount();
            <span class="keyword">if</span>(paramCount&gt;<span class="number">0</span>){
                <span class="keyword">if</span>(<span class="keyword">params</span>==<span class="keyword">null</span> || <span class="keyword">params</span>.length==<span class="number">0</span>){
                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数有误"</span>);
                }
                <span class="keyword">if</span>(paramCount!=<span class="keyword">params</span>.length){
                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数个数不匹配"</span>);
                }
                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;paramCount;i++){
                    stmt.setObject(i+<span class="number">1</span>, param[i])
                }
                stmt.excuteUpdate();
            }
        }<span class="keyword">catch</span>(e){
        }<span class="keyword">finally</span>{
            release(rs,stmt,conn);
        }
    }
    <span class="comment">//使用前提 javabean中的字段名和数据库中的列名必须一致</span>
    <span class="keyword">public</span> Object <span class="title">query</span>(String sql, Object[] param, ResultSetHandler h){
        Conneciton conn = <span class="keyword">null</span>;
        PreparedStateMent stmt = <span class="keyword">null</span>;
        ResultSet rs = <span class="keyword">null</span>;
        <span class="keyword">try</span>{
            conn = dataSource.getConnection();
            stmt = conn.prepareStateMent(sql);
            ParameterMetaData pmd = stmt.getParameterMetaData();
            <span class="keyword">int</span> paramCount = pmd.getParameterCount();
            <span class="keyword">if</span>(paramCount&gt;<span class="number">0</span>){
                <span class="keyword">if</span>(<span class="keyword">params</span>==<span class="keyword">null</span> || <span class="keyword">params</span>.length==<span class="number">0</span>){
                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数有误"</span>);
                }
            }
            <span class="keyword">if</span>(paramCount!=<span class="keyword">params</span>.length){
                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数个数不匹配"</span>);
            }
            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;paramCount;i++){
                stmt.setObject(i+<span class="number">1</span>, param[i])
            }
            rs = stmt.excuteQuery();
            h.handler(rs);
        }<span class="keyword">catch</span>(e){
        }<span class="keyword">finally</span>{
            release(rs,stmt,conn);
        }
    }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[测试用数据库H2db]]></title>
    <link href="http://zhpooer.github.io/2014/04/24/%E6%B5%8B%E8%AF%95%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93h2db/"/>
    <id>http://zhpooer.github.io/2014/04/24/测试用数据库h2db/</id>
    <published>2014-04-24T12:59:45.000Z</published>
    <updated>2014-04-24T14:12:02.000Z</updated>
    <content type="html"><![CDATA[<p>在写上一个项目时, 在运行测试和真实运行项目时, 连接的是同一个Mysql数据库.
但是运行单元测试必须要有可重复性和隔离性, 测试时连接真实数据库,
造成了单元测试不能重复运行, 所以需要一个机制, 在运行测试时,
新建一个隔离的数据库, 等测试完, 把这个数据库清空或者废除. 详细需求如下:</p>
<ol>
<li>根据配置文件, 让系统选择加载数据库, 如在测试时连接一个数据库, 运行时连接另一个数据</li>
<li>如果是测试, 那么系统在加载数据库之后需要运行一些SQL脚本, 初始化数据库</li>
<li>运行完测试, 这个数据库要重置, 或者废除</li>
<li>数据库不能是Mysql的外部安装的数据库, 这样可以在没有Mysql的机子上重复测试</li>
</ol>
<p>so, 根据谷歌搜索, 找到了java内嵌数据库<code>Derby</code>, 它是用纯Java写的数据库,
只用加载一个Jar包, 就可以在Java程序中内嵌运行一个数据库. 运行代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Class<span class="preprocessor">.forName</span>(<span class="string">"org.apache.derby.jdbc.EmbeddedDriver"</span>)<span class="comment">;</span>
DriverManager<span class="preprocessor">.getConnection</span>(<span class="string">"jdbc:derby:sample;create=true"</span>)<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>这样就连接了一个Sample数据库, 且Derby会在工作目录下新建一个文件夹,
存储Sample数据库的数据. 所以可以通过指定新建数据库文件夹在一个临时文件夹下, 来满足条件三.
如Linux可以把新建文件建在 <code>/tmp</code> 目录下, 代码如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>DriverManager.getConnection("jdbc:derby:/tmp/sample;<span class="operator"><span class="keyword">create</span>=<span class="keyword">true</span><span class="string">");</span></span>
</pre></td></tr></table></figure>

<p>因为每次运行测试不能连同一个数据库文件, 所以要用Java生成一个临时文件夹</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>DriverManager.getConnection(makeDerbyTempURL(<span class="string">"sample"</span>));

<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">makeDerbyTempURL</span>(String db) {
    Path p = makeTmpDir();
	<span class="keyword">return</span> <span class="string">"jdbc:derby:"</span> + p.toUri().getPath() + <span class="string">"/"</span> + db + <span class="string">";create=true"</span>;
}
<span class="keyword">private</span> <span class="keyword">static</span> Path <span class="title">makeTmpDir</span>() {
    Path path = <span class="keyword">new</span> File(<span class="string">"/tmp"</span>).toPath();
	Path p = <span class="keyword">null</span>;
	<span class="keyword">try</span> {
	    p = Files.createTempDirectory(path, <span class="string">"derby"</span>);
	} <span class="keyword">catch</span> (IOException e) {
	    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
	}
	<span class="keyword">return</span> p;
}
</pre></td></tr></table></figure>

<p>但是如何满足条件二呢? 我猜想Derby提供了在内嵌数据库模式下直接导入SQL脚本的API,
就一直通过谷歌搜索, 找这个解决方案, 可惜做了很多无用功.
后来发现, 其实可以换个思路, 通过JDBC, 来直接执行SQL语句, 但是如何执行脚本呢?
要我重新写一个程序, 加载脚本, 分析出SQL语句, 然后通过JDBC一条一条执行? no!
有其他人已经解决过这个问题, 并且有Jar包可以直接使用, 通过这个思路,
两三下就直接找到了<a href="http://www.cnblogs.com/zencorn/archive/2011/01/27/1946348.html" target="_blank">解决方案</a>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>public static void execSQL(String scriptPath, String driveClass,
        String url, String user, String passwd) {
	SQLExec sqlExec = new SQLExec()<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setDriver</span>(driveClass)<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setUrl</span>(url)<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setUserid</span>(user)<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setPassword</span>(passwd)<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setSrc</span>(new File(scriptPath))<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setOnerror</span>((SQLExec<span class="preprocessor">.OnError</span>) (EnumeratedAttribute<span class="preprocessor">.getInstance</span>(
	        SQLExec<span class="preprocessor">.OnError</span><span class="preprocessor">.class</span>, <span class="string">"abort"</span>)))<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setPrint</span>(false)<span class="comment">;</span>
	sqlExec<span class="preprocessor">.setProject</span>(new Project())<span class="comment">;</span>
	sqlExec<span class="preprocessor">.execute</span>()<span class="comment">;</span>
}
</pre></td></tr></table></figure>

<p>所以说如何看待一个问题, 是解决一个问题的关键点.</p>
<p>至于需求一, 可以通过配置<code>properties</code>来解决, 感兴趣的童鞋可以
<a href="https://github.com/zhpooer/itcast-customer-demo/blob/master/src/java/io/zhpooer/util/ConnManager.java" target="_blank">猛击这里</a></p>
<p>到这里, 已经基本解决了问题, 不过又出现了一个问题, Derby 不支持语句 <code>create table if exists tablename()...</code>, 
而且每次运行测试时, 发现Derby创建数据库时, 总会造成硬盘忙的状态, 卡一小段时间.
那么是不是可以有一个数据库直接在内存里运行, 测试运行完之后, 数据库直接删除.</p>
<p>这个可以有, 那就是<code>H2db</code>, 它既支持内存数据库, 又支持内嵌数据.
不过经我测试, 在H2内存数据库模式下, 只要运行完 <code>connection.close()</code>, 数据库就会被重置(有谁指正一下如何可以避免这个问题).
这和我的项目需求不一致, 但是我发现他在内嵌模式下启动速度比Derby快. 所以直接换掉Derby.</p>
<p><a href="https://github.com/zhpooer/itcast-customer-demo/blob/master/src/java/io/zhpooer/util/ConnManager.java" target="_blank">具体代码猛击这里</a></p>
]]></content>
    
    
      <category term="java" scheme="http://zhpooer.github.io/tags/java/"/>
    
  </entry>
  
</feed>
