<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Poe's World]]></title>
  <subtitle><![CDATA[竹杖芒鞋轻胜马，一蓑烟雨任平生]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhpooer.github.io/"/>
  <updated>2014-08-07T08:51:11.525Z</updated>
  <id>http://zhpooer.github.io/</id>
  
  <author>
    <name><![CDATA[zhpooer]]></name>
    <email><![CDATA[zhpooer@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Play for Scala-Getting Start]]></title>
    <link href="http://zhpooer.github.io/2014/08/07/play-for-scala-getting-start/"/>
    <id>http://zhpooer.github.io/2014/08/07/play-for-scala-getting-start/</id>
    <published>2014-08-07T08:35:31.000Z</published>
    <updated>2014-08-07T08:46:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="what-play-is">What Play is</h1>
<p>Play makes you more productive. Play is also a web framework whose HTTP interface is
simple, convenient, flexible, and powerful. Most importantly, Play improves on the
most popular non-Java web development languages and frameworks—PHP and Ruby
on Rails—by introducing the advantages of the Java Virtual Machine (JVM).</p>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Integration]]></title>
    <link href="http://zhpooer.github.io/2014/08/06/akka-in-action-integration/"/>
    <id>http://zhpooer.github.io/2014/08/06/akka-in-action-integration/</id>
    <published>2014-08-06T06:45:54.000Z</published>
    <updated>2014-08-07T02:17:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="message-endpoints">Message endpoints</h1>
<p>The implementation of an interface between two systems isn&#39;t always
easy, because the interface contains two areas: the transport layer and the data
which is sent over this transport layer.</p>
<p>For example, we are creating an order system for use in a book
stockroom, that processes orders from all kinds of customers. These customers can
order the books by visiting the store. The bookstore already uses an application to
sell and order books.  So the new system needs to exchange data with this existing
application.</p>
<p>Because you probably can&#39;t change the external
application, you have to create a component that can send and/or receive messages
from the existing application. This component is called an endpoint. Endpoints are
part of your system and are the glue between the external system and the rest of
your system.</p>
<p>There are a lot of different transport protocols to potentially
support: REST/HTTP, TCP, MQueues, or simple files. </p>
<h2 id="normalizer">Normalizer</h2>
<p>We have seen that our order system receives the orders from the bookshop
application, but it is possible that our system also receives orders from a web shop,
or by customers sending email.</p>
<p>We can use the Normalizer pattern to make these
different sources all feed into a single interface on the application side. The pattern
translates the different external messages to a common, canonical message.</p>
<p>We create three different endpoints to consume the different messages, but
translate them into the same message, which is sent to the rest of the system.</p>
<p><img src="/img/akka_order_system.png" alt="akka order system"></p>
<p>Translating the different messages into a common message is called the
Normalizer pattern.</p>
<p> Let us assume that
there is another bookshop that is connecting to this system using the same
messages but using MQueue to send those message.</p>
<p><img src="/img/akka_normalizer.png" alt="akka normalizer partern"></p>
<h2 id="canonical-data-model">Canonical Data Model</h2>
<p> But when the connectivity requirements between the systems
increases we need more and more endpoints.</p>
<p>To solve this problem, we can use the Canonical Data Model. This pattern
connects multiple applications using interface(s) that are independent of any
specific system.</p>
<p>When the Bookshop application
wants to send a message to the order system, the message is first translated to the
canonical format and then it is sent using the common transport layer.</p>
<p>The Normalizer
pattern is used to connect several similar clients to another system. But when the
number of integrated systems increases, we need the Canonical Data Model, which
looks like the Normalizer Pattern, because it also uses normalized messages.</p>
<p>The difference is that the Canonical Data Model provides an additional level of
indirection between the application&#39;s individual data formats and those used by the
remote systems. While the Normalizer is only within one application.</p>
<h1 id="camel-framework">Camel Framework</h1>
<p>Camel is an apache framework whose goal is to make integration easier and more
accessible. It makes it possible to implement the standard enterprise integration
patterns in a few lines of code. This is achieved by addressing three areas:</p>
<ol>
<li>Concrete implementations of the widely used Enterprise Integration Patterns</li>
<li>Connectivity to a great variety of transports and APIs</li>
<li>Easy to use Domain Specific Languages (DSLs) to wire EIPs and transports together</li>
</ol>
<p>The Camel module works internally with Camel classes. Important Camel
classes are the camel context and the ProducerTemplate. The CamelContext
represents a single Camel routing rule base, and the ProducerTemplate is needed
when producing messages.</p>
<h2 id="implement-a-consumer-endpoint">Implement a consumer endpoint</h2>
<p>The example we are going to implement is an Order System receiving messages
from a bookshop. 
Let&#39;s say the received messages are XML files in a
directory. The transport layer is in this case the file system. The endpoint of the
order system needs to track new files and when there is a new file it has to parse
the XML content and create a message the system can process.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">// Consumer Endpoint</span>

<span class="keyword">import</span> akka.camel.{CamelMessage, Consumer}

<span class="class"><span class="keyword">class</span> <span class="title">OrderConsumerXml</span><span class="params">(uri:String, next:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Consumer</span>{</span>
  <span class="comment">// override the endpointUri</span>
  <span class="keyword">def</span> endpointUri = uri

  <span class="comment">// receive the Camel message</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg:CamelMessage =&gt; {
      <span class="keyword">val</span> content = msg.bodyAs[String]
      <span class="keyword">val</span> xml = XML.loadString(content)
      <span class="keyword">val</span> order = xml\\<span class="string">"order"</span>
      <span class="keyword">val</span> customer = (order \\ <span class="string">"customerId"</span>).text
      <span class="keyword">val</span> productId = (order \\ <span class="string">"productId"</span>).text
      <span class="keyword">val</span> number = (order \\ <span class="string">"number"</span>).text.toInt
      next ! <span class="keyword">new</span> Order(customer, productId, number)
    }
  }
}

<span class="comment">// This Uri starts with the Camel component.</span>
<span class="comment">// http://camel.apache.org/components.html</span>
<span class="keyword">val</span> camelUri = <span class="string">"file:messages"</span>
</pre></td></tr></table></figure>

<p>When a new message is received, it comes to the Actor through its usual
method, as a CamelMessage. A CamelMessage contains a body, which is the
actual message received, and a map of headers. The content of these headers
depends on the protocol used. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">val</span> probe = TestProbe()
<span class="keyword">val</span> camelUri = <span class="string">"file:messages"</span>
<span class="keyword">val</span> consumer = system.actorOf(Props(<span class="keyword">new</span> OrderConsumerXml(camelUri, probe.<span class="keyword">ref</span>)))
</pre></td></tr></table></figure>

<p>Because we use the Camel Consumer trait, a lot of components are started and
we have to wait for these components before we can proceed with our test. To be
able detect that Camel&#39;s startup has finished, we need to use the CamelExtension.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>val camelExtention = CamelExtension(<span class="keyword">system</span>)
val activated =
  camelExtention.activationFutureFor(consumer)(timeout = <span class="number">10</span> <span class="built_in">seconds</span>, executor = <span class="keyword">system</span>.dispatcher)
Await.<span class="built_in">result</span>(activated, <span class="number">5</span> <span class="built_in">seconds</span>)


val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml =
  &lt;order&gt;
    &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
    &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
    &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
  &lt;/order&gt;
val msgFile = <span class="built_in">new</span> File(dir, <span class="string">"msg1.xml"</span>)
FileUtils.<span class="built_in">write</span>(msgFile, xml.toString())
probe.expectMsg(msg)
<span class="keyword">system</span>.stop(consumer)
</pre></td></tr></table></figure>

<h2 id="changing-the-transport-layer-of-our-consumer">CHANGING THE TRANSPORT LAYER OF OUR CONSUMER</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>val probe = TestProbe()
val camelUri = <span class="string">"mina:tcp://localhost:8888?textline=true&sync=false"</span>
val consumer = <span class="keyword">system</span>.actorOf(Props(<span class="built_in">new</span> OrderConsumerXml(camelUri, probe.ref)))

val activated =
  CamelExtension(<span class="keyword">system</span>).activationFutureFor(consumer)(timeout = <span class="number">10</span> <span class="built_in">seconds</span>, executor = <span class="keyword">system</span>.dispatcher)
  
Await.<span class="built_in">result</span>(activated, <span class="number">5</span> <span class="built_in">seconds</span>)
val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml = &lt;order&gt;
            &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
            &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
            &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
          &lt;/order&gt;
val xmlStr = xml.toString().<span class="built_in">replace</span>(<span class="string">"n"</span>, <span class="string">""</span>)

val sock = <span class="built_in">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8888</span>)
val ouputWriter = <span class="built_in">new</span> PrintWriter(sock.getOutputStream, <span class="constant">true</span>)
ouputWriter.println(xmlStr)
ouputWriter.flush()
probe.expectMsg(msg)
ouputWriter.<span class="built_in">close</span>()
<span class="keyword">system</span>.stop(consumer)
</pre></td></tr></table></figure>

<ul>
<li><code>textline=true</code>, This indicates that we are expecting plain text over this connection and that each message
is ended with a newline</li>
<li><code>sync=false</code>, This indicates that we don&#39;t create a response</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">def</span> receive = {
  <span class="keyword">case</span> msg: CamelMessage =&gt; {
    <span class="keyword">try</span> {
      <span class="keyword">val</span> content = msg.bodyAs[String]
      <span class="keyword">val</span> xml = XML.loadString(content)
      <span class="keyword">val</span> order = xml \ <span class="string">"order"</span>
      <span class="keyword">val</span> customer = (order \ <span class="string">"customerId"</span>).text
      <span class="keyword">val</span> productId = (order \ <span class="string">"productId"</span>).text
      <span class="keyword">val</span> number = (order \ <span class="string">"number"</span>).text.toInt
      next ! <span class="keyword">new</span> Order(customer, productId, number)
      sender ! <span class="string">"&lt;confirm&gt;OK&lt;/confirm&gt;"</span>
    } <span class="keyword">catch</span> {
      <span class="comment">// 如果是同步的通信, 发生错误, actor重启, 会失去发送者的信息</span>
      <span class="keyword">case</span> ex: Exception =&gt;
        sender ! <span class="string">"&lt;confirm&gt;%s&lt;/confirm&gt;"</span>.format(ex.getMessage)
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="using-the-camel-context">USING THE CAMEL CONTEXT</h2>
<p>For example when we want to use the ActiveMQ component. To be able to use
this we need to add the component to the Camel context and define the MQ broker.
This requires the camel context.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>// Component name should be used <span class="keyword">in</span> the Uri
val camelContext = CamelExtension(system)<span class="preprocessor">.context</span>
camelContext<span class="preprocessor">.addComponent</span>(<span class="string">"activemq"</span>,
  ActiveMQComponent<span class="preprocessor">.activeMQComponent</span>(
    <span class="string">"vm:(broker:(tcp://localhost:8899)?persistent=false)"</span>))

val camelUri = <span class="string">"activemq:queue:xmlTest"</span>
val consumer = system<span class="preprocessor">.actorOf</span>(
    Props(new OrderConsumerXml(camelUri, probe<span class="preprocessor">.ref</span>)))
val activated = CamelExtension(system)<span class="preprocessor">.activationFutureFor</span>(
    consumer)(timeout = <span class="number">10</span> seconds, executor = system<span class="preprocessor">.dispatcher</span>)
...
sendMQMessage(xml<span class="preprocessor">.toString</span>())
probe<span class="preprocessor">.expectMsg</span>(msg)
system<span class="preprocessor">.stop</span>(consumer)

// Because a broker is started, we also need to stop them when we are ready. 
// This can be done using the BrokerRegistry of ActiveMQ
val brokers = BrokerRegistry<span class="preprocessor">.getInstance</span>()<span class="preprocessor">.getBrokers</span>
brokers<span class="preprocessor">.foreach</span> { case (name, broker) =&gt; broker<span class="preprocessor">.stop</span>() }
</pre></td></tr></table></figure>

<h2 id="implement-a-producer-endpoint">Implement a producer endpoint</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.camel.Producer

<span class="class"><span class="keyword">class</span> <span class="title">SimpleProducer</span><span class="params">(uri: Strint)</span> <span class="keyword">extends</span> <span class="title">Producer</span> {</span>
  <span class="keyword">def</span> endpointUri = uri
}

implicit <span class="keyword">val</span> ExecutionContext = system.dispatcher
<span class="keyword">val</span> probe = TestProbe()
<span class="keyword">val</span> camelUri =
  <span class="string">"mina:tcp://localhost:8888?textline=true&sync=false"</span>
<span class="keyword">val</span> consumer = system.actorOf(
  Props(<span class="keyword">new</span> OrderConsumerXml(camelUri, probe.ref)))
  
<span class="keyword">val</span> producer = system.actorOf(
  Props(<span class="keyword">new</span> SimpleProducer(camelUri)))
<span class="keyword">val</span> activatedCons = CamelExtension(system).activationFutureFor(
  consumer)(timeout = <span class="number">10</span> seconds, executor = system.dispatcher)
<span class="keyword">val</span> activatedProd = CamelExtension(system).activationFutureFor(
  producer)(timeout = <span class="number">10</span> seconds, executor = system.dispatcher)
  
<span class="keyword">val</span> camel = Future.sequence(List(activatedCons, activatedProd))
Await.result(camel, <span class="number">5</span> seconds)
</pre></td></tr></table></figure>

<p>Here we can do the translation of our message to the expected XML</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderProducerXml</span><span class="params">(uri: String)</span> <span class="keyword">extends</span> <span class="title">Producer</span> {</span>
  <span class="keyword">def</span> endpointUri = uri
  <span class="keyword">override</span> <span class="keyword">def</span> oneway: Boolean = <span class="keyword">false</span>
  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> transformOutgoingMessage(message: Any): Any = {
    message <span class="keyword">match</span> {
      <span class="keyword">case</span> msg: Order =&gt; {
        <span class="keyword">val</span> xml = &lt;order&gt;
          &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
          &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
          &lt;number&gt;{ msg.number }&lt;/number&gt;
        &lt;/order&gt;
        
        xml.toString().replace(<span class="string">"n"</span>, <span class="string">""</span>)
      }
      <span class="keyword">case</span> other =&gt; message
    }
  }
  
  <span class="comment">// 反向序列化</span>
  <span class="keyword">override</span> <span class="keyword">def</span> transformResponse(message: Any): Any = {
    message <span class="keyword">match</span> {
      <span class="keyword">case</span> msg: CamelMessage =&gt; {
        <span class="keyword">try</span> {
          <span class="keyword">val</span> content = msg.bodyAs[String]
          <span class="keyword">val</span> xml = XML.loadString(content)
          (xml \ <span class="string">"confirm"</span>).text
        } <span class="keyword">catch</span> {
          <span class="keyword">case</span> ex: Exception =&gt;
            <span class="string">"TransformException: %s"</span>.format(ex.getMessage)
        }
      }
      <span class="keyword">case</span> other =&gt; message
    }
  }
}
</pre></td></tr></table></figure>

<p>There is a method called routeResponse.
This method is responsible for sending the received
response to the original sender. </p>
<h1 id="example-of-implementing-a-rest-interface">Example of implementing a REST interface</h1>
<p>REST is a standard protocol to expose intuitive interfaces
to systems. We are still creating an endpoint for our system.</p>
<p>Spray is an open-source toolkit for REST/HTTP and low-level network IO on
top of Scala and Akka.</p>
<p>We start by defining the
messages for both interfaces. The Order system will support two functions. The
first function is to add a new order and the second function is to get the status of an
order. The REST interface we are going to implement supports a POST and a GET.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">ProcssOrders</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  val orderList = <span class="keyword">new</span> mutable.HashMap[Long, TrackingOrder]
  val lastOrderId = <span class="number">0</span>L

  def receive = {
    <span class="keyword">case</span> order:Order =&gt; {
      lastOrderId += <span class="number">1</span>
      val newOrder = <span class="keyword">new</span> TrackingOrder(lastOrderId, <span class="string">"received"</span>, order)
      orderList += lastOrdered -&gt; newOrder
      sender ! newOrder
    }
    <span class="keyword">case</span> order:OrderId =&gt; {
      orderList.get(order.id) match {
        <span class="keyword">case</span> Some(intOrder) =&gt;
          sender ! intOrder.copy(status=<span class="string">"process"</span>)
        <span class="keyword">case</span> None =&gt; sender ! NoSuchOrder(order.id)
      }
    }
    <span class="keyword">case</span> <span class="string">"reset"</span> =&gt; {
      lastOrderId = <span class="number">0</span>
      orderList.clear()
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="implementing-a-rest-endpoint-with-spray">Implementing a Rest endpoint with Spray</h2>
<p>Spray also has it own test kit and is able to test your code without
building a complete application.</p>
<p>When you need REST/HTTP support, Spray is a great way to connect your Akka
applications to other Systems.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre>import spray.routing.HttpService

trait OrderService extends HttpService {
  val myRoute = path("orderTest") {
    get {
      parameters('id.as[Long]).as(OrderId) { orderId =&gt;
        complete {
          val askFuture = orderSystem ? orderId
          askFuture.map {
            case result:TrackingOrder =&gt; {
              <span class="tag">&lt;<span class="title">statusResponse</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{result.id}<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>{result.status}<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">statusResponse</span>&gt;</span>
            }
            case result:NoSuchOrder =&gt; {
              <span class="tag">&lt;<span class="title">statusResponse</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{result.id}<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>ID is unknown<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">statusResponse</span>&gt;</span>
            }
          }
        }
      }
    } ~
    post {
      //add order
      entity(as[String]) { body =&gt;
        val order = XMLConverter.createOrder(body.toString)
        complete {
          val askFuture = orderSystem ? order
          askFuture.map {
            case result: TrackingOrder =&gt; {
              <span class="tag">&lt;<span class="title">confirm</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{ result.id }<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>{ result.status }<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">confirm</span>&gt;</span>.toString()
            }
            case result: Any =&gt; {
              <span class="tag">&lt;<span class="title">confirm</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>
                  Response is unknown{ result.toString() }
                <span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">confirm</span>&gt;</span>.toString()
            }
          }
        }
      }
    }
  }
}
class OrderServiceActor (val orderSystem:ActorRef) extends Actor with OrderService {
  // actorRefFactory used by Spray framework
  def actorRefFactory = context
  
  // use Spray Route
  def receive = runRoute(myRoute)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderHttpServer</span><span class="params">(host: String, portNr: Int, orderSystem: ActorRef)</span></span>
    <span class="keyword">extends</span> SprayCanHttpServerApp {
  <span class="comment">//create and start our service actor</span>
  <span class="keyword">val</span> service = system.actorOf(Props(
    <span class="keyword">new</span> OrderServiceActor(orderSystem)), <span class="string">"my-service"</span>)
  <span class="comment">//create a new HttpServer using our handler tell it where to bind to</span>
  <span class="keyword">val</span> httpServer = newHttpServer(service)
  httpServer ! Bind(interface = host, port = portNr)
  
  <span class="keyword">def</span> stop() {
    system.stop(httpServer)
    system.shutdown()
  }
}
</pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre>val orderSystem = <span class="keyword">system</span>.actorOf(Props[OrderSystem])
val orderHttp = <span class="built_in">new</span> OrderHttpServer(<span class="string">"localhost"</span>, <span class="number">8181</span>, orderSystem)

orderSystem ! <span class="string">"reset"</span>
val url = <span class="string">"http://localhost:8181/orderTest"</span>
val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml =
  &lt;order&gt;
    &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
    &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
    &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
  &lt;/order&gt;

val urlConnection = <span class="built_in">new</span> <span class="built_in">URL</span>(url)
val conn = urlConnection.openConnection()
conn.setDoOutput(<span class="constant">true</span>)
conn.setRequestProperty(<span class="string">"Content-type"</span>, <span class="string">"text/xml; charset=UTF-8"</span>)
val writer = <span class="built_in">new</span> OutputStreamWriter(conn.getOutputStream)
writer.<span class="built_in">write</span>(xml.toString())
writer.flush()
<span class="comment">
//check result</span>
val reader = <span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader((conn.getInputStream)))
val response = <span class="built_in">new</span> StringBuffer()
var <span class="built_in">line</span> = reader.readLine()
<span class="keyword">while</span> (<span class="built_in">line</span> != <span class="constant">null</span>) {
  response.append(<span class="built_in">line</span>)
  <span class="built_in">line</span> = reader.readLine()
}
writer.<span class="built_in">close</span>()
reader.<span class="built_in">close</span>()

conn.getHeaderField(<span class="constant">null</span>) must be(<span class="string">"HTTP/1.1 200 OK"</span>)
val responseXml = XML.loadString(response.toString)
val confirm = responseXml \ <span class="string">"confirm"</span>

(confirm \ <span class="string">"id"</span>).<span class="keyword">text</span> must be(<span class="string">"1"</span>)
(confirm \ <span class="string">"status"</span>).<span class="keyword">text</span> must be(<span class="string">"received"</span>)

val url2 = <span class="string">"http://localhost:8181/orderTest?id=1"</span>


val urlConnection2 = <span class="built_in">new</span> <span class="built_in">URL</span>(url2)
val conn2 = urlConnection2.openConnection()<span class="comment">
//Get response</span>
val reader2 = <span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader((conn2.getInputStream)))
val response2 = <span class="built_in">new</span> StringBuffer()
<span class="built_in">line</span> = reader2.readLine()
<span class="keyword">while</span> (<span class="built_in">line</span> != <span class="constant">null</span>) {
  response2.append(<span class="built_in">line</span>)
  <span class="built_in">line</span> = reader2.readLine()
}
reader2.<span class="built_in">close</span>()
<span class="comment">
// check response</span>
conn2.getHeaderField(<span class="constant">null</span>) must be(<span class="string">"HTTP/1.1 200 OK"</span>)
val responseXml2 = XML.loadString(response2.toString)
val status = responseXml2 \ <span class="string">"statusResponse"</span>

(status \ <span class="string">"id"</span>).<span class="keyword">text</span> must be(<span class="string">"1"</span>)
(status \ <span class="string">"status"</span>).<span class="keyword">text</span> must be(<span class="string">"processing"</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Working with Transactions]]></title>
    <link href="http://zhpooer.github.io/2014/08/06/akka-in-action-working-with-transactions/"/>
    <id>http://zhpooer.github.io/2014/08/06/akka-in-action-working-with-transactions/</id>
    <published>2014-08-06T01:47:35.000Z</published>
    <updated>2014-08-06T03:49:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="software-transactional-memory">Software Transactional Memory</h1>
<p>We have an event and we have a number of seats that multiple
threads want to lay claim to. Our shared data is a list of seats</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Seat</span><span class="params">(seatNumber:Int)</span></span>
<span class="keyword">val</span> availableSeats: Seq[Seat])

<span class="comment">// When we want to get a seat from the list we need to</span>
<span class="comment">// get the first available seat and update the list.</span>
<span class="keyword">val</span> head = availableSeats.head
availableSeats = availableSeats.tail
</pre></td></tr></table></figure>

<p>When we can&#39;t or want to use immutable messages
and just want to protect the shared data from becoming inconsistent.</p>
<h2 id="protecting-shared-data">Protecting Shared data</h2>
<p>The most common solution to protecting shared data is that when a thread wants to
access the shared data, we block all other threads from accessing the shared
structure.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val reservedSeat = availableSeats<span class="preprocessor">.synchronized</span> {
  head = availableSeats<span class="preprocessor">.head</span>
  availableSeats = availableSeats<span class="preprocessor">.tail</span>
  head
}
</pre></td></tr></table></figure>

<p>A problem with this is that when a thread only wants to read all available seats
it still has to lock the list too.</p>
<p>All this locking decreases the performance of the system.</p>
<p>This is called &quot;pessimistic locking”.</p>
<p>Clearly, since there is &#39;pessimistic locking,&#39; there must also be &#39;optimistic
locking.&#39;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>import concurrent.stm.Ref
val availableSeats = Ref(Seq[<span class="link_label">Seat</span>](<span class="link_url"></span>))

//  update our availableSeats we can write
availableSeats() = availableSeats().tail

// When we want to protect the seat list, we get the following 
import concurrent.stm._
val availableSeats = Ref(seats)
val reservedSeat = atomic {implicit txn =&gt; {
  val head = availableSeats().head
  availableSeats() = availableSeats().tail
  head
}}
</pre></td></tr></table></figure>

<p>The critical section
will be executed only once when using synchronized, but using the STM atomic,
the critical section can be executed more than once. This is because at the end of
the block&#39;s execution, a check is done to see if there was a collision. </p>
<h2 id="using-the-stm-transactions">Using the STM transactions</h2>
<p>But when we
want to do a simple read of shared data we need to create an atomic block and this
means writing a lot of code just for a single, simple read. When using only one
reference, you could also use the View of a reference. The Ref.View enables you
to execute one action on one Reference.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>availableSeats<span class="preprocessor">.single</span><span class="preprocessor">.get</span>

val mySeat = atomic {implicit txn =&gt; {
    val head = availableSeats()<span class="preprocessor">.head</span>
    availableSeats() = availableSeats()<span class="preprocessor">.tail</span>
    head
  }}
}

val myseat = availableSeats<span class="preprocessor">.single</span><span class="preprocessor">.getAndTransform</span>(_<span class="preprocessor">.tail</span>)<span class="preprocessor">.head</span>
</pre></td></tr></table></figure>

<p>Using the Ref.View method makes the code a little bit more compact and also
makes the critical section smaller, which decreases the chance of a collision,
improving the total performance of the system.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>// 硬重试
// When the availableSeat list is empty, we call the retry,
// which triggers to execute the alternative atomic block.
val availableSeats = Ref(Seq[<span class="link_label">Seat</span>](<span class="link_url"></span>))
val mySeat = atomic { implicit txn =&gt; {
  val allSeats = availableSeats()
  if (allSeats.isEmpty)
<span class="code">    retry</span>
  val reservedSeat = allSeats.head
  availableSeats() = allSeats.tail
  Some(reservedSeat)
}}.orAtomic {implicit txn =&gt; {
  //else give up and do nothing
  // return a None to indicate we were unable to get a seat.
  None
}}
mySeat must be (None)
</pre></td></tr></table></figure>

<h1 id="agents-within-transactions">Agents within transactions</h1>
<p>When an Agent is used within a transaction, it isn&#39;t necessary to wrap it with an
STM reference to be able to use its data.</p>
<p>Our competing thread will update the agent every 50 ms and our test thread
tries to read the Agent&#39;s state twice within a transaction. When the Agent&#39;s state has
changed in the meantime, the transaction has to be retried.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">// Competing thread updating the agent</span>
<span class="keyword">val</span> seats = (<span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">15</span>) <span class="keyword">yield</span> Seat(i))
<span class="keyword">val</span> availableSeats = Agent(seats)
<span class="keyword">val</span> future = Future {
  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">10</span>) {
    availableSeats send (_.tail)
  }
  Thread.sleep(<span class="number">50</span>)
}

<span class="comment">// 获取线程</span>
<span class="keyword">var</span> nrRuns = <span class="number">0</span>
<span class="keyword">val</span> firstSeat = atomic { implicit txn =&gt; {
  nrRuns += <span class="number">1</span>
  <span class="keyword">val</span> currentList = availableSeats.get
  Thread.sleep(<span class="number">100</span>)
  availableSeats.get.head
}}
Await.ready(future, <span class="number">1</span> second)
nrRuns must be &gt; (<span class="number">1</span>)
firstSeat.seatNumber must be (<span class="number">10</span>)
</pre></td></tr></table></figure>

<p>In this example we see that the critical section is executed more than once,
because the value of the agent has changed during the transaction. </p>
<h2 id="updating-agents-within-a-transaction">Updating Agents within a transaction</h2>
<p>This means that
when we send an action, the action is held until the transaction is committed and
when if the transaction is rolled back, the action sent to the Agent is also rolled
back.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>val numberUpdates = Agent(<span class="number">0</span>)
val count = Ref(<span class="number">5</span>)
Future {
  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">10</span>) {
    atomic { <span class="keyword">implicit</span> txn =&gt; {
      count() = count() +<span class="number">1</span>
    }}
    Thread.sleep(<span class="number">50</span>)
  }
}
<span class="keyword">var</span> nrRuns = <span class="number">0</span>
val myNumber = atomic { <span class="keyword">implicit</span> txn =&gt; {
  nrRuns += <span class="number">1</span>
  numberUpdates send (_ + <span class="number">1</span>)
  val <span class="keyword">value</span> = count()
  Thread.sleep(<span class="number">100</span>)
  count()
}}

nrRuns must be &gt; (<span class="number">1</span>)
myNumber must be (<span class="number">15</span>)
Await.ready(numberUpdates.future(), <span class="number">1</span> second)
<span class="comment">// The agent is only one time updated</span>
numberUpdates.<span class="keyword">get</span>() must be (<span class="number">1</span>)
</pre></td></tr></table></figure>

<p> We can&#39;t use Agents and transactions to
solve the problem of transferring money. The problem is that the two actors are
completely unrelated.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(from: Agent[Int], to: Agent[Int], amount: Int)</span>:</span> Boolean = {
  atomic { txn =&gt; 
    <span class="keyword">if</span> (<span class="keyword">from</span>.get &lt; amount) false
    <span class="keyword">else</span> {
      <span class="keyword">from</span> send (_ - amount)
      to send (_ + amount)
      true
    }
  }
}
</pre></td></tr></table></figure>

<h1 id="actors-within-transactions">Actors within transactions</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.transactor.Coordinated
<span class="keyword">import</span> scala.concurrent.duration._
<span class="keyword">import</span> akka.util.Timeout


<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Withdraw</span><span class="params">(amount:Int)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Deposit</span><span class="params">(amount:Int)</span></span>
<span class="class"><span class="keyword">object</span> <span class="title">GetBalance</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">InsufficientFunds</span><span class="params">(msg:String)</span> <span class="keyword">extends</span> <span class="title">Exception</span><span class="params">(msg)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> balance = Ref(<span class="number">0</span>)
  
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> coordinated @ Coordinated(Withdraw(amount)) {
      coordinated atomic { implicit t
        <span class="keyword">val</span> currentBalance = balance()
        <span class="keyword">if</span> ( currentBalance &lt; amount) {
          <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFunds( <span class="string">"Balance is too low: "</span>+ currentBalance)
        }
        balance() = currentBalance - amount
      }
    }
    <span class="keyword">case</span> coordinated @ Coordinated(Deposit(amount)) {
      coordinated atomic { implicit t
        balance() = balance() + amount
      }
    }
    <span class="keyword">case</span> GetBalance =&gt; sender ! balance.single.get
  }
  
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
    self ! Coordinated(Deposit(balance.single.get))(Timeout(<span class="number">5</span> seconds))
    <span class="keyword">super</span>.preRestart(reason, message)
  }
}

<span class="comment">// 测试代码</span>
implicit <span class="keyword">val</span> timeout = Timeout(<span class="number">5</span> seconds)
<span class="keyword">val</span> transaction = Coordinated()
transaction atomic { implicit t =&gt;
  account1 ! transaction(Deposit(amount = <span class="number">100</span>))
}

<span class="keyword">val</span> probe = TestProbe()
probe.send(account1, GetBalance)
probe.expectMsg(<span class="number">100</span>)

<span class="comment">// 更简洁的代码</span>
<span class="keyword">val</span> account1 = system.actorOf(Props[Account])
implicit <span class="keyword">val</span> timeout = <span class="keyword">new</span> Timeout(<span class="number">1</span> second)

account1 ! Coordinated(Deposit(amount = <span class="number">100</span>))

<span class="keyword">val</span> probe = TestProbe()
probe.send(account1, GetBalance)
probe.expectMsg(<span class="number">100</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 转账的代码</span>
def receive = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="keyword">from</span>, to) =&gt; {
    val transaction = Coordinated()
    transaction atomic { <span class="keyword">implicit</span> t
      <span class="keyword">from</span> ! transaction(Withdraw(amount))
      to ! transaction(Deposit(amount))
    }
    sender ! <span class="string">"done"</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="creating-transactors">Creating transactors</h2>
<p>Transactors are actors that are capable of dealing with messages that comprise
Coordinated transactions.</p>
<p>All the functional code will been seen again in the example, only the
Coordinated part is removed, because the transactor will hide it from our code.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.transactor.Transactor
<span class="class"><span class="keyword">class</span> <span class="title">AccountTransactor</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Transactor</span> {</span>
  <span class="keyword">val</span> balance = Ref(<span class="number">0</span>)
  <span class="keyword">def</span> atomically = implicit txn =&gt; {
    <span class="keyword">case</span> Withdraw(amount) =&gt; {
      <span class="keyword">val</span> currentBalance = balance()
      <span class="keyword">if</span> ( currentBalance &lt; amount) {
        <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFunds(<span class="string">"Balance is too low: "</span>+ currentBalance)
      }
      balance() = currentBalance - amount
      
    <span class="keyword">case</span> Deposit(amount) =&gt; {
      balance() = balance() + amount
    }
  }
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message:Option[Any]) {
    <span class="comment">// 为了保存数据</span>
    self ! Deposit(balance.single.get)
    <span class="keyword">super</span>.preRestart(reason, message)
  }
  <span class="comment">// All messages which are implemented in the normally function,</span>
  <span class="comment">// will not be passed to the atomically function. </span>
  <span class="keyword">override</span> <span class="keyword">def</span> normally = {
    <span class="keyword">case</span> GetBalance =&gt; sender ! balance.single.get
  }
}

<span class="comment">// 测试代码</span>
<span class="keyword">val</span> account1 = system.actorOf(Props[AccountTransactor])
<span class="keyword">val</span> account2 = system.actorOf(Props[AccountTransactor])
<span class="keyword">val</span> transaction = Coordinated()
transaction atomic { implicit t
  account1 ! transaction(Withdraw(amount = <span class="number">50</span>))
  account2 ! transaction(Deposit(amount = <span class="number">50</span>))
}
</pre></td></tr></table></figure>

<p>When we deposit some
money in an account it doesn&#39;t need to be done in a Coordinated transaction. We
already saw that we can send a coordinated message without joining the
transaction, but when using a transactor, we can also send just the message.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>// These <span class="constant">two</span> <span class="keyword">lines</span> <span class="operator">of</span> code are equivalent when <span class="keyword">using</span> <span class="operator">a</span> transactor. 
account1 ! Coordinated(Deposit(amount = <span class="number">100</span>))
account1 ! Deposit(amount = <span class="number">100</span>)
</pre></td></tr></table></figure>

<p>The AccountTransactor only
acts within a transaction, but it doesn&#39;t include other actors within its transaction.
When the transfer Actor starts a coordinated transaction we need to include both
accounts in the transaction.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>override def coordinate = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="built_in">from</span>, <span class="built_in">to</span>) =&gt;
    sendTo(<span class="built_in">from</span> -&gt; Withdraw(amount),
    <span class="built_in">to</span> -&gt; Deposit(amount))
}<span class="comment">
// When you want to send the received message to the other actors, you can also use the include method:</span><span class="comment">
// sends the received Message to the three actors. </span>
override def coordinate = {
  <span class="keyword">case</span> msg:Message =&gt; <span class="built_in">include</span>(actor1, actor2, actor3)
}
</pre></td></tr></table></figure>

<p>For these kind of actions, a
transactor has two methods which can be overridden, the before and after method.
These methods are called just before and after the atomically method and are also
partial functions. For our example, we don&#39;t need the before method, but using the
after to be able to send the &quot;done&quot; message when the transaction has successfully
ended.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>override def <span class="keyword">after</span> = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="built_in">from</span>, <span class="built_in">to</span>) =&gt; sender ! <span class="string">"done"</span>
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Message Channels & Finite State Machines]]></title>
    <link href="http://zhpooer.github.io/2014/08/05/akka-in-action-message-channels/"/>
    <id>http://zhpooer.github.io/2014/08/05/akka-in-action-message-channels/</id>
    <published>2014-08-05T03:11:47.000Z</published>
    <updated>2014-08-05T14:26:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="chinnel-types">Chinnel types</h1>
<p>Other names which are often used for these kind of channels are EventQueue or
EventBus. Akka has an EventStream which implements a publish-subscribe
channel. But when this implementation isn&#39;t sufficient, then Akka has a collection
of traits which helps to implement an custom publish subscribe channel.</p>
<p>Next we describe two special channels. The first is the Dead Letter channel,
which contain message that couldn&#39;t be delivered.
This channel can help when debugging, why some messages
aren&#39;t processed or to monitor where there are problems.</p>
<h2 id="point-to-point">Point to Point</h2>
<p>The point-to-point channel sends the message to one receiver.</p>
<p><img src="/img/akka_point2point.png" alt="point 2 point img"></p>
<p>The round-robin
Router in section 7.3.1 is an example of the channel having multiple receivers. The
processing of the messages can be done concurrently by different Receivers, but
only one Receiver consumes any one message.</p>
<p>Because in Akka the ActorRef is the implementation of a point-to-point channel.
Because all the messages send will be delivered to one Actor.</p>
<h2 id="publish-subscribe">Publish subscribe</h2>
<p>The channel can also deliver the same message to multiple receivers.</p>
<p>To solve this problem we can use
the Publish-subscribe channel. The channel is able to send the same message to
multiple receivers, without the sender knows which receiver.</p>
<p>When a receiver is interested in a message of the publisher, it subscribes itself
to the channel.</p>
<p>The most easiest when needed a publish-subscribe channel,
is to use the EventStream.The EventStream can be seen as a
manager of multiple Publish-Subscribe channels.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// subscirbe <span class="built_in">to</span> <span class="operator">the</span> EventStream <span class="built_in">to</span> receive Order messages
<span class="keyword">system</span>.eventStream.subscribe(giftModule, classOf[Order])<span class="comment">
// unsubscribe</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule, classOf[Order])
<span class="comment">
// 取消订阅所有消息</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule.ref)<span class="comment">
// 发布消息</span>
<span class="keyword">system</span>.eventStream.publish(msg)
</pre></td></tr></table></figure>

<h2 id="custom-eventbus">CUSTOM EVENTBUS</h2>
<p>Let assume that we only want to send a gift when someone ordered more than one
book.</p>
<p> An EventBus is generalized so
that it can be used for all implementations of a publish-subscribe channel. In the
generalized form there are three entities.</p>
<ul>
<li>Event, This is the type of all events published on that bus. In the Akka EventStream all uses
AnyRef as event and therefor supports all type of messages</li>
<li>Subscriber, This is the type of subscribers allowed to register on that event bus. In the Akka
EventStream the subscribers are ActorRef&#39;s</li>
<li>Classifier, This defines the classifier to be used in selecting subscribers
for dispatching events. </li>
</ul>
<p>EventBus Interface</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>package akka.event
trait EventBus {
  type Event
  type Classifier
  type Subscriber
  /**
  * Attempts to register the subscriber to the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it was</span>
  * already subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(subscriber: Subscriber, to: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it wasn't</span>
  * subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber, from: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> all Classifiers it may
  * be subscribed to
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber)</span>:</span> Unit
  /**
  * Publishes the specified Event to this bus
  */
  <span class="function"><span class="keyword">def</span> <span class="title">publish</span><span class="params">(event: Event)</span>:</span> Unit
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> {</span>
  <span class="keyword">type</span> Event = Order
  <span class="comment">// chosen to classify the Order messages on the criteria "is Multiple</span>
  <span class="comment">// Book Order" and use a Boolean as classifier </span>
  <span class="keyword">type</span> Classifier = Boolean

}
</pre></td></tr></table></figure>

<p>Akka has three composable traits which can help in keeping
track of the subscribers.</p>
<ul>
<li>LookupClassification,  It maintain a set of subscribers for each
possible classifier and extract a classifier from each event.</li>
<li>SubchannelClassification, This trait is used when classifiers form a hierarchy
and it is desired that subscription can be possible not only at the leaf nodes,
but also to the higher nodes.</li>
<li>ScanningClassification,  it can be used when classifiers have an overlap. This
means that one Event can be part of more classifiers, for example if we give more gifts
when ordering more books.</li>
</ul>
<p>API of LookupClassification</p>
<ul>
<li>classify(event: Event): Classifier
This is used for extracting the classifier from the incoming events.</li>
<li>compareSubscribers(a: Subscriber, b: Subscriber): Int
This method must define a order over the subscribers, to be able to compare them just as
the java.lang.Comparable.compare method.</li>
<li>publish(event: Event, subscriber: Subscriber),
This method will be invoked for each event for all subscribers which registered
themselves for the events classifier.</li>
<li>mapSize: Int, This returns the expected number of the different classifiers.
This is used for the initial size of an internal data structure.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.event.ActorEventBus
<span class="keyword">import</span> akka.event.{ LookupClassification, EventBus }

<span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> <span class="keyword">with</span> <span class="title">LookupClassification</span></span>
    <span class="keyword">with</span> ActorEventBus {  <span class="comment">//  defines that the subscriber is an ActorRef.</span>
  <span class="keyword">type</span> Event = Order
  <span class="keyword">type</span> Classifier = Boolean
  <span class="keyword">def</span> mapSize = <span class="number">2</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> classify(event: StateEventBus#Event) = {
    event.number &gt; <span class="number">1</span>
  }
  
  <span class="comment">// publish method by sending the event to the subscriber</span>
  <span class="keyword">protected</span> <span class="keyword">def</span> publish(event: OrderMessageBus#Event,
      subscriber: OrderMessageBus#Subscriber) {
    subscriber ! event
  }

}


<span class="comment">// Test for event bus</span>
<span class="keyword">val</span> bus = <span class="keyword">new</span> OrderMessageBus
<span class="keyword">val</span> singleBooks = TestProbe()
bus.subscribe(singleBooks.ref, <span class="keyword">false</span>)

<span class="keyword">val</span> multiBooks = TestProbe()
bus.subscribe(multiBooks.ref, <span class="keyword">true</span>)

<span class="keyword">val</span> msg = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)
bus.publish(msg)

singleBooks.expectMsg(msg)
multiBooks.expectNoMsg(<span class="number">3</span> seconds)

<span class="keyword">val</span> msg2 = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">3</span>)
bus.publish(msg2)
singleBooks.expectNoMsg(<span class="number">3</span> seconds)
multiBooks.expectMsg(msg2)
</pre></td></tr></table></figure>

<h1 id="specialize-channel">Specialize Channel</h1>
<p>DeadLetter channel,  Only failed message are put on this channel. Listening on this
channel can help to find problems in your system.</p>
<p>Guaranteed deliver channel, his channel guaranties
all messages which are send are also delivered</p>
<h2 id="dead-letter">Dead letter</h2>
<p>By monitoring this channel you know which messages aren&#39;t processed and can
take corrective actions.</p>
<p> To get these dead letter messages you
only need to subscribe your actor to the EventStream with the DeadLetter class as
the Classifier.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>val deadLetterMonitor: ActorRef

system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
  deadLetterMonitor,
  classOf[DeadLetter])

// 测试代码
val deadLetterMonitor = TestProbe()
system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
    deadLetterMonitor<span class="preprocessor">.ref</span>,
    classOf[DeadLetter])
    
val actor = system<span class="preprocessor">.actorOf</span>(Props[EchoActor], <span class="string">"echo"</span>)
actor ! PoisonPill
val msg = new Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)

actor ! msg

//  wrapped also into a DeadLetter object
val dead = deadLetterMonitor<span class="preprocessor">.expectMsgType</span>[DeadLetter]
dead<span class="preprocessor">.message</span> must be(msg)
dead<span class="preprocessor">.sender</span> must be(testActor)
dead<span class="preprocessor">.recipient</span> must be(actor)
</pre></td></tr></table></figure>

<h1 id="guaranteed-delivery">Guaranteed delivery</h1>
<p>The guaranteed delivery channel is point-to-point channel with the guaranty that
the message is always delivered to the receiver.</p>
<p>This means that the channel must have
all kind of mechanism and checks to be able to guaranty the delivery, for example
the message has to be saved on disk in case the process crashes.</p>
<p>The general rule of message delivery is that messages are delivered
at-most-once. This means that Akka promise that messages are delivered once or
fails to deliver, Which means that the message is lost.</p>
<p>Sending local messages will not likely fails, because it is like a normal method
call. This fails only when there are catastrophic VM errors, like
StackOverflowError, OutOfMemoryError or a memory access violation.
So the guaranties when sending a message to a local actor, are pretty good
and reliable.</p>
<p>The problem of losing the messages is when using remote actors. When using
remote actors, it is a lot more likely for a message delivery failure to occur.</p>
<p>The Egress is an Actor which is started by the
ReliableProxy and both Actors implements the checks and resend functionality to
be able to keep track of which of the messages are delivered to the remote receiver.</p>
<p> One restriction of using the ReliableProxy is that the tunnel is only one-way
and for one receiver. This means that when the receiver replies to the sender the
tunnel is NOT used.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.contrib.pattern.ReliableProxy
<span class="keyword">val</span> echo = system.actorFor(node(server) / <span class="string">"user"</span> / <span class="string">"echo"</span>)
<span class="comment">// In the example we create a proxy using the echo reference.</span>
<span class="comment">// When failing to send a message it is retried after 500 milliseconds.</span>
<span class="keyword">val</span> proxy = system.actorOf(Props(<span class="keyword">new</span> ReliableProxy(echo, <span class="number">500.</span>millis)), <span class="string">"proxy"</span>)
</pre></td></tr></table></figure>

<p>We create a Multi-node test with two nodes, the client and server
node. On the server Node we create a EchoActor as receiver and on the client node
we run our actual test.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.remote.testkit.MultiNodeSpecCallbacks
<span class="keyword">import</span> akka.remote.testkit.MultiNodeConfig
<span class="keyword">import</span> akka.remote.testkit.MultiNodeSpec

<span class="class"><span class="keyword">trait</span> <span class="title">STMultiNodeSpec</span></span>
    <span class="keyword">extends</span> MultiNodeSpecCallbacks
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> BeforeAndAfterAll {
  <span class="keyword">override</span> <span class="keyword">def</span> beforeAll() = multiNodeSpecBeforeAll()
  <span class="keyword">override</span> <span class="keyword">def</span> afterAll() = multiNodeSpecAfterAll()
}

<span class="class"><span class="keyword">object</span> <span class="title">ReliableProxySampleConfig</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> {</span>
  <span class="keyword">val</span> client = role(<span class="string">"Client"</span>)
  <span class="keyword">val</span> server = role(<span class="string">"Server"</span>)
  testTransport(on = <span class="keyword">true</span>)
}

<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode1</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode2</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
</pre></td></tr></table></figure>

<p>TODO P257</p>
<h1 id="using-a-finite-state-machine">Using a Finite State Machine</h1>
<p>Finite-state machine (FSM), also called a state machine, is a common,
language-independent modeling technique.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p><img src="/img/akka_FSM.png" alt="fsm"></p>
<h2 id="creating-an-fsm-model">Creating an FSM Model</h2>
<p>The inventory Service gets requests for
specific books and sends a reply. When the book is in inventory, the order system
gets a reply that a book has been reserved. But it is possible that there aren&#39;t any
books left and that the inventory will have to ask the publisher for more books,
before it can service the order.</p>
<p><img src="/img/akka_FMS.png" alt="fms"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td class="code"><pre>
<span class="comment">// State, The super type of all state names</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForRequests</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessRequest</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForPublisher</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessSoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>

<span class="comment">// StateData, The type of the state data which are tracked by the FSM.</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateData</span><span class="params">(nrBooksInStore:Int,pendingRequests:Seq[BookRequest])</span></span>


<span class="keyword">import</span> akka.actor.{Actor, FSM}
<span class="class"><span class="keyword">class</span> <span class="title">Inventory</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">FSM</span>[<span class="title">State</span>, <span class="title">StateData</span>] {</span>
  <span class="comment">// define the initial state and the initial StateData.</span>
  startWith(WaitForRequests, <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq()))

  <span class="comment">// Declare the transitions for state WaitForRequests</span>
  when(WaitForRequests) {
    <span class="comment">// Declare the possible Event when a BookRequest messages occur</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; 
      <span class="keyword">val</span> newStateData = data.copy(pendingRequests = data.pendingRequests :+ request)
      
      <span class="keyword">if</span> (newStateData.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest) using newStateData
      } <span class="keyword">else</span> {
        goto(WaitForPublisher) using newStateData
      }
    <span class="keyword">case</span> Event(PendingRequests, data:StateData) =&gt; 
      <span class="keyword">if</span> (data.pendingRequests.isEmpty) {
        stay
      } <span class="keyword">else</span> <span class="keyword">if</span>(data.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest)
      } <span class="keyword">else</span> {
        goto(WaitForPublisher)
      }
  }

  when(WaitForPublisher) {
    <span class="keyword">case</span> Event(supply:BookSupply, data:StateData) =&gt; {
      goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
    }
    <span class="keyword">case</span> Event(BookSupplySoldOut, _) =&gt; {
      goto(ProcessSoldOut)
    }
  }

  when(ProcessRequest) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(WaitForRequests) using data.copy(
          nrBooksInStore = data.nrBooksInStore - <span class="number">1</span>,
          pendingRequests = data.pendingRequests.tail)
    }
  }

  when(SoldOut) {
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      goto(ProcessSoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq(request))
    }
  }

  when(ProcessSoldOut) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(SoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq())
    }
  }

  whenUnhandled {
    <span class="comment">// common code for all states</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      <span class="comment">// Only update the stateData</span>
      stay using data.copy(pendingRequests = data.pendingRequests :+ request)
    }
    <span class="comment">// Log when the event isn't handled</span>
    <span class="keyword">case</span> Event(e, s) =&gt; {
      log.warning(<span class="string">"received unhandled request {} in state {}/{}"</span>, e, stateName, s)
      stay
    }
  }

  <span class="comment">// entry Action of the WaitForRequests state</span>
  onTransition {
    <span class="keyword">case</span> _ -&gt; WaitForRequests =&gt; {
      <span class="keyword">if</span> (!nextStateData.pendingRequests.isEmpty) {
        <span class="comment">// go to next state</span>
        self ! PendingRequests
      }
    }
    
    <span class="keyword">case</span> _ -&gt; WaitForPublisher =&gt; {
      publisher ! PublisherRequest
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessRequest =&gt; {
      <span class="keyword">val</span> request = nextStateData.pendingRequests.head
      reserveId += <span class="number">1</span>
      request.target ! <span class="keyword">new</span> BookReply(request.context, Right(reserveId))
      self ! Done
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessSoldOut =&gt; {
      nextStateData.pendingRequests.foreach(request =&gt; {
        request.target ! <span class="keyword">new</span> BookReply(request.context, Left(<span class="string">"SoldOut"</span>))
      })
      self ! Done
    }
  }

}
</pre></td></tr></table></figure>

<h2 id="testing-the-fsm">TESTING THE FSM</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(totalNrBooks: Int, nrBooksPerRequest: Int)</span></span>
    <span class="keyword">extends</span> Actor {
  <span class="keyword">var</span> nrLeft = totalNrBooks
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> PublisherRequest =&gt; {
      <span class="keyword">if</span> (nrLeft == <span class="number">0</span>)
      sender ! BookSupplySoldOut
      <span class="keyword">else</span> {
        <span class="keyword">val</span> supply = min(nrBooksPerRequest, nrLeft)
        nrLeft -= supply
        sender ! <span class="keyword">new</span> BookSupply(supply)
      }
    }
  }
}

<span class="keyword">val</span> publisher = system.actorOf(Props(<span class="keyword">new</span> Publisher(<span class="number">2</span>,<span class="number">2</span>)))
<span class="keyword">val</span> inventory = system.actorOf(Props(<span class="keyword">new</span> Inventory(publisher)))
<span class="keyword">val</span> stateProbe = TestProbe()

<span class="comment">// 订阅状态变化信息</span>
inventory ! <span class="keyword">new</span> SubscribeTransitionCallBack(stateProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> CurrentState(inventory, WaitForRequests))

inventory ! <span class="keyword">new</span> BookRequest(<span class="string">"context1"</span>, replyProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForRequests, WaitForPublisher))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForPublisher, ProcessRequest))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, ProcessRequest, WaitForRequests))
replyProbe.expectMsg(<span class="keyword">new</span> BookReply(<span class="string">"context1"</span>, Right(<span class="number">1</span>)))
</pre></td></tr></table></figure>

<h2 id="timers-within-fsm">Timers within FSM</h2>
<p>When it is in the state &#39;WaitingForPublisher,&#39;
we don&#39;t wait forever for the publisher to reply.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">when</span>(WaitForPublisher, stateTimeout = <span class="number">5</span> seconds) {
  <span class="reserved">case</span> Event<span class="function"><span class="params">(supply:BookSupply, data:StateData)</span> =&gt;</span> {
    goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
  }
  <span class="reserved">case</span> Event<span class="function"><span class="params">(BookSupplySoldOut, _)</span> =&gt;</span> {
    goto(ProcessSoldOut)
  }
  <span class="regexp">//</span> Define the timeout transition
  <span class="reserved">case</span> Event<span class="function"><span class="params">(StateTimeout,_)</span> =&gt;</span> goto(WaitForRequests)
}

<span class="regexp">//</span> 当测试时
<span class="regexp">//</span> stateProbe.expectMsg(<span class="number">6</span> seconds,<span class="keyword">new</span> Transition(inventory, WaitForPublisher, WaitForRequests))
</pre></td></tr></table></figure>

<p>The timer can also be set by specifying the next state using the
method forMax.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">goto</span><span class="params">(<span class="variable">WaitForPublisher</span>)</span> <span class="title">using</span> <span class="params">(new<span class="variable">Data</span>)</span> <span class="title">forMax</span> <span class="params">(<span class="number">5</span> seconds)</span></span>
</pre></td></tr></table></figure>

<h2 id="termination-of-fsm">Termination of FSM</h2>
<p>The FSM has an
specific handler for these cases: onTermination. This handler is also a partial
function and takes a StopEvent as an argument.</p>
<p>There are three possible reasons this can be received.</p>
<ul>
<li>Normal. This is received when there is a normal termination.</li>
<li>Shutdown. This is received when the FSM is stopped due to a shutdown.</li>
<li>Failure(cause: Any), This reason is received when the termination was caused by a failure</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="title">onTermination</span> {
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Normal</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Shutdown</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Failure</span>(cause), state, <span class="typedef"><span class="keyword">data</span>)</span>
}
</pre></td></tr></table></figure>

<h1 id="implement-shared-state-using-agents">Implement Shared state using agents</h1>
<p>Akka accomplishes this by sending
actions to the agent for each operation, where the messaging infrastructure will
preclude a race condition.</p>
<p>For our example, we need to share the number
of copies sold for each book, so we will create an Agent that contains this value.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">BookStatics</span><span class="params">(val nameBook: String, nrSold: Int)</span></span>
<span class="comment">// a BookStatics instance is created which is put into a map using the title as the key</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateBookStatics</span><span class="params">(val sequence: Long, books: Map[String, BookStatics])</span></span>
</pre></td></tr></table></figure>

<p>The state object contained by the agent must be immutable.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.global
<span class="keyword">import</span> akka.agent.Agent
<span class="keyword">val</span> stateAgent = <span class="keyword">new</span> Agent(<span class="keyword">new</span> StateBookStatics(<span class="number">0</span>,Map()))

<span class="keyword">val</span> currentBookStatics = stateAgent.get <span class="comment">// 使用 stateAgent() 效果一样</span>

<span class="comment">// 如果 agent 的值是依赖前一个状态的呢?</span>
<span class="keyword">val</span> newState = StateBookStatics(<span class="number">1</span>, Map(book -&gt; bookStat ))
stateAgent send newState

<span class="comment">// 可以这样</span>
<span class="keyword">val</span> book = <span class="string">"Akka in Action"</span>
<span class="keyword">val</span> nrSold = <span class="number">1</span>
stateAgent send( oldState =&gt; {
  <span class="keyword">val</span> bookStat = oldState.books.get(book) <span class="keyword">match</span> {
    <span class="keyword">case</span> Some(bookState) =&gt;
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="keyword">case</span> None =&gt; <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>, oldState.books + (book -&gt; bookStat ))
})
</pre></td></tr></table></figure>

<h2 id="waiting-for-the-state-update">Waiting for the state update</h2>
<p>In some cases, we need to update shared state and use the new state. For example,
we need to know which book is selling the most, and when a book becomes
popular, we want to notify the authors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>implicit val timeout = Timeout(<span class="number">1000</span>)

<span class="regexp">//</span> It works exactly as the send method only it returns a Future,
<span class="regexp">//</span> which can be used to wait <span class="keyword">for</span> the <span class="keyword">new</span> state.
val future = stateAgent alter( oldState<span class="function"> =&gt;</span> {
  val bookStat = oldState.books.get(book) match {
    <span class="reserved">case</span> Some<span class="function"><span class="params">(bookState)</span> =&gt;</span>
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="reserved">case</span> None<span class="function"> =&gt;</span>
      <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>,oldState.books + (book<span class="function"> -&gt;</span> bookStat ))
})

val newState = Await.result(future, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<p> It is possible that there are multiple changes at
nearly the same time and we want the final state or another thread needs the final
state and only knows that the process before it may have updated the state. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>val <span class="keyword">future</span> = stateAgent.<span class="keyword">future</span>
val newState = <span class="keyword">Await</span>.<span class="keyword">result</span>(<span class="keyword">future</span>, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.<span class="keyword">global</span>
val agent1 = Agent(<span class="number">3</span>)
// When using this notation, agent2 <span class="keyword">is</span> a newly created Agent that contains the
// value <span class="number">4</span> <span class="keyword">and</span> agent1 <span class="keyword">is</span> just the same <span class="keyword">as</span> before (it still contains the value <span class="number">3</span>).
val agent2 = agent1 map (_ + <span class="number">1</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-System Structure & Routing Messages]]></title>
    <link href="http://zhpooer.github.io/2014/08/04/akka-in-action-system-structure/"/>
    <id>http://zhpooer.github.io/2014/08/04/akka-in-action-system-structure/</id>
    <published>2014-08-04T10:47:29.000Z</published>
    <updated>2014-08-05T03:10:01.000Z</updated>
    <content type="html"><![CDATA[<p>One of the immediate implications of Actor based programming is how do we
model code that requires collaborators to work together if each unit of work is done
in parallel?</p>
<p>Akka allows us to use these design approaches while still making use of its
inherent concurrency.</p>
<ul>
<li>integration tools and platforms</li>
<li>messaging systems</li>
<li>WSO2, and SOA and Web-service based solutions</li>
</ul>
<h1 id="pipes-and-filters">Pipes and Filters</h1>
<p>The concept of piping refers to the ability for one process or thread to pump its
results to another processor for additional processing.</p>
<p>In many systems a single event will trigger a sequence of tasks.</p>
<p>It receives the photo and before the event is sent to central
processing, a number of checks are done. When no license plate is found in the
photo, the system is unable to process the message any further and therefore, it will
be discarded.  In this example we also discard the message when the speed is below
the maximum speed. Which means that only messages that contain the license
plate of a speeding vehicle end up getting to the central processor.</p>
<p>Each Filter consists of three parts, the inbound pipe where the message is
received, the processor of the message, and finally the outbound pipe where the
result of the processing is published.</p>
<p>An important restriction is that each filter must accept and
send the same messages, because the outbound pipe of a filter can be the inbound
pipe of any other filter in the pattern. </p>
<p>A Pipe with Two Filters Example</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Photo</span><span class="params">(license: String, speed: Int)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">SpeedFilter</span><span class="params">(minSpeed: Int, pipe: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>

  <span class="comment">// Filter all Photos which have a speed lower than the minimal speed</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: Photo =&gt;
      <span class="keyword">if</span> (msg.speed &gt; minSpeed) pipe ! msg
  }
}

<span class="comment">// Filter all Photos which have an empty license</span>
<span class="class"><span class="keyword">class</span> <span class="title">LicenseFilter</span><span class="params">(pipe: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: Photo =&gt;
      <span class="keyword">if</span> (!msg.license.isEmpty) pipe ! msg
  }
}


<span class="comment">// Pipe and filter test</span>

<span class="keyword">val</span> endProbe = TestProbe()
<span class="keyword">val</span> speedFilterRef = system.actorOf( Props(<span class="keyword">new</span> SpeedFilter(<span class="number">50</span>, endProbe.ref)))

<span class="keyword">val</span> licenseFilterRef = system.actorOf(Props(<span class="keyword">new</span> LicenseFilter(speedFilterRef)))
<span class="keyword">val</span> msg = <span class="keyword">new</span> Photo(<span class="string">"123xyz"</span>, <span class="number">60</span>)

licenseFilterRef ! msg
endProbe.expectMsg(msg)
licenseFilterRef ! <span class="keyword">new</span> Photo(<span class="string">""</span>, <span class="number">60</span>)

endProbe.expectNoMsg(<span class="number">1</span> second)
licenseFilterRef ! <span class="keyword">new</span> Photo(<span class="string">"123xyz"</span>, <span class="number">49</span>)
endProbe.expectNoMsg(<span class="number">1</span> second)
</pre></td></tr></table></figure>

<h1 id="scatter-gather-pattern">Scatter-Gather Pattern</h1>
<p>The first case is when the
tasks are functionally the same, but only one is passed through to the gather
component as the chosen result. The second scenario is when work is divided for
parallel processing and each processor submits its results which are then combined
into a result set by the aggregator. </p>
<h2 id="competing-tasks">Competing Tasks</h2>
<p>A client buys a product, let&#39;s say a book at a
web shop, but the shop doesn&#39;t have the requested book in stock, so it has to buy
the book from a supplier. But the shop is doing business with three different
suppliers and wants to pay the lowest price.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PhotoMessage</span><span class="params">(id: String,
    photo: String,
    creationTime: Option[Date] = None,
    speed: Option[Int] = None)</span></span>
    
<span class="comment">// task  handler</span>
<span class="class"><span class="keyword">class</span> <span class="title">GetSpeed</span><span class="params">(pipe:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg:PhotoMessage =&gt; {
      pipe ! msp.copy(speed = ImageProcessing.getSpeed(msg.photo))
    }
  }
}
<span class="class"><span class="keyword">class</span> <span class="title">GetTime</span><span class="params">(pipe: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: PhotoMessage =&gt; {
      pipe ! msg.copy(creationTime = ImageProcessing.getTime(msg.photo))
    }
  }
}

<span class="comment">// distribute received message to all processing tasks</span>
<span class="class"><span class="keyword">class</span> <span class="title">RecipientList</span><span class="params">(recipientList:Seq[ActorRef])</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: AnyRef =&gt; recipientList.foreach( _ ! msg)
  }
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">TimeoutMessage</span><span class="params">(msg:PhotoMessage)</span></span>

<span class="comment">// 聚合, 等待两个actor消息, 当一个消息回来时, 接着等待另一个, 加上了定时功能</span>
<span class="class"><span class="keyword">class</span> <span class="title">Aggregator</span><span class="params">(timeout:Duration, pipe:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> messages = <span class="keyword">new</span> ListBuffer[PhotoMessage]
  implicit <span class="keyword">val</span> ec = context.system.dispatcher
  <span class="comment">// Send all the received messages to our own mailbox</span>

  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
    <span class="keyword">super</span>.preRestart(reason, message)
    messages.foreach(self ! _)
    messages.clear()
  }
  
  <span class="comment">// The first thing when receiving a message,</span>
  <span class="comment">// is to check if it is the first message or the second. </span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> rcvMsg: PhotoMessage =&gt; {
      messages.find(_.id == rcvMsg.id) <span class="keyword">match</span> {
        <span class="keyword">case</span> Some(alreadyRcvMsg) =&gt; {
        
          <span class="keyword">val</span> newCombinedMsg = <span class="keyword">new</span> PhotoMessage(
            rcvMsg.id,
            rcvMsg.photo,
            rcvMsg.creationTime.orElse(alreadyRcvMsg.creationTime),
            rcvMsg.speed.orElse(alreadyRcvMsg.speed) )
            
          pipe ! newCombinedMsg
          <span class="comment">//cleanup message</span>
          messages -= alreadyRcvMsg
        }
        <span class="keyword">case</span> None =&gt;{
          messages += rcvMsg
          <span class="comment">// 如果在规定的时间内没有收到信息</span>
          context.system.scheduler.scheduleOnce(
            timeout,
            self,
            <span class="keyword">new</span> TimeoutMessage(rcvMsg))
        }
    }
    <span class="keyword">case</span> TimeoutMessage(rcvMsg) =&gt; {
      messages.find(_.id == rcvMsg.id) <span class="keyword">match</span> {
        <span class="keyword">case</span> Some(alreadyRcvMsg) =&gt; {
          pipe ! alreadyRcvMsg
          messages -= alreadyRcvMsg
        }
        <span class="keyword">case</span> None =&gt; <span class="comment">//message is already processed</span>
    }
    <span class="keyword">case</span> ex: Exception =&gt; <span class="keyword">throw</span> ex
  }
}
</pre></td></tr></table></figure>

<p>Test Aggregator missing a message</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">val</span> endProbe = TestProbe()
<span class="keyword">val</span> actorRef = system.actorOf(Props(<span class="keyword">new</span> Aggregator(<span class="number">1</span> second, endProbe.<span class="keyword">ref</span>)))
<span class="keyword">val</span> photoStr = ImageProcessing.createPhotoString(<span class="keyword">new</span> Date(), <span class="number">60</span>)
<span class="keyword">val</span> msg1 = PhotoMessage(<span class="string">"id1"</span>, photoStr, Some(<span class="keyword">new</span> Date()), None)
actorRef ! msg1
actorRef ! <span class="keyword">new</span> IllegalStateException(<span class="string">"restart"</span>)
<span class="keyword">val</span> msg2 = PhotoMessage(<span class="string">"id1"</span>,photoStr, None, Some(<span class="number">60</span>))
actorRef ! msg2

<span class="keyword">val</span> combinedMsg = PhotoMessage(<span class="string">"id1"</span>, photoStr, msg1.creationTime, msg2.speed)
endProbe.expectMsg(combinedMsg)
</pre></td></tr></table></figure>

<h1 id="routing-messages">Routing Messages</h1>
<p>Akka’s routing feature lets you alter a message’s path from
sender to receiver.</p>
<p>Akka provides a set of standard routers that implement routing patterns that
frequently show up in those everyday problems.</p>
<h2 id="roundrobinrouter">RoundRobinRouter</h2>
<p>The RoundRobinRouter sends messages to the Actors for which it fronts in
a round-robin fashion.</p>
<h2 id="smallestmailboxrouter">SmallestMailboxRouter</h2>
<p>When a message comes into the Router, it decides to route the message to
the composed Actor whose Mailbox is the smallest.</p>
<p>The SmallestMailboxRouter is a pretty good choice when it comes to
balancing load among your composed Actors. </p>
<h2 id="configuring-a-router">Configuring a Router</h2>
<p>The configurations are specified in the akka.actor.deployment block. Be-
low is a simple configuration of a RoundRobinRouter, which would appear
in your application.conf file:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>akka {
  actor {
    deployment {
      /DatabaseConnectionRouter {
        router <span class="subst">=</span> <span class="string">"round-robin"</span>
        nr<span class="attribute">-of</span><span class="attribute">-instances</span> <span class="subst">=</span> <span class="number">20</span>
      }
    }
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.routing.FromConfig
<span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span> ...
}
<span class="keyword">val</span> dbRouter = system.actorOf(Props[DBConnection].withRouter(FromConfig(),
                              <span class="string">"DatabaseConnectionRouter"</span>), <span class="string">"DBRouter"</span>)
</pre></td></tr></table></figure>

<p>The dbRouter will be an instance of a RoundRobinRouter that will rep-
resent the database connection, and it will also be the parent of 20 instances
of the DBConnection Actor.</p>
<h2 id="routers-and-children">Routers and Children</h2>
<p>Routers route to routees. You can create those routees dynamically by the
Router, or you can assign them to it from an already created set. </p>
<p>These two different methods of assigning routees have an impact
on the relationship and supervision of those routees.</p>
<h2 id="letting-the-router-create-the-routees">Letting the Router Create the Routees</h2>
<p>Advantages</p>
<ul>
<li>The Router handles the Supervision.</li>
<li>It works well with configuration.</li>
</ul>
<p>Disadvantages</p>
<ul>
<li>You’ll have a difficult time constructing anything but a single type of
Actor.</li>
<li>You can’t name them the way you might like.</li>
</ul>
<h2 id="passing-the-router-pre-created-actors">Passing the Router Pre-Created Actors</h2>
<ul>
<li>You have to have parents for them.</li>
<li>It’s not as flexible from a configuration perspective. </li>
</ul>
<h2 id="the-router-and-its-children-s-life-cycles">The Router and Its Children’s Life Cycles</h2>
<p>When the Router creates the routees, they are its children, which means that
the Router must manage their life cycles. The Router will assign a
supervisorStrategy that always escalates the decision to its parent.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>val dbRouter = system<span class="preprocessor">.actorOf</span>(Props<span class="preprocessor">.empty</span><span class="preprocessor">.withRouter</span>(RoundRobinRouter(
    nrOfInstances = <span class="number">5</span>,
    supervisorStrategy = OneForOneStrategy {
    // define your Decider here
    }), <span class="string">"DBRouter"</span>)

// you can assign that easily enough:
val dbRouter = system<span class="preprocessor">.actorOf</span>(Props<span class="preprocessor">.empty</span><span class="preprocessor">.withRouter</span>(RoundRobinRouter(
    nrOfInstances = <span class="number">5</span>,
    supervisorStrategy = SupervisorStrategy<span class="preprocessor">.defaultStrategy</span>
    ), <span class="string">"DBRouter"</span>)
</pre></td></tr></table></figure>

<h2 id="routers-on-a-plane">Routers on a Plane</h2>
<p>A BroadcastRouter would make the perfect component for allowing the passengers
to receive important information, such as “Fasten Seat Belts,”.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>zzz<span class="preprocessor">.akka</span><span class="preprocessor">.avionics</span> {
  passengers = [
    [ <span class="string">"Kelly Franqui"</span>, <span class="string">"01"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Tyrone Dotts"</span>, <span class="string">"02"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Malinda Class"</span>, <span class="string">"03"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Kenya Jolicoeur"</span>, <span class="string">"04"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Christian Piche"</span>, <span class="string">"10"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Neva Delapena"</span>, <span class="string">"11"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Alana Berrier"</span>, <span class="string">"12"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Malinda Heister"</span>, <span class="string">"13"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Carlene Heiney"</span>, <span class="string">"14"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Erik Dannenberg"</span>, <span class="string">"15"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Jamie Karlin"</span>, <span class="string">"20"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Julianne Schroth"</span>, <span class="string">"21"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Elinor Boris"</span>, <span class="string">"22"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Louisa Mikels"</span>, <span class="string">"30"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Jessie Pillar"</span>, <span class="string">"31"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Darcy Goudreau"</span>, <span class="string">"32"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Harriett Isenhour"</span>, <span class="string">"33"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Odessa Maury"</span>, <span class="string">"34"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Malinda Hiett"</span>, <span class="string">"40"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Darcy Syed"</span>, <span class="string">"41"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Julio Dismukes"</span>, <span class="string">"42"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Jessie Altschuler"</span>, <span class="string">"43"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Tyrone Ericsson"</span>, <span class="string">"44"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Mallory Dedrick"</span>, <span class="string">"50"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Javier Broder"</span>, <span class="string">"51"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Alejandra Fritzler"</span>, <span class="string">"52"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Rae Mcaleer"</span>, <span class="string">"53"</span>, <span class="string">"C"</span> ]
  ]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Passenger</span> {</span>
  <span class="comment">// These are notifications that tell the Passenger</span>
  <span class="comment">// to fasten or unfasten their seat belts</span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">FastenSeatbelts</span></span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">UnfastenSeatbelts</span></span>
  <span class="comment">// Regular expression to extract Name-Row-Seat tuple</span>
  <span class="keyword">val</span> SeatAssignment = <span class="string">"""([\w\s_]+)-(\d+)-([A-Z])"""</span>.r
}

<span class="comment">// The DrinkRequestProbability trait defines some</span>
<span class="comment">// thresholds that we can modify in tests to</span>
<span class="comment">// speed things up.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">DrinkRequestProbability</span> {</span>
  <span class="comment">// Limits the decision on whether the passenger</span>
  <span class="comment">// actually asks for a drink</span>
  <span class="keyword">val</span> askThreshold = <span class="number">0.9</span>f
  
  <span class="comment">// The minimum time between drink requests</span>
  <span class="keyword">val</span> requestMin = <span class="number">20.</span>minutes
  
  <span class="comment">// Some portion of this (0 to 100</span>
  <span class="comment">// to requestMin</span>
  <span class="keyword">val</span> requestUpper = <span class="number">30.</span>minutes
  <span class="comment">// Gives us a 'random' time within the previous</span>
  <span class="comment">// two bounds</span>
  <span class="keyword">def</span> randomishTime(): Duration = {
    requestMin + scala.util.Random.nextInt(requestUpper.toMillis.toInt).millis
  }
}

<span class="comment">// The idea behind the PassengerProvider is old news at this point.</span>
<span class="comment">// We can use it in other classes to give us the ability to slide</span>
<span class="comment">// in different Actor types to ease testing.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">PassengerProvider</span> {</span>
  <span class="keyword">def</span> newPassenger(callButton: ActorRef): Actor =
    <span class="keyword">new</span> Passenger(callButton) <span class="keyword">with</span> DrinkRequestProbability
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Passenger</span><span class="params">(callButton: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">this</span>: DrinkRequestProbability =&gt;
  <span class="keyword">import</span> Passenger._
  <span class="keyword">import</span> FlightAttendant.{GetDrink, Drink}
  <span class="keyword">import</span> scala.collection.JavaConverters._
  
  <span class="comment">// We'll be adding some randomness to our Passenger,</span>
  <span class="comment">// and this shortcut will make things a little more</span>
  <span class="comment">// readable.</span>
  <span class="keyword">val</span> r = scala.util.Random
  
  <span class="comment">// It's about time that someone actually asked for a</span>
  <span class="comment">// drink since our Flight Attendants have been coded</span>
  <span class="comment">// to serve them up</span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">CallForDrink</span></span>
  
  <span class="comment">// The name of the Passenger can't have spaces in it,</span>
  <span class="comment">// since that's not a valid character in the URI</span>
  <span class="comment">// spec. We know the name will have underscores in</span>
  <span class="comment">// place of spaces, and we'll convert those back</span>
  <span class="comment">// here.</span>
  <span class="keyword">val</span> SeatAssignment(myname, _, _) =
    self.path.name.replaceAllLiterally(<span class="string">"_"</span>, <span class="string">" "</span>)
    
  <span class="comment">// We'll be pulling some drink names from the</span>
  <span class="comment">// configuration file as well</span>
  <span class="keyword">val</span> drinks = context.system.settings.config.getStringList(<span class="string">"zzz.akka.avionics.drinks"</span>).asScala.toIndexedSeq
  
  <span class="comment">// A shortcut for the scheduler to make things look</span>
  <span class="comment">// nicer later</span>
  <span class="keyword">val</span> scheduler = context.system.scheduler
  
  <span class="comment">// We've just sat down, so it's time to get a drink</span>
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
    self ! CallForDrink
  }

  <span class="comment">// This method will decide whether or not we actually</span>
  <span class="comment">// want to get a drink using some randomness to</span>
  <span class="comment">// decide</span>
  <span class="keyword">def</span> maybeSendDrinkRequest(): Unit = {
    <span class="keyword">if</span> (r.nextFloat() &gt; askThreshold) {
      <span class="keyword">val</span> drinkname = drinks(r.nextInt(drinks.length))
      callButton ! GetDrink(drinkname)
    }
    scheduler.scheduleOnce(randomishTime(), self, CallForDrink)
  }

  <span class="comment">// Standard message handler</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> CallForDrink =&gt;
      maybeSendDrinkRequest()
    <span class="keyword">case</span> Drink(drinkname) =&gt;
      log.info(<span class="string">"{} received a {} - Yum"</span>, myname, drinkname)
    <span class="keyword">case</span> FastenSeatbelts =&gt;
      log.info(<span class="string">"{} fastening seatbelt"</span>, myname)
    <span class="keyword">case</span> UnfastenSeatbelts =&gt;
      log.info(<span class="string">"{} UNfastening seatbelt"</span>, myname)
  }
}
</pre></td></tr></table></figure>

<p>Testing and the Event Stream</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">TestDrinkRequestProbability</span> <span class="keyword">extends</span> <span class="title">DrinkRequestProbability</span> {</span>
  <span class="keyword">override</span> <span class="keyword">val</span> askThreshold = <span class="number">0</span>f
  <span class="keyword">override</span> <span class="keyword">val</span> requestMin = <span class="number">0.</span>milliseconds
  <span class="keyword">override</span> <span class="keyword">val</span> requestUpper = <span class="number">2.</span>milliseconds
}

<span class="class"><span class="keyword">class</span> <span class="title">PassengersSpec</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(ActorSystem()</span>) <span class="keyword">with</span> <span class="title">ImplicitSender</span> {</span>
  <span class="keyword">import</span> akka.event.Logging.Info
  <span class="keyword">import</span> akka.testkit.TestProbe
  <span class="keyword">var</span> seatNumber = <span class="number">9</span>
  
  <span class="keyword">def</span> newPassenger(): ActorRef = {
    seatNumber += <span class="number">1</span>
    system.actorOf(Props(<span class="keyword">new</span> Passenger(testActor) <span class="keyword">with</span> TestDrinkRequestProbability), s<span class="string">"Pat_Metheny-$seatNumber-B"</span>)
  }
  
  <span class="string">"Passengers"</span> should {
    <span class="string">"fasten seatbelts when asked"</span> in {
      <span class="keyword">val</span> a = newPassenger()
      <span class="keyword">val</span> p = TestProbe()
      <span class="comment">// This says that we want the TestProbe’s ActorRef (p.ref) to be the handle</span>
      <span class="comment">// to the subscribed Actor, and that we want it to receive events that match the</span>
      <span class="comment">// class akka.event.Logger.Info. </span>
      system.eventStream.subscribe(p.ref, classOf[Info])
      
      a ! FastenSeatbelts
      p.expectMsgPF() {
        <span class="keyword">case</span> Info(_, _, m) =&gt;
          m.toString must include (<span class="string">"fastening seatbelt"</span>)
      }
    }
  }
}
</pre></td></tr></table></figure>

<h3 id="the-passenger-router">The Passenger Router</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">PassengerSupervisor</span> {</span>
  <span class="comment">// Allows someone to request the BroadcastRouter</span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GetPassengerBroadcaster</span></span>
  <span class="comment">// Returns the BroadcastRouter to the requestor</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PassengerBroadcaster</span><span class="params">(broadcaster: ActorRef)</span></span>
  <span class="comment">// Factory method for easy construction</span>
  <span class="keyword">def</span> apply(callButton: ActorRef) = <span class="keyword">new</span> PassengerSupervisor(callButton)
        <span class="keyword">with</span> PassengerProvider
}

<span class="class"><span class="keyword">class</span> <span class="title">PassengerSupervisor</span><span class="params">(callButton: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">this</span>: PassengerProvider =&gt;
  <span class="keyword">import</span> PassengerSupervisor._
  <span class="comment">// We'll resume our immediate children instead of restarting them</span>
  <span class="comment">// on an Exception</span>
  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = OneForOneStrategy() {
    <span class="keyword">case</span> _: ActorKilledException =&gt; Escalate
    <span class="keyword">case</span> _: ActorInitializationException =&gt; Escalate
    <span class="keyword">case</span> _ =&gt; Resume
  }
  
  <span class="comment">// Internal messages we use to communicate between this Actor</span>
  <span class="comment">// and its subordinate IsolatedStopSupervisor</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">GetChildren</span><span class="params">(forSomeone: ActorRef)</span></span>

  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Children</span><span class="params">(children: Iterable[ActorRef], childrenFor: ActorRef)</span></span>
  
  <span class="comment">// We use preStart() to create our IsolatedStopSupervisor</span>
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
    context.actorOf(Props(<span class="keyword">new</span> Actor {
      <span class="keyword">val</span> config = context.system.settings.config
      
      <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = OneForOneStrategy() {
        <span class="keyword">case</span> _: ActorKilledException =&gt; Escalate
        <span class="keyword">case</span> _: ActorInitializationException =&gt; Escalate
        <span class="keyword">case</span> _ =&gt; Stop
      }
      <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
        <span class="keyword">import</span> scala.collection.JavaConverters._
        <span class="keyword">import</span> com.typesafe.config.ConfigList
        <span class="comment">// Get our passenger names from the configuration</span>
        <span class="keyword">val</span> passengers = config.getList(<span class="string">"zzz.akka.avionics.passengers"</span>)
        
        <span class="comment">// Iterate through them to create the passenger children</span>
        passengers.asScala.foreach { nameWithSeat =&gt;
          <span class="keyword">val</span> id = nameWithSeat.asInstanceOf[ConfigList].unwrapped().asScala.mkString(<span class="string">"-"</span>).replaceAllLiterally(<span class="string">" "</span>, <span class="string">"_"</span>)
          <span class="comment">// Convert spaces to underscores to comply with URI standard</span>
          context.actorOf(Props(newPassenger(callButton)), id)
        }
      }
    
      <span class="keyword">override</span> <span class="keyword">def</span> receive = {
        <span class="keyword">case</span> GetChildren(forSomeone: ActorRef) =&gt;
          sender ! Children(context.children, forSomeone)
      }
    }), <span class="string">"PassengersSupervisor"</span>)
  }

  <span class="keyword">def</span> receive = noRouter

  <span class="comment">// TODO: This noRouter method could be made simpler by using a Future.</span>
  <span class="comment">// We'll have to refactor this later.</span>
  <span class="keyword">def</span> noRouter: Receive = {
    <span class="keyword">case</span> GetPassengerBroadcaster =&gt;
      context.actorFor(<span class="string">"PassengersSupervisor"</span>) ! GetChildren(sender)
    <span class="keyword">case</span> Children(passengers, destinedFor) =&gt;
      <span class="keyword">val</span> router = context.actorOf(Props().withRouter(
        BroadcastRouter(passengers.toSeq)), <span class="string">"Passengers"</span>)
        
      destinedFor ! PassengerBroadcaster(router)
      context.become(withRouter(router))
  }
  
  <span class="keyword">def</span> withRouter(router: ActorRef): Receive = {
    <span class="keyword">case</span> GetPassengerBroadcaster =&gt;
      sender ! PassengerBroadcaster(router)
  }

}
</pre></td></tr></table></figure>

<h3 id="using-the-passenger-router">Using the Passenger Router</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="code"><pre><span class="keyword">package</span> zzz.akka.avionics

<span class="keyword">import</span> akka.actor.{ActorSystem, Actor, ActorRef, Props}
<span class="keyword">import</span> akka.testkit.{TestKit, ImplicitSender}
<span class="keyword">import</span> scala.concurrent.util.duration._
<span class="keyword">import</span> com.typesafe.config.ConfigFactory
<span class="keyword">import</span> org.scalatest.{WordSpec, BeforeAndAfterAll}
<span class="keyword">import</span> org.scalatest.matchers.MustMatchers


<span class="comment">// ActorSystem so we have a known quantity we can test with</span>
<span class="class"><span class="keyword">object</span> <span class="title">PassengerSupervisorSpec</span> {</span>
  <span class="keyword">val</span> config = ConfigFactory.parseString(<span class="string">"""
    zzz.akka.avionics.passengers = [
      [ "Kelly Franqui", "23", "A" ],
      [ "Tyrone Dotts", "23", "B" ],
      [ "Malinda Class", "23", "C" ],
      [ "Kenya Jolicoeur", "24", "A" ],
      [ "Christian Piche", "24", "B" ]
    ]
  """</span>)
}

<span class="comment">// We don't want to work with "real" passengers.</span>
 This mock
<span class="comment">// passenger will be much easier to verify things with</span>
<span class="class"><span class="keyword">trait</span> <span class="title">TestPassengerProvider</span> <span class="keyword">extends</span> <span class="title">PassengerProvider</span> {</span>
  <span class="keyword">override</span> <span class="keyword">def</span> newPassenger(callButton: ActorRef): Actor =
    <span class="keyword">new</span> Actor {
      <span class="keyword">def</span> receive = {
        <span class="keyword">case</span> m =&gt; callButton ! m
      }
    }
}

<span class="comment">// The Test class injects the configuration into the</span>
<span class="comment">// ActorSystem</span>
<span class="class"><span class="keyword">class</span> <span class="title">PassengerSupervisorSpec</span> <span class="keyword">extends</span></span>
    TestKit(ActorSystem(<span class="string">"PassengerSupervisorSpec"</span>, PassengerSupervisorSpec.config))
        <span class="keyword">with</span> ImplicitSender
        <span class="keyword">with</span> WordSpec
        <span class="keyword">with</span> BeforeAndAfterAll
        <span class="keyword">with</span> MustMatchers {
  <span class="keyword">import</span> PassengerSupervisor._
  <span class="comment">// Clean up the system when all the tests are done</span>
  <span class="keyword">override</span> <span class="keyword">def</span> afterAll() {
    system.shutdown()
  }

  <span class="string">"PassengerSupervisor"</span> should {
    <span class="string">"work"</span> in {
      <span class="comment">// Get our SUT</span>
      <span class="keyword">val</span> a = system.actorOf(Props(<span class="keyword">new</span> PassengerSupervisor(testActor) <span class="keyword">with</span> TestPassengerProvider))
      
      <span class="comment">// Grab the BroadcastRouter</span>
      a ! GetPassengerBroadcaster
      <span class="keyword">val</span> broadcaster = expectMsgPF() {
        <span class="keyword">case</span> PassengerBroadcaster(b) =&gt;
          <span class="comment">// Exercise the BroadcastRouter</span>
          b ! <span class="string">"Hithere"</span>
          
          <span class="comment">// All 5 passengers should say "Hithere"</span>
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          
          <span class="comment">// And then nothing else!</span>
          expectNoMsg(<span class="number">100.</span>milliseconds)
          <span class="comment">// Return the BroadcastRouter</span>
          b
      }
      
      <span class="comment">// Ensure that the cache works</span>
      a ! GetPassengerBroadcaster
      expectMsg(PassengerBroadcaster(`broadcaster`))
    }
  }
}
</pre></td></tr></table></figure>

<p>TODO</p>
]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Distribute Akka App]]></title>
    <link href="http://zhpooer.github.io/2014/08/04/akka-in-action-distribute-akka-app/"/>
    <id>http://zhpooer.github.io/2014/08/04/akka-in-action-distribute-akka-app/</id>
    <published>2014-08-04T01:58:24.000Z</published>
    <updated>2014-08-04T08:55:32.000Z</updated>
    <content type="html"><![CDATA[<p>We&#39;ll scale the goticks.com app out to two nodes; a frontend
and a backend server.
The REST Interface will run
on a frontend node. The BoxOffice and all TicketSellers will run on a backend
node. Both nodes have a static reference to each other&#39;s network addresses. </p>
<p><img src="/img/akka_network_topologies.png" alt="net work topologies"></p>
<p>Messages between the nodes are sent over the transport protocol and
need to be encoded and decoded into network specific protocol data units. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-multi-node-testkit" %</span> akkaV % <span class="string">"test"</span>,
<span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-testkit" %</span> akkaV % <span class="string">"test"</span>,
</pre></td></tr></table></figure>

<h1 id="remote-repl-action">Remote REPL action</h1>
<p>Akka provides two ways to get a reference to an actor on a remote node. One is to
look up the actor by its path, the other is to create the actor, get its reference and
deploy it remotely.</p>
<p><code>sbt console</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">// Select the Remote ActorRef Provider to bootstrap remoting</span>
<span class="comment">// the configuration section for remoting</span>
<span class="comment">// 建立一个远程的 Actor</span>
<span class="keyword">val</span> conf = <span class="string">"""
  akka {
    actor {
      provider = "akka.remote.RemoteActorRefProvider"
    }
    remote {
      enabled-transports = ["akka.remote.netty.tcp"]
      netty.tcp {
        hostname = "0.0.0.0"
        port = 2551
      }
    }
  }
"""</span>

<span class="keyword">import</span> com.typesafe.config._
<span class="keyword">import</span> akka.actor._
<span class="keyword">val</span> config = ConfigFactory.parseString(conf)
<span class="comment">// Create the ActorSystem with the parsed Config object.</span>
<span class="keyword">val</span> backend = ActorSystem(<span class="string">"backend"</span>, config)

<span class="class"><span class="keyword">class</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> m =&gt; println(s<span class="string">"received $m!"</span>)
  }
}
<span class="comment">// Create the simple actor in the backend actor system with the name "simple"</span>
backend.actorOf(Props[Simple], <span class="string">"simple"</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">// 建立一个前端的 Actor</span>
<span class="keyword">val</span> conf = <span class="string">"""
  akka {
    actor {
      provider = "akka.remote.RemoteActorRefProvider"
    }
    remote {
      enabled-transports = ["akka.remote.netty.tcp"]
      netty.tcp {
        hostname = "0.0.0.0"
        port = 2552
      }
    }
  }
"""</span>
<span class="keyword">import</span> com.typesafe.config._
<span class="keyword">import</span> akka.actor._
<span class="keyword">val</span> config = ConfigFactory.parseString(conf)
<span class="keyword">val</span> frontend= ActorSystem(<span class="string">"frontend"</span>, config)

<span class="comment">// Select the actor with an ActorSelection</span>
<span class="comment">// the guardian actor is aways called 'user'</span>
<span class="keyword">val</span> path = <span class="string">"akka.tcp://backend@0.0.0.0:2551/user/simple"</span>
<span class="comment">// Think of the actorSelection method as a query in the actor hierarchy</span>
<span class="keyword">val</span> simple = frontend.actorSelection(path)
</pre></td></tr></table></figure>

<p><code>scala&gt; simple ! &quot;Hello Remote World!&quot;</code></p>
<h1 id="remote-lookup">Remote Lookup</h1>
<p>Instead of directly creating a BoxOffice actor in the RestInterface actor we will
look it up on the backend node.</p>
<h2 id="version-1">version 1</h2>
<p>Creator of BoxOffice</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">BoxOfficeCreator</span> {</span> <span class="keyword">this</span>: Actor =&gt;
  <span class="keyword">def</span> createBoxOffice:ActorRef = {
    context.actorOf(Props[BoxOffice], <span class="string">"boxOffice"</span>)
  }
}
<span class="class"><span class="keyword">class</span> <span class="title">RestInterface</span> <span class="keyword">extends</span> <span class="title">HttpServiceActor</span> <span class="keyword">with</span> <span class="title">RestApi</span> {</span>
  <span class="keyword">def</span> receive = runRoute(routes)
}

<span class="class"><span class="keyword">trait</span> <span class="title">RestApi</span> <span class="keyword">extends</span> <span class="title">HttpService</span></span>
    <span class="keyword">with</span> ActorLogging
    <span class="keyword">with</span> BoxOfficeCreator { actor: Actor =&gt;
  <span class="comment">// BoxOffice is created using the createBoxOffice method</span>
  <span class="keyword">val</span> boxOffice = createBoxOffice
  <span class="comment">// rest of the code of the RestApi</span>
}
</pre></td></tr></table></figure>

<h2 id="version-2">version 2</h2>
<p>A RemoteBoxOfficeCreator trait will override the default behavior of which
the details will follow shortly.</p>
<p>A SingleNodeMain, FrontendMain and a
BackendMain are created to start the app in single node mode or to start a
frontend and backend separately.</p>
<p>load from the files singlenode.conf, frontend.conf and backend.conf respectively</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// 同一台机子上</span>
<span class="comment">//Snippet from SingleNodeMain</span>
<span class="keyword">val</span> system = ActorSystem(<span class="string">"singlenode"</span>, config)
<span class="keyword">val</span> restInterface = system.actorOf(Props[RestInterface], <span class="string">"restInterface"</span>)

<span class="comment">// 前端</span>
<span class="comment">//Snippet from FrontendMain</span>
<span class="keyword">val</span> system = ActorSystem(<span class="string">"frontend"</span>, config)
<span class="class"><span class="keyword">class</span> <span class="title">FrontendRestInterface</span> <span class="keyword">extends</span> <span class="title">RestInterface</span> <span class="keyword">with</span> <span class="title">RemoteBoxOfficeCreator</span></span>
  
<span class="keyword">val</span> restInterface = system.actorOf(Props[FrontendRestInterface], <span class="string">"restInterface"</span>)

<span class="comment">// 后端</span>
<span class="comment">//Snippet from BackendMain</span>
<span class="keyword">val</span> system = ActorSystem(<span class="string">"backend"</span>, config)
<span class="keyword">val</span> config = ConfigFactory.load(<span class="string">"backend"</span>)
<span class="keyword">val</span> system = ActorSystem(<span class="string">"backend"</span>, config)

system.actorOf(Props[BoxOffice], <span class="string">"boxOffice"</span>)
</pre></td></tr></table></figure>

<p>The RemoteBoxOfficeCreator loads these extra configuration properties:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>backend {
  host = <span class="string">"0.0.0.0"</span>
  port = <span class="number">2552</span>
  protocol = <span class="string">"akka.tcp"</span>
  <span class="keyword">system</span> = <span class="string">"backend"</span>
  actor = <span class="string">"user/boxOffice"</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">RemoteBoxOfficeCreator</span> {</span>
  <span class="keyword">val</span> config = ConfigFactory.load(<span class="string">"frontend"</span>).getConfig(<span class="string">"backend"</span>)
  <span class="keyword">val</span> host = config.getString(<span class="string">"host"</span>)
  <span class="keyword">val</span> port = config.getInt(<span class="string">"port"</span>)
  <span class="keyword">val</span> protocol = config.getString(<span class="string">"protocol"</span>)
  <span class="keyword">val</span> systemName = config.getString(<span class="string">"system"</span>)
  <span class="keyword">val</span> actorName = config.getString(<span class="string">"actor"</span>)
}

<span class="class"><span class="keyword">trait</span> <span class="title">RemoteBoxOfficeCreator</span> <span class="keyword">extends</span> <span class="title">BoxOfficeCreator</span> {</span> <span class="keyword">this</span>:Actor =&gt;
  <span class="keyword">import</span> RemoteBoxOfficeCreator._
  <span class="keyword">def</span> createPath:String = {
    s<span class="string">"$protocol://$systemName@$host:$port/$actorName"</span>
  }
  <span class="keyword">override</span> <span class="keyword">def</span> createBoxOffice = {
  <span class="keyword">val</span> path = createPathcontext.actorOf(Props(classOf[RemoteLookup],path),
      <span class="string">"lookupBoxOffice"</span>)
  }
}
</pre></td></tr></table></figure>

<p>The RemoteBoxOfficeCreator creates a separate RemoteLookup Actor to
lookup the boxOffice.</p>
<p>The RemoteLookup actor is a state machine that can only be in one of two
states we have defined: identify or active. It uses the become method to switch its
receive method to identify or active. The RemoteLookup tries to get a valid
ActorRef to the BoxOffice when it does not have one yet in the identify state or it
forwards all messages sent to a valid ActorRef to the BoxOffice in the active state.</p>
<p>If the RemoteLookup detects that the BoxOffice has been terminated it tries to get
a valid ActorRef again when it receives no messages for a while. We&#39;ll use Remote
Deathwatch for this. Sounds like something new but from the perspective of API
usage it&#39;s exactly the same thing as normal actor monitoring/watching.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.duration._

<span class="class"><span class="keyword">class</span> <span class="title">RemoteLookup</span><span class="params">(path:String)</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="comment">// Send a ReceiveTimeout message if no message has</span>
  <span class="comment">// been received for 3 seconds</span>
  context.setReceiveTimeout(<span class="number">3</span> seconds)
  sendIdentifyRequest()
  <span class="keyword">def</span> sendIdentifyRequest(): Unit = {
    <span class="keyword">val</span> selection = context.actorSelection(path)
    selection ! Identify(path)
  }

  <span class="comment">// The actor is initially in identify receive state</span>
  <span class="keyword">def</span> receive = identify

  <span class="keyword">def</span> identify: Receive = {
    <span class="keyword">case</span> ActorIdentity(`path`, Some(actor)) =&gt;
      <span class="comment">// No longer send a ReceiveTimeout if the actor</span>
      <span class="comment">// gets not messges since it is now active.</span>
      context.setReceiveTimeout(Duration.Undefined)
      log.info(<span class="string">"switching to active state"</span>)
      <span class="comment">// Change to active receive state</span>
      context.become(active(actor))
      context.watch(actor)
    <span class="keyword">case</span> ActorIdentity(`path`, None) =&gt;
      log.error(s<span class="string">"Remote actor with path $path is not available."</span>)
    <span class="keyword">case</span> ReceiveTimeout =&gt;
      sendIdentifyRequest()
    <span class="keyword">case</span> msg:Any =&gt;
      log.error(s<span class="string">"Ignoring message $msg, not ready yet."</span>)
  }

  <span class="keyword">def</span> active(actor: ActorRef): Receive = {
    <span class="keyword">case</span> Terminated(actorRef) =&gt;
      log.info(<span class="string">"Actor $actorRef terminated."</span>)
      context.become(identify)
      log.info(<span class="string">"switching to identify state"</span>)
      context.setReceiveTimeout(<span class="number">3</span> seconds)
      sendIdentifyRequest()
    <span class="keyword">case</span> msg:Any =&gt; actor forward msg
  }
}
</pre></td></tr></table></figure>

<h2 id="remote-deployment">Remote Deployment</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// creates <span class="operator">and</span> deploys <span class="operator">the</span> boxOffice remotely <span class="built_in">to</span> <span class="operator">the</span> backend <span class="keyword">as</span><span class="comment">
// well. The Props configuration object specifies a remote scope for deployment.</span>
val uri = <span class="string">"akka.tcp://backend@0.0.0.0:2552"</span>
val backendAddress = AddressFromURIString(uri)
val props = Props[BoxOffice].withDeploy( Deploy(scope = RemoteScope(backendAddress)) )
context.actorOf(props, <span class="string">"boxOffice"</span>)
</pre></td></tr></table></figure>

<p>When we use configured remote deployment all
we have to do is tell the frontend actor system that when an actor is created with
the path <code>/restInterface/boxOffice</code> it should not create it locally but
remotely.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>actor {
  provider = <span class="string">"akka.remote.RemoteActorRefProvider"</span>
  deployment {
    <span class="regexp">/restInterface/box</span>Office {
      remote = <span class="string">"akka.tcp://backend@0.0.0.0:2552"</span>
    }
  }
}
</pre></td></tr></table></figure>

<p>TODO</p>
<h1 id="configuration">Configuration</h1>
<p>Akka uses the Typesafe Config Library, which sports a pretty state-of-the-art set of
capabilities.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">val config </span>=<span class="string"> ConfigFactory.load()</span>
</pre></td></tr></table></figure>

<p>Since the library supports a number of different configuration formats,
it looks for different files, in the following order:</p>
<ul>
<li>application.properties</li>
<li>application.json</li>
<li>application.conf</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">// application.conf</span>
hostname=<span class="string">"localhost"</span>
<span class="comment">// If there is an env var, override, otherwise, leave it with the value we just assigned</span>
hostname=${?HOST_NAME}
MyAppl {
  <span class="keyword">version</span> = <span class="number">10</span>
  description = <span class="string">"My application"</span>
  database {
    connect=<span class="string">"jdbc:mysql://${hostname}/mydata"</span>
    user=<span class="string">"me"</span>
  }
}
</pre></td></tr></table></figure>

<p>usage</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">val</span> applicationVersion = config.getInt(<span class="string">"MyAppl.version"</span>)
<span class="keyword">val</span> databaseConnectSting = config.getString(<span class="string">"MyAppl.database.connect"</span>)
</pre></td></tr></table></figure>

<h2 id="using-defaults">Using Defaults</h2>
<p>The configuration library contains a fall-back mechanism;
the defaults are placed into a configuration object.</p>
<p>It to provide the defaults we need, we have to know how to configure them.
They are configured in the file reference.conf and placed in the root of the jar file; the idea is
that every library contains its own defaults.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// This way it doesn't try to load application.{conf,json,properties},</span>
<span class="comment">// but myapp.{conf,json,properties}</span>
<span class="keyword">val</span> config = ConfigFactory.load(<span class="string">"myapp"</span>)
</pre></td></tr></table></figure>

<p>Another option is to use system properties.
Sometimes, this is the easiest thing
because you can just create a bash script and set a property and the app will pick it
up and start using it</p>
<ul>
<li>config.resource specifies a resource name - not a base-name, i.e. application.conf not
application</li>
<li>config.file specifies a file system path, again it should include the extension</li>
<li>config.url specifies a URL</li>
</ul>
<h2 id="akka-configuration">Akka Configuration</h2>
<p>default configuration</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">val</span> system = ActorSystem(<span class="string">"mySystem"</span>)

<span class="comment">// supply the configuration while creating an ActorSystem</span>
<span class="keyword">val</span> configuration = ConfigFactory.load(<span class="string">"mysystem"</span>)
<span class="keyword">val</span> systemA = ActorSystem(<span class="string">"mysystem"</span>,configuration)

<span class="comment">//  it can be found in the settings of the ActorSystem.</span>
<span class="keyword">val</span> mySystem = ActorSystem(<span class="string">"myAppl"</span>)
<span class="comment">// Once the ActorSystem is constructed, we can get the config</span>
<span class="comment">// just by referencing it using this path</span>
<span class="keyword">val</span> config = mySystem.settings.config
<span class="keyword">val</span> applicationDescription = config.getString(<span class="string">"myAppl.name"</span>)
</pre></td></tr></table></figure>

<h2 id="mutiple-systems">Mutiple Systems</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// baseConfig.conf</span>
MyAppl {
  version = <span class="number">10</span>
  description = <span class="string">"My application"</span>
}

<span class="comment">// subAppl.conf</span>
<span class="keyword">include</span> <span class="string">"baseConfig"</span>
MyAppl {
  description = <span class="string">"Sub Application"</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>MyAppl {
  <span class="built_in">version</span> = <span class="number">10</span>
  description = <span class="string">"My application"</span>
}

subApplA {
  MyAppl {
    description = <span class="string">"Sub application"</span>
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">val</span> configuration = ConfigFactory.load(<span class="string">"combined"</span>)
<span class="keyword">val</span> subApplACfg = configuration.getConfig(<span class="string">"subApplA"</span>)
<span class="comment">// subApplA 覆盖 原始配置</span>
<span class="keyword">val</span> config = subApplACfg.withFallback(configuration)
</pre></td></tr></table></figure>

<h1 id="logging">Logging</h1>
<p>The Akka toolkit has implemented a logging adapter to be able to support all
kinds of logging frameworks and also minimize the dependencies on other
libraries. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> log = Logging(context.system, <span class="keyword">this</span>)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>akka {
  <span class="comment"># Event handlers to register at boot time</span>
  <span class="comment"># (Logging$DefaultLogger logs to STDOUT)</span>
  
  <span class="comment"># This eventHandler doesn't use a log framework,</span>
  <span class="comment"># but logs all the received messages to standard out.</span>
  event-handlers = [<span class="string">"akka.event.Logging<span class="variable">$DefaultLogger</span>"</span>]
  <span class="comment"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p>When you want to create your own eventhandler you
have to create an Actor which handles several messages. An example of such
handler is</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="reserved">import</span> akka.event.Logging.InitializeLogger
<span class="reserved">import</span> akka.event.Logging.LoggerInitialized
<span class="reserved">import</span> akka.event.Logging.Error
<span class="reserved">import</span> akka.event.Logging.Warning
<span class="reserved">import</span> akka.event.Logging.Info
<span class="reserved">import</span> akka.event.Logging.Debug
<span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">extends</span> <span class="title">Actor</span>{</span>
  def receive = {
    <span class="reserved">case</span> InitializeLogger<span class="function"><span class="params">(_)</span> =&gt;</span>
      sender ! LoggerInitialized
    <span class="reserved">case</span> Error<span class="function"><span class="params">(cause, logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"ERROR "</span> + message)
    <span class="reserved">case</span> Warning<span class="function"><span class="params">(logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"WARN "</span> + message)
    <span class="reserved">case</span> Info<span class="function"><span class="params">(logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"INFO "</span> + message)
    <span class="reserved">case</span> Debug<span class="function"><span class="params">(logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"DEBUG "</span> + message)
  }
}
</pre></td></tr></table></figure>

<p>The Akka toolkit has two
implementations of this logging eventHandler. The first is already mentioned and
that is the default logger to STDOUT. The second implementation is using SLF4J.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="preprocessor"># import akka-slf4j.jar.</span>
akka {
  <span class="keyword">event</span>-handlers = [<span class="string">"akka.event.slf4j.Slf4jEventHandler"</span>]
  <span class="preprocessor"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p>For convenience you can also use the ActorLogging trait to mix-in the log member into actors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  ...
}
</pre></td></tr></table></figure>

<p>The adapter also supports the ability to use placeholders in the message.
Placeholders prevent you from having to check logging levels.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">log</span>.debug(<span class="string">"two parameters: {}, {}"</span>, <span class="string">"one"</span>,<span class="string">"two"</span>)
</pre></td></tr></table></figure>

<h2 id="controlling-akka-s-logging">Controlling Akka&#39;s logging</h2>
<p>Akka provides a simple configuration layer that allows you to exert
some control over what it outputs to the log, and as we are both using the pubsub
attached to a single adapter, once we change these settings, we will see the results
in whatever our chosen appenders are.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>akka
{
  # logging must be <span class="operator"><span class="keyword">set</span> <span class="keyword">to</span> DEBUG <span class="keyword">to</span> use <span class="keyword">any</span> <span class="keyword">of</span> the options below
  loglevel = DEBUG
  
  # Log the complete configuration <span class="keyword">at</span> INFO <span class="keyword">level</span> <span class="keyword">when</span> the actor
  # system <span class="keyword">is</span> started. This <span class="keyword">is</span> useful <span class="keyword">when</span> you <span class="keyword">are</span> uncertain <span class="keyword">of</span>
  # what configuration <span class="keyword">is</span> used.
  log-config-<span class="keyword">on</span>-<span class="keyword">start</span> = <span class="keyword">on</span>
  debug {
    # logging <span class="keyword">of</span> <span class="keyword">all</span> <span class="keyword">user</span>-<span class="keyword">level</span> messages that <span class="keyword">are</span> processed <span class="keyword">by</span>
    # Actors that use akka.event.LoggingReceive enable function <span class="keyword">of</span>
    # LoggingReceive, which <span class="keyword">is</span> <span class="keyword">to</span> log <span class="keyword">any</span> received message <span class="keyword">at</span>
    # DEBUG <span class="keyword">level</span>
    receive = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> <span class="keyword">all</span> AutoReceiveMessages
    # (Kill, PoisonPill <span class="keyword">and</span> the <span class="keyword">like</span>)
    autoreceive = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> actor lifecycle changes
    # (restarts, deaths etc)
    lifecycle = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> <span class="keyword">all</span> LoggingFSMs <span class="keyword">for</span> events,
    # transitions <span class="keyword">and</span> timers
    fsm = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> subscription (subscribe/unsubscribe)
    # changes <span class="keyword">on</span> the eventStream
    event-stream = <span class="keyword">on</span>
  }
  remote {
    # <span class="keyword">If</span> this <span class="keyword">is</span> <span class="string">"on"</span>, Akka will log <span class="keyword">all</span> outbound messages <span class="keyword">at</span>
    # DEBUG <span class="keyword">level</span>, <span class="keyword">if</span> off <span class="keyword">then</span> they <span class="keyword">are</span> <span class="keyword">not</span> logged
    log-sent-messages = <span class="keyword">on</span>
    # <span class="keyword">If</span> this <span class="keyword">is</span> <span class="string">"on,"</span> Akka will log <span class="keyword">all</span> inbound messages <span class="keyword">at</span>
    # DEBUG <span class="keyword">level</span>, <span class="keyword">if</span> off <span class="keyword">then</span> they <span class="keyword">are</span> <span class="keyword">not</span> logged
    log-received-messages = <span class="keyword">on</span>
  }
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// Now when you set the property akka.debug.receive to on, the messages</span>
<span class="comment">// received by our actor will be logged.</span>
<span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">def</span> receive = LoggingReceive {
    <span class="keyword">case</span> ... =&gt; ...
  }
}
</pre></td></tr></table></figure>

<h1 id="deploying-stand-alone-application">Deploying Stand-alone application</h1>
<p>To create a stand alone application we use the MicroKernel of Akka combined
with the akka-plugin to create a distribution.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg:String =&gt;
      <span class="keyword">val</span> hello = <span class="string">"Hello %s"</span>.format(msg)
      sender ! hello
      log.info(<span class="string">"Sent response {}"</span>,hello)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCaller</span><span class="params">(timer:Duration, actor:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">TimerTick</span><span class="params">(msg:String)</span></span>
  <span class="comment">// Using the Akka scheduler to send messages to yourself</span>
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
    <span class="keyword">super</span>.preStart()
    context.system.scheduler.schedule(
      timer, <span class="comment">// The duration before the schedule is triggered for the first time</span>
      timer, <span class="comment">// The duration between the scheduled triggers</span>
      self,  <span class="comment">// The message which is sent</span>
      <span class="keyword">new</span> TimerTick(<span class="string">"everybody"</span>))
  }
  
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: String =&gt; log.info(<span class="string">"received {}"</span>,msg)
    <span class="keyword">case</span> tick: TimerTick =&gt; actor ! tick.msg
  }
}


<span class="keyword">import</span> akka.actor.{ Props, ActorSystem }
<span class="keyword">import</span> akka.kernel.Bootable
<span class="keyword">import</span> scala.concurrent.duration._
<span class="comment">// Extends the Bootable trait to be able to be called when starting the application</span>
<span class="class"><span class="keyword">class</span> <span class="title">BootHello</span> <span class="keyword">extends</span> <span class="title">Bootable</span> {</span>
  <span class="keyword">val</span> system = ActorSystem(<span class="string">"hellokernel"</span>)
  <span class="keyword">def</span> startup = {
    <span class="keyword">val</span> actor = system.actorOf(Props[HelloWorld])
    <span class="keyword">val</span> config = system.settings.config
    <span class="keyword">val</span> timer = config.getInt(<span class="string">"helloWorld.timer"</span>)
    system.actorOf(Props( <span class="keyword">new</span> HelloWorldCaller( timer millis, actor)))
  }
  <span class="keyword">def</span> shutdown = {
    system.shutdown()
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="preprocessor"># reference.conf</span>
helloWorld {
  timer=<span class="number">5000</span>
}
</pre></td></tr></table></figure>

<p>application.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>akka {
  <span class="keyword">event</span>-handlers = [<span class="string">"akka.event.slf4j.Slf4jEventHandler"</span>]
  <span class="preprocessor"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p><code>project/plugins.sbt</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>resolvers += <span class="string">"Typesafe Repository"</span> <span class="keyword">at</span> <span class="string">"http://repo.akka.io/releases/"</span>
addSbtPlugin(<span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-sbt-plugin"</span> % <span class="string">"2.0.1"</span>)
</pre></td></tr></table></figure>

<p><code>project/HelloKernelBuild.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="keyword">import</span> sbt._
<span class="keyword">import</span> Keys._
<span class="keyword">import</span> akka.sbt.AkkaKernelPlugin
<span class="keyword">import</span> akka.sbt.AkkaKernelPlugin.{ Dist, outputDirectory, distJvmOptions }
<span class="class"><span class="keyword">object</span> <span class="title">HelloKernelBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> HelloKernel = Project(
    id = <span class="string">"hello-kernel-book"</span>,
    base = file(<span class="string">"."</span>),
    settings = defaultSettings ++ AkkaKernelPlugin.distSettings ++ Seq(
      libraryDependencies ++= Dependencies.helloKernel,
      distJvmOptions in Dist := <span class="string">"-Xms256M -Xmx1024M"</span>,
      outputDirectory in Dist := file(<span class="string">"target/helloDist"</span>)
    )
  )
  
  <span class="keyword">lazy</span> <span class="keyword">val</span> buildSettings = Defaults.defaultSettings ++ Seq(
    organization := <span class="string">"com.manning"</span>,
    version := <span class="string">"0.1-SNAPSHOT"</span>,
    scalaVersion := <span class="string">"2.9.1"</span>,
    crossPaths := <span class="keyword">false</span>,
    organizationName := <span class="string">"Mannings"</span>,
    organizationHomepage := Some(url(<span class="string">"http://www.mannings.com"</span>))
  )
  
  <span class="keyword">lazy</span> <span class="keyword">val</span> defaultSettings = buildSettings ++ Seq(
    resolvers += <span class="string">"Typesafe Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,
    <span class="comment">// compile options</span>
    scalacOptions ++= Seq(<span class="string">"-encoding"</span>, <span class="string">"UTF-8"</span>,<span class="string">"-deprecation"</span>,<span class="string">"-unchecked"</span>),
    javacOptions ++= Seq(<span class="string">"-Xlint:unchecked"</span>,<span class="string">"-Xlint:deprecation"</span>)
  )
}
<span class="comment">// Dependencies</span>
<span class="class"><span class="keyword">object</span> <span class="title">Dependencies</span> {</span>
  <span class="keyword">import</span> Dependency._
  <span class="keyword">val</span> helloKernel = Seq(
    akkaActor, akkaKernel,
    akkaSlf4j, slf4jApi, slf4jLog4j,
    Test.junit, Test.scalatest, Test.akkaTestKit)
}
<span class="class"><span class="keyword">object</span> <span class="title">Dependency</span> {</span>
  <span class="comment">// Versions</span>
  <span class="class"><span class="keyword">object</span> <span class="title">V</span> {</span>
    <span class="keyword">val</span> Scalatest = <span class="string">"1.6.1"</span>
    <span class="keyword">val</span> Slf4j = <span class="string">"1.6.4"</span>
    <span class="keyword">val</span> Akka = <span class="string">"2.0"</span>
  }
  <span class="comment">// Compile</span>
  <span class="keyword">val</span> commonsCodec = <span class="string">"commons-codec"</span> % <span class="string">"commons-codec"</span>% <span class="string">"1.4"</span>
  <span class="keyword">val</span> commonsIo = <span class="string">"commons-io"</span> % <span class="string">"commons-io"</span> % <span class="string">"2.0.1"</span>
  <span class="keyword">val</span> commonsNet = <span class="string">"commons-net"</span> % <span class="string">"commons-net"</span> % <span class="string">"3.1"</span>
  <span class="keyword">val</span> slf4jApi = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-api"</span> % V.Slf4j
  <span class="keyword">val</span> slf4jLog4j = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-log4j12"</span>% V.Slf4j
  <span class="keyword">val</span> akkaActor = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-actor"</span> % V.Akka
  <span class="keyword">val</span> akkaKernel = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-kernel"</span> % V.Akka
  <span class="keyword">val</span> akkaSlf4j = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-slf4j"</span> % V.Akka
  <span class="keyword">val</span> scalatest = <span class="string">"org.scalatest"</span> %% <span class="string">"scalatest"</span> % V.Scalatest
  
  <span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
    <span class="keyword">val</span> junit = <span class="string">"junit"</span> % <span class="string">"junit"</span> % <span class="string">"4.5"</span> % <span class="string">"test"</span>
    <span class="keyword">val</span> scalatest = <span class="string">"org.scalatest"</span> %% <span class="string">"scalatest"</span> % V.Scalatest % <span class="string">"test"</span>
    <span class="keyword">val</span> akkaTestKit =<span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-testkit"</span> % V.Akka % <span class="string">"test"</span>
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sbt dist
</pre></td></tr></table></figure>

<p>After this, SBT has created a distribution in the directory <code>/target/helloDist</code>. This
directory contains 4 subdirectories</p>
<ul>
<li>bin, This contains the start script. One for windows and one for Unix</li>
<li>config, This directory contains the configuration files needed to run our application.</li>
<li>deploy, This directory is where our jar file placed</li>
<li>lib, This directory contains all the jar files our application depends upon.</li>
</ul>
<h2 id="akka-with-a-web-application">Akka with a web application</h2>
<p>There are a number of options for deploying Akka in a webapp,
we are showing play-mini because it is very simple and lightweight.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="comment">// Just by extending Application, we bring a lot of functionality in here.</span>
<span class="class"><span class="keyword">object</span> <span class="title">PlayMiniHello</span> <span class="keyword">extends</span> <span class="title">Application</span> {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> system = ActorSystem(<span class="string">"webhello"</span>)
  <span class="keyword">lazy</span> <span class="keyword">val</span> actor = system.actorOf(Props[HelloWorld])
  <span class="keyword">val</span> writeForm = Form(<span class="string">"name"</span> -&gt; text(<span class="number">1</span>,<span class="number">10</span>))
  
  <span class="keyword">def</span> route = {
    <span class="keyword">case</span> GET(Path(<span class="string">"/test"</span>)) =&gt; Action {
      Ok(<span class="string">"TEST @ %s\n"</span>.format(System.currentTimeMillis))
    }
    <span class="keyword">case</span> GET(Path(<span class="string">"/hello"</span>)) =&gt; Action { implicit request =&gt;
      <span class="keyword">val</span> name = <span class="keyword">try</span> {
        <span class="comment">// Bind our form to the implicit request and get the result</span>
        writeForm.bindFromRequest.get
      } <span class="keyword">catch</span> {
        <span class="keyword">case</span> ex:Exception =&gt; {
          log.warning(<span class="string">"no name specified"</span>)
          system.settings.config.getString(<span class="string">"helloWorld.name"</span>)
        }
      }
      <span class="comment">//  Instead of returning our response directly, we create an AsyncResult.</span>
      AsyncResult {
        <span class="comment">// Translate the AskTimeoutException into the string "Timeout"</span>
        <span class="keyword">val</span> resultFuture = actor ? name recover {
          <span class="keyword">case</span> ex:AskTimeoutException =&gt; <span class="string">"Timeout"</span>
          <span class="keyword">case</span> ex:Exception =&gt; {
            log.error(<span class="string">"recover from "</span>+ex.getMessage)
            <span class="string">"Exception:"</span> + ex.getMessage
          }
        }
        <span class="keyword">val</span> promise = resultFuture.asPromise
        promise.map {
          <span class="keyword">case</span> res:String =&gt; {
            Ok(res)
          }
          <span class="keyword">case</span> ex:Exception =&gt; {
            log.error(<span class="string">"Exception "</span>+ex.getMessage)
            Ok(ex.getMessage)
          }
          <span class="keyword">case</span> _ =&gt; {
            Ok(<span class="string">"Unexpected message"</span>)
          }
        }
      }
    }
  }
}

<span class="comment">//  This allows us to use the onStart and onStop methods</span>
<span class="comment">// which create and stop the Actor system.</span>
<span class="class"><span class="keyword">object</span> <span class="title">Global</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">typesafe</span>.<span class="title">play</span>.<span class="title">mini</span>.<span class="title">Setup</span><span class="params">(ch04.PlayMiniHello)</span></span>
</pre></td></tr></table></figure>

<p>reference.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="attribute">helloWorld {
  name</span>=<span class="string">world
}</span>
</pre></td></tr></table></figure>

<p>application.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>helloWorld {
  name=<span class="string">"world!!!"</span>
}
akka {
  <span class="keyword">event</span>-handlers = [<span class="string">"akka.event.slf4j.Slf4jEventHandler"</span>]
  <span class="preprocessor"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p>Build.scala</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>importimportimportsbt._
Keys._
PlayProject._
<span class="class"><span class="keyword">object</span> <span class="title">Build</span> <span class="keyword">extends</span> <span class="title">Build</span> {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> root = Project(id = <span class="string">"playminiHello"</span>,base = file(<span class="string">"."</span>), settings = Project.defaultSettings)
    .settings(
      resolvers += <span class="string">"Typesafe Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,
      resolvers += <span class="string">"Typesafe Snapshot Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/snapshots/"</span>,
      libraryDependencies ++= Dependencies.hello,
      mainClass in (Compile, run) := Some(<span class="string">"play.core.server.NettyServer"</span>))
}

<span class="class"><span class="keyword">object</span> <span class="title">Dependencies</span> {</span>
  <span class="keyword">import</span> Dependency._
  <span class="keyword">val</span> hello = Seq(akkaActor, akkaSlf4j, playmini)
  <span class="comment">// slf4jLog4j,</span>
}
<span class="class"><span class="keyword">object</span> <span class="title">Dependency</span> {</span>
  <span class="comment">// Versions</span>
  <span class="class"><span class="keyword">object</span> <span class="title">V</span> {</span>
    <span class="keyword">val</span> Slf4j =<span class="string">"1.6.4"</span>
    <span class="keyword">val</span> Akka  = <span class="string">"2.0"</span>
  }
  
  <span class="comment">// Compile</span>
  <span class="keyword">val</span> slf4jLog4j = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-log4j12"</span>% V.Slf4j
  <span class="keyword">val</span> akkaActor  = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-actor"</span> % V.Akka
  <span class="keyword">val</span> playmini   = <span class="string">"com.typesafe"</span> %% <span class="string">"play-mini"</span> % <span class="string">"2.0-RC3"</span>
  <span class="keyword">val</span> akkaSlf4j  =  <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-slf4j"</span> % V.Akka
}

<span class="comment">// sbt run</span>
<span class="comment">// At this moment the application is running and listening on port 9000</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Testing Actors & Fault tolerance]]></title>
    <link href="http://zhpooer.github.io/2014/08/03/akka-in-action-testing-actors/"/>
    <id>http://zhpooer.github.io/2014/08/03/akka-in-action-testing-actors/</id>
    <published>2014-08-03T07:20:54.000Z</published>
    <updated>2014-08-04T01:57:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="difficult-in-testing-actors">difficult in testing Actors</h1>
<ul>
<li>Timing - Sending messages is asynchronous, so it is difficult to know when
to assert expected values in the unit test.</li>
<li>Asynchronicity - Actors are meant to be run in parallel on several threads.</li>
<li>Statelessness - An actor hides its internal state and does not allow access to
this state.</li>
<li>Collaboration/Integraton - If you want to do an integration test of a couple
of actors, you would need to eavesdrop in between the actors to assert that
the messages have the expected values.</li>
</ul>
<h1 id="akka-testkit">akka-testkit</h1>
<p>Akka provides the akka-testkit module.The testkit module makes a
couple of different types of tests possible:</p>
<ul>
<li>Single threaded unit testing </li>
<li>Multi-threaded unit testing,  The testkit module provides the TestKit
and TestProbe classes, which make it possible to receive replies from
actors, inspect messages and set timing bounds for particular messages to
arrive.</li>
<li>Multiple JVM testing, comes in handy when you want to test remote actor systems.</li>
</ul>
<p>The TestKit has the TestActorRef extending the LocalActorRef class
and sets the dispatcher to a CallingThreadDispatcher that is built for
testing only.</p>
<h1 id="preparing-to-test">Preparing to Test</h1>
<p>The TestKit exposes a system value, which can be accessed
in the test to create actors and everything else you would like to do with the system.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">import</span> org.scalatest.{ Suite, BeforeAndAfterAll }
<span class="keyword">import</span> akka.testkit.TestKit

<span class="comment">// Stop the system after all tests are done</span>
<span class="class"><span class="keyword">trait</span> <span class="title">StopSystemAfterAll</span> <span class="keyword">extends</span> <span class="title">BeforeAndAfterAll</span> {</span>
  <span class="keyword">this</span>: TestKit <span class="keyword">with</span> Suite =&gt;
  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> afterAll() {
    <span class="keyword">super</span>.afterAll()
    system.shutdown()
  }
}
</pre></td></tr></table></figure>

<h1 id="one-way-messages">One-way messages</h1>
<p>There are a three variations that we will look at:</p>
<ul>
<li>SilentActor - An actor&#39;s behavior is not directly observable from the
outside, it might be an intermediate step that the actor takes to create some
internal state.</li>
<li>SendingActor - An actor sends a message to another actor (or possibly
many actors) after it is done processing the received message.</li>
<li>SideEffectingActor - An actor receives a message and interacts with a
normal object in some kind of way.</li>
</ul>
<h2 id="silentactor-examples">SilentActor Examples</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">SilentActorProtocol</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">SilentMessage</span><span class="params">(data: String)</span></span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">GetState</span><span class="params">(receiver: ActorRef)</span></span>
}
<span class="class"><span class="keyword">class</span> <span class="title">SilentActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">import</span> SilentActorProtocol._
  <span class="keyword">var</span> internalState = Vector[String]()
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> SilentMessage(data) =&gt;
      internalState = internalState :+ data
    <span class="keyword">case</span> GetState(receiver) =&gt; receiver ! internalState
  }
  <span class="keyword">def</span> state = internalState
}

<span class="class"><span class="keyword">class</span> <span class="title">SilentActor01Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(ActorSystem(<span class="string">"testsystem"</span>)</span>)</span>
    <span class="keyword">with</span> WordSpec         <span class="comment">// WordSpec provides an easy to read DSL for testing in the BDD style</span>
    <span class="keyword">with</span> MustMatchers     <span class="comment">// MustMatchers provides easy to read assertions</span>
    <span class="keyword">with</span> StopSystemAfterAll {
  <span class="comment">// MustMatchers provides easy to read assertions</span>
  <span class="string">"A Silent Actor"</span> must {
    <span class="string">"change state when it receives a message, single threaded"</span> in {
      <span class="keyword">import</span> SilentActorProtocol._
      <span class="keyword">val</span> silentActor = TestActorRef[SilentActor]
      silentActor ! SilentMessage(<span class="string">"whisper"</span>)
      <span class="comment">// Get the underlying actor and assert the state</span>
      silentActor.underlyingActor.state must (contain(<span class="string">"whisper"</span>))
    }
    
    <span class="string">"change state when it receives a message, multi-threaded"</span> in {
      <span class="keyword">import</span> SilentActorProtocol._
      <span class="keyword">val</span> silentActor = system.actorOf(Props[SilentActor], <span class="string">"s3"</span>)
      silentActor ! SilentMessage(<span class="string">"whisper1"</span>)
      silentActor ! SilentMessage(<span class="string">"whisper2"</span>)
      silentActor ! GetState(testActor)
      <span class="comment">// Used to check what message(s) have been sent to the testActor</span>
      expectMsg(Vector(<span class="string">"whisper1"</span>, <span class="string">"whisper2"</span>))
      
      <span class="comment">//Write the test, first fail</span>
      fail(<span class="string">"not implemented yet"</span>)
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="sendingactor-example">SendingActor Example</h2>
<p>Returning to our ticketing example from Chapter 1, we need to test the fact that
when we buy a Ticket to an Event , the count of available tickets is properly
decremented. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="string">"A Sending Actor"</span> must {
  <span class="string">"send a message to an actor when it has finished"</span> in {
    <span class="keyword">import</span> Kiosk01Protocol._
    <span class="keyword">val</span> props = Props(<span class="keyword">new</span> Kiosk01(testActor))
    <span class="keyword">val</span> sendingActor = system.actorOf(props, <span class="string">"kiosk1"</span>)
    <span class="keyword">val</span> tickets = Vector(Ticket(<span class="number">1</span>), Ticket(<span class="number">2</span>), Ticket(<span class="number">3</span>))
    <span class="keyword">val</span> game = Game(<span class="string">"Lakers vs Bulls"</span>, tickets)
    sendingActor ! game
    <span class="comment">// the testActor should receive one ticket less</span>
    <span class="comment">// expect Message Partial function</span>
    expectMsgPF() {
      <span class="keyword">case</span> Game(_, tickets) =&gt;
        tickets.size must be(game.tickets.size - <span class="number">1</span>)
    }
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Kiosk01Protocol</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Ticket</span><span class="params">(seat: Int)</span></span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Game</span><span class="params">(name: String, tickets: Seq[Ticket])</span></span>
}

<span class="class"><span class="keyword">class</span> <span class="title">Kiosk01</span><span class="params">(nextKiosk: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">import</span> Kiosk01Protocol._
  <span class="keyword">def</span> receive = {
  <span class="keyword">case</span> game @ Game(_, tickets) =&gt;
    nextKiosk ! game.copy(tickets = tickets.tail)
  }
}
</pre></td></tr></table></figure>

<p>Let&#39;s write a test for the FilteringActor. 
The FilteringActor that we are going to build should filter out
duplicate events.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="string">"filter out particular messages"</span> in {
  <span class="keyword">import</span> FilteringActorProtocol._
  <span class="keyword">val</span> props = Props(<span class="keyword">new</span> FilteringActor(testActor, <span class="number">5</span>))
  <span class="keyword">val</span> filter = system.actorOf(props, <span class="string">"filter-1"</span>)
  
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">2</span>)
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">3</span>)
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">4</span>)
  filter ! Event(<span class="number">5</span>)
  filter ! Event(<span class="number">5</span>)
  <span class="comment">//  Event(6) does not match the pattern in the case statement</span>
  filter ! Event(<span class="number">6</span>)
  
  <span class="comment">// The receiveWhile method returns the collected items as they are returned in</span>
  <span class="comment">// the partial function as a list, which is not allowed to have any duplicates. </span>
  <span class="keyword">val</span> eventIds = receiveWhile() {
    <span class="keyword">case</span> Event(id) <span class="keyword">if</span> id &lt;= <span class="number">5</span> =&gt; id
  }
  
  eventIds must be(List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))
  <span class="comment">// Assert that the duplicates are not in the result</span>
  expectMsg(Event(<span class="number">6</span>))
}



<span class="class"><span class="keyword">object</span> <span class="title">FilteringActorProtocol</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Event</span><span class="params">(id: Long)</span></span>
}

<span class="comment">// The oldest message that was received is discarded when a max</span>
<span class="comment">// bufferSize is reached to prevent the lastMessages list from growing too</span>
<span class="comment">// large and possibly causing us to run out of space.</span>

<span class="class"><span class="keyword">class</span> <span class="title">FilteringActor</span><span class="params">(nextActor: ActorRef,
      bufferSize: Int)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
    <span class="keyword">import</span> FilteringActorProtocol._
    <span class="keyword">var</span> lastMessages = Vector[Event]()
    <span class="keyword">def</span> receive = {
      <span class="keyword">case</span> msg: Event =&gt;
        <span class="keyword">if</span> (!lastMessages.contains(msg)) {
          lastMessages = lastMessages :+ msg
          nextActor ! msg
          <span class="keyword">if</span> (lastMessages.size &gt; bufferSize) {
            <span class="comment">// discard the oldest</span>
            lastMessages = lastMessages.tail
          }
        }
    }
}

<span class="string">"filter out particular messages using expectNoMsg"</span> in {
  <span class="keyword">import</span> FilteringActorProtocol._
  <span class="keyword">val</span> props = Props(<span class="keyword">new</span> FilteringActor(testActor, <span class="number">5</span>))
  <span class="keyword">val</span> filter = system.actorOf(props, <span class="string">"filter-2"</span>)
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">2</span>)
  expectMsg(Event(<span class="number">1</span>))
  expectMsg(Event(<span class="number">2</span>))
  filter ! Event(<span class="number">1</span>)
  expectNoMsg
  filter ! Event(<span class="number">3</span>)
  expectMsg(Event(<span class="number">3</span>))
  filter ! Event(<span class="number">1</span>)
  expectNoMsg
  filter ! Event(<span class="number">4</span>)
  filter ! Event(<span class="number">5</span>)
  filter ! Event(<span class="number">5</span>)
  expectMsg(Event(<span class="number">4</span>))
  expectMsg(Event(<span class="number">5</span>))
  expectNoMsg()
}
</pre></td></tr></table></figure>

<p>The TestProbe class is very much like the TestKit, only you
can use this class without having to extend from it.
Simply create a TestProbe with <code>TestProbe()</code> and start using it.</p>
<h2 id="sideeffectingactor-example">SideEffectingActor Example</h2>
<p>It does just one thing: its Greeter receives
a message and outputs it to the console.</p>
<p>The SideEffectingActor allows us to test scenarios such as these:
where the effect of the action is not directly accessible.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">import</span> Greeter01Test._
<span class="comment">// Create a system with a configuration that attaches a test event listener</span>
<span class="class"><span class="keyword">class</span> <span class="title">Greeter01Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(testSystem)</span></span>
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> StopSystemAfterAll {
  <span class="string">"The Greeter"</span> must {
    <span class="string">"say Hello World! when a Greeting("</span>World<span class="string">") is sent to it"</span> in {
      <span class="keyword">val</span> dispatcherId = CallingThreadDispatcher.Id
      <span class="comment">// Single threaded environment</span>
      <span class="keyword">val</span> props = Props[Greeter].withDispatcher(dispatcherId)
      <span class="keyword">val</span> greeter = system.actorOf(props)
      <span class="comment">// Intercept the log messages that were logged</span>
      EventFilter.info(message = <span class="string">"Hello World!"</span>, occurrences = <span class="number">1</span>).intercept {
        <span class="comment">// The filter is applied when the intercept code block is executed,</span>
        <span class="comment">// which is when we send the message.</span>
        greeter ! Greeting(<span class="string">"World"</span>)
      }
    }
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Greeter01Test</span> {</span>
  <span class="keyword">val</span> testSystem = {
    <span class="comment">// parse a configuration file from a String, in this case we only override the event handlers list.</span>
    <span class="keyword">val</span> config = ConfigFactory.parseString(<span class="string">"""akka.event-handlers = ["akka.testkit.TestEventListener"]"""</span>)
    ActorSystem(<span class="string">"testsystem"</span>, config)
  }
}

<span class="comment">// 注册一个监听器</span>
<span class="class"><span class="keyword">class</span> <span class="title">Greeter02</span><span class="params">(listener: Option[ActorRef] = None)</span></span>
    <span class="keyword">extends</span> Actor <span class="keyword">with</span> ActorLogging {
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> Greeting(who) =&gt;
      <span class="keyword">val</span> message = <span class="string">"Hello "</span> + who + <span class="string">"!"</span>
      log.info(message)
      listener.foreach(_ ! message)
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Greeter02Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(ActorSystem(<span class="string">"testsystem"</span>)</span>)</span>
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> StopSystemAfterAll {
    
  <span class="string">"The Greeter"</span> must {
    <span class="string">"say Hello World! when a Greeting("</span>World<span class="string">") is sent to it"</span> in {
      <span class="keyword">val</span> props = Props(<span class="keyword">new</span> Greeter02(Some(testActor)))
      <span class="keyword">val</span> greeter = system.actorOf(props, <span class="string">"greeter02-1"</span>)
      greeter ! Greeting(<span class="string">"World"</span>)
      expectMsg(<span class="string">"Hello World!"</span>)
    }
  <span class="string">"say something else and see what happens"</span> in {
      <span class="keyword">val</span> props = Props(<span class="keyword">new</span> Greeter02(Some(testActor)))
      <span class="keyword">val</span> greeter = system.actorOf(props, <span class="string">"greeter02-2"</span>)
      <span class="comment">// 获取没有处理的 信息</span>
      system.eventStream.subscribe(testActor, classOf[UnhandledMessage])
      greeter ! <span class="string">"World"</span>
      expectMsg(UnhandledMessage(<span class="string">"World"</span>, system.deadLetters, greeter))
    }
  }
}
</pre></td></tr></table></figure>

<h1 id="two-way-messages">Two-way messages</h1>
<p>Two-way messages are quite easy to test in a black box fashion, a request
should result in a response, which you can simply assert. In the following test we
will test an EchoActor , an actor that echoes any request back in a response.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="string">"Reply with the same message it receives without ask"</span> in {
  val <span class="keyword">echo</span> = system.actorOf(Props[EchoActor], <span class="string">"echo2"</span>)
  <span class="comment">// Call tell with the testActor as the sender</span>
  <span class="keyword">echo</span>.tell(<span class="string">"some message"</span>, testActor)
  expectMsg(<span class="string">"some message"</span>)
}

<span class="class"><span class="keyword">class</span> <span class="title">EchoActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  def receive = {
    <span class="keyword">case</span> msg =&gt;
      sender ! msg
  }
}
</pre></td></tr></table></figure>

<h1 id="what-is-fault-tolerance">What is fault tolerance</h1>
<p>A fault should be contained to a part of the system and not escalate to a total
crash.</p>
<p>Isolating a faulty component means that some structure needs to exist to
isolate it from; the system will need a defined structure in which active parts
can be isolated.</p>
<p>A backup component should be able to take over when a component fails.</p>
<p>If a faulty component can be isolated we can also replace it in the structure.
The other parts of the system should be able to communicate with the
replaced component just as they did before with the failed component.</p>
<p>If a component gets into an incorrect state, we need to have the ability to get
it back to a defined initial state. </p>
<p>A faulty component needs to be isolated and if it cannot recover it should be
terminated and removed from the system or re-initialized with a correct
starting state.</p>
<p>When a component fails we would like all calls to the component to be
suspended until the component is fixed or replaced so that when it is, the new
component can continue the work without dropping a beat.</p>
<p>It would be great if the fault recovery code could be separated from the
normal processing code. </p>
<h2 id="plain-old-objects-and-exceptions">Plain old objects and exceptions</h2>
<ul>
<li>Recreating objects and their dependencies and replacing these in the application structure
is not available as a first-class feature.</li>
<li>Objects communicate with each other directly so it is hard to isolate them.</li>
<li>The fault recovery code and the functional code are tangled up with each other.</li>
</ul>
<h2 id="let-it-crash">Let it crash</h2>
<p>Instead of using one flow to handle both normal code and recovery code Akka
provides two separate flows; one for normal logic and one for fault recovery logic.</p>
<p>The normal flow consists of actors that handle normal messages, the recovery flow
consists of actors that monitor the actors in the normal flow. Actors that monitor
other actors are called supervisors.</p>
<p>The actor code only contains normal processing logic and no error handling or fault
recovery logic, so its effectively not part of the recovery process, which keeps
things much clearer. The mailbox for a crashed actor is suspended until the
supervisor in the recovery flow has decided what to do with the exception.</p>
<p>Akka has chosen to enforce parental
supervision , meaning that any actor that creates actors automatically becomes the
supervisor of those actors.</p>
<p>The supervisor has 4 options when deciding what to do with the actor:</p>
<ul>
<li>Restart; the actor must be recreated from its Props. after it is restarted (or rebooted if you
will) the actor will continue to process messages. Since the rest of the application uses an
ActorRef to communicate with the actor the new actor instance will automatically get the
next messages.</li>
<li>Resume; the same actor instance should continue to process messages, the crash is
ignored.</li>
<li>Stop; the actor must be terminated. It will no longer take part in processing messages.</li>
<li>Escalate; the supervisor does not know what to do with it and escalates the problem to its
parent, which is also a supervisor.
<img src="/img/akka_recover.png" alt="Normal and recovery flow in the logs processing application"></li>
</ul>
<p>Akka chooses not to provide the failing message to the mailbox again after
a restart, but there is a way to do this yourself if you are absolutely sure that the
message did not cause the error, which we will discuss later.</p>
<h1 id="actor-life-cycle">Actor life-cycle</h1>
<p>During the life cycle of an actor there are three types of events:</p>
<ol>
<li>The actor is created and started, for simplicity we
will refer to this as the Start event.</li>
<li>The actor is restarted on the Restart event.</li>
<li>The actor is stopped by the Stop event.</li>
</ol>
<h2 id="start-event">Start event</h2>
<p>An actor is created and automatically started with the actorOf method. Top level
actors are created with the actorOf method on the ActorSystem . A parent actor
creates a child actor using the actorOf on its ActorContext .</p>
<p>The preStart hook is called just before the actor is started. To use this trigger we
have to override the preStart method.</p>
<h2 id="stop-event">Stop event</h2>
<p>An actor can be stopped using the stop method on the
ActorSystem and ActorContext objects, or by sending a PoisonPill
message to an actor.</p>
<p>The postStop hook is called just before the actor is terminated.</p>
<p>A stopped actor is disconnected from its ActorRef. After the actor is
stopped, the ActorRef is redirected to the deadLetters ActorRef of the actor
system, which is a special ActorRef that receives all messages that are sent to dead
actors.</p>
<h2 id="restart-event">Restart event</h2>
<p>When a restart occurs the preRestart method of the crashed actor instance
is called.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
  println(<span class="string">"preRestart"</span>)
  <span class="keyword">super</span>.preRestart(reason, message)
}
</pre></td></tr></table></figure>

<p>The default implementation of the
preRestart method stops all the child actors of the actor and then calls the
postStop hook. If you forget to call super.preRestart this default
behavior will not occur.</p>
<p>Remember that actors are (re)created from a Props
object. The Props object eventually calls the constructor of the actor.</p>
<p>A stopped actor is disconnected from its
ActorRef and redirected to the deadLetters ActorRef as described by the stop
event.</p>
<p>The preRestart method takes two arguments: the reason for the restart and
optionally the message that was being processed when the actor crashed. </p>
<p>The super.postRestart can be omitted if you are certain that you
don&#39;t want the preStart to be called when restarting, in most cases though this
is not going to be the case.</p>
<h2 id="putting-the-life-cycle-pieces-together">Putting the Life cycle Pieces Together</h2>
<p><img src="/img/akka_lifecycle.png" alt="akka_lifecycle"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">LifeCycleHooks</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span>{</span>
  System.out.println(<span class="string">"Constructor"</span>)
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {println(<span class="string">"preStart"</span>)}
  <span class="keyword">override</span> <span class="keyword">def</span> postStop() {println(<span class="string">"postStop"</span>)}
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
    println(<span class="string">"preRestart"</span>)
    <span class="keyword">super</span>.preRestart (reason, message)
  }
  <span class="keyword">override</span> <span class="keyword">def</span> postRestart(reason: Throwable) {
    println(<span class="string">"postRestart"</span>)
    <span class="keyword">super</span>.postRestart(reason)
  }
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> <span class="string">"restart"</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"force restart"</span>)
    <span class="keyword">case</span> msg: AnyRef =&gt; println(<span class="string">"Receive"</span>)
  }
}
</pre></td></tr></table></figure>

<h1 id="monitoring-the-lifecycle">Monitoring the lifecycle</h1>
<p>The supervision hierarchy is fixed for the lifetime of a child. Once the child is
created by the parent it will fall under the supervision of that parent as long as it
lives, there is no such thing as adoption in Akka.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">LogProcessingApp</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> sources = Vector(<span class="string">"file:///source1/"</span>, <span class="string">"file:///source2/"</span>)
  <span class="keyword">val</span> system = ActorSystem(<span class="string">"logprocessing"</span>)
  <span class="comment">// create the props and dependencies</span>
  <span class="keyword">val</span> con = <span class="keyword">new</span> DbCon(<span class="string">"http://mydatabase"</span>)
  <span class="keyword">val</span> writerProps = Props(<span class="keyword">new</span> DbWriter(con))
  <span class="keyword">val</span> dbSuperProps = Props(<span class="keyword">new</span> DbSupervisor(writerProps))
  <span class="keyword">val</span> logProcSuperProps = Props(<span class="keyword">new</span> LogProcSupervisor(dbSuperProps))
  <span class="keyword">val</span> topLevelProps = Props(<span class="keyword">new</span> FileWatchingSupervisor(
    sources,logProcSuperProps))
  system.actorOf(topLevelProps)
}
</pre></td></tr></table></figure>

<p>Props objects are passed as recipes to the actors so that
they can create their children without knowing the details of
the dependencies of the child actors.</p>
<h2 id="predefined-strategies">Predefined strategies</h2>
<p> There are two predefined strategies available in the
SupervisorStrategy object; the defaultStrategy and the
stoppingStrategy .</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">final</span> val defaultStrategy: SupervisorStrategy = {
  def defaultDecider: Decider = { <span class="comment">//</span>
    <span class="keyword">case</span> _: ActorInitializationException =&gt; Stop <span class="comment">//</span>
    <span class="keyword">case</span> _: ActorKilledException =&gt; Stop
    <span class="keyword">case</span> _: <span class="keyword">Exception</span> =&gt; Restart
  }
  OneForOneStrategy()(defaultDecider) <span class="comment">//</span>
}
</pre></td></tr></table></figure>

<p>In some cases you might want to only stop the child actor that failed.
In other cases you might want to stop all child actors if one of them fails, maybe because they all
depend on a particular resource.</p>
<p> The OneForOneStrategy determines that child actors will not share the
same fate, only the crashed child will be decided upon by the Decider. The other
option is to use an AllForOneStrategy which uses the same decision for all
child actors even if only one crashed.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>final val stoppingStrategy: SupervisorStrategy = {
  <span class="function"><span class="keyword">def</span> <span class="title">stoppingDecider</span>:</span> Decider = {
    case _: Exception =&gt; Stop //
  }
  OneForOneStrategy()(stoppingDecider)
}
</pre></td></tr></table></figure>

<h2 id="custom-strategies">Custom Strategies</h2>
<p>First we&#39;ll look at the exceptions that can occur in the log processing
application.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre></td><td class="code"><pre>@<span class="type">SerialVersionUID</span>(<span class="number">1</span>L)
// <span class="type">An</span> unrecoverable <span class="type">Error</span> that occurs when the disk for the source has crashed
<span class="class"><span class="keyword">class</span> <span class="type">DiskError</span><span class="container">(<span class="title">msg</span>: <span class="type">String</span>)</span> extends <span class="type">Error</span><span class="container">(<span class="title">msg</span>)</span> with <span class="type">Serializable</span>

@<span class="type">SerialVersionUID</span><span class="container">(1L)</span>
// <span class="type">An</span> <span class="type">Exception</span> that occurs when the log file is corrupt and cannot be processed.
<span class="keyword">class</span> <span class="type">CorruptedFileException</span><span class="container">(<span class="title">msg</span>: <span class="type">String</span>, <span class="title">val</span> <span class="title">file</span>: <span class="type">File</span>)</span>
  extends <span class="type">Exception</span><span class="container">(<span class="title">msg</span>)</span> with <span class="type">Serializable</span>
  
@<span class="type">SerialVersionUID</span><span class="container">(1L)</span>
// <span class="type">An</span> <span class="type">Exception</span> that occurs when the database connection is broken.
<span class="keyword">class</span> <span class="type">DbBrokenConnectionException</span><span class="container">(<span class="title">msg</span>: <span class="type">Striing</span>)</span>
  extends <span class="type">Exception</span><span class="container">(<span class="title">msg</span>)</span> with <span class="type">Serializable</span>


object <span class="type">LogProcessingProtocol</span> {
  // represents a new log file
  case <span class="keyword">class</span> <span class="type">LogFile</span><span class="container">(<span class="title">file</span>: <span class="type">File</span>)</span>
  // <span class="type">A</span> line in the log file parsed by the <span class="type">LogProcessor</span> <span class="type">Actor</span>
  case <span class="keyword">class</span> <span class="type">Line</span><span class="container">(<span class="title">time</span>: <span class="type">Long</span>, <span class="title">message</span>: <span class="type">String</span>, <span class="title">messageType</span>: <span class="type">String</span>)</span>
}

<span class="keyword">class</span> <span class="type">DbWriter</span><span class="container">(<span class="title">connection</span>: <span class="type">DbCon</span>)</span> extends <span class="type">Actor</span> {
  import <span class="type">LogProcessingProtocol</span>._
  def receive = {
    case <span class="type">Line</span><span class="container">(<span class="title">time</span>, <span class="title">message</span>, <span class="title">messageType</span>)</span> =&gt;
      connection.write<span class="container">(<span class="type">Map</span>('<span class="title">time</span> -&gt; <span class="title">time</span>,
        '<span class="title">message</span> -&gt; <span class="title">message</span>,
        '<span class="title">messageType</span> -&gt; <span class="title">messageType</span>)</span>)
  }
}

/// <span class="type">Send</span> the parsed lines to the dbSupervisor which in turn will forward the message
// to the dbWriter.
<span class="keyword">class</span> <span class="type">DbSupervisor</span><span class="container">(<span class="title">writerProps</span>: <span class="type">Props</span>)</span> extends <span class="type">Actor</span> {
  override def supervisorStrategy = <span class="type">OneForOneStrategy</span><span class="container">()</span> {
    case _: <span class="type">DbBrokenConnectionException</span> =&gt; <span class="type">Restart</span>
  }
  val writer = context.actorOf<span class="container">(<span class="title">writerProps</span>)</span>
  def receive = {
    case m =&gt; writer forward <span class="container">(<span class="title">m</span>)</span>
  }
}

<span class="keyword">class</span> <span class="type">LogProcessor</span><span class="container">(<span class="title">dbSupervisor</span>: <span class="type">ActorRef</span>)</span> extends <span class="type">Actor</span> with <span class="type">LogParsing</span> {
  import <span class="type">LogProcessingProtocol</span>._
  def receive = {
    case <span class="type">LogFile</span><span class="container">(<span class="title">file</span>)</span> =&gt;
      val lines = parse<span class="container">(<span class="title">file</span>)</span>
      lines.foreach<span class="container">(<span class="title">dbSupervisor</span> ! <span class="title">_</span>)</span>
  }
}


<span class="keyword">class</span> <span class="type">LogProcSupervisor</span><span class="container">(<span class="title">dbSupervisorProps</span>: <span class="type">Props</span>)</span>
    extends <span class="type">Actor</span> {
  override def supervisorStrategy = <span class="type">OneForOneStrategy</span><span class="container">()</span> {
    case _: <span class="type">CorruptedFileException</span> =&gt; <span class="type">Resume</span>
  }
  val dbSupervisor = context.actorOf<span class="container">(<span class="title">dbSupervisorProps</span>)</span>
  val logProcProps = <span class="type">Props</span><span class="container">(<span class="title">new</span> <span class="type">LogProcessor(dbSupervisor)</span>)</span>
  val logProcessor = context.actorOf<span class="container">(<span class="title">logProcProps</span>)</span>
  def receive = {
    case m =&gt; logProcessor forward <span class="container">(<span class="title">m</span>)</span>
  }
}

<span class="keyword">class</span> <span class="type">FileWatcher</span><span class="container">(<span class="title">sourceUri</span>: <span class="type">String</span>, <span class="title">logProcSupervisor</span>: <span class="type">ActorRef</span>)</span>
    extends <span class="type">Actor</span> with <span class="type">FileWatchingAbilities</span> {
  // <span class="type">Registers</span> on a source uri in the file watching <span class="type">API</span>.
  register<span class="container">(<span class="title">sourceUri</span>)</span>
  import <span class="type">FileWatcherProtocol</span>._
  import <span class="type">LogProcessingProtocol</span>._
  def receive = {
    case <span class="type">NewFile</span><span class="container">(<span class="title">file</span>, <span class="title">_</span>)</span> =&gt;
      logProcSupervisor ! <span class="type">LogFile</span><span class="container">(<span class="title">file</span>)</span>
    case <span class="type">SourceAbandoned</span><span class="container">(<span class="title">uri</span>)</span> if uri == sourceUri =&gt;
      self ! <span class="type">PoisonPill</span>
  }
}

<span class="keyword">class</span> <span class="type">FileWatchingSupervisor</span><span class="container">(<span class="title">sources</span>: <span class="type">Vector</span>[<span class="type">String</span>], <span class="title">logProcSuperProps</span>: <span class="type">Props</span>)</span>
    extends <span class="type">Actor</span> {
  var fileWatchers: <span class="type">Vector</span>[<span class="type">ActorRef</span>] = sources.map { source =&gt;
    val logProcSupervisor = context.actorOf<span class="container">(<span class="title">logProcSuperProps</span>)</span>
    //  <span class="type">Watch</span> the file watchers for termination.
    val fileWatcher = context.actorOf<span class="container">(<span class="type">Props</span>(
          <span class="title">new</span> <span class="type">FileWatcher</span>(<span class="title">source</span>, <span class="title">logProcSupervisor</span>)</span>))
    context.watch<span class="container">(<span class="title">fileWatcher</span>)</span>
    fileWatcher
  }
  override def supervisorStrategy = <span class="type">AllForOneStrategy</span><span class="container">()</span> {
    case _: <span class="type">DiskError</span> =&gt; <span class="type">Stop</span>
  }
  def receive = {
    case <span class="type">Terminated</span><span class="container">(<span class="title">fileWatcher</span>)</span> =&gt;
      fileWatchers = fileWatchers.filterNot<span class="container">(<span class="title">w</span> =&gt; <span class="title">w</span> == <span class="title">fileWatcher</span>)</span>
      if <span class="container">(<span class="title">fileWatchers</span>.<span class="title">isEmpty</span>)</span> self ! <span class="type">PoisonPill</span>
  }
}


<span class="keyword">class</span> <span class="type">DbImpatientSupervisor</span><span class="container">(<span class="title">writerProps</span>: <span class="type">Props</span>)</span> extends <span class="type">Actor</span> {
  // <span class="type">Escalate</span> the issue if the problem has not been resolved within 60 seconds or it has
  // failed to be solved within 5 restarts.
  override def supervisorStrategy = <span class="type">OneForOneStrategy</span><span class="container">(
      <span class="title">maxNrOfRetries</span> = 5,
      <span class="title">withinTimeRange</span> = 60 <span class="title">seconds</span>)</span> {
    case _: <span class="type">DbBrokenConnectionException</span> =&gt; <span class="type">Restart</span>
  }
  val writer = context.actorOf<span class="container">(<span class="title">writerProps</span>)</span>
  
  def receive = {
    case m =&gt; writer forward <span class="container">(<span class="title">m</span>)</span>
  }
}</span>
</pre></td></tr></table></figure>

<h1 id="futures">Futures</h1>
<p>TODO</p>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Introduce]]></title>
    <link href="http://zhpooer.github.io/2014/08/03/akka-in-action-introducing/"/>
    <id>http://zhpooer.github.io/2014/08/03/akka-in-action-introducing/</id>
    <published>2014-08-03T03:15:32.000Z</published>
    <updated>2014-08-03T14:19:47.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">启动案例</h1>
<p>Akka is based on the Actor programming model.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>git clone https://github<span class="preprocessor">.com</span>/RayRoestenburg/akka-<span class="keyword">in</span>-action<span class="preprocessor">.git</span>
sbt assembly
java -jar target/scala-<span class="number">2.10</span>/goticks-server<span class="preprocessor">.jar</span>
</pre></td></tr></table></figure>

<h1 id="-">模板</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>name <span class="symbol">:</span>= <span class="string">"goticks"</span>

version <span class="symbol">:</span>= <span class="string">"0.1-SNAPSHOT"</span>

organization <span class="symbol">:</span>= <span class="string">"com.goticks"</span>

scalaVersion <span class="symbol">:</span>= <span class="string">"2.10.0"</span>

resolvers ++=
  <span class="constant">Seq</span>(<span class="string">"repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,
    <span class="string">"Spray Repository"</span> at <span class="string">"http://repo.spray.io"</span>,
    <span class="string">"Spray Nightlies"</span> at <span class="string">"http://nightlies.spray.io/"</span>)

libraryDependencies ++= {
  val akkaVersion = <span class="string">"2.1.2"</span>
  val sprayVersion = <span class="string">"1.1-20130123"</span>
  <span class="constant">Seq</span>(
    <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-actor" %</span> akkaVersion,
    <span class="string">"io.spray"</span> % <span class="string">"spray-can"</span> % sprayVersion,
    <span class="string">"io.spray"</span> % <span class="string">"spray-routing"</span> % sprayVersion,
    <span class="string">"io.spray"</span> <span class="string">%% "spray-json" %</span> <span class="string">"1.2.3"</span>,
    <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-slf4j" %</span> akkaVersion,
    <span class="string">"ch.qos.logback"</span> % <span class="string">"logback-classic"</span> % <span class="string">"1.0.10"</span>,
    <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-testkit" %</span> akkaVersion % <span class="string">"test"</span>,
    <span class="string">"org.scalatest"</span> <span class="string">%% "scalatest" %</span> <span class="string">"1.9.1"</span> % <span class="string">"test"</span>
  )
}
</pre></td></tr></table></figure>

<h1 id="goticks-com">GoTicks.com</h1>
<p>Our ticket selling service which will allow customers to buy tickets to all sorts of
events, concerts, sports games and the like.</p>
<p>Once all the tickets are sold for an event the server should respond with a 404 (Not
Found) HTTP status code.</p>
<p>REST API</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>Http Method</th>
<th>URL</th>
<th>Body</th>
<th>Response exammple</th>
</tr>
</thead>
<tbody>
<tr>
<td>create an event with a number of tickets</td>
<td>PUT</td>
<td>/events</td>
<td>{event:rhcp, nrOfTickets:250}</td>
<td>Http 200 OK</td>
</tr>
<tr>
<td>Get an overview of all events and the number of tickets available.</td>
<td>GET</td>
<td>/events</td>
<td></td>
<td>[ { event : &quot;RHCP&quot;, nrOfTickets : 249}, { event : &quot;Radiohead&quot;, nrOfTickets : 130}, ]</td>
</tr>
<tr>
<td>Buy a ticket</td>
<td>GET</td>
<td>/ticket/:eventName</td>
<td></td>
<td>{ event: &quot;RHCP&quot;, nr: 1 } or HTTP 404</td>
</tr>
</tbody>
</table>
<p>启动服务器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sbt <span class="command">run</span>
</pre></td></tr></table></figure>

<h1 id="structure-of-the-app">Structure of the App</h1>
<p><img src="/img/akka_buy_tickets.png" alt="Structure of the App"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">package</span> com.goticks
<span class="keyword">import</span> spray.can.server.SprayCanHttpServerApp
<span class="keyword">import</span> akka.actor.Props
<span class="keyword">import</span> com.typesafe.config.ConfigFactory
<span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> <span class="keyword">with</span> <span class="title">SprayCanHttpServerApp</span> {</span>
  <span class="keyword">val</span> config = ConfigFactory.load()
  <span class="keyword">val</span> host = config.getString(<span class="string">"http.host"</span>)
  <span class="keyword">val</span> port = config.getInt(<span class="string">"http.port"</span>)
  <span class="keyword">val</span> api = system.actorOf(
    Props(<span class="keyword">new</span> RestInterface()),
    <span class="string">"httpInterface"</span>
  )
  newHttpServer(api) ! Bind(interface = host, port = port)
}
</pre></td></tr></table></figure>

<p>REST Interface Message Classes</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">// Message to create an event</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Event</span><span class="params">(event:String, nrOfTickets:Int)</span></span>
<span class="comment">// Message for requesting the state of all events</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GetEvents</span></span>
<span class="comment">// Response message that contains current status of all events</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Events</span><span class="params">(events:List[Event])</span></span>
<span class="comment">// Signal event to indicate an event was created</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">EventCreated</span></span>
<span class="comment">// Request for a ticket for a particular event</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">TicketRequest</span><span class="params">(event:String)</span></span>
<span class="comment">// Signal event that the event is sold out</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SoldOut</span></span>
<span class="comment">// New tickets for an Event, created by BoxOffice</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Tickets</span><span class="params">(tickets:List[Ticket])</span></span>
<span class="comment">// Message to buy a ticket from the TicketSeller</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">BuyTicket</span></span>
<span class="comment">// The numbered ticket to an event</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Ticket</span><span class="params">(event:String, nr:Int)</span></span>
</pre></td></tr></table></figure>

<p>Akka is going to get
these parts to go together with immutable messages, so the Actors have to be
designed to get all the information they need, and produce all that is needed if they
enlist any collaborators. </p>
<h2 id="the-actor-that-handles-the-sale-ticketseller">The Actor that handles the sale: TicketSeller</h2>
<p>The TicketSeller is created by the BoxOffice and just simply keeps a list of tickets.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>package com.goticks
import akka.actor.{PoisonPill, Actor}
<span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  import TicketProtocol._
  <span class="keyword">var</span> tickets = Vector[Ticket]()
  def receive = {
    <span class="keyword">case</span> GetEvents =&gt; sender ! tickets.size
    <span class="keyword">case</span> Tickets(newTickets) =&gt;
      tickets = tickets ++ newTickets
    <span class="keyword">case</span> BuyTicket =&gt;
      <span class="keyword">if</span> (tickets.isEmpty) {
        sender ! SoldOut
        <span class="comment">// cleans up the actor </span>
        <span class="keyword">self</span> ! PoisonPill
      }
      tickets.headOption.<span class="keyword">foreach</span> { ticket =&gt;
        tickets = tickets.tail
        sender ! ticket
      }

  }
}
</pre></td></tr></table></figure>

<h2 id="boxoffice">BoxOffice</h2>
<p>The BoxOffice needs to create TicketSeller children for every event and delegates
the selling to them.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="regexp">//</span> create Event
<span class="reserved">case</span> Event<span class="function"><span class="params">(name, nrOfTickets)</span> =&gt;</span>
  <span class="regexp">//</span> If TicketSellers have <span class="keyword">not</span> been created already
  <span class="keyword">if</span>(context.child(name).isEmpty) {
    <span class="regexp">//</span> create the actor
    val ticketSeller = context.actorOf(Props[TicketSeller], name)
    val tickets = Tickets((<span class="number">1</span> to nrOfTickets).map{
      nr=&gt; Ticket(name, nr)).toList
    }
    ticketSeller ! tickets
  }
  sender ! EventCreated
<span class="regexp">//</span> buy ticket
<span class="reserved">case</span> TicketRequest<span class="function"><span class="params">(name)</span> =&gt;</span>
  context.child(name) match {
    <span class="reserved">case</span> Some<span class="function"><span class="params">(ticketSeller)</span> =&gt;</span> ticketSeller.forward(BuyTicket)
    <span class="reserved">case</span> None<span class="function"> =&gt;</span> sender ! SoldOut
  }
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.pattern.ask
val capturedSender = sender

<span class="function"><span class="keyword">def</span> <span class="title">askEvent</span><span class="params">(ticketSeller:ActorRef)</span>:</span> Future[Event] = {
  val futureInt = ticketSeller.ask(GetEvents).mapTo[Int]
  futureInt.map { nrOfTickets =&gt;
    Event(ticketSeller.actorRef.path.name, nrOfTickets)
  }
}

val futures = context.children.map { ticketSeller =&gt;
  askEvent(ticketSeller)
}

// sends an Events message back to the sender once all responses
// have been handled.
Future.sequence(futures).map { events =&gt;
  capturedSender ! Events(events.toList)
}
</pre></td></tr></table></figure>

<h2 id="rest-interface">REST Interface</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>// <span class="type">Creation</span> <span class="keyword">of</span> the <span class="type">BoxOffice</span> <span class="type">Actor</span>
<span class="title">val</span> <span class="type">BoxOffice</span> = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>])

// stays around for the lifetime <span class="keyword">of</span> the <span class="type">HTTP</span> request
<span class="title">def</span> createResponder(requestContext:<span class="type">RequestContext</span>) = {
  context.actorOf(<span class="type">Props</span>(new <span class="type">Responder</span>(requestContext, <span class="type">BoxOffice</span>)))
}

//  a snippet <span class="keyword">of</span> the <span class="type">DSL</span> that is used to handle <span class="type">HTTP</span> requests:
<span class="title">path</span>(<span class="string">"ticket"</span>) {
  get {
      entity(<span class="keyword">as</span>[<span class="type">TicketRequest</span>]) { ticketRequest =&gt; requestContext =&gt;
        val responder = createResponder(requestContext)
        <span class="type">BoxOffice</span>.ask(ticketRequest).pipeTo(responder)
    }
  }
}
<span class="class">
<span class="keyword">class</span> <span class="type">Responder</span><span class="container">(<span class="title">requestContext</span>:<span class="type">RequestContext</span>, <span class="type">BoxOffice</span>:<span class="type">ActorRef</span>)</span>
    extends <span class="type">Actor</span> with <span class="type">ActorLogging</span> {
  import <span class="type">TicketProtocol</span>._
  import spray.httpx.<span class="type">SprayJsonSupport</span>._
  
  def receive = {
    case ticket:<span class="type">Ticket</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">OK</span>, <span class="title">ticket</span>)</span>
      self ! <span class="type">PoisonPill</span>
    case <span class="type">EventCreated</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">OK</span>)</span>
      self ! <span class="type">PoisonPill</span>
    case <span class="type">SoldOut</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">NotFound</span>)</span>
      self ! <span class="type">PoisonPill</span>
    case <span class="type">Events</span><span class="container">(<span class="title">events</span>)</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">OK</span>, <span class="title">events</span>)</span>
      self ! <span class="type">PoisonPill</span>
  }
}</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="Akka" scheme="http://zhpooer.github.io/tags/Akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim spf13 快捷键小记]]></title>
    <link href="http://zhpooer.github.io/2014/08/02/vim-%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%B0%8F%E8%AE%A1/"/>
    <id>http://zhpooer.github.io/2014/08/02/vim-快捷键小计/</id>
    <published>2014-08-02T13:31:16.000Z</published>
    <updated>2014-08-03T02:08:48.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://vim.spf13.com/" target="_blank">spf13 intro</a></p>
<p><a href="http://coolshell.cn/articles/5426.html" target="_blank">简明vim攻略</a></p>
<p><a href="http://coolshell.cn/articles/1679.html" target="_blank">vim分屏功能</a></p>
<p><a href="http://coolshell.cn/articles/11312.html" target="_blank">无插件vim编程技巧</a></p>
<p>Toggle comments using <code>&lt;Leader&gt;c&lt;space&gt;</code></p>
<p>mechanism to load files from the file system <code>&lt;c-p&gt;</code></p>
<p>Use <code>&lt;C-E&gt;</code> to toggle NERDTree</p>
<p>Use <code>&lt;leader&gt;e</code> or <code>&lt;leader&gt;nt</code> to load NERDTreeFind</p>
<p><code>&lt;leader&gt;gs</code> :Gstatus</p>
<p><code>&lt;leader&gt;gd</code> :Gdiff</p>
<p><code>&lt;leader&gt;gc</code> :Gcommit</p>
<p><code>&lt;leader&gt;gb</code> :Gblame</p>
<p><code>&lt;leader&gt;gl</code> :Glog</p>
<p><code>&lt;leader&gt;gp</code> :Git push</p>
<p><code>&lt;Leader&gt;a=</code> :Tabularize /=</p>
<p><code>&lt;Leader&gt;a:</code> :Tabularize /:</p>
<p><code>&lt;Leader&gt;a:</code>: :Tabularize /:\zs</p>
<p><code>&lt;Leader&gt;a,</code> :Tabularize /,</p>
<p><code>&lt;Leader&gt;a&lt;Bar&gt;</code> :Tabularize /</p>
<p>EasyMotion is triggered using the normal movements, but prefixing them with <code>,,w</code></p>
<p><code>map &lt;leader&gt;tn :tabnew&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;to :tabonly&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;tc :tabclose&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;tm :tabmove</code></p>
<p><code>map &lt;leader&gt;te :tabedit &lt;c-r&gt;=expand(&quot;%:p:h&quot;)&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;cd :cd %:p:h&lt;cr&gt;:pwd&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;g :vimgrep // **/*.&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;</code></p>
<p><code>map &lt;leader&gt;&lt;space&gt; :vimgrep // &lt;C-R&gt;%&lt;C-A&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;</code></p>
<p>关闭当前窗口 <code>Ctrl+W c</code></p>
<p>关闭当前窗口，如果只剩最后一个了，则退出Vim <code>Ctrl+W q</code></p>
<p>让所有的屏都有一样的高度 <code>Ctrl+W =</code></p>
<p>增加高度 <code>Ctrl+W +</code></p>
<p>减少高度。 <code>Ctrl+W -</code></p>
<p>宽度你可以使用 <code>[Ctrl+W &lt;]</code>或是<code>[Ctrl+W &gt;]</code></p>
<p>buffernext <code>:bn</code> bufferprevious <code>:bp</code></p>
]]></content>
    
    
      <category term="vim" scheme="http://zhpooer.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[learning scalaz 进阶3]]></title>
    <link href="http://zhpooer.github.io/2014/07/30/learning-scalaz-%E8%BF%9B%E9%98%B63/"/>
    <id>http://zhpooer.github.io/2014/07/30/learning-scalaz-进阶3/</id>
    <published>2014-07-30T06:43:47.000Z</published>
    <updated>2014-08-01T02:51:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="origami-programming">Origami programming</h1>
<p>The dual of folding is unfolding.
The Haskell standard List library deﬁnes
the function unfoldr for generating lists.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Prelude <span class="built_in">Data</span><span class="built_in">.</span><span class="built_in">List</span><span class="subst">&gt;</span> unfoldr (<span class="subst">\</span>b <span class="subst">-&gt; </span><span class="keyword">if</span> b <span class="subst">==</span> <span class="number">0</span> then Nothing <span class="keyword">else</span> Just (b, b<span class="subst">-</span><span class="number">1</span>)) <span class="number">10</span>
<span class="preprocessor">[</span><span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span><span class="preprocessor">]</span><span class="markup"></span>
</pre></td></tr></table></figure>

<h2 id="dlist">DList</h2>
<p>There’s a data structure called DList that supports <code>DList.unfoldr</code>.
DList, or difference list, is a data structure that supports
constant-time appending.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; DList.unfoldr<span class="function"><span class="params">(<span class="number">10</span>, { (x: Int) =&gt; <span class="keyword">if</span> (x == <span class="number">0</span>) none <span class="keyword">else</span> (x, x - <span class="number">1</span>).some })</span>
<span class="title">res50</span>: <span class="title">scalaz</span>.<span class="title">DList</span>[<span class="title">Int</span>] = <span class="title">scalaz</span>.<span class="title">DListFunctions$$anon$3</span>@70627153

<span class="title">scala</span>&gt; <span class="title">res50</span>.<span class="title">toList</span>
<span class="title">res51</span>: <span class="title">List</span>[<span class="title">Int</span>] = <span class="title">List</span><span class="params">(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span></span>
</pre></td></tr></table></figure>

<h2 id="folds-for-streams">Folds for Streams</h2>
<p>In Scalaz unfold defined in StreamFunctions is introduced by <code>import Scalaz._</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; unfold<span class="function"><span class="params">(<span class="number">10</span>)</span> { <span class="params">(x)</span> =&gt;</span> <span class="keyword">if</span> (x == <span class="number">0</span>) none <span class="keyword">else</span> (x, x - <span class="number">1</span>).some }
<span class="attribute">res36</span>: Stream[Int] = Stream(<span class="number">10</span>, ?)

scala&gt; res36.toList
<span class="attribute">res37</span>: List[Int] = List(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)
</pre></td></tr></table></figure>

<h2 id="the-essence-of-the-iterator-pattern">The Essence of the Iterator Pattern</h2>
<p>In 2006 the same author wrote <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf" target="_blank">The Essence of the Iterator Pattern</a>.
This paper discusses applicative style by breaking down the GoF Iterator
pattern into two aspects: mapping and accumulating.</p>
<h2 id="monoidal-applicatives">Monoidal applicatives</h2>
<p>Scalaz implements Monoid[m].applicative to turn any monoids into
an applicative.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; Monoid[Int]<span class="preprocessor">.applicative</span><span class="preprocessor">.ap</span>2(<span class="number">1</span>, <span class="number">1</span>)(<span class="number">0</span>)
<span class="label">res99:</span> Int = <span class="number">2</span>

scala&gt; Monoid[List[Int]]<span class="preprocessor">.applicative</span><span class="preprocessor">.ap</span>2(List(<span class="number">1</span>), List(<span class="number">1</span>))(Nil)
<span class="label">res100:</span> List[Int] = List(<span class="number">1</span>, <span class="number">1</span>)
</pre></td></tr></table></figure>

<h2 id="combining-applicative-functors">Combining applicative functors</h2>
<p>Like monads, applicative functors are closed under products;
so two independent idiomatic effects can generally be fused into one,
their product.</p>
<p>In Scalaz, product is implemented under Applicative typeclass</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; Applicative[<span class="keyword">List</span>].product[Option]
res0: scalaz.Applicative[[α](<span class="keyword">List</span>[α], Option[α])] = scalaz.Applicative$$anon$<span class="number">2</span>@<span class="number">211</span>b3c6a

scala&gt; Applicative[<span class="keyword">List</span>].product[Option].point(<span class="number">1</span>)
res1: (<span class="keyword">List</span>[Int], Option[Int]) = (<span class="keyword">List</span>(<span class="number">1</span>),Some(<span class="number">1</span>))

// The product seems to be implemented as a Tuple2. 
scala&gt; ((<span class="keyword">List</span>(<span class="number">1</span>), <span class="number">1.</span>some) |@| (<span class="keyword">List</span>(<span class="number">1</span>), <span class="number">1.</span>some)) <span class="list">{_ |+| _}</span>
res2: (<span class="keyword">List</span>[Int], Option[Int]) = (<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">1</span>),Some(<span class="number">2</span>))

scala&gt; ((<span class="keyword">List</span>(<span class="number">1</span>), <span class="number">1.</span>success[<span class="keyword">String</span>]) |@| (<span class="keyword">List</span>(<span class="number">1</span>), <span class="string">"boom"</span>.failure[Int])) <span class="list">{_ |+| _}</span>
res6: (<span class="keyword">List</span>[Int], scalaz.Validation[<span class="keyword">String</span>,Int]) = (<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">1</span>),Failure(boom))
</pre></td></tr></table></figure>

<p>two sequentially-dependent idiomatic effects
can generally be fused into one, their composition.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Applicative</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Apply</span>[<span class="title">F</span>] <span class="keyword">with</span> <span class="title">Pointed</span>[<span class="title">F</span>] {</span> self =&gt;
...
  <span class="javadoc">/**The composition of Applicatives `F` and `G`, `[x]F[G[x]]`, is an Applicative */</span>
  <span class="keyword">def</span> compose[G[_]](implicit G0: Applicative[G]): Applicative[({<span class="keyword">type</span> λ[α] = F[G[α]]})#λ] = <span class="keyword">new</span> CompositionApplicative[F, G] {
    implicit <span class="keyword">def</span> F = self
    implicit <span class="keyword">def</span> G = G0
  }
...
}

scala&gt; Applicative[List].compose[Option]
res7: scalaz.Applicative[[α]List[Option[α]]] = scalaz.Applicative$$anon$<span class="number">1</span>@<span class="number">461800</span>f1

scala&gt; Applicative[List].compose[Option].point(<span class="number">1</span>)
res8: List[Option[Int]] = List(Some(<span class="number">1</span>))
</pre></td></tr></table></figure>

<h2 id="idiomatic-traversal">Idiomatic traversal</h2>
<p>The corresponding typeclass in Scalaz 7 is called Traverse:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Traverse</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Functor</span>[<span class="title">F</span>] <span class="keyword">with</span> <span class="title">Foldable</span>[<span class="title">F</span>] {</span> self =&gt;
  <span class="keyword">def</span> traverseImpl[G[_]:Applicative,A,B](fa: F[A])(f: A =&gt; G[B]): G[F[B]]
}

<span class="class"><span class="keyword">trait</span> <span class="title">TraverseOps</span>[<span class="title">F</span>[<span class="title">_</span>],<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">Ops</span>[<span class="title">F</span>[<span class="title">A</span>]] {</span>
  <span class="keyword">final</span> <span class="keyword">def</span> traverse[G[_], B](f: A =&gt; G[B])(implicit G: Applicative[G]): G[F[B]] =
    G.traverse(self)(f)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) traverse <span class="list">{ x =&gt; (x &gt; 0) option (x + 1) }</span>
res14: Option[<span class="keyword">List</span>[Int]] = Some(<span class="keyword">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))

scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>) traverse <span class="list">{ x =&gt; (x &gt; 0) option (x + 1) }</span>
res15: Option[<span class="keyword">List</span>[Int]] = <span class="keyword">None</span>
</pre></td></tr></table></figure>

<h2 id="sequence">sequence</h2>
<p>There’s a useful method that Traverse introduces called sequence.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>/<span class="emphasis">** Traverse with the identity function *</span>/
final def sequence[<span class="link_label">G[_</span>], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {
  val fgb: F[<span class="link_label">G[B</span>]] = ev.subst[<span class="link_label">F</span>](<span class="link_url">self</span>)
  F.sequence(fgb)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">List</span>(<span class="number">1.</span>some, <span class="number">2.</span>some).sequence
res156: Option[<span class="keyword">List</span>[Int]] = Some(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>))

scala&gt; <span class="keyword">List</span>(<span class="number">1.</span>some, <span class="number">2.</span>some, none).sequence
res157: Option[<span class="keyword">List</span>[Int]] = <span class="keyword">None</span>
</pre></td></tr></table></figure>

<h1 id="import-guide">import guide</h1>
<p>In Scala, imports are used for two purposes:</p>
<ol>
<li>To include names of values and types into the scope.</li>
<li>To include implicits into the scope.</li>
</ol>
<h2 id="import-scalaz-_">import scalaz._</h2>
<ol>
<li>First, the names. Typeclasses like <code>Equal[A]</code> and <code>Functor[F[_]]</code>
are implemented as trait,
and are defined under scalaz package.</li>
<li>also the names, but type aliases. scalaz’s package object
declares most of the major type aliases like <code>@@[T, Tag]</code> and <code>Reader[E, A]</code>,
which is treated as a specialization of ReaderT transformer.</li>
<li>idInstance is defined as typeclass instance of <code>Id[A]</code> for <code>Traverse[F[_]]</code>, <code>Monad[F[_]]</code></li>
</ol>
<h2 id="import-scalaz-_">import Scalaz._</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz

object Scalaz
  extends StateFunctions        // Functions related <span class="keyword">to</span> the state monad
  <span class="keyword">with</span> syntax.ToTypeClassOps    // syntax associated <span class="keyword">with</span> <span class="keyword">type</span> classes
  <span class="keyword">with</span> syntax.ToDataOps         // syntax associated <span class="keyword">with</span> Scalaz data structures
  <span class="keyword">with</span> std.AllInstances         // <span class="keyword">Type</span> class instances <span class="keyword">for</span> the standard <span class="keyword">library</span> types
  <span class="keyword">with</span> std.AllFunctions         // Functions related <span class="keyword">to</span> standard <span class="keyword">library</span> types
  <span class="keyword">with</span> syntax.std.ToAllStdOps   // syntax associated <span class="keyword">with</span> standard <span class="keyword">library</span> types
  <span class="keyword">with</span> IdInstances              // Identity <span class="keyword">type</span> <span class="keyword">and</span> instances
</pre></td></tr></table></figure>

<h3 id="statefunctions">StateFunctions</h3>
<p>Remember, import brings in names and implicits. First, the names.
StateFunctions defines several functions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>package scalaz

trait StateFunctions {
  <span class="function"><span class="keyword">def</span> <span class="title">constantState</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A, s: =&gt; S)</span>:</span> State[S, A] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">state</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A)</span>:</span> State[S, A] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">init</span>[<span class="title">S</span>]:</span> State[S, S] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">get</span>[<span class="title">S</span>]:</span> State[S, S] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">gets</span>[<span class="title">S</span>, <span class="title">T</span>]<span class="params">(f: S =&gt; T)</span>:</span> State[S, T] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">put</span>[<span class="title">S</span>]<span class="params">(s: S)</span>:</span> State[S, Unit] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">modify</span>[<span class="title">S</span>]<span class="params">(f: S =&gt; S)</span>:</span> State[S, Unit] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">delta</span>[<span class="title">A</span>]<span class="params">(a: A)</span><span class="params">(implicit A: Group[A])</span>:</span> State[A, A] = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">for</span> {
  xs &lt;- <span class="keyword">get</span>[List[Int]]
  _ &lt;- put(xs.tail)
} <span class="keyword">yield</span> xs.head
</pre></td></tr></table></figure>

<h3 id="std-allfunctions">std.AllFunctions</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz
<span class="keyword">package</span> std

<span class="class"><span class="keyword">trait</span> <span class="title">AllFunctions</span></span>
  <span class="keyword">extends</span> ListFunctions
  <span class="keyword">with</span> OptionFunctions
  <span class="keyword">with</span> StreamFunctions
  <span class="keyword">with</span> math.OrderingFunctions
  <span class="keyword">with</span> StringFunctions

<span class="class"><span class="keyword">object</span> <span class="title">AllFunctions</span> <span class="keyword">extends</span> <span class="title">AllFunctions</span></span>
</pre></td></tr></table></figure>

<p>For example, ListFunctions bring in intersperse function that puts
a given element in ever other position:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">intersperse(<span class="function">List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span>, <span class="number">7</span>)</span>
</pre></td></tr></table></figure>

<h3 id="idinstances">IdInstances</h3>
<p>defines the type alias <code>Id[A]</code> as follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class"><span class="keyword">type</span> <span class="title">Id</span>[+<span class="title">X</span>] =</span> X
</pre></td></tr></table></figure>

<h3 id="std-allinstances">std.AllInstances</h3>
<p>the fact that list is a monad and that
monad introduces <code>&gt;&gt;=</code> operator are two different things.</p>
<p>one of the most interesting design of scalaz 7 is that it
rigorously separates the two concepts into “instance” and “syntax.”</p>
<p><code>std.allinstances</code> is a mixin of typeclass instances for built-in (std) data structures:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz.std

<span class="class"><span class="keyword">trait</span> <span class="title">allinstances</span></span>
  <span class="keyword">extends</span> anyvalinstances <span class="keyword">with</span> functioninstances <span class="keyword">with</span> listinstances <span class="keyword">with</span> mapinstances
  <span class="keyword">with</span> optioninstances <span class="keyword">with</span> setinstances <span class="keyword">with</span> stringinstances <span class="keyword">with</span> streaminstances <span class="keyword">with</span> tupleinstances
  <span class="keyword">with</span> eitherinstances <span class="keyword">with</span> partialfunctioninstances <span class="keyword">with</span> typeconstraintinstances
  <span class="keyword">with</span> scalaz.std.math.bigdecimalinstances <span class="keyword">with</span> scalaz.std.math.bigints
  <span class="keyword">with</span> scalaz.std.math.orderinginstances
  <span class="keyword">with</span> scalaz.std.util.parsing.combinator.parsers
  <span class="keyword">with</span> scalaz.std.java.util.mapinstances
  <span class="keyword">with</span> scalaz.std.java.math.bigintegerinstances
  <span class="keyword">with</span> scalaz.std.java.util.concurrent.callableinstances
  <span class="keyword">with</span> nodeseqinstances
  <span class="comment">// intentionally omitted: iterableinstances</span>

<span class="class"><span class="keyword">object</span> <span class="title">allinstances</span> <span class="keyword">extends</span> <span class="title">allinstances</span></span>
</pre></td></tr></table></figure>

<h3 id="syntax-totypeclassops">syntax.totypeclassops</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz
<span class="keyword">package</span> syntax

<span class="class"><span class="keyword">trait</span> <span class="title">totypeclassops</span></span>
  <span class="keyword">extends</span> tosemigroupops <span class="keyword">with</span> tomonoidops <span class="keyword">with</span> togroupops <span class="keyword">with</span> toequalops <span class="keyword">with</span> tolengthops <span class="keyword">with</span> toshowops
  <span class="keyword">with</span> toorderops <span class="keyword">with</span> toenumops <span class="keyword">with</span> tometricspaceops <span class="keyword">with</span> toplusemptyops <span class="keyword">with</span> toeachops <span class="keyword">with</span> toindexops
  <span class="keyword">with</span> tofunctorops <span class="keyword">with</span> topointedops <span class="keyword">with</span> tocontravariantops <span class="keyword">with</span> tocopointedops <span class="keyword">with</span> toapplyops
  <span class="keyword">with</span> toapplicativeops <span class="keyword">with</span> tobindops <span class="keyword">with</span> tomonadops <span class="keyword">with</span> tocojoinops <span class="keyword">with</span> tocomonadops
  <span class="keyword">with</span> tobifoldableops <span class="keyword">with</span> tocozipops
  <span class="keyword">with</span> toplusops <span class="keyword">with</span> toapplicativeplusops <span class="keyword">with</span> tomonadplusops <span class="keyword">with</span> totraverseops <span class="keyword">with</span> tobifunctorops
  <span class="keyword">with</span> tobitraverseops <span class="keyword">with</span> toarridops <span class="keyword">with</span> tocomposeops <span class="keyword">with</span> tocategoryops
  <span class="keyword">with</span> toarrowops <span class="keyword">with</span> tofoldableops <span class="keyword">with</span> tochoiceops <span class="keyword">with</span> tosplitops <span class="keyword">with</span> tozipops <span class="keyword">with</span> tounzipops <span class="keyword">with</span> tomonadwriterops <span class="keyword">with</span> tolistenablemonadwriterops
</pre></td></tr></table></figure>

<h3 id="syntax-todataops">syntax.todataops</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">todataops</span> <span class="keyword">extends</span> <span class="title">toidops</span> <span class="keyword">with</span> <span class="title">totreeops</span> <span class="keyword">with</span> <span class="title">towriterops</span> <span class="keyword">with</span> <span class="title">tovalidationops</span> <span class="keyword">with</span> <span class="title">toreducerops</span> <span class="keyword">with</span> <span class="title">tokleisliops</span></span>

<span class="comment">///</span>
<span class="keyword">package</span> scalaz.syntax

<span class="class"><span class="keyword">trait</span> <span class="title">idops</span>[<span class="title">a</span>] <span class="keyword">extends</span> <span class="title">ops</span>[<span class="title">a</span>] {</span>
  <span class="keyword">final</span> <span class="keyword">def</span> ??(d: =&gt; a)(implicit ev: <span class="keyword">null</span> &lt;:&lt; a): a = ...
  <span class="keyword">final</span> <span class="keyword">def</span> |&gt;[b](f: a =&gt; b): b = ...
  <span class="keyword">final</span> <span class="keyword">def</span> squared: (a, a) = ...
  <span class="keyword">def</span> left[b]: (a \/ b) = ...
  <span class="keyword">def</span> right[b]: (b \/ a) = ...
  <span class="keyword">final</span> <span class="keyword">def</span> wrapnel: nonemptylist[a] = ...
  <span class="keyword">def</span> matchorzero[b: monoid](pf: partialfunction[a, b]): b = ...
  <span class="keyword">final</span> <span class="keyword">def</span> dowhile(f: a =&gt; a, p: a =&gt; boolean): a = ...
  <span class="keyword">final</span> <span class="keyword">def</span> whiledo(f: a =&gt; a, p: a =&gt; boolean): a = ...
  <span class="keyword">def</span> visit[f[_] : pointed](p: partialfunction[a, f[a]]): f[a] = ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">toidops</span> {</span>
  implicit <span class="keyword">def</span> toidops[a](a: a): idops[a] = <span class="keyword">new</span> idops[a] {
    <span class="keyword">def</span> self: a = a
  }
}

<span class="comment">///</span>
<span class="keyword">package</span> scalaz
<span class="keyword">package</span> syntax

<span class="class"><span class="keyword">trait</span> <span class="title">treeops</span>[<span class="title">a</span>] <span class="keyword">extends</span> <span class="title">ops</span>[<span class="title">a</span>] {</span>
  <span class="keyword">def</span> node(subforest: tree[a]*): tree[a] = ...
  <span class="keyword">def</span> leaf: tree[a] = ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">totreeops</span> {</span>
  implicit <span class="keyword">def</span> totreeops[a](a: a) = <span class="keyword">new</span> treeops[a]{ <span class="keyword">def</span> self = a }
}
</pre></td></tr></table></figure>

<p>the same goes for <code>writerops[a]</code>, <code>validationops[a]</code>,
<code>reducerops[a]</code>, and <code>kleisliidops[a]</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span>node(<span class="number">2.</span>leaf)
<span class="label">res7:</span> scalaz<span class="preprocessor">.tree</span>[int] = &lt;tree&gt;

scala&gt; <span class="number">1.</span><span class="keyword">set</span>(<span class="string">"log1"</span>)
<span class="label">res8:</span> scalaz<span class="preprocessor">.writer</span>[string,int] = scalaz<span class="preprocessor">.writertfunctions</span>$$anon$26<span class="localvars">@2375</span>d245

scala&gt; <span class="string">"log2"</span><span class="preprocessor">.tell</span>
<span class="label">res9:</span> scalaz<span class="preprocessor">.writer</span>[string,unit] = scalaz<span class="preprocessor">.writertfunctions</span>$$anon$26<span class="localvars">@699289</span>fb

scala&gt; <span class="number">1.</span>success[string]
<span class="label">res11:</span> scalaz<span class="preprocessor">.validation</span>[string,int] = success(<span class="number">1</span>)

scala&gt; <span class="string">"boom"</span><span class="preprocessor">.failurenel</span>[int]
<span class="label">res12:</span> scalaz<span class="preprocessor">.validationnel</span>[string,int] = failure(nonemptylist(boom))
</pre></td></tr></table></figure>

<h3 id="syntax-std-toallstdops">syntax.std.toallstdops</h3>
<p>introduces methods and operators to scala’s standard types.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz
<span class="keyword">package</span> syntax
<span class="keyword">package</span> std

<span class="class"><span class="keyword">trait</span> <span class="title">toallstdops</span></span>
  <span class="keyword">extends</span> tobooleanops <span class="keyword">with</span> tooptionops <span class="keyword">with</span> tooptionidops <span class="keyword">with</span> tolistops <span class="keyword">with</span> tostreamops
  <span class="keyword">with</span> tofunction2ops <span class="keyword">with</span> tofunction1ops <span class="keyword">with</span> tostringops <span class="keyword">with</span> totupleops <span class="keyword">with</span> tomapops <span class="keyword">with</span> toeitherops
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>scala&gt; <span class="constant">false</span> /\ <span class="constant">true</span>
res14: <span class="type">boolean</span> = <span class="constant">false</span>

scala&gt; <span class="constant">false</span> \/ <span class="constant">true</span>
res15: <span class="type">boolean</span> = <span class="constant">true</span>

scala&gt; <span class="constant">true</span> option <span class="string">"foo"</span>
res16: option[<span class="type">string</span>] = <span class="keyword">some</span>(foo)

scala&gt; (<span class="number">1</span> &gt; <span class="number">10</span>)? <span class="string">"foo"</span> | <span class="string">"bar"</span>
res17: <span class="type">string</span> = bar

scala&gt; (<span class="number">1</span> &gt; <span class="number">10</span>)?? {<span class="type">list</span>(<span class="string">"foo"</span>)}
res18: <span class="type">list</span>[<span class="type">string</span>] = <span class="type">list</span>()


scala&gt; <span class="number">1.</span><span class="keyword">some</span>? <span class="string">"foo"</span> | <span class="string">"bar"</span>
res28: <span class="type">string</span> = foo

scala&gt; <span class="number">1.</span><span class="keyword">some</span> | <span class="number">2</span>
res30: int = <span class="number">1</span>


scala&gt; <span class="type">list</span>(<span class="number">1</span>, <span class="number">2</span>) filterm {_ =&gt; <span class="type">list</span>(<span class="constant">true</span>, <span class="constant">false</span>)}
res37: <span class="type">list</span>[<span class="type">list</span>[int]] = <span class="type">list</span>(<span class="type">list</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">list</span>(<span class="number">1</span>), <span class="type">list</span>(<span class="number">2</span>), <span class="type">list</span>())
</pre></td></tr></table></figure>

<h1 id="hacking-on-a-project">hacking on a project</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>git clone <span class="attribute">-b</span> scalaz<span class="attribute">-seven</span> git:<span class="comment">//github.com/scalaz/scalaz.git scalaz-seven</span>
git branch topic/vectorinstance
git co topic/vectorinstance
</pre></td></tr></table></figure>

<p>What’s actually going on is not just the combination of applicative
<code>functors (m ⊠ n)</code>, but the combination of applicative functions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="label">(⊗)::</span>(Functor m,Functor n) ⇒ (<span class="literal">a</span> → m b) → (<span class="literal">a</span> → n b) → (<span class="literal">a</span> → (m ⊠ n) b)
(f ⊗ g) x = Prod (f x) (g x)
</pre></td></tr></table></figure>

<p>Int is a Monoid, and any Monoid can be treated as an applicative functor,
which is called monoidal applicatives.
The problem is that when we make that into a function, it’s not distinguishable
from <code>Int =&gt; Int</code>, but we need <code>Int =&gt; [α]Int</code></p>
<p>TODO</p>
<h1 id="arrow">Arrow</h1>
<p>An arrow is the term used in category theory as an abstract
notion of thing that behaves like a function.</p>
<p>In Scalaz, these are <code>Function1[A, B]</code>, <code>PartialFunction[A, B]</code>,
<code>Kleisli[F[_], A, B], and CoKleisli[F[_], A, B]</code>. Arrow
abstracts them all similar to the way other typeclasses abtracts containers.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// Looks like Arrow[=&gt;:[_, _]] extends Category[=&gt;:].
trait Arrow[=&gt;:[_, _]] extends Category[=&gt;:] { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">id</span>[<span class="title">A</span>]:</span> A =&gt;: A
  <span class="function"><span class="keyword">def</span> <span class="title">arr</span>[<span class="title">A</span>, <span class="title">B</span>]<span class="params">(f: A =&gt; B)</span>:</span> A =&gt;: B
  <span class="function"><span class="keyword">def</span> <span class="title">first</span>[<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>]<span class="params">(f: <span class="params">(A =&gt;: B)</span>)</span>:</span> ((A, C) =&gt;: (B, C))
}
</pre></td></tr></table></figure>

<h2 id="category-and-compose">Category and Compose</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>trait Category[=&gt;:[_, _]] extends Compose[=&gt;:] { self =&gt;
  /** The left <span class="keyword">and</span> right identity over `compose`. */
  <span class="function"><span class="keyword">def</span> <span class="title">id</span>[<span class="title">A</span>]:</span> A =&gt;: A
}

trait Compose[=&gt;:[_, _]]  { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">compose</span>[<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>]<span class="params">(f: B =&gt;: C, g: A =&gt;: B)</span>:</span> (A =&gt;: C)
}
</pre></td></tr></table></figure>

<p>compose function composes two arrows into one. Using compose, Compose
introduces the following operators:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>trait ComposeOps[F[_, _],A, B] extends Ops[F[A, B]] {
  final <span class="function"><span class="keyword">def</span> &lt;&lt;&lt;[<span class="title">C</span>]<span class="params">(x: F[C, A])</span>:</span> F[C, B] = F.compose(self, x)
  final <span class="function"><span class="keyword">def</span> &gt;&gt;&gt;[<span class="title">C</span>]<span class="params">(x: F[B, C])</span>:</span> F[A, C] = F.compose(x, self)
}
</pre></td></tr></table></figure>

<p>The meaning of <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code> depends on the arrow, but for functions,
it’s the same as andThen and compose:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; val f = (_:<span class="built_in">Int</span>) + <span class="number">1</span>
f: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span> = &lt;function1&gt;

scala&gt; val g = (_:<span class="built_in">Int</span>) * <span class="number">100</span>
g: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span> = &lt;function1&gt;

scala&gt; (f &gt;&gt;&gt; g)(<span class="number">2</span>)
res0: <span class="built_in">Int</span> = <span class="number">300</span>

scala&gt; (f &lt;&lt;&lt; g)(<span class="number">2</span>)
res1: <span class="built_in">Int</span> = <span class="number">201</span>
</pre></td></tr></table></figure>

<h2 id="arrow-again">Arrow, again</h2>
<p><code>=&gt;:[A, B]</code> as <code>A =&gt;: B</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>trait ArrowOps[F[_, _],A, B] extends Ops[F[A, B]] {
  final <span class="function"><span class="keyword">def</span> ***[<span class="title">C</span>, <span class="title">D</span>]<span class="params">(k: F[C, D])</span>:</span> F[(A, C), (B, D)] = F.splitA(self, k)
  final <span class="function"><span class="keyword">def</span> &&&[<span class="title">C</span>]<span class="params">(k: F[A, C])</span>:</span> F[A, (B, C)] = F.combine(self, k)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>scala&gt; val f = (<span class="attribute">_</span>:Int) + <span class="number">1</span>
<span class="attribute">f</span>: Int<span class="function"> =&gt;</span> Int = &lt;function1&gt;

scala&gt; val g = (<span class="attribute">_</span>:Int) * <span class="number">100</span>
<span class="attribute">g</span>: Int<span class="function"> =&gt;</span> Int = &lt;function1&gt;

<span class="regexp">//</span> combines two arrows into a <span class="keyword">new</span> arrow <span class="keyword">by</span> running
<span class="regexp">//</span> the two arrows <span class="literal">on</span> a pair <span class="keyword">of</span> values
scala&gt; (f *** g)(<span class="number">1</span>, <span class="number">2</span>)
<span class="attribute">res3</span>: (Int, Int) = (<span class="number">2</span>,<span class="number">200</span>)

<span class="regexp">//</span> combines two arrows into a <span class="keyword">new</span> arrow <span class="keyword">by</span> running the
<span class="regexp">//</span> two arrows <span class="literal">on</span> the same value
scala&gt; (f &&& g)(<span class="number">2</span>)
<span class="attribute">res4</span>: (Int, Int) = (<span class="number">3</span>,<span class="number">200</span>)
</pre></td></tr></table></figure>

<h1 id="unapply">Unapply</h1>
<p>One thing that I’ve been fighting the Scala compiler over
is the lack of type inference support across the different kinded types
like <code>F[M[_, _]]</code> and <code>F[M[_]]</code>, and <code>M[_] and F[M[_]]</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>scala&gt; Applicative[Function1[Int, Int]]
&lt;<span class="built_in">console</span>&gt;:<span class="number">14</span>: <span class="attribute">error</span>: Int<span class="function"> =&gt;</span> Int takes <span class="literal">no</span> type parameters, <span class="attribute">expected</span>: one
              Applicative[Function1[Int, Int]]
                          ^
<span class="regexp">//</span> an instance <span class="keyword">of</span> Applicative[M[_]] <span class="keyword">is</span> <span class="function"><span class="params">(* -&gt; *)</span> -&gt;</span> *                          
scala&gt; Applicative[({type l[A]=Function1[Int, A]})<span class="comment">#l]</span>
<span class="attribute">res14</span>: scalaz.Applicative[[A]Int<span class="function"> =&gt;</span> A] = scalaz.std.FunctionInstances$$anon$<span class="number">2</span>@<span class="number">56</span>ae78ac
</pre></td></tr></table></figure>

<p>One of the way Scalaz helps you out is to provide
meta-instances of typeclass instance called Unapply.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Unapply</span>[<span class="title">TC</span>[<span class="title">_</span>[<span class="title">_</span>]], <span class="title">MA</span>] {</span>
  <span class="javadoc">/** The type constructor */</span>
  <span class="keyword">type</span> M[_]
  <span class="javadoc">/** The type that `M` was applied to */</span>
  <span class="keyword">type</span> A
  <span class="javadoc">/** The instance of the type class */</span>
  <span class="keyword">def</span> TC: TC[M]
  <span class="javadoc">/** Evidence that MA =:= M[A] */</span>
  <span class="keyword">def</span> apply(ma: MA): M[A]
}
</pre></td></tr></table></figure>

<p>TODO</p>
<h2 id="parallel-composition">parallel composition</h2>
<p>TODO</p>
<h1 id="momo">Momo</h1>
<p>Pure functions don’t imply they are computationally cheap.</p>
<p>Given you have some space in RAM, we could trade some of the
expensive calculations for space by caching the result.
This is called memoization.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>sealed trait Memo[<span class="decorator">@specialized(Int) K, @specialized(Int, Long, Double) V] {</span>
  <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(z: K =&gt; V)</span>:</span> K =&gt; V
}
</pre></td></tr></table></figure>

<p>We pass in a potentially expensive function as an input
and you get back a function that behaves the same but may cache the result.</p>
<p>Memo object there are some default implementations of Memo like
<code>Memo.mutableHashMapMemo[K, V]</code>, <code>Memo.weakHashMapMemo[K, V]</code>, and <code>Memo.arrayMemo[V]</code>.</p>
<p>缓存每次运算的结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>scala&gt; val slowFib: Int =&gt; Int = {
         <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">0</span>
         <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="number">1</span>
         <span class="keyword">case</span> n =&gt; slowFib(n - <span class="number">2</span>) + slowFib(n - <span class="number">1</span>)
       }
slowFib: Int =&gt; Int = &lt;function1&gt;

scala&gt; slowFib(<span class="number">45</span>)
res2: Int = <span class="number">1134903170</span>

scala&gt; val memoizedFib: Int =&gt; Int = Memo.mutableHashMapMemo {
         <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">0</span>
         <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="number">1</span>
         <span class="keyword">case</span> n =&gt; memoizedFib(n - <span class="number">2</span>) + memoizedFib(n - <span class="number">1</span>)
       }
memoizedFib: Int =&gt; Int = &lt;function1&gt;

scala&gt; memoizedFib(<span class="number">45</span>)
res14: Int = <span class="number">1134903170</span>
</pre></td></tr></table></figure>

<h1 id="functional-programming">functional programming</h1>
<p>An expression e is referentially transparent if every occurrence e can
be replaced with its value without affecting the observable result of the program.</p>
<h1 id="effect-system">Effect system</h1>
<h2 id="st">ST</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>sealed trait ST[S, A] {
  private[effect] <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(s: World[S])</span>:</span> (World[S], A)
}
</pre></td></tr></table></figure>

<p>This looks similar to State monad, but the difference I think is that
the state is mutated in-place, and in return is not observable from outside.</p>
<h2 id="stref">STRef</h2>
<p>STRef is a mutable variable that’s used only within
the context of ST monad. It’s created using ST.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">STRef</span>[<span class="title">S</span>, <span class="title">A</span>] {</span>
  <span class="keyword">protected</span> <span class="keyword">var</span> value: A

  <span class="javadoc">/**Reads the value pointed at by this reference. */</span>
  <span class="keyword">def</span> read: ST[S, A] = returnST(value)
  <span class="javadoc">/**Modifies the value at this reference with the given function. */</span>
  <span class="keyword">def</span> mod[B](f: A =&gt; A): ST[S, STRef[S, A]] = ...
  <span class="javadoc">/**Associates this reference with the given value. */</span>
  <span class="keyword">def</span> write(a: =&gt; A): ST[S, STRef[S, A]] = ...
  <span class="javadoc">/**Synonym for write*/</span>
  <span class="keyword">def</span> |=(a: =&gt; A): ST[S, STRef[S, A]] = ...
  <span class="javadoc">/**Swap the value at this reference with the value at another. */</span>
  <span class="keyword">def</span> swap(that: STRef[S, A]): ST[S, Unit] = ...
}

<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">STArray</span>[<span class="title">S</span>, <span class="title">A</span>] {</span>
  <span class="keyword">val</span> size: Int
  <span class="keyword">val</span> z: A
  <span class="keyword">private</span> <span class="keyword">val</span> value: Array[A] = Array.fill(size)(z)
  <span class="javadoc">/**Reads the value at the given index. */</span>
  <span class="keyword">def</span> read(i: Int): ST[S, A] = returnST(value(i))
  <span class="javadoc">/**Writes the given value to the array, at the given offset. */</span>
  <span class="keyword">def</span> write(i: Int, a: A): ST[S, STArray[S, A]] = ...
  <span class="javadoc">/**Turns a mutable array into an immutable one which is safe to return. */</span>
  <span class="keyword">def</span> freeze: ST[S, ImmutableArray[A]] = ...
  <span class="javadoc">/**Fill this array from the given association list. */</span>
  <span class="keyword">def</span> fill[B](f: (A, B) =&gt; A, xs: Traversable[(Int, B)]): ST[S, Unit] = ...
  <span class="javadoc">/**Combine the given value with the value at the given index, using the given function. */</span>
  <span class="keyword">def</span> update[B](f: (A, B) =&gt; A, i: Int, v: B) = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="title">scala</span>&gt; <span class="import"><span class="keyword">import</span> effect._</span>
<span class="import"><span class="keyword">import</span> effect._</span>

<span class="title">scala</span>&gt; <span class="import"><span class="keyword">import</span> ST.{newVar, runST, newArr, returnST}</span>
<span class="import"><span class="keyword">import</span> ST.{newVar, runST, newArr, returnST}</span>

<span class="title">scala</span>&gt; def e1[<span class="type">S</span>] = for {
         x &lt;- newVar[<span class="type">S</span>](<span class="number">0</span>)
         r &lt;- x mod {_ + <span class="number">1</span>}
       } yield x
<span class="title">e1</span>: [<span class="type">S</span>]=&gt; scalaz.effect.<span class="type">ST</span>[<span class="type">S</span>,scalaz.effect.<span class="type">STRef</span>[<span class="type">S</span>,<span class="type">Int</span>]]

<span class="title">scala</span>&gt; def e2[<span class="type">S</span>]: <span class="type">ST</span>[<span class="type">S</span>, <span class="type">Int</span>] = for {
         x &lt;- e1[<span class="type">S</span>]
         r &lt;- x.read
       } yield r 
<span class="title">e2</span>: [<span class="type">S</span>]=&gt; scalaz.effect.<span class="type">ST</span>[<span class="type">S</span>,<span class="type">Int</span>]

<span class="title">scala</span>&gt; <span class="typedef"><span class="keyword">type</span> <span class="type">ForallST</span>[<span class="type">A</span>] = <span class="type">Forall</span>[<span class="container">({<span class="title">type</span> λ[<span class="type">S</span>] = <span class="type">ST</span>[<span class="type">S</span>, <span class="type">A</span>]})</span>#λ]</span>
<span class="title">defined</span> <span class="typedef"><span class="keyword">type</span> alias <span class="type">ForallST</span></span>

<span class="title">scala</span>&gt; runST(new <span class="type">ForallST</span>[<span class="type">Int</span>] { def apply[<span class="type">S</span>] = e2[<span class="type">S</span>] })
<span class="title">res5</span>: <span class="type">Int</span> = <span class="number">1</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="string">"STArray"</span> <span class="keyword">in</span> {
  def e1[S] = <span class="keyword">for</span> {
    arr &lt;- newArr[S, <span class="built_in">Boolean</span>](<span class="number">3</span>, <span class="literal">true</span>)
    _ &lt;- arr.write(<span class="number">0</span>, <span class="literal">false</span>)
    r &lt;- arr.freeze
  } <span class="keyword">yield</span> r
  runST(<span class="keyword">new</span> ForallST[ImmutableArray[<span class="built_in">Boolean</span>]] { def apply[S] = e1[S] }).toList must be_===(
    List(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>))
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>scala&gt; def mapM[<span class="link_label">A, S, B</span>](<span class="link_url">xs: List[A]</span>)(f: A =&gt; ST[S, B]): ST[S, List[B]] =
<span class="code">         Monad[({type λ[α] = ST[S, α]})#λ].sequence(xs map f)</span>
mapM: [<span class="link_label">A, S, B</span>](<span class="link_url">xs: List[A]</span>)(f: A =&gt; scalaz.effect.ST[S,B])scalaz.effect.ST[S,List[B]]

scala&gt; def sieve[<span class="link_label">S</span>](<span class="link_url">n: Int</span>) = for {
<span class="code">         arr &lt;- newArr[S, Boolean](n + 1, true)</span>
<span class="code">         _ &lt;- arr.write(0, false)</span>
<span class="code">         _ &lt;- arr.write(1, false)</span>
<span class="code">         val nsq = (math.sqrt(n.toDouble).toInt + 1)</span>
<span class="code">         _ &lt;- mapM (1 |-&gt; nsq) { i =&gt;</span>
<span class="code">           for {</span>
<span class="code">             x &lt;- arr.read(i)</span>
<span class="code">             _ &lt;-</span>
<span class="code">               if (x) mapM (i * i |--&gt; (i, n)) { j =&gt; arr.write(j, false) }</span>
<span class="code">               else returnST[S, List[Boolean]] {Nil}</span>
<span class="code">           } yield ()</span>
<span class="code">         }</span>
<span class="code">         r &lt;- arr.freeze</span>
<span class="code">       } yield r</span>
sieve: [<span class="link_label">S</span>](<span class="link_url">n: Int</span>)scalaz.effect.ST[S,scalaz.ImmutableArray[Boolean]]

scala&gt; type ForallST[A] = Forall[({type λ[S] = ST[S, A]})#λ]
defined type alias ForallST

scala&gt; def prime(n: Int) =
<span class="code">         runST(new ForallST[ImmutableArray[Boolean]] { def apply[S] = sieve[S](n) }).toArray.</span>
<span class="code">         zipWithIndex collect { case (true, x) =&gt; x }</span>
prime: (n: Int)Array[Int]

scala&gt; prime(1000)
</pre></td></tr></table></figure>

<h1 id="io-monad">IO Monad</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>sealed trait IO[+A] {
  private[effect] <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(rw: World[RealWorld])</span>:</span> Trampoline[(World[RealWorld], A)]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; import scalaz._, Scalaz._, effect._, IO._
scala&gt; val action1 = for {
         _ &lt;- putStrLn(<span class="string">"Hello, world!"</span>)
       } yield ()
<span class="label">action1:</span> scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IO</span>[Unit] = scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IOFunctions</span>$$anon$4<span class="localvars">@149</span>f6f65

scala&gt; action1<span class="preprocessor">.unsafePerformIO</span>
Hello, world!
</pre></td></tr></table></figure>

<p>IO actions</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>  /** Reads a character <span class="keyword">from</span> standard input. */
  <span class="function"><span class="keyword">def</span> <span class="title">getChar</span>:</span> IO[Char] = ...
  /** Writes a character to standard output. */
  <span class="function"><span class="keyword">def</span> <span class="title">putChar</span><span class="params">(c: Char)</span>:</span> IO[Unit] = ...
  /** Writes a string to standard output. */
  <span class="function"><span class="keyword">def</span> <span class="title">putStr</span><span class="params">(s: String)</span>:</span> IO[Unit] = ...
  /** Writes a string to standard output, followed by a newline.*/
  <span class="function"><span class="keyword">def</span> <span class="title">putStrLn</span><span class="params">(s: String)</span>:</span> IO[Unit] = ...
  /** Reads a line of standard input. */
  <span class="function"><span class="keyword">def</span> <span class="title">readLn</span>:</span> IO[String] = ...
  /** Write the given value to standard output. */
  <span class="function"><span class="keyword">def</span> <span class="title">putOut</span>[<span class="title">A</span>]<span class="params">(a: A)</span>:</span> IO[Unit] = ...
  // Mutable variables <span class="keyword">in</span> the IO monad
  <span class="function"><span class="keyword">def</span> <span class="title">newIORef</span>[<span class="title">A</span>]<span class="params">(a: =&gt; A)</span>:</span> IO[IORef[A]] = ...
  /**Throw the given error <span class="keyword">in</span> the IO monad. */
  <span class="function"><span class="keyword">def</span> <span class="title">throwIO</span>[<span class="title">A</span>]<span class="params">(e: Throwable)</span>:</span> IO[A] = ...
  /** An IO action that does nothing. */
  val ioUnit: IO[Unit] = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; val action2 = IO {
         val source = scala<span class="preprocessor">.io</span><span class="preprocessor">.Source</span><span class="preprocessor">.fromFile</span>(<span class="string">"./README.md"</span>)
         source<span class="preprocessor">.getLines</span><span class="preprocessor">.toStream</span>
       }
<span class="label">action2:</span> scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IO</span>[scala<span class="preprocessor">.collection</span><span class="preprocessor">.immutable</span><span class="preprocessor">.Stream</span>[String]] = scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IOFunctions</span>$$anon$4@bab4387

scala&gt; action2<span class="preprocessor">.unsafePerformIO</span><span class="preprocessor">.toList</span>
<span class="label">res57:</span> List[String] = List(<span class="preprocessor"># Scalaz, "", Scalaz is a Scala library for functional programming., "", It provides purely functional data structures to complement those from the Scala standard library., ...</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">program</span>:</span> IO[Unit] = <span class="keyword">for</span> {
  line &lt;- readLn
  _    &lt;- putStrLn(line)
} <span class="keyword">yield</span> ()

scala&gt; (program |+| program).unsafePerformIO
<span class="number">123</span>
<span class="number">123</span>
</pre></td></tr></table></figure>

<h2 id="enumeration-based-i-o-with-iteratees">Enumeration-Based I/O with Iteratees</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>sealed trait Input[E] {
  def fold[<span class="link_label">Z</span>](<span class="link_url">empty: =&gt; Z, el: (=&gt; E</span>) =&gt; Z, eof: =&gt; Z): Z
  def apply[<span class="link_label">Z</span>](<span class="link_url">empty: =&gt; Z, el: (=&gt; E</span>) =&gt; Z, eof: =&gt; Z) =
<span class="code">    fold(empty, el, eof)</span>
}

sealed trait IterateeT[E, F[_], A] {
  def value: F[StepT[E, F, A]]
}
type Iteratee[E, A] = IterateeT[E, Id, A]

object Iteratee
  extends IterateeFunctions
  with IterateeTFunctions
  with EnumeratorTFunctions
  with EnumeratorPFunctions
  with EnumerateeTFunctions
  with StepTFunctions
  with InputFunctions {

  def apply[<span class="link_label">E, A</span>](<span class="link_url">s: Step[E, A]</span>): Iteratee[E, A] = iteratee(s)
}

type &gt;@&gt;[E, A] = Iteratee[E, A]
</pre></td></tr></table></figure>

<p>Let’s try implementing the counter example from EBIOI.
For that we switch to iteratee project using sbt:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>sealed trait IterateeT[E, F[_], A] {
  <span class="function"><span class="keyword">def</span> <span class="title">value</span>:</span> F[StepT[E, F, A]]
}
type Iteratee[E, A] = IterateeT[E, Id, A]

object Iteratee
  extends IterateeFunctions
  <span class="keyword">with</span> IterateeTFunctions
  <span class="keyword">with</span> EnumeratorTFunctions
  <span class="keyword">with</span> EnumeratorPFunctions
  <span class="keyword">with</span> EnumerateeTFunctions
  <span class="keyword">with</span> StepTFunctions
  <span class="keyword">with</span> InputFunctions {

  <span class="function"><span class="keyword">def</span> <span class="title">apply</span>[<span class="title">E</span>, <span class="title">A</span>]<span class="params">(s: Step[E, A])</span>:</span> Iteratee[E, A] = iteratee(s)
}

type &gt;<span class="decorator">@&gt;[E, A] = Iteratee[E, A]</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="scalaz" scheme="http://zhpooer.github.io/tags/scalaz/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[learning scalaz 进阶2]]></title>
    <link href="http://zhpooer.github.io/2014/07/30/learning-scalaz-%E8%BF%9B%E9%98%B62/"/>
    <id>http://zhpooer.github.io/2014/07/30/learning-scalaz-进阶2/</id>
    <published>2014-07-29T23:48:27.000Z</published>
    <updated>2014-07-30T06:43:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="applicative-builder">Applicative Builder</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; (<span class="number">3.</span>some |@| <span class="number">5.</span>some) {_ + _}
res18: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">8</span>)

scala&gt; val f = ({(_: <span class="built_in">Int</span>) * <span class="number">2</span>} |@| {(_: <span class="built_in">Int</span>) + <span class="number">10</span>}) {_ + _}
f: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span> = &lt;function1&gt;
</pre></td></tr></table></figure>

<h1 id="state-and-statet">State and StateT</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>scala&gt; type Stack = List[Int]
defined type alias Stack

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(stack: Stack)</span>:</span> (Int, Stack) = stack match {
         case x :: xs =&gt; (x, xs)
       }
pop: (stack: Stack)(Int, Stack)

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(a: Int, stack: Stack)</span>:</span> (Unit, Stack) = ((), a :: stack)
push: (a: Int, stack: Stack)(Unit, Stack)

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">stackManip</span><span class="params">(stack: Stack)</span>:</span> (Int, Stack) = {
         val (_, newStack1) = push(<span class="number">3</span>, stack)
         val (a, newStack2) = pop(newStack1)
         pop(newStack2)
       }
stackManip: (stack: Stack)(Int, Stack)

scala&gt; stackManip(List(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>))
res0: (Int, Stack) = (<span class="number">5</span>,List(<span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>))
</pre></td></tr></table></figure>

<p>We’ll say that a stateful computation is a function that takes some
state and returns a value along with some new state.
That function would have the following type:<code>s -&gt; (a, s)</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">type</span> State[S, +A] = StateT[Id, S, A]

<span class="comment">// important to define here, rather than at the top-level, to avoid Scala 2.9.2 bug</span>
<span class="class"><span class="keyword">object</span> <span class="title">State</span> <span class="keyword">extends</span> <span class="title">StateFunctions</span> {</span>
  <span class="keyword">def</span> apply[S, A](f: S =&gt; (S, A)): State[S, A] = <span class="keyword">new</span> StateT[Id, S, A] {
    <span class="keyword">def</span> apply(s: S) = f(s)
  }
}

<span class="class"><span class="keyword">trait</span> <span class="title">StateT</span>[<span class="title">F</span>[+<span class="title">_</span>], <span class="title">S</span>, +<span class="title">A</span>] {</span> self =&gt;
  <span class="javadoc">/** Run and return the final value and state in the context of `F` */</span>
  <span class="keyword">def</span> apply(initial: S): F[(S, A)]

  <span class="javadoc">/** An alias for `apply` */</span>
  <span class="keyword">def</span> run(initial: S): F[(S, A)] = apply(initial)

  <span class="javadoc">/** Calls `run` using `Monoid[S].zero` as the initial state */</span>
  <span class="keyword">def</span> runZero(implicit S: Monoid[S]): F[(S, A)] =
    run(S.zero)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>scala&gt; type Stack = List[Int]
defined type alias Stack

scala&gt; val <span class="keyword">pop</span> = State[Stack, Int] {
         case <span class="built_in">x</span> :: xs =&gt; (xs, <span class="built_in">x</span>)
       }
<span class="label">pop:</span> scalaz<span class="preprocessor">.State</span>[Stack,Int]

scala&gt; def <span class="keyword">push</span>(a: Int) = State[Stack, Unit] {
         case xs =&gt; (a :: xs, ())
       }
<span class="label">push:</span> (a: Int)scalaz<span class="preprocessor">.State</span>[Stack,Unit]

scala&gt; def stackManip: State[Stack, Int] = for {
         _ &lt;- <span class="keyword">push</span>(<span class="number">3</span>)
         a &lt;- <span class="keyword">pop</span>
         b &lt;- <span class="keyword">pop</span>
       } yield(b)
<span class="label">stackManip:</span> scalaz<span class="preprocessor">.State</span>[Stack,Int]

scala&gt; stackManip(List(<span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>))
<span class="label">res2:</span> (Stack, Int) = (List(<span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>),<span class="number">5</span>)
</pre></td></tr></table></figure>

<p>The State object extends StateFunctions trait, which defines a few helper functions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>trait StateFunctions {
  <span class="function"><span class="keyword">def</span> <span class="title">constantState</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A, s: =&gt; S)</span>:</span> State[S, A] =
    State((_: S) =&gt; (s, a))
  <span class="function"><span class="keyword">def</span> <span class="title">state</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A)</span>:</span> State[S, A] =
    State((_ : S, a))
  <span class="function"><span class="keyword">def</span> <span class="title">init</span>[<span class="title">S</span>]:</span> State[S, S] = State(s =&gt; (s, s))
  <span class="function"><span class="keyword">def</span> <span class="title">get</span>[<span class="title">S</span>]:</span> State[S, S] = init
  <span class="function"><span class="keyword">def</span> <span class="title">gets</span>[<span class="title">S</span>, <span class="title">T</span>]<span class="params">(f: S =&gt; T)</span>:</span> State[S, T] = State(s =&gt; (s, f(s)))
  <span class="function"><span class="keyword">def</span> <span class="title">put</span>[<span class="title">S</span>]<span class="params">(s: S)</span>:</span> State[S, Unit] = State(_ =&gt; (s, ()))
  <span class="function"><span class="keyword">def</span> <span class="title">modify</span>[<span class="title">S</span>]<span class="params">(f: S =&gt; S)</span>:</span> State[S, Unit] = State(s =&gt; {
    val r = f(s);
    (r, ())
  })
  /**
   * Computes the difference between the current <span class="keyword">and</span> previous values of `a`
   */
  <span class="function"><span class="keyword">def</span> <span class="title">delta</span>[<span class="title">A</span>]<span class="params">(a: A)</span><span class="params">(implicit A: Group[A])</span>:</span> State[A, A] = State{
    (prevA) =&gt;
      val diff = A.minus(a, prevA)
      (diff, a)
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">stackyStack</span>:</span> State[Stack, Unit] = <span class="keyword">for</span> {
         stackNow &lt;- get
         r &lt;- <span class="keyword">if</span> (stackNow === List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) put(List(<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>))
              <span class="keyword">else</span> put(List(<span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>))
       } <span class="keyword">yield</span> r
stackyStack: scalaz.State[Stack,Unit]

scala&gt; stackyStack(List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))
res4: (Stack, Unit) = (List(<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>),())


// We can also implement pop <span class="keyword">and</span> push <span class="keyword">in</span> terms of get <span class="keyword">and</span> put:
scala&gt; val pop: State[Stack, Int] = <span class="keyword">for</span> {
         s &lt;- get[Stack]
         val (x :: xs) = s
         _ &lt;- put(xs)
       } <span class="keyword">yield</span> x
pop: scalaz.State[Stack,Int] = scalaz.StateT$$anon$<span class="number">7</span><span class="decorator">@40014da3</span>

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(x: Int)</span>:</span> State[Stack, Unit] = <span class="keyword">for</span> {
         xs &lt;- get[Stack]
         r &lt;- put(x :: xs)
       } <span class="keyword">yield</span> r
push: (x: Int)scalaz.State[Stack,Unit]
</pre></td></tr></table></figure>

<h1 id="either">Either</h1>
<p>We know <code>Either[A, B]</code> from the standard library, but Scalaz 7 
implements its own Either equivalent named <code>\/</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> \/[+<span class="title">A</span>, +<span class="title">B</span>] {</span>
  ...
  <span class="javadoc">/** Return `true` if this disjunction is left. */</span>
  <span class="keyword">def</span> isLeft: Boolean =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(_) =&gt; <span class="keyword">true</span>
      <span class="keyword">case</span> \/-(_) =&gt; <span class="keyword">false</span>
    }

  <span class="javadoc">/** Return `true` if this disjunction is right. */</span>
  <span class="keyword">def</span> isRight: Boolean =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(_) =&gt; <span class="keyword">false</span>
      <span class="keyword">case</span> \/-(_) =&gt; <span class="keyword">true</span>
    }
  ...
  <span class="javadoc">/** Flip the left/right values in this disjunction. Alias for `unary_~` */</span>
  <span class="keyword">def</span> swap: (B \/ A) =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(a) =&gt; \/-(a)
      <span class="keyword">case</span> \/-(b) =&gt; -\/(b)
    }
  <span class="javadoc">/** Flip the left/right values in this disjunction. Alias for `swap` */</span>
  <span class="keyword">def</span> unary_~ : (B \/ A) = swap
  ...
  <span class="javadoc">/** Return the right value of this disjunction or the given default if left. Alias for `|` */</span>
  <span class="keyword">def</span> getOrElse[BB &gt;: B](x: =&gt; BB): BB =
    toOption getOrElse x
  <span class="javadoc">/** Return the right value of this disjunction or the given default if left. Alias for `getOrElse` */</span>
  <span class="keyword">def</span> |[BB &gt;: B](x: =&gt; BB): BB = getOrElse(x)
  
  <span class="javadoc">/** Return this if it is a right, otherwise, return the given value. Alias for `|||` */</span>
  <span class="keyword">def</span> orElse[AA &gt;: A, BB &gt;: B](x: =&gt; AA \/ BB): AA \/ BB =
    <span class="keyword">this</span> <span class="keyword">match</span> {
      <span class="keyword">case</span> -\/(_) =&gt; x
      <span class="keyword">case</span> \/-(_) =&gt; <span class="keyword">this</span>
    }
  <span class="javadoc">/** Return this if it is a right, otherwise, return the given value. Alias for `orElse` */</span>
  <span class="keyword">def</span> |||[AA &gt;: A, BB &gt;: B](x: =&gt; AA \/ BB): AA \/ BB = orElse(x)
  ...
}

<span class="keyword">private</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> -\/[+<span class="title">A</span>]<span class="params">(a: A)</span> <span class="keyword">extends</span> <span class="params">(A \/ Nothing)</span></span>
<span class="keyword">private</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> \/-[+<span class="title">B</span>]<span class="params">(b: B)</span> <span class="keyword">extends</span> <span class="params">(Nothing \/ B)</span></span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span><span class="built_in">right</span>[<span class="built_in">String</span>]
res12: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>] = \/-(<span class="number">1</span>)

scala&gt; <span class="string">"error"</span>.<span class="built_in">left</span>[<span class="built_in">Int</span>]
res13: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>] = -\/(<span class="keyword">error</span>)
</pre></td></tr></table></figure>

<p>The Either type in Scala standard library is not a monad on its own,
which means it does not implement flatMap method with or without Scalaz:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>// scala 中的Left 不是 一个 monad 没有实现 flatmap
scala&gt; Left[<span class="link_label">String, Int</span>](<span class="link_url">"boom"</span>) flatMap { x =&gt; Right[<span class="link_label">String, Int</span>](<span class="link_url">x + 1</span>) }
<span class="xml"><span class="tag">&lt;<span class="title">console</span>&gt;</span></span>:8: error: value flatMap is not a member of scala.util.Left[String,Int]
<span class="code">              Left[String, Int]("boom") flatMap { x =&gt; Right[String, Int](x + 1) }</span>
<span class="code">                                        ^</span>
// 取得右边的值进行运算
scala&gt; Left[<span class="link_label">String, Int</span>](<span class="link_url">"boom"</span>).right flatMap { x =&gt; Right[<span class="link_label">String, Int</span>](<span class="link_url">x + 1</span>)}
res15: scala.util.Either[String,Int] = Left(boom)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// 与 Either 操作相关</span>
<span class="comment">// 如果遇到left(失败), 就直接返回left</span>
scala&gt; <span class="keyword">for</span> {
         e1 &lt;- <span class="string">"event 1 ok"</span>.right
         e2 &lt;- <span class="string">"event 2 failed!"</span>.left[<span class="built_in">String</span>]
         e3 &lt;- <span class="string">"event 3 failed!"</span>.left[<span class="built_in">String</span>]
       } <span class="keyword">yield</span> (e1 |+| e2 |+| e3)
res24: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">String</span>] = -\/(event <span class="number">2</span> failed!)

<span class="comment">// getOrElse</span>
scala&gt; <span class="string">"event 1 ok"</span>.right | <span class="string">"something bad"</span>
res27: <span class="built_in">String</span> = event <span class="number">1</span> ok

scala&gt; <span class="string">"event 1 ok"</span>.right map {_ + <span class="string">"!"</span>}
res31: scalaz.\/[Nothing,<span class="built_in">String</span>] = \/-(event <span class="number">1</span> ok!)

<span class="comment">// orElse</span>
scala&gt; <span class="string">"event 1 failed!"</span>.left ||| <span class="string">"retry event 1 ok"</span>.right 
res32: scalaz.\/[<span class="built_in">String</span>,<span class="built_in">String</span>] = \/-(retry event <span class="number">1</span> ok)
</pre></td></tr></table></figure>

<h1 id="validation">Validation</h1>
<p>Another data structure that’s compared to Either in Scalaz is Validation:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Validation</span>[+<span class="title">E</span>, +<span class="title">A</span>] {</span>
  <span class="javadoc">/** Return `true` if this validation is success. */</span>
  <span class="keyword">def</span> isSuccess: Boolean = <span class="keyword">this</span> <span class="keyword">match</span> {
    <span class="keyword">case</span> Success(_) =&gt; <span class="keyword">true</span>
    <span class="keyword">case</span> Failure(_) =&gt; <span class="keyword">false</span>
  }
  <span class="javadoc">/** Return `true` if this validation is failure. */</span>
  <span class="keyword">def</span> isFailure: Boolean = !isSuccess

  ...
}

<span class="keyword">final</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Success</span>[<span class="title">E</span>, <span class="title">A</span>]<span class="params">(a: A)</span> <span class="keyword">extends</span> <span class="title">Validation</span>[<span class="title">E</span>, <span class="title">A</span>]</span>
<span class="keyword">final</span> <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Failure</span>[<span class="title">E</span>, <span class="title">A</span>]<span class="params">(e: E)</span> <span class="keyword">extends</span> <span class="title">Validation</span>[<span class="title">E</span>, <span class="title">A</span>]</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>scala&gt; <span class="string">"event 1 ok"</span>.success[<span class="built_in">String</span>]
res36: scalaz.Validation[<span class="built_in">String</span>,<span class="built_in">String</span>] = Success(event <span class="number">1</span> ok)

scala&gt; <span class="string">"event 1 failed!"</span>.failure[<span class="built_in">String</span>]
res38: scalaz.Validation[<span class="built_in">String</span>,<span class="built_in">String</span>] = Failure(event <span class="number">1</span> failed!)

<span class="comment">// Validation keeps going and reports back all failures. </span>
scala&gt; (<span class="string">"event 1 ok"</span>.success[<span class="built_in">String</span>] |@| <span class="string">"event 2 failed!"</span>.failure[<span class="built_in">String</span>] |@| <span class="string">"event 3 failed!"</span>.failure[<span class="built_in">String</span>]) {_ + _ + _}
res44: scalaz.Unapply[scalaz.Apply,scalaz.Validation[<span class="built_in">String</span>,<span class="built_in">String</span>]]{type M[X] = scalaz.Validation[<span class="built_in">String</span>,X]; type A = <span class="built_in">String</span>}#M[<span class="built_in">String</span>] = Failure(event <span class="number">2</span> failed!event <span class="number">3</span> failed!)
</pre></td></tr></table></figure>

<h1 id="nonemptylist-nel-">NonEmptyList(Nel)</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="javadoc">/** A singly-linked list that is guaranteed to be non-empty. */</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">NonEmptyList</span>[+<span class="title">A</span>] {</span>
  <span class="keyword">val</span> head: A
  <span class="keyword">val</span> tail: List[A]
  <span class="keyword">def</span> &lt;::[AA &gt;: A](b: AA): NonEmptyList[AA] = nel(b, head :: tail)
  ...
}
</pre></td></tr></table></figure>

<p>This is a wrapper trait for plain List that’s guaranteed to be non-empty.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span>wrapNel
<span class="label">res47:</span> scalaz<span class="preprocessor">.NonEmptyList</span>[Int] = NonEmptyList(<span class="number">1</span>)

scala&gt; <span class="string">"event 1 ok"</span><span class="preprocessor">.successNel</span>[String]
<span class="label">res48:</span> scalaz<span class="preprocessor">.ValidationNEL</span>[String,String] = Success(event <span class="number">1</span> ok)

scala&gt; <span class="string">"event 1 failed!"</span><span class="preprocessor">.failureNel</span>[String]
<span class="label">res49:</span> scalaz<span class="preprocessor">.ValidationNEL</span>[String,String] = Failure(NonEmptyList(event <span class="number">1</span> failed!))

scala&gt; (<span class="string">"event 1 ok"</span><span class="preprocessor">.successNel</span>[String] |@| <span class="string">"event 2 failed!"</span><span class="preprocessor">.failureNel</span>[String] |@| <span class="string">"event 3 failed!"</span><span class="preprocessor">.failureNel</span>[String]) {_ + _ + _}
<span class="label">res50:</span> scalaz<span class="preprocessor">.Unapply</span>[scalaz<span class="preprocessor">.Apply</span>,scalaz<span class="preprocessor">.ValidationNEL</span>[String,String]]{type M[<span class="built_in">X</span>] = scalaz<span class="preprocessor">.ValidationNEL</span>[String,<span class="built_in">X</span>]<span class="comment">; type A = String}#M[String] = Failure(NonEmptyList(event 2 failed!, event 3 failed!))</span>
</pre></td></tr></table></figure>

<h1 id="some-useful-monadic-functions">Some useful monadic functions</h1>
<h2 id="join">join</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; (Some(<span class="number">9.</span>some): <span class="keyword">Option</span>[<span class="keyword">Option</span>[<span class="built_in">Int</span>]]).<span class="built_in">join</span>
res9: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">9</span>)

scala&gt; (Some(none): <span class="keyword">Option</span>[<span class="keyword">Option</span>[<span class="built_in">Int</span>]]).<span class="built_in">join</span>
res10: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = None

scala&gt; List(List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), List(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)).<span class="built_in">join</span>
res12: List[<span class="built_in">Int</span>] = List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)

scala&gt; <span class="number">9.</span><span class="built_in">right</span>[<span class="built_in">String</span>].<span class="built_in">right</span>[<span class="built_in">String</span>].<span class="built_in">join</span>
res15: scalaz.Unapply[scalaz.Bind,scalaz.\/[<span class="built_in">String</span>,scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]]]{type M[X] = scalaz.\/[<span class="built_in">String</span>,X]; type A = scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]}#M[<span class="built_in">Int</span>] = \/-(<span class="number">9</span>)

scala&gt; <span class="string">"boom"</span>.<span class="built_in">left</span>[<span class="built_in">Int</span>].<span class="built_in">right</span>[<span class="built_in">String</span>].<span class="built_in">join</span>
res16: scalaz.Unapply[scalaz.Bind,scalaz.\/[<span class="built_in">String</span>,scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]]]{type M[X] = scalaz.\/[<span class="built_in">String</span>,X]; type A = scalaz.\/[<span class="built_in">String</span>,<span class="built_in">Int</span>]}#M[<span class="built_in">Int</span>] = -\/(boom)
</pre></td></tr></table></figure>

<h2 id="filterm">filterM</h2>
<p>In Scalaz filterM is implemented in several places. For List it
seems to be there by <code>import Scalaz._</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>trait ListOps[A] extends Ops[List[A]] {
  <span class="keyword">...</span>
  final def filterM[M[_] : Monad](p: A =&gt; M[Boolean]): M[List[A]] = l.filterM(self)(p)
  <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// TODO 查源代码</span>
scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) filterM { x =&gt; <span class="keyword">List</span>(<span class="keyword">true</span>, <span class="keyword">false</span>) }
res19: <span class="keyword">List</span>[<span class="keyword">List</span>[Int]] = <span class="keyword">List</span>(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">1</span>), <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">2</span>), <span class="keyword">List</span>(<span class="number">3</span>), <span class="keyword">List</span>())

scala&gt; import syntax.std.vector._
import syntax.std.vector._

scala&gt; Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) filterM { x =&gt; Vector(<span class="keyword">true</span>, <span class="keyword">false</span>) }
res20: scala.collection.immutable.Vector[Vector[Int]] = Vector(Vector(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Vector(<span class="number">1</span>, <span class="number">2</span>), Vector(<span class="number">1</span>, <span class="number">3</span>), Vector(<span class="number">1</span>), Vector(<span class="number">2</span>, <span class="number">3</span>), Vector(<span class="number">2</span>), Vector(<span class="number">3</span>), Vector())
</pre></td></tr></table></figure>

<h2 id="foldleftm">foldLeftM</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; def binSmalls(acc: <span class="built_in">Int</span>, x: <span class="built_in">Int</span>): <span class="keyword">Option</span>[<span class="built_in">Int</span>] = {
         <span class="keyword">if</span> (x &gt; <span class="number">9</span>) (none: <span class="keyword">Option</span>[<span class="built_in">Int</span>])
         <span class="keyword">else</span> (acc + x).some
       }
binSmalls: (acc: <span class="built_in">Int</span>, x: <span class="built_in">Int</span>)<span class="keyword">Option</span>[<span class="built_in">Int</span>]

scala&gt; List(<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>).foldLeftM(<span class="number">0</span>) {binSmalls}
res25: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">14</span>)

scala&gt; List(<span class="number">2</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">1</span>).foldLeftM(<span class="number">0</span>) {binSmalls}
res26: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = None
</pre></td></tr></table></figure>

<h1 id="making-a-safe-rpn-calculator">Making a safe RPN calculator</h1>
<p>When we were solving the problem of implementing a RPN calculator,
we noted that it worked fine as long as the input that it got made sense.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">foldingFunction</span><span class="params">(list: List[Double], next: String)</span>:</span> List[Double] = (list, next) match {
         case (x :: y :: ys, <span class="string">"*"</span>) =&gt; (y * x) :: ys
         case (x :: y :: ys, <span class="string">"+"</span>) =&gt; (y + x) :: ys
         case (x :: y :: ys, <span class="string">"-"</span>) =&gt; (y - x) :: ys
         case (xs, numString) =&gt; numString.toInt :: xs
       }
foldingFunction: (list: List[Double], next: String)List[Double]

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">solveRPN</span><span class="params">(s: String)</span>:</span> Double =
         (s.split(<span class="string">' '</span>).toList.foldLeft(Nil: List[Double]) {foldingFunction}).head
solveRPN: (s: String)Double

scala&gt; solveRPN(<span class="string">"10 4 3 + 2 * -"</span>)
res27: Double = -<span class="number">4.0</span>
</pre></td></tr></table></figure>

<p>版本2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>scala&gt; def foldingFunction(<span class="keyword">list</span>: <span class="keyword">List</span>[Double], next: String): Option[<span class="keyword">List</span>[Double]] = (<span class="keyword">list</span>, next) match {
         <span class="keyword">case</span> (x :: y :: ys, <span class="string">"*"</span>) =&gt; ((y * x) :: ys).point[Option]
         <span class="keyword">case</span> (x :: y :: ys, <span class="string">"+"</span>) =&gt; ((y + x) :: ys).point[Option]
         <span class="keyword">case</span> (x :: y :: ys, <span class="string">"-"</span>) =&gt; ((y - x) :: ys).point[Option]
         <span class="keyword">case</span> (xs, numString) =&gt; numString.parseInt.toOption map {_ :: xs}
       }
foldingFunction: (<span class="keyword">list</span>: <span class="keyword">List</span>[Double], next: String)Option[<span class="keyword">List</span>[Double]]

scala&gt; foldingFunction(<span class="keyword">List</span>(<span class="number">3</span>, <span class="number">2</span>), <span class="string">"*"</span>)
res33: Option[<span class="keyword">List</span>[Double]] = Some(<span class="keyword">List</span>(<span class="number">6.0</span>))

scala&gt; foldingFunction(Nil, <span class="string">"*"</span>)
res34: Option[<span class="keyword">List</span>[Double]] = None

<span class="comment">// 软错误</span>
scala&gt; foldingFunction(Nil, <span class="string">"wawa"</span>)
res35: Option[<span class="keyword">List</span>[Double]] = None
</pre></td></tr></table></figure>

<h1 id="composing-monadic-functions">Composing monadic functions</h1>
<h2 id="kleisli">Kleisli</h2>
<p>In Scalaz there’s a special wrapper for function
of <code>type A =&gt; M[B]</code> called Kleisli:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Kleisli</span>[<span class="title">M</span>[+<span class="title">_</span>], -<span class="title">A</span>, +<span class="title">B</span>] {</span> self =&gt;
  <span class="keyword">def</span> run(a: A): M[B]
  ...
  <span class="javadoc">/** alias for `andThen` */</span>
  <span class="keyword">def</span> &gt;=&gt;[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] =  kleisli((a: A) =&gt; b.bind(<span class="keyword">this</span>(a))(k(_)))
  <span class="keyword">def</span> andThen[C](k: Kleisli[M, B, C])(implicit b: Bind[M]): Kleisli[M, A, C] = <span class="keyword">this</span> &gt;=&gt; k
  <span class="javadoc">/** alias for `compose` */</span> 
  <span class="keyword">def</span> &lt;=&lt;[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; <span class="keyword">this</span>
  <span class="keyword">def</span> compose[C](k: Kleisli[M, C, A])(implicit b: Bind[M]): Kleisli[M, C, B] = k &gt;=&gt; <span class="keyword">this</span>
  ...
}

<span class="class"><span class="keyword">object</span> <span class="title">Kleisli</span> <span class="keyword">extends</span> <span class="title">KleisliFunctions</span> <span class="keyword">with</span> <span class="title">KleisliInstances</span> {</span>
  <span class="keyword">def</span> apply[M[+_], A, B](f: A =&gt; M[B]): Kleisli[M, A, B] = kleisli(f)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; val f = Kleisli { (<span class="built_in">x</span>: Int) =&gt; (<span class="built_in">x</span> + <span class="number">1</span>)<span class="preprocessor">.some</span> }
<span class="label">f:</span> scalaz<span class="preprocessor">.Kleisli</span>[Option,Int,Int] = scalaz<span class="preprocessor">.KleisliFunctions</span>$$anon$18<span class="localvars">@7</span>da2734e

scala&gt; val g = Kleisli { (<span class="built_in">x</span>: Int) =&gt; (<span class="built_in">x</span> * <span class="number">100</span>)<span class="preprocessor">.some</span> }
<span class="label">g:</span> scalaz<span class="preprocessor">.Kleisli</span>[Option,Int,Int] = scalaz<span class="preprocessor">.KleisliFunctions</span>$$anon$18<span class="localvars">@49</span>e07991

scala&gt; <span class="number">4.</span>some &gt;&gt;= (f &lt;=&lt; g)
<span class="label">res59:</span> Option[Int] = Some(<span class="number">401</span>)

scala&gt; <span class="number">4.</span>some &gt;&gt;= (f &gt;=&gt; g)
<span class="label">res60:</span> Option[Int] = Some(<span class="number">500</span>)
</pre></td></tr></table></figure>

<h2 id="reader">Reader</h2>
<p>As a bonus, Scalaz defines Reader as a special case of Kleisli as follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>type ReaderT[F[+_], E, A] = Kleisli[F, E, A]
type Reader[E, A] = ReaderT[Id, E, A]
object Reader {
  def apply[<span class="link_label">E, A</span>](<span class="link_url">f: E =&gt; A</span>): Reader[<span class="link_label">E, A</span>] = Kleisli[<span class="link_label">Id, E, A</span>](<span class="link_url">f</span>)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; val addStuff: Reader[<span class="built_in">Int</span>, <span class="built_in">Int</span>] = <span class="keyword">for</span> {
         a &lt;- Reader { (_: <span class="built_in">Int</span>) * <span class="number">2</span> }
         b &lt;- Reader { (_: <span class="built_in">Int</span>) + <span class="number">10</span> }
       } yield a + b
addStuff: scalaz.Reader[<span class="built_in">Int</span>,<span class="built_in">Int</span>] = scalaz.KleisliFunctions$$anon$<span class="number">18</span>@<span class="number">343</span>bd3ae

scala&gt; addStuff(<span class="number">3</span>)
res76: scalaz.Id.Id[<span class="built_in">Int</span>] = <span class="number">19</span>
</pre></td></tr></table></figure>

<h1 id="making-monads">Making monads</h1>
<p>What if we wanted to model a non-deterministic value like <code>[3,5,9]</code>
but we wanted to express that 3 has a 50% chance of happening and 5 and 9
both have a 25% chance of happening?</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Prob</span>[<span class="title">A</span>]<span class="params">(list: List[(A, Double)</span>])</span>

<span class="comment">// the list is a functor, so this should probably be a functor as well,</span>
<span class="comment">// because we just added some stuff to the list.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">ProbInstances</span> {</span>

  <span class="keyword">def</span> flatten[B](xs: Prob[Prob[B]]): Prob[B] = {
    <span class="keyword">def</span> multall(innerxs: Prob[B], p: Double) =
      innerxs.list map { <span class="keyword">case</span> (x, r) =&gt; (x, p * r) }
    Prob((xs.list map { <span class="keyword">case</span> (innerxs, p) =&gt; multall(innerxs, p) }).flatten)
  }
  
  implicit <span class="keyword">val</span> probInstance = <span class="keyword">new</span> Functor[Prob] {
    <span class="keyword">def</span> map[A, B](fa: Prob[A])(f: A =&gt; B): Prob[B] =
      Prob(fa.list map { <span class="keyword">case</span> (x, p) =&gt; (f(x), p) })
  }
  implicit <span class="keyword">def</span> probShow[A]: Show[Prob[A]] = Show.showA
}

<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Prob</span> <span class="keyword">extends</span> <span class="title">ProbInstances</span></span>
</pre></td></tr></table></figure>

<p>The probability of having all three coins on Tails even
with a loaded coin is pretty low.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Coin</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Heads</span> <span class="keyword">extends</span> <span class="title">Coin</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Tails</span> <span class="keyword">extends</span> <span class="title">Coin</span></span>
implicit <span class="keyword">val</span> coinEqual: Equal[Coin] = Equal.equalA

<span class="keyword">def</span> coin: Prob[Coin] = Prob(Heads -&gt; <span class="number">0.5</span> :: Tails -&gt; <span class="number">0.5</span> :: Nil)
<span class="keyword">def</span> loadedCoin: Prob[Coin] = Prob(Heads -&gt; <span class="number">0.1</span> :: Tails -&gt; <span class="number">0.9</span> :: Nil)

<span class="keyword">def</span> flipThree: Prob[Boolean] = <span class="keyword">for</span> {
  a &lt;- coin
  b &lt;- coin
  c &lt;- loadedCoin
} <span class="keyword">yield</span> { List(a, b, c) all {_ === Tails} }
</pre></td></tr></table></figure>

<h1 id="tree">Tree</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Tree</span>[<span class="title">A</span>] {</span>
  <span class="javadoc">/** The label at the root of this tree. */</span>
  <span class="keyword">def</span> rootLabel: A
  <span class="javadoc">/** The child nodes of this tree. */</span>
  <span class="keyword">def</span> subForest: Stream[Tree[A]]
}

<span class="class"><span class="keyword">object</span> <span class="title">Tree</span> <span class="keyword">extends</span> <span class="title">TreeFunctions</span> <span class="keyword">with</span> <span class="title">TreeInstances</span> {</span>
  <span class="javadoc">/** Construct a tree node with no children. */</span>
  <span class="keyword">def</span> apply[A](root: =&gt; A): Tree[A] = leaf(root)

  <span class="class"><span class="keyword">object</span> <span class="title">Node</span> {</span>
    <span class="keyword">def</span> unapply[A](t: Tree[A]): Option[(A, Stream[Tree[A]])] = Some((t.rootLabel, t.subForest))
  }
}

<span class="class"><span class="keyword">trait</span> <span class="title">TreeFunctions</span> {</span>
  <span class="javadoc">/** Construct a new Tree node. */</span>
  <span class="keyword">def</span> node[A](root: =&gt; A, forest: =&gt; Stream[Tree[A]]): Tree[A] = <span class="keyword">new</span> Tree[A] {
    <span class="keyword">lazy</span> <span class="keyword">val</span> rootLabel = root
    <span class="keyword">lazy</span> <span class="keyword">val</span> subForest = forest
    <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"&lt;tree&gt;"</span>
  }
  <span class="javadoc">/** Construct a tree node with no children. */</span>
  <span class="keyword">def</span> leaf[A](root: =&gt; A): Tree[A] = node(root, Stream.empty)
  ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">TreeV</span>[<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">Ops</span>[<span class="title">A</span>] {</span>
  <span class="keyword">def</span> node(subForest: Tree[A]*): Tree[A] = Tree.node(self, subForest.toStream)

  <span class="keyword">def</span> leaf: Tree[A] = Tree.leaf(self)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>scala&gt; def freeTree: Tree[Char] =
         <span class="string">'P'</span><span class="preprocessor">.node</span>(
           <span class="string">'O'</span><span class="preprocessor">.node</span>(
             <span class="string">'L'</span><span class="preprocessor">.node</span>(<span class="string">'N'</span><span class="preprocessor">.leaf</span>, <span class="string">'T'</span><span class="preprocessor">.leaf</span>),
             <span class="string">'Y'</span><span class="preprocessor">.node</span>(<span class="string">'S'</span><span class="preprocessor">.leaf</span>, <span class="string">'A'</span><span class="preprocessor">.leaf</span>)),
           <span class="string">'L'</span><span class="preprocessor">.node</span>(
             <span class="string">'W'</span><span class="preprocessor">.node</span>(<span class="string">'C'</span><span class="preprocessor">.leaf</span>, <span class="string">'R'</span><span class="preprocessor">.leaf</span>),
             <span class="string">'A'</span><span class="preprocessor">.node</span>(<span class="string">'A'</span><span class="preprocessor">.leaf</span>, <span class="string">'C'</span><span class="preprocessor">.leaf</span>)))
<span class="label">freeTree:</span> scalaz<span class="preprocessor">.Tree</span>[Char]

scala&gt; def changeToP(tree: Tree[Char]): Tree[Char] = tree match {
         case Tree<span class="preprocessor">.Node</span>(<span class="built_in">x</span>, Stream(
           l, Tree<span class="preprocessor">.Node</span>(<span class="built_in">y</span>, Stream(
             Tree<span class="preprocessor">.Node</span>(_, Stream(m, n)), r)))) =&gt;
           <span class="built_in">x</span><span class="preprocessor">.node</span>(l, <span class="built_in">y</span><span class="preprocessor">.node</span>(<span class="string">'P'</span><span class="preprocessor">.node</span>(m, n), r))
       }
<span class="label">changeToP:</span> (tree: scalaz<span class="preprocessor">.Tree</span>[Char])scalaz<span class="preprocessor">.Tree</span>[Char]
</pre></td></tr></table></figure>

<h2 id="treeloc">TreeLoc</h2>
<p>The zipper for Tree in Scalaz is called TreeLoc:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TreeLoc</span>[<span class="title">A</span>] {</span>
  <span class="keyword">import</span> TreeLoc._
  <span class="keyword">import</span> Tree._

  <span class="javadoc">/** The currently selected node. */</span>
  <span class="keyword">val</span> tree: Tree[A]
  <span class="javadoc">/** The left siblings of the current node. */</span>
  <span class="keyword">val</span> lefts: TreeForest[A]
  <span class="javadoc">/** The right siblings of the current node. */</span>
  <span class="keyword">val</span> rights: TreeForest[A]
  <span class="javadoc">/** The parent contexts of the current node. */</span>
  <span class="keyword">val</span> parents: Parents[A]
  ...
}

<span class="class"><span class="keyword">object</span> <span class="title">TreeLoc</span> <span class="keyword">extends</span> <span class="title">TreeLocFunctions</span> <span class="keyword">with</span> <span class="title">TreeLocInstances</span> {</span>
  <span class="keyword">def</span> apply[A](t: Tree[A], l: TreeForest[A], r: TreeForest[A], p: Parents[A]): TreeLoc[A] =
    loc(t, l, r, p)
}

<span class="class"><span class="keyword">trait</span> <span class="title">TreeLocFunctions</span> {</span>
  <span class="keyword">type</span> TreeForest[A] = Stream[Tree[A]]
  <span class="keyword">type</span> Parent[A] = (TreeForest[A], A, TreeForest[A])
  <span class="keyword">type</span> Parents[A] = Stream[Parent[A]]
}

<span class="comment">// similar to DOM API:</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TreeLoc</span>[<span class="title">A</span>] {</span>
  ...
  <span class="javadoc">/** Select the parent of the current node. */</span>
  <span class="keyword">def</span> parent: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the root node of the tree. */</span>
  <span class="keyword">def</span> root: TreeLoc[A] = ...
  <span class="javadoc">/** Select the left sibling of the current node. */</span>
  <span class="keyword">def</span> left: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the right sibling of the current node. */</span>
  <span class="keyword">def</span> right: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the leftmost child of the current node. */</span>
  <span class="keyword">def</span> firstChild: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the rightmost child of the current node. */</span>
  <span class="keyword">def</span> lastChild: Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the nth child of the current node. */</span>
  <span class="keyword">def</span> getChild(n: Int): Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Select the first immediate child of the current node that satisfies the given predicate. */</span>
  <span class="keyword">def</span> findChild(p: Tree[A] =&gt; Boolean): Option[TreeLoc[A]] = ...
  <span class="javadoc">/** Get the label of the current node. */</span>
  <span class="keyword">def</span> getLabel: A = ...
    <span class="javadoc">/** Modify the current node with the given function. */</span>
  <span class="keyword">def</span> modifyTree(f: Tree[A] =&gt; Tree[A]): TreeLoc[A] = ...
  <span class="javadoc">/** Modify the label at the current node with the given function. */</span>
  <span class="keyword">def</span> modifyLabel(f: A =&gt; A): TreeLoc[A] = ...
  <span class="javadoc">/** Insert the given node as the last child of the current node and give it focus. */</span>
  <span class="keyword">def</span> insertDownLast(t: Tree[A]): TreeLoc[A] = ...
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; freeTree<span class="preprocessor">.loc</span><span class="preprocessor">.getChild</span>(<span class="number">2</span>) &gt;&gt;= {_<span class="preprocessor">.getChild</span>(<span class="number">1</span>)}
<span class="label">res8:</span> Option[scalaz<span class="preprocessor">.TreeLoc</span>[Char]] = Some(scalaz<span class="preprocessor">.TreeLocFunctions</span>$$anon$2<span class="localvars">@417</span>ef051)

scala&gt; freeTree<span class="preprocessor">.loc</span><span class="preprocessor">.getChild</span>(<span class="number">2</span>) &gt;&gt;= {_<span class="preprocessor">.getChild</span>(<span class="number">1</span>)} &gt;&gt;= {_<span class="preprocessor">.getLabel</span><span class="preprocessor">.some</span>}
<span class="label">res9:</span> Option[Char] = Some(W)

// modify the label to <span class="string">'P'</span>:
scala&gt; val newFocus = freeTree<span class="preprocessor">.loc</span><span class="preprocessor">.getChild</span>(<span class="number">2</span>) &gt;&gt;= {_<span class="preprocessor">.getChild</span>(<span class="number">1</span>)} &gt;&gt;= {_<span class="preprocessor">.modifyLabel</span>({_ =&gt; <span class="string">'P'</span>})<span class="preprocessor">.some</span>}
<span class="label">newFocus:</span> Option[scalaz<span class="preprocessor">.TreeLoc</span>[Char]] = Some(scalaz<span class="preprocessor">.TreeLocFunctions</span>$$anon$2<span class="localvars">@107</span>a26d0)

scala&gt; newFocus<span class="preprocessor">.get</span><span class="preprocessor">.toTree</span>
<span class="label">res19:</span> scalaz<span class="preprocessor">.Tree</span>[Char] = &lt;tree&gt;
</pre></td></tr></table></figure>

<h2 id="zipper">Zipper</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>scala&gt; for {
         <span class="built_in">z</span> &lt;- Stream(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)<span class="preprocessor">.toZipper</span>
         n1 &lt;- <span class="built_in">z</span><span class="preprocessor">.next</span>
         n2 &lt;- n1<span class="preprocessor">.next</span>
       } yield { n2<span class="preprocessor">.modify</span> {_ =&gt; <span class="number">7</span>} }
<span class="label">res33:</span> Option[scalaz<span class="preprocessor">.Zipper</span>[Int]] = Some(Zipper(&lt;lefts&gt;, <span class="number">7</span>, &lt;rights&gt;))
</pre></td></tr></table></figure>

<h2 id="id">Id</h2>
<p>The Identity monad is a monad that does not embody any computational
strategy.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>/** The strict identity type constructor. Can be thought of <span class="keyword">as</span> `Tuple1`, but <span class="keyword">with</span> no
 *  runtime representation.
 */
type Id[+X] = X

trait IdOps[A] extends Ops[A] {
  /**Returns `self` <span class="keyword">if</span> it <span class="keyword">is</span> non-null, otherwise returns `d`. */
  final <span class="function"><span class="keyword">def</span> ??<span class="params">(d: =&gt; A)</span><span class="params">(implicit ev: Null &lt;:&lt; A)</span>:</span> A =
    <span class="keyword">if</span> (self == null) d <span class="keyword">else</span> self
  /**Applies `self` to the provided function */
  final <span class="function"><span class="keyword">def</span> |&gt;[<span class="title">B</span>]<span class="params">(f: A =&gt; B)</span>:</span> B = f(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">squared</span>:</span> (A, A) = (self, self)
  <span class="function"><span class="keyword">def</span> <span class="title">left</span>[<span class="title">B</span>]:</span> (A \/ B) = \/.left(self)
  <span class="function"><span class="keyword">def</span> <span class="title">right</span>[<span class="title">B</span>]:</span> (B \/ A) = \/.right(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">wrapNel</span>:</span> NonEmptyList[A] = NonEmptyList(self)
  /** <span class="decorator">@return the result of pf(value) if defined, otherwise the the Zero element of type B. */</span>
  <span class="function"><span class="keyword">def</span> <span class="title">matchOrZero</span>[<span class="title">B</span>:</span> Monoid](pf: PartialFunction[A, B]): B = ...
  /** Repeatedly apply `f`, seeded <span class="keyword">with</span> `self`, checking after each iteration whether the predicate `p` holds. */
  final <span class="function"><span class="keyword">def</span> <span class="title">doWhile</span><span class="params">(f: A =&gt; A, p: A =&gt; Boolean)</span>:</span> A = ...
  /** Repeatedly apply `f`, seeded <span class="keyword">with</span> `self`, checking before each iteration whether the predicate `p` holds. */
  final <span class="function"><span class="keyword">def</span> <span class="title">whileDo</span><span class="params">(f: A =&gt; A, p: A =&gt; Boolean)</span>:</span> A = ...
  /** If the provided partial function <span class="keyword">is</span> defined <span class="keyword">for</span> `self` run this,
   * otherwise lift `self` into `F` <span class="keyword">with</span> the provided [[scalaz.Pointed]]. */
  <span class="function"><span class="keyword">def</span> <span class="title">visit</span>[<span class="title">F</span>[<span class="title">_</span>] :</span> Pointed](p: PartialFunction[A, F[A]]): F[A] = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">// |&gt; lets you write the function application at the end of an expression:</span>
scala&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> |&gt; {_.point[<span class="keyword">List</span>]}
res45: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">6</span>)

scala&gt; <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> |&gt; {_ * <span class="number">6</span>}
res46: Int = <span class="number">36</span>

<span class="comment">// visit is also kind of interesting:</span>
scala&gt; <span class="number">1</span> visit { <span class="keyword">case</span> x@(<span class="number">2</span>|<span class="number">3</span>) =&gt; <span class="keyword">List</span>(x * <span class="number">2</span>) }
res55: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">1</span>)

scala&gt; <span class="number">2</span> visit { <span class="keyword">case</span> x@(<span class="number">2</span>|<span class="number">3</span>) =&gt; <span class="keyword">List</span>(x * <span class="number">2</span>) }
res56: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">4</span>)
</pre></td></tr></table></figure>

<h1 id="lawless-typeclasses">Lawless typeclasses</h1>
<p>Scalaz 7.0 contains several typeclasses that are now deemed
lawless by Scalaz project: Length, Index, and Each.</p>
<h2 id="length">Length</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>trait Length[F[_]]  { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">length</span>[<span class="title">A</span>]<span class="params">(fa: F[A])</span>:</span> Int
}
</pre></td></tr></table></figure>

<h2 id="index">Index</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>trait Index[F[_]]  { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">index</span>[<span class="title">A</span>]<span class="params">(fa: F[A], i: Int)</span>:</span> Option[A]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>trait IndexOps[F[_],A] extends Ops[F[A]] {
  final <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(n: Int)</span>:</span> Option[A] = F.index(self, n)
  final <span class="function"><span class="keyword">def</span> <span class="title">indexOr</span><span class="params">(default: =&gt; A, n: Int)</span>:</span> A = F.indexOr(self, default, n)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>scala&gt; List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">3</span>)
java.lang.IndexOutOfBoundsException: <span class="number">3</span>
        <span class="keyword">...</span>

scala&gt; List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) index <span class="number">3</span>
res62: Option[Int] = None
</pre></td></tr></table></figure>

<h2 id="each">Each</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">trait</span> Each[F[_]]  { <span class="keyword">self</span> =&gt;
  def each[A](fa: F[A])(f: A =&gt; Unit)
}

sealed <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EachOps</span>[<span class="title">F</span>[<span class="title">_</span>],<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">Ops</span>[<span class="title">F</span>[<span class="title">A</span>]] {</span>
  <span class="keyword">final</span> def <span class="keyword">foreach</span>(f: A =&gt; Unit): Unit = F.each(<span class="keyword">self</span>)(f)
}
</pre></td></tr></table></figure>

<h1 id="monad-transformers">Monad transformers</h1>
<p>A monad transformer is similar to a regular monad,
but it’s not a standalone entity:
instead, it modifies the behaviour of an underlying monad.</p>
<h2 id="reader-yet-again">Reader, yet again</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">myName</span><span class="params">(step: String)</span>:</span> Reader[String, String] = Reader {step + <span class="string">", I am "</span> + _}
myName: (step: String)scalaz.Reader[String,String]

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">localExample</span>:</span> Reader[String, (String, String, String)] = <span class="keyword">for</span> {
         a &lt;- myName(<span class="string">"First"</span>)
         b &lt;- myName(<span class="string">"Second"</span>) &gt;=&gt; Reader { _ + <span class="string">"dy"</span>}
         c &lt;- myName(<span class="string">"Third"</span>)  
       } <span class="keyword">yield</span> (a, b, c)
localExample: scalaz.Reader[String,(String, String, String)]

scala&gt; localExample(<span class="string">"Fred"</span>)
res0: (String, String, String) = (First, I am Fred,Second, I am Freddy,Third, I am Fred)
</pre></td></tr></table></figure>

<h2 id="readert">ReaderT</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">type</span> ReaderTOption[A, B] = ReaderT[Option, A, B]
<span class="class"><span class="keyword">object</span> <span class="title">ReaderTOption</span> <span class="keyword">extends</span> <span class="title">KleisliFunctions</span> <span class="keyword">with</span> <span class="title">KleisliInstances</span> {</span>
  <span class="keyword">def</span> apply[A, B](f: A =&gt; Option[B]): ReaderTOption[A, B] = kleisli(f)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>scala&gt; def configure(key: <span class="keyword">String</span>) = ReaderTOption[<span class="keyword">Map</span>[<span class="keyword">String</span>, <span class="keyword">String</span>], <span class="keyword">String</span>] <span class="list">{_.get(key)}</span> 
configure: (key: <span class="keyword">String</span>)ReaderTOption[<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>],<span class="keyword">String</span>]

scala&gt; def setupConnection = for <span class="list">{
         host &lt;- configure("host")
         user &lt;- configure("user")
         password &lt;- configure("password")
     }</span> yield (host, user, password)
setupConnection: scalaz.Kleisli[Option,<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>],(<span class="keyword">String</span>, <span class="keyword">String</span>, <span class="keyword">String</span>)]

scala&gt; val goodConfig = <span class="keyword">Map</span>(
         <span class="string">"host"</span> -&gt; <span class="string">"eed3si9n.com"</span>,
         <span class="string">"user"</span> -&gt; <span class="string">"sa"</span>,
         <span class="string">"password"</span> -&gt; <span class="string">"****"</span>
       )
goodConfig: scala.collection.immutable.<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>] = <span class="keyword">Map</span>(host -&gt; eed3si9n.com, user -&gt; sa, password -&gt; ****)

scala&gt; setupConnection(goodConfig)
res2: Option[(<span class="keyword">String</span>, <span class="keyword">String</span>, <span class="keyword">String</span>)] = Some((eed3si9n.com,sa,****))

scala&gt; val badConfig = <span class="keyword">Map</span>(
         <span class="string">"host"</span> -&gt; <span class="string">"example.com"</span>,
         <span class="string">"user"</span> -&gt; <span class="string">"sa"</span>
       )
badConfig: scala.collection.immutable.<span class="keyword">Map</span>[<span class="keyword">String</span>,<span class="keyword">String</span>] = <span class="keyword">Map</span>(host -&gt; example.com, user -&gt; sa)

scala&gt; setupConnection(badConfig)
res3: Option[(<span class="keyword">String</span>, <span class="keyword">String</span>, <span class="keyword">String</span>)] = <span class="keyword">None</span>
</pre></td></tr></table></figure>

<h2 id="stacking-multiple-monad-transformers">Stacking multiple monad transformers</h2>
<p>TODO</p>
<h1 id="lens">Lens</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>scala&gt; case class Turtle(position: Point, heading: Double, color: Color) {
         def forward(dist: Double): Turtle =
           copy(position =
             position<span class="preprocessor">.copy</span>(
               <span class="built_in">x</span> = position<span class="preprocessor">.x</span> + dist * math<span class="preprocessor">.cos</span>(heading),
               <span class="built_in">y</span> = position<span class="preprocessor">.y</span> + dist * math<span class="preprocessor">.sin</span>(heading)
           ))
     }
defined class Turtle

scala&gt; Turtle(Point(<span class="number">2.0</span>, <span class="number">3.0</span>), <span class="number">0.0</span>,
         Color(<span class="number">255.</span>toByte, <span class="number">255.</span>toByte, <span class="number">255.</span>toByte))
<span class="label">res10:</span> Turtle = Turtle(Point(<span class="number">2.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

scala&gt; res10<span class="preprocessor">.forward</span>(<span class="number">10</span>)
<span class="label">res11:</span> Turtle = Turtle(Point(<span class="number">12.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

// To update the child data structure, we need to nest copy <span class="keyword">call</span>.
// To quote from Seth’s example again:

// imperative
a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.d</span><span class="preprocessor">.e</span> += <span class="number">1</span>

// functional
a<span class="preprocessor">.copy</span>(
  b = a<span class="preprocessor">.b</span><span class="preprocessor">.copy</span>(
    c = a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.copy</span>(
      d = a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.d</span><span class="preprocessor">.copy</span>(
        e = a<span class="preprocessor">.b</span><span class="preprocessor">.c</span><span class="preprocessor">.d</span><span class="preprocessor">.e</span> + <span class="number">1</span>
))))
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="keyword">type</span> Lens[A, B] = LensT[Id, A, B]

<span class="class"><span class="keyword">object</span> <span class="title">Lens</span> <span class="keyword">extends</span> <span class="title">LensTFunctions</span> <span class="keyword">with</span> <span class="title">LensTInstances</span> {</span>
  <span class="keyword">def</span> apply[A, B](r: A =&gt; Store[B, A]): Lens[A, B] =
    lens(r)
}

<span class="keyword">import</span> StoreT._
<span class="keyword">import</span> Id._

<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">LensT</span>[<span class="title">F</span>[+<span class="title">_</span>], <span class="title">A</span>, <span class="title">B</span>] {</span>
  <span class="keyword">def</span> run(a: A): F[Store[B, A]]
  <span class="keyword">def</span> apply(a: A): F[Store[B, A]] = run(a)
  ...
}

<span class="class"><span class="keyword">object</span> <span class="title">LensT</span> <span class="keyword">extends</span> <span class="title">LensTFunctions</span> <span class="keyword">with</span> <span class="title">LensTInstances</span> {</span>
  <span class="keyword">def</span> apply[F[+_], A, B](r: A =&gt; F[Store[B, A]]): LensT[F, A, B] =
    lensT(r)
}

<span class="class"><span class="keyword">trait</span> <span class="title">LensTFunctions</span> {</span>
  <span class="keyword">import</span> StoreT._

  <span class="keyword">def</span> lensT[F[+_], A, B](r: A =&gt; F[Store[B, A]]): LensT[F, A, B] = <span class="keyword">new</span> LensT[F, A, B] {
    <span class="keyword">def</span> run(a: A): F[Store[B, A]] = r(a)
  }

  <span class="keyword">def</span> lensgT[F[+_], A, B](set: A =&gt; F[B =&gt; A], get: A =&gt; F[B])(implicit M: Bind[F]): LensT[F, A, B] =
    lensT(a =&gt; M(set(a), get(a))(Store(_, _)))
  <span class="keyword">def</span> lensg[A, B](set: A =&gt; B =&gt; A, get: A =&gt; B): Lens[A, B] =
    lensgT[Id, A, B](set, get)
  <span class="keyword">def</span> lensu[A, B](set: (A, B) =&gt; A, get: A =&gt; B): Lens[A, B] =
    lensg(set.curried, get)
  ...
}

<span class="keyword">type</span> Store[A, B] = StoreT[Id, A, B]
  <span class="comment">// flipped</span>
  <span class="keyword">type</span> |--&gt;[A, B] = Store[B, A]
  <span class="class"><span class="keyword">object</span> <span class="title">Store</span> {</span>
    <span class="keyword">def</span> apply[A, B](f: A =&gt; B, a: A): Store[A, B] = StoreT.store(a)(f)
}
</pre></td></tr></table></figure>

<h2 id="using-lens">Using Lens</h2>
<p>类似给类设置 get 和 set 方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>scala&gt; val turtlePosition = Lens<span class="preprocessor">.lensu</span>[Turtle, Point] (
         (a, value) =&gt; a<span class="preprocessor">.copy</span>(position = value),
         _<span class="preprocessor">.position</span>
       )
<span class="label">turtlePosition:</span> scalaz<span class="preprocessor">.Lens</span>[Turtle,Point] = scalaz<span class="preprocessor">.LensTFunctions</span>$$anon$5<span class="localvars">@421</span>dc8c8

scala&gt; val pointX = Lens<span class="preprocessor">.lensu</span>[Point, Double] (
         (a, value) =&gt; a<span class="preprocessor">.copy</span>(<span class="built_in">x</span> = value),
         _<span class="preprocessor">.x</span>
       )
<span class="label">pointX:</span> scalaz<span class="preprocessor">.Lens</span>[Point,Double] = scalaz<span class="preprocessor">.LensTFunctions</span>$$anon$5<span class="localvars">@30</span>d31cf9

scala&gt; val turtleX = turtlePosition &gt;=&gt; pointX
<span class="label">turtleX:</span> scalaz<span class="preprocessor">.LensT</span>[scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>,Turtle,Double] = scalaz<span class="preprocessor">.LensTFunctions</span>$$anon$5<span class="localvars">@11</span>b3536

scala&gt; val t0 = Turtle(Point(<span class="number">2.0</span>, <span class="number">3.0</span>), <span class="number">0.0</span>,
                  Color(<span class="number">255.</span>toByte, <span class="number">255.</span>toByte, <span class="number">255.</span>toByte))
<span class="label">t0:</span> Turtle = Turtle(Point(<span class="number">2.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

scala&gt; turtleX<span class="preprocessor">.get</span>(t0)
<span class="label">res16:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Double] = <span class="number">2.0</span>

scala&gt; turtleX<span class="preprocessor">.set</span>(t0, <span class="number">5.0</span>)
<span class="label">res17:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">5.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

scala&gt; turtleX<span class="preprocessor">.mod</span>(_ + <span class="number">1.0</span>, t0)
<span class="label">res19:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">3.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))

// 柯里化
scala&gt; val incX = turtleX =&gt;= {_ + <span class="number">1.0</span>}
<span class="label">incX:</span> Turtle =&gt; scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = &lt;function1&gt;

scala&gt; incX(t0)
<span class="label">res26:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">3.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))
</pre></td></tr></table></figure>

<h2 id="lens-as-a-state-monad">Lens as a State monad</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>// %= method takes a function Double =&gt; Double
// <span class="keyword">and</span> returns a State monad that expresses the change.
scala&gt; val incX = for {
         <span class="built_in">x</span> &lt;- turtleX %= {_ + <span class="number">1.0</span>}
       } yield <span class="built_in">x</span>
<span class="label">incX:</span> scalaz<span class="preprocessor">.StateT</span>[scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>,Turtle,Double] = scalaz<span class="preprocessor">.StateT</span>$$anon$7<span class="localvars">@38</span>e61ffa

scala&gt; incX(t0)
<span class="label">res28:</span> (Turtle, Double) = (Turtle(Point(<span class="number">3.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>)),<span class="number">3.0</span>)

//  Instead of general %=, Scalaz even provides sugars like += for Numeric lenses
scala&gt; def forward(dist: Double) = for {
         heading &lt;- turtleHeading
         <span class="built_in">x</span> &lt;- turtleX += dist * math<span class="preprocessor">.cos</span>(heading)
         <span class="built_in">y</span> &lt;- turtleY += dist * math<span class="preprocessor">.sin</span>(heading)
       } yield (<span class="built_in">x</span>, <span class="built_in">y</span>)
<span class="label">forward:</span> (dist: Double)scalaz<span class="preprocessor">.StateT</span>[scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>,Turtle,(Double, Double)]

scala&gt; forward(<span class="number">10.0</span>)(t0)
<span class="label">res31:</span> (Turtle, (Double, Double)) = (Turtle(Point(<span class="number">12.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>)),(<span class="number">12.0</span>,<span class="number">3.0</span>))

scala&gt; forward(<span class="number">10.0</span>) exec (t0)
<span class="label">res32:</span> scalaz<span class="preprocessor">.Id</span><span class="preprocessor">.Id</span>[Turtle] = Turtle(Point(<span class="number">12.0</span>,<span class="number">3.0</span>),<span class="number">0.0</span>,Color(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>))
</pre></td></tr></table></figure>

<p>Lens 的一些其他方法的定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">LensT</span>[<span class="title">F</span>[+<span class="title">_</span>], <span class="title">A</span>, <span class="title">B</span>] {</span>
  <span class="keyword">def</span> get(a: A)(implicit F: Functor[F]): F[B] =
    F.map(run(a))(_.pos)
  <span class="keyword">def</span> set(a: A, b: B)(implicit F: Functor[F]): F[A] =
    F.map(run(a))(_.put(b))
  <span class="javadoc">/** Modify the value viewed through the lens */</span>
  <span class="keyword">def</span> mod(f: B =&gt; B, a: A)(implicit F: Functor[F]): F[A] = ...
  <span class="keyword">def</span> =&gt;=(f: B =&gt; B)(implicit F: Functor[F]): A =&gt; F[A] =
    mod(f, _)
  <span class="javadoc">/** Modify the portion of the state viewed through the lens and return its new value. */</span>
  <span class="keyword">def</span> %=(f: B =&gt; B)(implicit F: Functor[F]): StateT[F, A, B] =
    mods(f)
  <span class="javadoc">/** Lenses can be composed */</span>
  <span class="keyword">def</span> compose[C](that: LensT[F, C, A])(implicit F: Bind[F]): LensT[F, C, B] = ...
  <span class="javadoc">/** alias for `compose` */</span>
  <span class="keyword">def</span> &lt;=&lt;[C](that: LensT[F, C, A])(implicit F: Bind[F]): LensT[F, C, B] = compose(that)
  <span class="keyword">def</span> andThen[C](that: LensT[F, B, C])(implicit F: Bind[F]): LensT[F, A, C] =
    that compose <span class="keyword">this</span>
  <span class="javadoc">/** alias for `andThen` */</span>
  <span class="keyword">def</span> &gt;=&gt;[C](that: LensT[F, B, C])(implicit F: Bind[F]): LensT[F, A, C] = andThen(that)
}
</pre></td></tr></table></figure>

<h2 id="lens-laws">Lens laws</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>trait LensLaw {
  def identity(a: A)(implicit A: Equal[A], ev: F[Store[B, A]] =:= Id[Store[B, A]]): Boolean = {
    val c = <span class="command">run</span>(a)
    A.<span class="keyword">equal</span>(c.<span class="keyword">put</span>(c.pos), a)
  }
  def retention(a: A, b: B)(implicit B: Equal[B], ev: F[Store[B, A]] =:= Id[Store[B, A]]): Boolean =
    B.<span class="keyword">equal</span>(<span class="command">run</span>(<span class="command">run</span>(a) <span class="keyword">put</span> b).pos, b)
  def doubleSet(a: A, b1: B, b2: B)(implicit A: Equal[A], ev: F[Store[B, A]] =:= Id[Store[B, A]]) = {
    val r = <span class="command">run</span>(a)
    A.<span class="keyword">equal</span>(<span class="command">run</span>(r <span class="keyword">put</span> b1) <span class="keyword">put</span> b2, r <span class="keyword">put</span> b2)
  }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="scalaz" scheme="http://zhpooer.github.io/tags/scalaz/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[learning scalaz 进阶]]></title>
    <link href="http://zhpooer.github.io/2014/07/29/learning-scalaz-%E8%BF%9B%E9%98%B6/"/>
    <id>http://zhpooer.github.io/2014/07/29/learning-scalaz-进阶/</id>
    <published>2014-07-29T09:17:46.000Z</published>
    <updated>2014-07-29T14:38:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tagged-type">Tagged type</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="class"><span class="keyword">type</span> <span class="title">Tagged</span>[<span class="title">U</span>] =</span> { <span class="class"><span class="keyword">type</span> <span class="title">Tag</span> =</span> U }
<span class="class"><span class="keyword">type</span> @@[<span class="title">T</span>, <span class="title">U</span>] =</span> T <span class="keyword">with</span> Tagged[U]
</pre></td></tr></table></figure>

<p>Suppose we want a way to express mass using kilogram,
because kg is the international standard of unit.
Normally we would pass in Double and call it a day,
but we can’t distinguish that from other Double values.
Can we use case class for this?</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>case class KiloGram(value: Double)
// we have to call x.value every time we need to extract the value out of it.

// Tagged type to the rescue.
sealed trait KiloGram
def KiloGram[<span class="link_label">A</span>](<span class="link_url">a: A</span>): A @@ KiloGram = Tag[<span class="link_label">A, KiloGram</span>](<span class="link_url">a</span>)
val mass = KiloGram(20.0)

2 * mass // res2: Double = 40.0
</pre></td></tr></table></figure>

<p>A <code>@@</code> KiloGram is an infix notation of <code>scalaz.@@[A, KiloGram]</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>scala&gt; sealed trait JoulePerKiloGram
defined trait JoulePerKiloGram

scala&gt; def JoulePerKiloGram[<span class="link_label">A</span>](<span class="link_url">a: A</span>): A @@ JoulePerKiloGram = Tag[<span class="link_label">A, JoulePerKiloGram</span>](<span class="link_url">a</span>)
JoulePerKiloGram: [<span class="link_label">A</span>](<span class="link_url">a: A</span>)scalaz.@@[A,JoulePerKiloGram]

scala&gt; def energyR(m: Double @@ KiloGram): Double @@ JoulePerKiloGram =
<span class="code">     |   JoulePerKiloGram(299792458.0 * 299792458.0 * m)</span>
energyR: (m: scalaz.@@[Double,KiloGram])scalaz.@@[Double,JoulePerKiloGram]

scala&gt; energyR(mass)
res4: scalaz.@@[Double,JoulePerKiloGram] = 1.79751035747363533E18

scala&gt; energyR(10.0)
<span class="xml"><span class="tag">&lt;<span class="title">console</span>&gt;</span></span>:18: error: type mismatch;
 found   : Double(10.0)
 required: scalaz.@@[Double,KiloGram]
<span class="code">    (which expands to)  Double with AnyRef{type Tag = KiloGram}</span>
<span class="code">              energyR(10.0)</span>
</pre></td></tr></table></figure>

<h1 id="monoids">Monoids</h1>
<p>Monoid defined in scalaz</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>trait Monoid[A] extends Semigroup[A] { self =&gt;
  ////
  /** The identity element <span class="keyword">for</span> `append`. */
  <span class="function"><span class="keyword">def</span> <span class="title">zero</span>:</span> A
  ...
}

trait Semigroup[A]  { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(a1: A, a2: =&gt; A)</span>:</span> A
  ...
}

// operators
trait SemigroupOps[A] extends Ops[A] {
  final <span class="function"><span class="keyword">def</span> |+|<span class="params">(other: =&gt; A)</span>:</span> A = A.append(self, other)
  final <span class="function"><span class="keyword">def</span> <span class="title">mappend</span><span class="params">(other: =&gt; A)</span>:</span> A = A.append(self, other)
  final <span class="function"><span class="keyword">def</span> ⊹<span class="params">(other: =&gt; A)</span>:</span> A = A.append(self, other)
}

scala&gt; List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) |+| List(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)
res26: List[Int] = List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)

scala&gt; <span class="string">"one"</span> |+| <span class="string">"two"</span>
res27: String = onetwo

scala&gt; Monoid[List[Int]].zero
res15: List[Int] = List()

scala&gt; Monoid[String].zero
res16: String = <span class="string">""</span>
</pre></td></tr></table></figure>

<h1 id="tags-multiplication">Tags.Multiplication</h1>
<p>This is where Scalaz 7 uses tagged type.
There are 8 tags for Monoids and 1 named Zip for Applicative.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// 乘法表示, 也可以有加法
scala&gt; Tags<span class="preprocessor">.Multiplication</span>(<span class="number">10</span>) |+| Monoid[Int @@ Tags<span class="preprocessor">.Multiplication</span>]<span class="preprocessor">.zero</span>
<span class="label">res21:</span> scalaz.@@[Int,scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.Multiplication</span>] = <span class="number">10</span>

scala&gt; <span class="number">10</span> |+| Monoid[Int]<span class="preprocessor">.zero</span>
<span class="label">res22:</span> Int = <span class="number">10</span>
</pre></td></tr></table></figure>

<h2 id="tags-disjunction-and-tags-conjunction">Tags.Disjunction and Tags.Conjunction</h2>
<p>或 非</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; Tags<span class="preprocessor">.Disjunction</span>(true) |+| Tags<span class="preprocessor">.Disjunction</span>(false)
<span class="label">res28:</span> scalaz.@@[Boolean,scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.Disjunction</span>] = true

scala&gt; Monoid[Boolean @@ Tags<span class="preprocessor">.Disjunction</span>]<span class="preprocessor">.zero</span> |+| Tags<span class="preprocessor">.Disjunction</span>(true)
<span class="label">res29:</span> scalaz.@@[Boolean,scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.Disjunction</span>] = true

scala&gt; Monoid[Boolean @@ Tags<span class="preprocessor">.Disjunction</span>]<span class="preprocessor">.zero</span> |+| Monoid[Boolean @@ Tags<span class="preprocessor">.Disjunction</span>]<span class="preprocessor">.zero</span>
<span class="label">res30:</span> scalaz.@@[Boolean,scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.Disjunction</span>] = false

scala&gt; Monoid[Boolean @@ Tags<span class="preprocessor">.Conjunction</span>]<span class="preprocessor">.zero</span> |+| Tags<span class="preprocessor">.Conjunction</span>(true)
<span class="label">res31:</span> scalaz.@@[Boolean,scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.Conjunction</span>] = true

scala&gt; Monoid[Boolean @@ Tags<span class="preprocessor">.Conjunction</span>]<span class="preprocessor">.zero</span> |+| Tags<span class="preprocessor">.Conjunction</span>(false)
<span class="label">res32:</span> scalaz.@@[Boolean,scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.Conjunction</span>] = false
</pre></td></tr></table></figure>

<h2 id="ordering-as-monoid">Ordering as Monoid</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">Ordering</span>.LT |+| <span class="keyword">Ordering</span>.GT
&lt;console&gt;:<span class="number">14</span>: error: value |+| is not a member of object scalaz.<span class="keyword">Ordering</span>.LT
              <span class="keyword">Ordering</span>.LT |+| <span class="keyword">Ordering</span>.GT
                          ^

scala&gt; (<span class="keyword">Ordering</span>.LT: <span class="keyword">Ordering</span>) |+| (<span class="keyword">Ordering</span>.GT: <span class="keyword">Ordering</span>)
res42: scalaz.<span class="keyword">Ordering</span> = LT

scala&gt; (<span class="keyword">Ordering</span>.GT: <span class="keyword">Ordering</span>) |+| (<span class="keyword">Ordering</span>.LT: <span class="keyword">Ordering</span>)
res43: scalaz.<span class="keyword">Ordering</span> = GT

scala&gt; Monoid[<span class="keyword">Ordering</span>].zero |+| (<span class="keyword">Ordering</span>.LT: <span class="keyword">Ordering</span>)
res44: scalaz.<span class="keyword">Ordering</span> = LT

scala&gt; Monoid[<span class="keyword">Ordering</span>].zero |+| (<span class="keyword">Ordering</span>.GT: <span class="keyword">Ordering</span>)
res45: scalaz.<span class="keyword">Ordering</span> = GT

// 定义长度比较
scala&gt; def lengthCompare(lhs: <span class="keyword">String</span>, rhs: <span class="keyword">String</span>): <span class="keyword">Ordering</span> =
         (lhs.length ?|? rhs.length) |+| (lhs ?|? rhs)
lengthCompare: (lhs: <span class="keyword">String</span>, rhs: <span class="keyword">String</span>)scalaz.<span class="keyword">Ordering</span>

scala&gt; lengthCompare(<span class="string">"zen"</span>, <span class="string">"ants"</span>)
res46: scalaz.<span class="keyword">Ordering</span> = LT

scala&gt; lengthCompare(<span class="string">"zen"</span>, <span class="string">"ant"</span>)
res47: scalaz.<span class="keyword">Ordering</span> = GT
</pre></td></tr></table></figure>

<h1 id="functor-laws">Functor Laws</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>trait FunctorLaw {
  /** The identity function, lifted, <span class="keyword">is</span> a no-op. */
  <span class="function"><span class="keyword">def</span> <span class="title">identity</span>[<span class="title">A</span>]<span class="params">(fa: F[A])</span><span class="params">(implicit FA: Equal[F[A]])</span>:</span> Boolean = FA.equal(map(fa)(x =&gt; x), fa)

  /**
   * A series of maps may be freely rewritten <span class="keyword">as</span> a single map on a
   * composed function.
   */
  <span class="function"><span class="keyword">def</span> <span class="title">associative</span>[<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>]<span class="params">(fa: F[A], f1: A =&gt; B, f2: B =&gt; C)</span><span class="params">(implicit FC: Equal[F[C]])</span>:</span> Boolean =
    FC.equal(map(map(fa)(f1))(f2), map(fa)(f2 compose f1))
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>scalaVersion <span class="symbol">:</span>= <span class="string">"2.11.0"</span>

val scalazVersion = <span class="string">"7.0.6"</span>

libraryDependencies ++= <span class="constant">Seq</span>(
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-core" %</span> scalazVersion,
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-effect" %</span> scalazVersion,
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-typelevel" %</span> scalazVersion,
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-scalacheck-binding" %</span> scalazVersion % <span class="string">"test"</span>
)

scalacOptions += <span class="string">"-feature"</span>

initialCommands <span class="keyword">in</span> console <span class="symbol">:</span>= <span class="string">"import scalaz._, Scalaz._"</span>

initialCommands <span class="keyword">in</span> console <span class="keyword">in</span> <span class="constant">Test</span> <span class="symbol">:</span>= <span class="string">"import scalaz._, Scalaz._, scalacheck.ScalazProperties._, scalacheck.ScalazArbitrary._,scalacheck.ScalaCheckBinding._"</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>$ sbt test:console
[info] Starting scala interpreter...
[info] 
<span class="keyword">import</span> scalaz._
<span class="keyword">import</span> Scalaz._
<span class="keyword">import</span> scalacheck.ScalazProperties._
<span class="keyword">import</span> scalacheck.ScalazArbitrary._
<span class="keyword">import</span> scalacheck.ScalaCheckBinding._
Welcome to Scala <span class="keyword">version</span> <span class="number">2.10</span>.3 (Java HotSpot(TM) <span class="number">64</span>-Bit Server VM, Java <span class="number">1.6</span>.0_45).
Type <span class="keyword">in</span> expressions to have them evaluated.
Type :help <span class="keyword">for</span> more information.

scala&gt; functor.laws[List].check
</pre></td></tr></table></figure>

<p>这些规则可能会被破坏</p>
<h1 id="applicative-laws">Applicative Laws</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>trait ApplicativeLaw extends FunctorLaw {
  def identityAp[A](<span class="attribute">fa</span>: F[A])(implicit <span class="attribute">FA</span>: Equal[F[A]]): Boolean =
    FA.equal<span class="function"><span class="params">(ap(fa)(point((a: A) =&gt; a)), fa)</span>
    
  <span class="title">def</span> <span class="title">composition</span>[<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>]<span class="params">(fbc: F[B =&gt; C], fab: F[A =&gt; B], fa: F[A])(implicit FC: Equal[F[C]])</span> =
    <span class="title">FC</span>.<span class="title">equal</span><span class="params">(ap(ap(fa)(fab))(fbc), ap(fa)(ap(fab)(ap(fbc)(point((bc: B =&gt; C) =&gt; (ab: A =&gt; B) =&gt; bc compose ab)))))</span>
    
  <span class="title">def</span> <span class="title">homomorphism</span>[<span class="title">A</span>, <span class="title">B</span>]<span class="params">(ab: A =&gt; B, a: A)(implicit FB: Equal[F[B]])</span>: <span class="title">Boolean</span> =
    <span class="title">FB</span>.<span class="title">equal</span><span class="params">(ap(point(a))(point(ab)), point(ab(a)))</span>
    
  <span class="title">def</span> <span class="title">interchange</span>[<span class="title">A</span>, <span class="title">B</span>]<span class="params">(f: F[A =&gt; B], a: A)(implicit FB: Equal[F[B]])</span>: <span class="title">Boolean</span> =
    <span class="title">FB</span>.<span class="title">equal</span><span class="params">(ap(point(a))(f), ap(f)(point((f: A =&gt; B) =&gt; f(a))))</span>
}</span>
</pre></td></tr></table></figure>

<h1 id="semigroup-law">Semigroup Law</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>trait SemigroupLaw {
  <span class="function"><span class="keyword">def</span> <span class="title">associative</span><span class="params">(f1: F, f2: F, f3: F)</span><span class="params">(implicit F: Equal[F])</span>:</span> Boolean =
    F.equal(append(f1, append(f2, f3)), append(append(f1, f2), f3))
}
</pre></td></tr></table></figure>

<h1 id="monoid-laws">Monoid Laws</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">MonoidLaw</span> <span class="keyword">extends</span> <span class="title">SemigroupLaw</span> {</span>
  <span class="keyword">def</span> leftIdentity(a: F)(implicit F: Equal[F]) = F.equal(a, append(zero, a))
  <span class="keyword">def</span> rightIdentity(a: F)(implicit F: Equal[F]) = F.equal(a, append(a, zero))
}
</pre></td></tr></table></figure>

<h1 id="option-as-monoid">Option as Monoid</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>implicit def optionMonoid[<span class="attribute">A</span>: Semigroup]: Monoid[Option[A]] = <span class="keyword">new</span> Monoid[Option[A]] {
  def append(<span class="attribute">f1</span>: Option[A], <span class="attribute">f2</span>:<span class="function"> =&gt;</span> Option[A]) = (f1, f2) match {
    <span class="reserved">case</span> <span class="function"><span class="params">(Some(a1), Some(a2))</span> =&gt;</span> Some(Semigroup[A].append(a1, a2))
    <span class="reserved">case</span> <span class="function"><span class="params">(Some(a1), None)</span>     =&gt;</span> f1
    <span class="reserved">case</span> <span class="function"><span class="params">(None, Some(a2))</span>     =&gt;</span> f2
    <span class="reserved">case</span> <span class="function"><span class="params">(None, None)</span>         =&gt;</span> None
  }
  def <span class="attribute">zero</span>: Option[A] = None
}

scala&gt; (<span class="attribute">none</span>: Option[String]) |+| <span class="string">"andy"</span>.some
<span class="attribute">res23</span>: Option[String] = Some(andy)

scala&gt; (Ordering.<span class="attribute">LT</span>: Ordering).some |+| none
<span class="attribute">res25</span>: Option[scalaz.Ordering] = Some(LT)
</pre></td></tr></table></figure>

<p>if we don’t know if the contents are monoids,
we can’t use mappend between them, so what are we to do? Well,
one thing we can do is to just discard the second
value and keep the first one. For this, the First a type exists.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>scala&gt; Tags<span class="preprocessor">.First</span>(<span class="string">'a'</span><span class="preprocessor">.some</span>) |+| Tags<span class="preprocessor">.First</span>(<span class="string">'b'</span><span class="preprocessor">.some</span>)
<span class="label">res26:</span> scalaz.@@[Option[Char],scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.First</span>] = Some(a)

scala&gt; Tags<span class="preprocessor">.First</span>(none: Option[Char]) |+| Tags<span class="preprocessor">.First</span>(<span class="string">'b'</span><span class="preprocessor">.some</span>)
<span class="label">res27:</span> scalaz.@@[Option[Char],scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.First</span>] = Some(b)

scala&gt; Tags<span class="preprocessor">.First</span>(<span class="string">'a'</span><span class="preprocessor">.some</span>) |+| Tags<span class="preprocessor">.First</span>(none: Option[Char])
<span class="label">res28:</span> scalaz.@@[Option[Char],scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.First</span>] = Some(a)

// 同理可得
scala&gt; Tags<span class="preprocessor">.First</span>(<span class="string">'a'</span><span class="preprocessor">.some</span>) |+| Tags<span class="preprocessor">.First</span>(<span class="string">'b'</span><span class="preprocessor">.some</span>)
<span class="label">res26:</span> scalaz.@@[Option[Char],scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.First</span>] = Some(a)

scala&gt; Tags<span class="preprocessor">.First</span>(none: Option[Char]) |+| Tags<span class="preprocessor">.First</span>(<span class="string">'b'</span><span class="preprocessor">.some</span>)
<span class="label">res27:</span> scalaz.@@[Option[Char],scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.First</span>] = Some(b)

scala&gt; Tags<span class="preprocessor">.First</span>(<span class="string">'a'</span><span class="preprocessor">.some</span>) |+| Tags<span class="preprocessor">.First</span>(none: Option[Char])
<span class="label">res28:</span> scalaz.@@[Option[Char],scalaz<span class="preprocessor">.Tags</span><span class="preprocessor">.First</span>] = Some(a)
</pre></td></tr></table></figure>

<h1 id="foldable">Foldable</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>trait Foldable[F[_]] { self =&gt;
  /** Map each element of the structure to a [[scalaz.Monoid]], <span class="keyword">and</span> combine the results. */
  <span class="function"><span class="keyword">def</span> <span class="title">foldMap</span>[<span class="title">A</span>,<span class="title">B</span>]<span class="params">(fa: F[A])</span><span class="params">(f: A =&gt; B)</span><span class="params">(implicit F: Monoid[B])</span>:</span> B

  /**Right-associative fold of a structure. */
  <span class="function"><span class="keyword">def</span> <span class="title">foldRight</span>[<span class="title">A</span>, <span class="title">B</span>]<span class="params">(fa: F[A], z: =&gt; B)</span><span class="params">(f: <span class="params">(A, =&gt; B)</span> =&gt; B)</span>:</span> B

  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>/** Wraps a value `self` <span class="keyword">and</span> provides methods related to `Foldable` */
trait FoldableOps[F[_],A] extends Ops[F[A]] {
  implicit <span class="function"><span class="keyword">def</span> <span class="title">F</span>:</span> Foldable[F]
  ////
  final <span class="function"><span class="keyword">def</span> <span class="title">foldMap</span>[<span class="title">B</span>:</span> Monoid](f: A =&gt; B = (a: A) =&gt; a): B = F.foldMap(self)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldRight</span>[<span class="title">B</span>]<span class="params">(z: =&gt; B)</span><span class="params">(f: <span class="params">(A, =&gt; B)</span> =&gt; B)</span>:</span> B = F.foldRight(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span>[<span class="title">B</span>]<span class="params">(z: B)</span><span class="params">(f: <span class="params">(B, A)</span> =&gt; B)</span>:</span> B = F.foldLeft(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldRightM</span>[<span class="title">G</span>[<span class="title">_</span>], <span class="title">B</span>]<span class="params">(z: =&gt; B)</span><span class="params">(f: <span class="params">(A, =&gt; B)</span> =&gt; G[B])</span><span class="params">(implicit M: Monad[G])</span>:</span> G[B] = F.foldRightM(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldLeftM</span>[<span class="title">G</span>[<span class="title">_</span>], <span class="title">B</span>]<span class="params">(z: B)</span><span class="params">(f: <span class="params">(B, A)</span> =&gt; G[B])</span><span class="params">(implicit M: Monad[G])</span>:</span> G[B] = F.foldLeftM(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldr</span>[<span class="title">B</span>]<span class="params">(z: =&gt; B)</span><span class="params">(f: A =&gt; <span class="params">(=&gt; B)</span> =&gt; B)</span>:</span> B = F.foldr(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldl</span>[<span class="title">B</span>]<span class="params">(z: B)</span><span class="params">(f: B =&gt; A =&gt; B)</span>:</span> B = F.foldl(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldrM</span>[<span class="title">G</span>[<span class="title">_</span>], <span class="title">B</span>]<span class="params">(z: =&gt; B)</span><span class="params">(f: A =&gt; <span class="params">( =&gt; B)</span> =&gt; G[B])</span><span class="params">(implicit M: Monad[G])</span>:</span> G[B] = F.foldrM(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldlM</span>[<span class="title">G</span>[<span class="title">_</span>], <span class="title">B</span>]<span class="params">(z: B)</span><span class="params">(f: B =&gt; A =&gt; G[B])</span><span class="params">(implicit M: Monad[G])</span>:</span> G[B] = F.foldlM(self, z)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldr1</span><span class="params">(f: <span class="params">(A, =&gt; A)</span> =&gt; A)</span>:</span> Option[A] = F.foldr1(self)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">foldl1</span><span class="params">(f: <span class="params">(A, A)</span> =&gt; A)</span>:</span> Option[A] = F.foldl1(self)(f)
  final <span class="function"><span class="keyword">def</span> <span class="title">sumr</span><span class="params">(implicit A: Monoid[A])</span>:</span> A = F.foldRight(self, A.zero)(A.append)
  final <span class="function"><span class="keyword">def</span> <span class="title">suml</span><span class="params">(implicit A: Monoid[A])</span>:</span> A = F.foldLeft(self, A.zero)(A.append(_, _))
  final <span class="function"><span class="keyword">def</span> <span class="title">toList</span>:</span> List[A] = F.toList(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">toIndexedSeq</span>:</span> IndexedSeq[A] = F.toIndexedSeq(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">toSet</span>:</span> Set[A] = F.toSet(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">toStream</span>:</span> Stream[A] = F.toStream(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(p: A =&gt; Boolean)</span>:</span> Boolean = F.all(self)(p)
  final <span class="function"><span class="keyword">def</span> ∀<span class="params">(p: A =&gt; Boolean)</span>:</span> Boolean = F.all(self)(p)
  final <span class="function"><span class="keyword">def</span> <span class="title">allM</span>[<span class="title">G</span>[<span class="title">_</span>]:</span> Monad](p: A =&gt; G[Boolean]): G[Boolean] = F.allM(self)(p)
  final <span class="function"><span class="keyword">def</span> <span class="title">anyM</span>[<span class="title">G</span>[<span class="title">_</span>]:</span> Monad](p: A =&gt; G[Boolean]): G[Boolean] = F.anyM(self)(p)
  final <span class="function"><span class="keyword">def</span> <span class="title">any</span><span class="params">(p: A =&gt; Boolean)</span>:</span> Boolean = F.any(self)(p)
  final <span class="function"><span class="keyword">def</span> ∃<span class="params">(p: A =&gt; Boolean)</span>:</span> Boolean = F.any(self)(p)
  final <span class="function"><span class="keyword">def</span> <span class="title">count</span>:</span> Int = F.count(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(implicit A: Order[A])</span>:</span> Option[A] = F.maximum(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">minimum</span><span class="params">(implicit A: Order[A])</span>:</span> Option[A] = F.minimum(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">longDigits</span><span class="params">(implicit d: A &lt;:&lt; Digit)</span>:</span> Long = F.longDigits(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">empty</span>:</span> Boolean = F.empty(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">element</span><span class="params">(a: A)</span><span class="params">(implicit A: Equal[A])</span>:</span> Boolean = F.element(self, a)
  final <span class="function"><span class="keyword">def</span> <span class="title">splitWith</span><span class="params">(p: A =&gt; Boolean)</span>:</span> List[List[A]] = F.splitWith(self)(p)
  final <span class="function"><span class="keyword">def</span> <span class="title">selectSplit</span><span class="params">(p: A =&gt; Boolean)</span>:</span> List[List[A]] = F.selectSplit(self)(p)
  final <span class="function"><span class="keyword">def</span> <span class="title">collapse</span>[<span class="title">X</span>[<span class="title">_</span>]]<span class="params">(implicit A: ApplicativePlus[X])</span>:</span> X[A] = F.collapse(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">concatenate</span><span class="params">(implicit A: Monoid[A])</span>:</span> A = F.fold(self)
  final <span class="function"><span class="keyword">def</span> <span class="title">traverse_</span>[<span class="title">M</span>[<span class="title">_</span>]:</span>Applicative](f: A =&gt; M[Unit]): M[Unit] = F.traverse_(self)(f)

  ////
}
</pre></td></tr></table></figure>

<p>用法如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).foldRight (<span class="number">1</span>) {_ * _}
res49: Int = <span class="number">6</span>

scala&gt; <span class="number">9.</span>some.foldLeft(<span class="number">2</span>) {_ + _}
res50: Int = <span class="number">11</span>

<span class="comment">// use monoid</span>
scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) foldMap {identity}
res53: Int = <span class="number">6</span>

scala&gt; <span class="keyword">List</span>(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>) foldMap {Tags.Disjunction}
res56: scalaz.@@[Boolean,scalaz.Tags.Disjunction] = <span class="keyword">true</span>
</pre></td></tr></table></figure>

<h1 id="monads">Monads</h1>
<p>Monads are a natural extension applicative functors, and they provide
a solution to the following problem: If we have a value with context, m a,
how do we apply it to a function that takes a normal a and returns a value with a contex</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Applicative</span>[<span class="title">F</span>] <span class="keyword">with</span> <span class="title">Bind</span>[<span class="title">F</span>] {</span> self =&gt;
  <span class="comment">////</span>
}
</pre></td></tr></table></figure>

<h2 id="bind">Bind</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>trait Bind[F[_]] extends Apply[F] { self =&gt;
  /<span class="emphasis">** Equivalent to `join(map(fa)(f))`. *</span>/
  def bind[<span class="link_label">A, B</span>](<span class="link_url">fa: F[A]</span>)(f: A =&gt; F[B]): F[B]
}

/<span class="emphasis">** Wraps a value `self` and provides methods related to `Bind` *</span>/
trait BindOps[F[_],A] extends Ops[F[A]] {
  implicit def F: Bind[F]
  ////
  import Liskov.<span class="xml"><span class="tag">&lt;<span class="title">~</span>&lt;

  <span class="attribute">def</span> <span class="attribute">flatMap</span>[<span class="attribute">B</span>](<span class="attribute">f:</span> <span class="attribute">A</span> =&gt;</span></span> F[B]) = F.bind(self)(f)
  def &gt;&gt;=[<span class="link_label">B</span>](<span class="link_url">f: A =&gt; F[B]</span>) = F.bind(self)(f)
  def ∗[<span class="link_label">B</span>](<span class="link_url">f: A =&gt; F[B]</span>) = F.bind(self)(f)
  def join[<span class="link_label">B</span>](<span class="link_url">implicit ev: A &lt;~&lt; F[B]</span>): F[B] = F.bind(self)(ev(_))
  def μ[<span class="link_label">B</span>](<span class="link_url">implicit ev: A &lt;~&lt; F[B]</span>): F[B] = F.bind(self)(ev(_))
  def &gt;&gt;[<span class="link_label">B</span>](<span class="link_url">b: F[B]</span>): F[B] = F.bind(self)(_ =&gt; b)
  def ifM[<span class="link_label">B</span>](<span class="link_url">ifTrue: =&gt; F[B], ifFalse: =&gt; F[B]</span>)(implicit ev: A <span class="xml"><span class="tag">&lt;<span class="title">~</span>&lt; <span class="attribute">Boolean</span>)<span class="attribute">:</span> <span class="attribute">F</span>[<span class="attribute">B</span>] = {
    <span class="attribute">val</span> <span class="attribute">value:</span> <span class="attribute">F</span>[<span class="attribute">Boolean</span>] = <span class="attribute">Liskov.co</span>[<span class="attribute">F</span>, <span class="attribute">A</span>, <span class="attribute">Boolean</span>](<span class="attribute">ev</span>)(<span class="attribute">self</span>)
    <span class="attribute">F.ifM</span>(<span class="attribute">value</span>, <span class="attribute">ifTrue</span>, <span class="attribute">ifFalse</span>)
  }
  ////
}</span></span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="number">3.</span>some flatMap { x =&gt; (x + <span class="number">1</span>).some }
res2: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">4</span>)

scala&gt; (none: <span class="keyword">Option</span>[<span class="built_in">Int</span>]) flatMap { x =&gt; (x + <span class="number">1</span>).some }
res3: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = None
</pre></td></tr></table></figure>

<h2 id="monad">Monad</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; Monad[<span class="keyword">Option</span>].point(<span class="string">"WHAT"</span>)
res5: <span class="keyword">Option</span>[<span class="built_in">String</span>] = Some(WHAT)

scala&gt; <span class="number">9.</span>some flatMap { x =&gt; Monad[<span class="keyword">Option</span>].point(x * <span class="number">10</span>) }
res6: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = Some(<span class="number">90</span>)

scala&gt; (none: <span class="keyword">Option</span>[<span class="built_in">Int</span>]) flatMap { x =&gt; Monad[<span class="keyword">Option</span>].point(x * <span class="number">10</span>) }
res7: <span class="keyword">Option</span>[<span class="built_in">Int</span>] = None
</pre></td></tr></table></figure>

<h3 id="-">小鸟的案例</h3>
<p>小鸟在平衡杆两边停留</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">type</span> Birds = Int

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Pole</span><span class="params">(left: Birds, right: Birds)</span>{</span>
  <span class="keyword">def</span> landLeft(n: Birds): Pole = copy(left = left + n)
  <span class="keyword">def</span> landRight(n: Birds): Pole = copy(right = right + n) 
}

<span class="comment">// 可以这样使用</span>
Pole(<span class="number">0</span>, <span class="number">0</span>).landLeft(<span class="number">1</span>).landRight(<span class="number">1</span>).landLeft(<span class="number">2</span>)
</pre></td></tr></table></figure>

<p>version 2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">case</span> class Pole(left: Birds, <span class="constant">right</span>: Birds) {
  def landLeft(n: Birds): Option[Pole] = 
    <span class="keyword">if</span> (math.<span class="built_in">abs</span>((left + n) - <span class="constant">right</span>) &lt; <span class="number">4</span>) copy(left = left + n).some
    <span class="keyword">else</span> <span class="constant">none</span>
  def landRight(n: Birds): Option[Pole] =
    <span class="keyword">if</span> (math.<span class="built_in">abs</span>(left - (<span class="constant">right</span> + n)) &lt; <span class="number">4</span>) copy(<span class="constant">right</span> = <span class="constant">right</span> + n).some
    <span class="keyword">else</span> <span class="constant">none</span>
}
<span class="comment">
// 可以这样使用</span>
Pole(<span class="number">0</span>, <span class="number">0</span>).landRight(<span class="number">1</span>) flatMap {_.landLeft(<span class="number">2</span>)}

Monad[Option].point(Pole(<span class="number">0</span>, <span class="number">0</span>)) &gt;&gt;= {_.landRight(<span class="number">2</span>)} &gt;&gt;= {_.landLeft(<span class="number">2</span>)} &gt;&gt;= {_.landRight(<span class="number">2</span>)}

<span class="comment">
// &gt;&gt; 符号的使用</span>
scala&gt; (<span class="constant">none</span>: Option[Int]) &gt;&gt; <span class="number">3.</span>some
res25: Option[Int] = None

scala&gt; <span class="number">3.</span>some &gt;&gt; <span class="number">4.</span>some
res26: Option[Int] = Some(<span class="number">4</span>)

scala&gt; <span class="number">3.</span>some &gt;&gt; (<span class="constant">none</span>: Option[Int])
res27: Option[Int] = None
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="regexp">//</span> 这里会报错是因为 = 号的优先级是最低的
scala&gt; Monad[Option].point(Pole(<span class="number">0</span>, <span class="number">0</span>)) &gt;&gt;= {_.landLeft(<span class="number">1</span>)} &gt;&gt; (<span class="attribute">none</span>: Option[Pole]) &gt;&gt;= {_.landRight(<span class="number">1</span>)}
&lt;<span class="built_in">console</span>&gt;:<span class="number">26</span>: <span class="attribute">error</span>: missing parameter type <span class="keyword">for</span> expanded <span class="reserved">function</span> <span class="function"><span class="params">((x$<span class="number">1</span>) =&gt; x$<span class="number">1.</span>landLeft(<span class="number">1</span>))</span>
              <span class="title">Monad</span>[<span class="title">Option</span>].<span class="title">point</span><span class="params">(Pole(<span class="number">0</span>, <span class="number">0</span>))</span> &gt;&gt;= {<span class="title">_</span>.<span class="title">landLeft</span><span class="params">(<span class="number">1</span>)</span>} &gt;&gt; <span class="params">(none: Option[Pole])</span> &gt;&gt;= {<span class="title">_</span>.<span class="title">landRight</span><span class="params">(<span class="number">1</span>)</span>}

// 要这么写
<span class="title">Monad</span>[<span class="title">Option</span>].<span class="title">point</span><span class="params">(Pole(<span class="number">0</span>, <span class="number">0</span>))</span>.&gt;&gt;=<span class="params">({_.landLeft(<span class="number">1</span>)})</span>.&gt;&gt;<span class="params">(none: Option[Pole])</span>.&gt;&gt;=<span class="params">({_.landRight(<span class="number">1</span>)})</span>
// 或者这么写
<span class="params">(Monad[Option].point(Pole(<span class="number">0</span>, <span class="number">0</span>)) &gt;&gt;= {_.landLeft(<span class="number">1</span>)})</span> &gt;&gt; <span class="params">(none: Option[Pole])</span> &gt;&gt;= {<span class="title">_</span>.<span class="title">landRight</span><span class="params">(<span class="number">1</span>)</span>}</span>
</pre></td></tr></table></figure>

<h2 id="for-syntax">for syntax</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>scala&gt; <span class="number">3.</span>some &gt;&gt;= { x =&gt; (none: <span class="keyword">Option</span>[<span class="built_in">String</span>]) &gt;&gt;= { y =&gt; (x.shows + y).some } }
res17: <span class="keyword">Option</span>[<span class="built_in">String</span>] = None

scala&gt; (none: <span class="keyword">Option</span>[<span class="built_in">Int</span>]) &gt;&gt;= { x =&gt; <span class="string">"!"</span>.some &gt;&gt;= { y =&gt; (x.shows + y).some } }
res16: <span class="keyword">Option</span>[<span class="built_in">String</span>] = None

scala&gt; <span class="number">3.</span>some &gt;&gt;= { x =&gt; <span class="string">"!"</span>.some &gt;&gt;= { y =&gt; (none: <span class="keyword">Option</span>[<span class="built_in">String</span>]) } }
res18: <span class="keyword">Option</span>[<span class="built_in">String</span>] = Nonescala&gt; <span class="number">3.</span>some &gt;&gt;= { x =&gt; (none: <span class="keyword">Option</span>[<span class="built_in">String</span>]) &gt;&gt;= { y =&gt; (x.shows + y).some } }
res17: <span class="keyword">Option</span>[<span class="built_in">String</span>] = None

scala&gt; (none: <span class="keyword">Option</span>[<span class="built_in">Int</span>]) &gt;&gt;= { x =&gt; <span class="string">"!"</span>.some &gt;&gt;= { y =&gt; (x.shows + y).some } }
res16: <span class="keyword">Option</span>[<span class="built_in">String</span>] = None

scala&gt; <span class="number">3.</span>some &gt;&gt;= { x =&gt; <span class="string">"!"</span>.some &gt;&gt;= { y =&gt; (none: <span class="keyword">Option</span>[<span class="built_in">String</span>]) } }
res18: <span class="keyword">Option</span>[<span class="built_in">String</span>] = None
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">for</span> {
         x &lt;- <span class="number">3.</span>some
         y &lt;- <span class="string">"!"</span>.some
       } <span class="keyword">yield</span> (x.shows + y)
res19: Option[String] = Some(<span class="number">3</span>!)

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">routine</span>:</span> Option[Pole] =
         <span class="keyword">for</span> {
           start &lt;- Monad[Option].point(Pole(<span class="number">0</span>, <span class="number">0</span>))
           first &lt;- start.landLeft(<span class="number">2</span>)
           second &lt;- first.landRight(<span class="number">2</span>)
           third &lt;- second.landLeft(<span class="number">1</span>)
         } <span class="keyword">yield</span> third
routine: Option[Pole]

scala&gt; routine
res20: Option[Pole] = Some(Pole(<span class="number">3</span>,<span class="number">2</span>))

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">routine</span>:</span> Option[Pole] =
         <span class="keyword">for</span> {
           start &lt;- Monad[Option].point(Pole(<span class="number">0</span>, <span class="number">0</span>))
           first &lt;- start.landLeft(<span class="number">2</span>)
           _ &lt;- (none: Option[Pole])
           second &lt;- first.landRight(<span class="number">2</span>)
           third &lt;- second.landLeft(<span class="number">1</span>)
         } <span class="keyword">yield</span> third
routine: Option[Pole]

scala&gt; routine
res23: Option[Pole] = <span class="keyword">None</span>

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">wopwop</span>:</span> Option[Char] =
         <span class="keyword">for</span> {
           (x :: xs) &lt;- <span class="string">""</span>.toList.some
         } <span class="keyword">yield</span> x
wopwop: Option[Char]

scala&gt; wopwop
res28: Option[Char] = <span class="keyword">None</span>
</pre></td></tr></table></figure>

<h2 id="list-monad">List Monad</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; ^(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>)) {_ * _}
res29: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">30</span>, <span class="number">300</span>, <span class="number">300</span>)

scala&gt; <span class="keyword">List</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &gt;&gt;= {x =&gt; <span class="keyword">List</span>(x, -x)}
res30: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">3</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">4</span>, <span class="number">5</span>, -<span class="number">5</span>)

scala&gt; <span class="keyword">for</span> {
         n &lt;- <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>)
         ch &lt;- <span class="keyword">List</span>(<span class="string">'a'</span>, <span class="string">'b'</span>)
       } <span class="keyword">yield</span> (n, ch)
res33: <span class="keyword">List</span>[(Int, Char)] = <span class="keyword">List</span>((<span class="number">1</span>,a), (<span class="number">1</span>,b), (<span class="number">2</span>,a), (<span class="number">2</span>,b))
</pre></td></tr></table></figure>

<h2 id="monadplus-and-the-guard-function">MonadPlus and the guard function</h2>
<p>The MonadPlus type class is for monads that can also act as monoids.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">for</span> {
         x &lt;- <span class="number">1</span> |-&gt; <span class="number">50</span> <span class="keyword">if</span> x.shows contains <span class="string">'7'</span>
       } <span class="keyword">yield</span> x
res40: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">7</span>, <span class="number">17</span>, <span class="number">27</span>, <span class="number">37</span>, <span class="number">47</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">MonadPlus</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Monad</span>[<span class="title">F</span>] <span class="keyword">with</span> <span class="title">ApplicativePlus</span>[<span class="title">F</span>] {</span> self =&gt;
  ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">ApplicativePlus</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Applicative</span>[<span class="title">F</span>] <span class="keyword">with</span> <span class="title">PlusEmpty</span>[<span class="title">F</span>] {</span> self =&gt;
  ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">PlusEmpty</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Plus</span>[<span class="title">F</span>] {</span> self =&gt;
  <span class="comment">////</span>
  <span class="keyword">def</span> empty[A]: F[A]
}

<span class="class"><span class="keyword">trait</span> <span class="title">Plus</span>[<span class="title">F</span>[<span class="title">_</span>]]  {</span> self =&gt;
  <span class="keyword">def</span> plus[A](a: F[A], b: =&gt; F[A]): F[A]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;+&gt; <span class="keyword">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)
res43: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)

scala&gt; (<span class="number">1</span> |-&gt; <span class="number">50</span>) filter { x =&gt; x.shows contains <span class="string">'7'</span> }
res46: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">7</span>, <span class="number">17</span>, <span class="number">27</span>, <span class="number">37</span>, <span class="number">47</span>)
</pre></td></tr></table></figure>

<h2 id="a-knight-s-quest">A knight&#39;s quest</h2>
<p>Say you have a chess board and only one knight piece on it.
We want to find out if the knight can reach a certain position
in three moves.</p>
<p>移动三步能到达的位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">case</span> class KnightPos(c: Int, r: Int) {
 <span class="comment"> // 移动一步能到达的位置</span>
  def move: List[KnightPos] =
    <span class="keyword">for</span> {
      KnightPos(c2, r2) &lt;- List(KnightPos(c + <span class="number">2</span>, r - <span class="number">1</span>), KnightPos(c + <span class="number">2</span>, r + <span class="number">1</span>),
        KnightPos(c - <span class="number">2</span>, r - <span class="number">1</span>), KnightPos(c - <span class="number">2</span>, r + <span class="number">1</span>),
        KnightPos(c + <span class="number">1</span>, r - <span class="number">2</span>), KnightPos(c + <span class="number">1</span>, r + <span class="number">2</span>),
        KnightPos(c - <span class="number">1</span>, r - <span class="number">2</span>), KnightPos(c - <span class="number">1</span>, r + <span class="number">2</span>)) <span class="keyword">if</span> (
        ((<span class="number">1</span> |-&gt; <span class="number">8</span>) <span class="operator">contains</span> c2) && ((<span class="number">1</span> |-&gt; <span class="number">8</span>) <span class="operator">contains</span> r2))
    } yield KnightPos(c2, r2)

 <span class="comment"> // 移动三步</span>
  def in3: List[KnightPos] =
    <span class="keyword">for</span> {
      <span class="keyword">first</span> &lt;- move
      <span class="keyword">second</span> &lt;- <span class="keyword">first</span>.move
      <span class="keyword">third</span> &lt;- <span class="keyword">second</span>.move
    } yield <span class="keyword">third</span>
    
 <span class="comment"> // 移动三步是否能到达这个位置</span>
  def canReachIn3(<span class="function"><span class="keyword">end</span>: <span class="title">KnightPos</span>): <span class="title">Boolean</span> = <span class="title">in3</span> <span class="title">contains</span> <span class="title">end</span></span>
}
</pre></td></tr></table></figure>

<h2 id="writer">Writer</h2>
<p>Whereas the Maybe monad is for values with an added context of 
failure, and the list monad is for nondeterministic values, Writer
monad is for values that have another value attached that acts as a
sort of log value.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def isBigGang(x: Int): (Boolean, String) =
  (x &gt; 9, "Compared gang size to 9.")

implicit class PairOps[<span class="link_label">A</span>](<span class="link_url">pair: (A, String</span>)) {
  def applyLog[<span class="link_label">B</span>](<span class="link_url">f: A =&gt; (B, String</span>)): (B, String) = {
<span class="code">    val (x, log) = pair</span>
<span class="code">    val (y, newlog) = f(x)</span>
<span class="code">    (y, log ++ newlog)</span>
  }
}

(3, "Smallish gang.") applyLog isBigGang  // (false,Smallish gang.Compared gang size to 9.)
</pre></td></tr></table></figure>

<p>version 2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>implicit class PairOps[<span class="link_label">A, B: Monoid</span>](<span class="link_url">pair: (A, B</span>)) {
  def applyLog[<span class="link_label">C</span>](<span class="link_url">f: A =&gt; (C, B</span>)): (C, B) = {
<span class="code">    val (x, log) = pair</span>
<span class="code">    val (y, newlog) = f(x)</span>
<span class="code">    (y, log |+| newlog)</span>
  }
}

// (false,Smallish gang.Compared gang size to 9.)
(3, "Smallish gang.") applyLog isBigGang
</pre></td></tr></table></figure>

<h3 id="writer-define">Writer define</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">type</span> Writer[+W, +A] = WriterT[Id, W, A]

<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">WriterT</span>[<span class="title">F</span>[+<span class="title">_</span>], +<span class="title">W</span>, +<span class="title">A</span>] {</span> self =&gt;
  <span class="keyword">val</span> run: F[(W, A)]

  <span class="keyword">def</span> written(implicit F: Functor[F]): F[W] =
    F.map(run)(_._1)
  <span class="keyword">def</span> value(implicit F: Functor[F]): F[A] =
    F.map(run)(_._2)
}

<span class="class"><span class="keyword">trait</span> <span class="title">WriterV</span>[<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">Ops</span>[<span class="title">A</span>] {</span>
  <span class="keyword">def</span> set[W](w: W): Writer[W, A] = WriterT.writer(w -&gt; self)

  <span class="keyword">def</span> tell: Writer[A, Unit] = WriterT.tell(self)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; <span class="number">3.</span><span class="keyword">set</span>(<span class="string">"something"</span>)
<span class="label">res57:</span> scalaz<span class="preprocessor">.Writer</span>[String,Int] = scalaz<span class="preprocessor">.WriterTFunctions</span>$$anon$26<span class="localvars">@159663</span>c3

scala&gt; <span class="string">"something"</span><span class="preprocessor">.tell</span>
<span class="label">res58:</span> scalaz<span class="preprocessor">.Writer</span>[String,Unit] = scalaz<span class="preprocessor">.WriterTFunctions</span>$$anon$26<span class="localvars">@374</span>de9cf

scala&gt; MonadWriter[Writer, String]
<span class="label">res62:</span> scalaz<span class="preprocessor">.MonadWriter</span>[scalaz<span class="preprocessor">.Writer</span>,String] = scalaz<span class="preprocessor">.WriterTInstances</span>$$anon$1<span class="localvars">@6</span>b8501fa

scala&gt; MonadWriter[Writer, String]<span class="preprocessor">.point</span>(<span class="number">3</span>)<span class="preprocessor">.run</span>
<span class="label">res64:</span> (String, Int) = (<span class="string">""</span>,<span class="number">3</span>)
</pre></td></tr></table></figure>

<h3 id="using-for-syntax-with-writer">Using for syntax with Writer</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">logNumber</span><span class="params">(x: Int)</span>:</span> Writer[List[String], Int] =
         x.set(List(<span class="string">"Got number: "</span> + x.shows))
logNumber: (x: Int)scalaz.Writer[List[String],Int]

scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">multWithLog</span>:</span> Writer[List[String], Int] = <span class="keyword">for</span> {
         a &lt;- logNumber(<span class="number">3</span>)
         b &lt;- logNumber(<span class="number">5</span>)
       } <span class="keyword">yield</span> a * b
multWithLog: scalaz.Writer[List[String],Int]

scala&gt; multWithLog.run
res67: (List[String], Int) = (List(Got number: <span class="number">3</span>, Got number: <span class="number">5</span>),<span class="number">15</span>)


<span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a: Int, b: Int)</span>:</span> Writer[List[String], Int] =
  <span class="keyword">if</span> (b == <span class="number">0</span>)
    <span class="keyword">for</span> {
      _ &lt;- List(<span class="string">"Finished with "</span> + a.shows).tell
    } <span class="keyword">yield</span> a
  <span class="keyword">else</span>
    List(a.shows + <span class="string">" mod "</span> + b.shows + <span class="string">" = "</span> + (a % b).shows).tell &gt;&gt;= { _ =&gt;
      gcd(b, a % b)
    }

gcd(<span class="number">8</span>, <span class="number">3</span>).run
</pre></td></tr></table></figure>

<p><a href="http://docs.scala-lang.org/overviews/collections/performance-characteristics.html">What stands out for immutable collection is Vector since
it has effective constant for all operations.</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a: Int, b: Int)</span>:</span> Writer[Vector[String], Int] =
  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">for</span> {
      _ &lt;- Vector(<span class="string">"Finished with "</span> + a.shows).tell
    } <span class="keyword">yield</span> a
  <span class="keyword">else</span> <span class="keyword">for</span> {
      result &lt;- gcd(b, a % b)
      _ &lt;- Vector(a.shows + <span class="string">" mod "</span> + b.shows + <span class="string">" = "</span> + (a % b).shows).tell
    } <span class="keyword">yield</span> result
</pre></td></tr></table></figure>

<p>性能比较</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">import</span> std.vector._

<span class="function"><span class="keyword">def</span> <span class="title">vectorFinalCountDown</span><span class="params">(x: Int)</span>:</span> Writer[Vector[String], Unit] = {
  <span class="keyword">import</span> annotation.tailrec
  <span class="decorator">@tailrec def doFinalCountDown(x: Int, w: Writer[Vector[String], Unit]): Writer[Vector[String], Unit] = x match {</span>
    case <span class="number">0</span> =&gt; w &gt;&gt;= { _ =&gt; Vector(<span class="string">"0"</span>).tell }
    case x =&gt; doFinalCountDown(x - <span class="number">1</span>, w &gt;&gt;= { _ =&gt;
      Vector(x.shows).tell
    })
  }
  val t0 = System.currentTimeMillis
  val r = doFinalCountDown(x, Vector[String]().tell)
  val t1 = System.currentTimeMillis
  r &gt;&gt;= { _ =&gt; Vector((t1 - t0).shows + <span class="string">" msec"</span>).tell }
}

<span class="function"><span class="keyword">def</span> <span class="title">listFinalCountDown</span><span class="params">(x: Int)</span>:</span> Writer[List[String], Unit] = {
  <span class="keyword">import</span> annotation.tailrec
  <span class="decorator">@tailrec def doFinalCountDown(x: Int, w: Writer[List[String], Unit]): Writer[List[String], Unit] = x match {</span>
    case <span class="number">0</span> =&gt; w &gt;&gt;= { _ =&gt; List(<span class="string">"0"</span>).tell }
    case x =&gt; doFinalCountDown(x - <span class="number">1</span>, w &gt;&gt;= { _ =&gt;
      List(x.shows).tell
    })
  }
  val t0 = System.currentTimeMillis
  val r = doFinalCountDown(x, List[String]().tell)
  val t1 = System.currentTimeMillis
  r &gt;&gt;= { _ =&gt; List((t1 - t0).shows + <span class="string">" msec"</span>).tell }
}
</pre></td></tr></table></figure>

<h2 id="reader">Reader</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">// function as a functor</span>
scala&gt; val f = (_: Int) * <span class="number">5</span>
f: Int =&gt; Int = &lt;function1&gt;

scala&gt; val g = (_: Int) + <span class="number">3</span>
g: Int =&gt; Int = &lt;function1&gt;

scala&gt; (g map f)(<span class="number">8</span>)
res22: Int = <span class="number">55</span>

<span class="comment">// function as a applicative</span>
scala&gt; val f = ({(_: Int) * <span class="number">2</span>} |@| {(_: Int) + <span class="number">10</span>}) {_ + _}
f: Int =&gt; Int = &lt;function1&gt;

scala&gt; f(<span class="number">3</span>)
res35: Int = <span class="number">19</span>

<span class="comment">// function as a monad</span>
scala&gt; val addStuff: Int =&gt; Int = <span class="keyword">for</span> {
         a &lt;- (_: Int) * <span class="number">2</span>
         b &lt;- (_: Int) + <span class="number">10</span>
       } <span class="keyword">yield</span> a + b
addStuff: Int =&gt; Int = &lt;function1&gt;

scala&gt; addStuff(<span class="number">3</span>)
res39: Int = <span class="number">19</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="scalaz" scheme="http://zhpooer.github.io/tags/scalaz/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[learning scalaz]]></title>
    <link href="http://zhpooer.github.io/2014/07/29/learning-scalaz/"/>
    <id>http://zhpooer.github.io/2014/07/29/learning-scalaz/</id>
    <published>2014-07-29T06:48:01.000Z</published>
    <updated>2014-07-29T08:47:51.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://eed3si9n.com/learning-scalaz/Combined+Pages.html" target="_blank">猛击我</a></p>
<h1 id="polymorphism">polymorphism</h1>
<h2 id="parametric-polymorphism">Parametric polymorphism</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">head</span>[<span class="title">A</span>]<span class="params">(xs: List[A])</span>:</span> A = xs(<span class="number">0</span>)
</pre></td></tr></table></figure>

<p>in this function head, it takes a list of A’s,
and returns an A. And it doesn’t matter what the A is:
It could be Ints, Strings, Oranages, Cars, whatever.
Any A would work, and the function is defined for every A that there can be.</p>
<h2 id="subtype-polymorphism">Subtype polymorphism</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">plus</span>[<span class="title">A</span> &lt;:</span> Plus[A]](a1: A, a2: A): A = a1.plus(a2)
</pre></td></tr></table></figure>

<h2 id="ad-hoc-polymorphism">Ad-hoc polymorphism</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>def plus[<span class="link_label">A: Plus</span>](<span class="link_url">a1: A, a2: A</span>): A = implicitly[Plus[A]].plus(a1, a2)
</pre></td></tr></table></figure>

<ul>
<li>we can provide separate function definitions for different types of A</li>
<li>we can provide function definitions to types (like Int) without
access to its source code</li>
<li>the function definitions can be enabled or disabled in different scopes</li>
</ul>
<h1 id="monoid">Monoid</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>object IntMonoid {
  <span class="function"><span class="keyword">def</span> <span class="title">mappend</span><span class="params">(a: Int, b: Int)</span>:</span> Int = a + b
  <span class="function"><span class="keyword">def</span> <span class="title">mzero</span>:</span> Int = <span class="number">0</span>
}
<span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(xs: List[Int])</span>:</span> Int = xs.foldLeft(IntMonoid.mzero)(IntMonoid.mappend)
</pre></td></tr></table></figure>

<p>version 2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>trait Monoid[A] {
  <span class="function"><span class="keyword">def</span> <span class="title">mappend</span><span class="params">(a1: A, a2: A)</span>:</span> A
  <span class="function"><span class="keyword">def</span> <span class="title">mzero</span>:</span> A
}
object IntMonoid extends Monoid[Int] {
  <span class="function"><span class="keyword">def</span> <span class="title">mappend</span><span class="params">(a: Int, b: Int)</span>:</span> Int = a + b
  <span class="function"><span class="keyword">def</span> <span class="title">mzero</span>:</span> Int = <span class="number">0</span>
}
<span class="function"><span class="keyword">def</span> <span class="title">sum</span>[<span class="title">A</span>]<span class="params">(xs: List[A], m: Monoid[A])</span>:</span> A = xs.foldLeft(m.mzero)(m.mappend)
</pre></td></tr></table></figure>

<p>version 3</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">sum</span>[<span class="title">A</span>]<span class="params">(xs: List[A])</span><span class="params">(implicit m: Monoid[A])</span>:</span> A = xs.foldLeft(m.mzero)(m.mappend)
implicit val intMonoid = IntMonoid
// 也可以这样
<span class="function"><span class="keyword">def</span> <span class="title">sum</span>[<span class="title">A</span>:</span> Monoid](xs:List[A]):A = {
  val m = implicity[Monoid[A]]
  xs.foldLeft(m.mzero)(m.mappend)
}
</pre></td></tr></table></figure>

<p>我们也可以提供其他Monoid</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val multiMoinoid: Monoid[Int] = new Monoid[Int] {
  <span class="function"><span class="keyword">def</span> <span class="title">mappend</span><span class="params">(a:Int, b:Int)</span>:</span> Int = a * b
  <span class="function"><span class="keyword">def</span> <span class="title">mzero</span>:</span>Int = <span class="number">1</span>
}
sum(List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))(multiMonoid)
</pre></td></tr></table></figure>

<h1 id="foldleft">FoldLeft</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>object FoldLeftList {
  def foldLeft[<span class="link_label">A, B</span>](<span class="link_url">xs: List[A], b: B, f: (B, A</span>) =&gt; B) = xs.foldLeft(b)(f)
}
def sum[<span class="link_label">A: Monoid</span>](<span class="link_url">xs: List[A]</span>): A = {
  val m = implicitly[Monoid[A]]
  FoldLeftList.foldLeft(xs, m.mzero, m.mappend)
}

// 可以这样使用
sum(List(1, 2, 3, 4))(multiMonoid)
</pre></td></tr></table></figure>

<p>版本2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>trait FoldLeft[F[_]] {
  def foldLeft[<span class="link_label">A, B</span>](<span class="link_url">xs: F[A], b: B, f: (B, A</span>) =&gt; B): B
}

object FoldLeft {
  implicit val FoldLeftList: FoldLeft[List] = new FoldLeft[List] {
<span class="code">    def foldLeft[A, B](xs:List[a], b: B, f: (B, A) =&gt; B) = xs.foldLeft(b)(f)</span>
  }
}

def sum[<span class="link_label">M[_</span>]: FoldLeft, A: Monoid](xs: M[A]): A = {
  val m = implicitly[Monoid[A]]
  val fl = implicitly[FoldLeft[M]]
  fl.foldLeft(xs, m.mzero, m.mappend)
}

// 用法如下
sum(List("a", "b", "c"))
</pre></td></tr></table></figure>

<h1 id="typeclass-in-scalaz">Typeclass in Scalaz</h1>
<p>We would like to provide an operator.
But we don’t want to enrich just one type,
but enrich all types that has an instance for Monoid. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>trait MonoidOp[A] {
  val F: Monoid[A]
  val value: A
  def |+|(a2:A) = F.mappend(value, v2)
}

implicit def toMonoidOp[<span class="link_label">A: Monoid</span>](<span class="link_url">a: A</span>):MonoidOp[A] = new MonoidOp[A] {
  val F = implicitly[Monoid[A]]
  val value = a
}

// 简写如下
3 |+| 4
</pre></td></tr></table></figure>

<p>Using the same technique above, Scalaz also provides method
injections for standard library types like Option and Boolean:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span>some | <span class="number">2</span>
res0: <span class="built_in">Int</span> = <span class="number">1</span>

scala&gt; Some(<span class="number">1</span>).getOrElse(<span class="number">2</span>)
res1: <span class="built_in">Int</span> = <span class="number">1</span>

scala&gt; (<span class="number">1</span> &gt; <span class="number">10</span>)? <span class="number">1</span> | <span class="number">2</span>
res3: <span class="built_in">Int</span> = <span class="number">2</span>

scala&gt; <span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="number">10</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span>
res4: <span class="built_in">Int</span> = <span class="number">2</span>
</pre></td></tr></table></figure>

<h1 id="typeclasses">typeclasses</h1>
<p>It provides purely functional data structures to complement those from
the Scala standard library. It defines a set of foundational
type classes (e.g. Functor, Monad) and corresponding instances
for a large number of data structures.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scalaVersion <span class="symbol">:</span>= <span class="string">"2.11.0"</span>

val scalazVersion = <span class="string">"7.0.6"</span>

libraryDependencies ++= <span class="constant">Seq</span>(
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-core" %</span> scalazVersion,
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-effect" %</span> scalazVersion,
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-typelevel" %</span> scalazVersion,
  <span class="string">"org.scalaz"</span> <span class="string">%% "scalaz-scalacheck-binding" %</span> scalazVersion % <span class="string">"test"</span>
)

scalacOptions += <span class="string">"-feature"</span>

initialCommands <span class="keyword">in</span> console <span class="symbol">:</span>= <span class="string">"import scalaz._, Scalaz._"</span>
</pre></td></tr></table></figure>

<p>runt <code>sbt console</code></p>
<h2 id="equal">Equal</h2>
<p>Instead of the standard ==, Equal enables ===, =/=, and assert_=== syntax
by declaring equal method. The main difference is that === would fail
compilation if you tried to compare Int and String.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; <span class="number">1</span> === <span class="number">1</span>
res0: <span class="built_in">Boolean</span> = <span class="literal">true</span>

scala&gt; <span class="number">1</span> === <span class="string">"foo"</span>
&lt;console&gt;:<span class="number">14</span>: <span class="keyword">error</span>: could <span class="keyword">not</span> find implicit value <span class="keyword">for</span> parameter F0: scalaz.Equal[<span class="built_in">Object</span>]
              <span class="number">1</span> === <span class="string">"foo"</span>

scala&gt; <span class="number">1.</span>some =/= <span class="number">2.</span>some
res3: <span class="built_in">Boolean</span> = <span class="literal">true</span>

scala&gt; <span class="number">1</span> assert_=== <span class="number">2</span>
java.lang.RuntimeException: <span class="number">1</span> ≠ <span class="number">2</span>
</pre></td></tr></table></figure>

<h2 id="order">Order</h2>
<p>Ord is for types that have an ordering.
Ord covers all the standard comparing functions
such as <code>&gt;, &lt;, &gt;= and &lt;=</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.0</span> ?|? <span class="number">2.0</span>
<span class="label">res10:</span> scalaz<span class="preprocessor">.Ordering</span> = LT

scala&gt; <span class="number">1.0</span> max <span class="number">2.0</span>
<span class="label">res11:</span> Double = <span class="number">2.0</span>
</pre></td></tr></table></figure>

<h2 id="show">Show</h2>
<p>Members of Show can be presented as strings.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; <span class="number">3.</span>show
<span class="label">res14:</span> scalaz<span class="preprocessor">.Cord</span> = <span class="number">3</span>

scala&gt; <span class="number">3.</span>shows
<span class="label">res15:</span> String = <span class="number">3</span>

scala&gt; <span class="string">"hello"</span><span class="preprocessor">.println</span>
<span class="string">"hello"</span>
</pre></td></tr></table></figure>

<h2 id="read">Read</h2>
<p>Read is sort of the opposite typeclass of Show.
The read function takes a string and returns a type
which is a member of Read.</p>
<p>I could not find Scalaz equivalent for this typeclass.</p>
<h2 id="enum">Enum</h2>
<p>Enum members are sequentially ordered types — they can be enumerated.
The main advantage of the Enum typeclass is that we can use its types in list ranges.
They also have defined successors and predecesors,
which you can get with the succ and pred functions.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; <span class="string">'a'</span> to <span class="string">'e'</span>
<span class="label">res30:</span> scala<span class="preprocessor">.collection</span><span class="preprocessor">.immutable</span><span class="preprocessor">.NumericRange</span><span class="preprocessor">.Inclusive</span>[Char] = NumericRange(a, b, c, d, e)

scala&gt; <span class="string">'a'</span> |-&gt; <span class="string">'e'</span>
<span class="label">res31:</span> List[Char] = List(a, b, c, d, e)

scala&gt; <span class="number">3</span> |=&gt; <span class="number">5</span>
<span class="label">res32:</span> scalaz<span class="preprocessor">.EphemeralStream</span>[Int] = scalaz<span class="preprocessor">.EphemeralStreamFunctions</span>$$anon$4<span class="localvars">@6</span>a61c7b6

scala&gt; <span class="string">'B'</span><span class="preprocessor">.succ</span>
<span class="label">res33:</span> Char = C
</pre></td></tr></table></figure>

<p>Instead of the standard to, Enum enables |-&gt; that returns a List by
declaring pred and succ method on top of Order typeclass.
There are a bunch of other operations it enables like
<code>-+-, ---, from, fromStep, pred, predx, succ, succx, |--&gt;, |-&gt;, |==&gt;, and |=&gt;.</code>
these are all about stepping forward or backward, and returning ranges.</p>
<h2 id="bounded">Bounded</h2>
<p>Bounded members have an upper and a lower bound.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; implicitly[<span class="keyword">Enum</span>[<span class="built_in">Char</span>]].min
res43: <span class="keyword">Option</span>[<span class="built_in">Char</span>] = Some(?)

scala&gt; implicitly[<span class="keyword">Enum</span>[<span class="built_in">Char</span>]].max
res44: <span class="keyword">Option</span>[<span class="built_in">Char</span>] = Some( )

scala&gt; implicitly[<span class="keyword">Enum</span>[<span class="built_in">Double</span>]].max
res45: <span class="keyword">Option</span>[<span class="built_in">Double</span>] = Some(<span class="number">1.7976931348623157E308</span>)

scala&gt; implicitly[<span class="keyword">Enum</span>[Int]].min
res46: <span class="keyword">Option</span>[Int] = Some(-<span class="number">2147483648</span>)
</pre></td></tr></table></figure>

<p>Enum typeclass instance returns Option[T] for max values.</p>
<h2 id="num">Num</h2>
<p>Num is a numeric typeclass.
Its members have the property of being able to act like numbers.</p>
<p>I did not find Scalaz equivalent for Num, Floating, and Integral.</p>
<h1 id="making-our-own-types-and-typeclasses">Making Our Own Types and Typeclasses</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="xml"><span class="php"><span class="class">// 下面这样是不行的, 因为 <span class="title">Equal</span>[<span class="title">F</span>] 是 <span class="title">nonvariant</span>
// <span class="title">sealed</span> <span class="title">trait</span> <span class="title">TrafficLight</span>
// <span class="title">case</span> <span class="title">object</span> <span class="title">Red</span> <span class="keyword">extends</span> <span class="title">TrafficLight</span>
// <span class="title">case</span> <span class="title">object</span> <span class="title">Yellow</span> <span class="keyword">extends</span> <span class="title">TrafficLight</span>
// <span class="title">case</span> <span class="title">object</span> <span class="title">Green</span> <span class="keyword">extends</span> <span class="title">TrafficLight</span>

<span class="title">case</span> <span class="title">class</span> <span class="title">TrafficLight</span>(<span class="title">name</span>: <span class="title">String</span>)
<span class="title">val</span> <span class="title">red</span> = <span class="title">TrafficLight</span>("<span class="title">red</span>")
<span class="title">val</span> <span class="title">yellow</span> = <span class="title">TrafficLight</span>("<span class="title">yellow</span>")
<span class="title">val</span> <span class="title">green</span> = <span class="title">TrafficLight</span>("<span class="title">green</span>")

<span class="title">implicit</span> <span class="title">val</span> <span class="title">TrafficLightEqual</span>: <span class="title">Equal</span>[<span class="title">TrafficLight</span>] = <span class="title">Equal</span>.<span class="title">equal</span>(<span class="title">_</span> == <span class="title">_</span>)</span></span></span>
</pre></td></tr></table></figure>

<h2 id="yes-no-typeclass">Yes-No typeclass</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">CanTruthy</span>[<span class="title">A</span>] {</span> self =&gt;
  <span class="javadoc">/** <span class="javadoctag">@return</span> true, if `a` is truthy. */</span>
  <span class="keyword">def</span> truthys(a: A): Boolean
}

<span class="class"><span class="keyword">object</span> <span class="title">CanTruthy</span> {</span>
  <span class="keyword">def</span> apply[A](implicit ev: CanTruthy[A]): CanTruthy[A] = ev
  <span class="keyword">def</span> truthys[A](f: A =&gt; Boolean): CanTruthy[A] = <span class="keyword">new</span> CanTruthy[A] {
    <span class="keyword">def</span> truthys(a: A): Boolean = f(a)
  }
}

<span class="class"><span class="keyword">trait</span> <span class="title">CanTruthyOps</span>[<span class="title">A</span>] {</span>
  <span class="keyword">def</span> self: A
  implicit <span class="keyword">def</span> F: CanTruthy[A]
  <span class="keyword">final</span> <span class="keyword">def</span> truthy: Boolean = F.truthys(self)
}

<span class="class"><span class="keyword">object</span> <span class="title">ToCanIsTruthyOps</span> {</span>
  implicit <span class="keyword">def</span> toCanIsTruthyOps[A](v: A)(implicit ev: CanTruthy[A]) =
    <span class="keyword">new</span> CanTruthyOps[A] {
      <span class="keyword">def</span> self = v
      implicit <span class="keyword">def</span> F: CanTruthy[A] = ev
    }
}

<span class="comment">// 可以这样使用</span>
implicit <span class="keyword">val</span> intCanTruthy: CanTruthy[Int] = CanTruthy.truthys({
  <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="keyword">false</span>
  <span class="keyword">case</span> _ =&gt; <span class="keyword">true</span>
})
<span class="number">10.</span>truthy  <span class="comment">// true</span>

<span class="comment">// list can truthy</span>
implicit <span class="keyword">def</span> listCanTruthy[A]: CanTruthy[List[A]] = CanTruthy.truthys({
  <span class="keyword">case</span> Nil =&gt; <span class="keyword">false</span>
  <span class="keyword">case</span> _   =&gt; <span class="keyword">true</span>  
})
<span class="comment">// 如果不加这一句, 那么 Nil.truthy 会报错, 因为 canTruthy 是 nonvariance 的</span>
implicit <span class="keyword">val</span> nilCanTruthy: CanTruthy[scala.collection.immutable.Nil.<span class="keyword">type</span>] = CanTruthy.truthys(_ =&gt; <span class="keyword">false</span>)

<span class="comment">// 按需要计算</span>
<span class="keyword">def</span> truthyIf[A: CanTruthy, B, C](cond: A)(ifyes: =&gt; B)(ifno: =&gt; C) =
  <span class="keyword">if</span> (cond.truthy) ifyes
  <span class="keyword">else</span> ifno

truthyIf (<span class="keyword">true</span>) {<span class="string">"YEAH!"</span>} {<span class="string">"NO!"</span>}
truthyIf (Nil) {<span class="string">"YEAH!"</span>} {<span class="string">"NO!"</span>}
truthyIf (<span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: Nil) {<span class="string">"YEAH!"</span>} {<span class="string">"NO!"</span>}
</pre></td></tr></table></figure>

<h1 id="functor">Functor</h1>
<p>And now, we’re going to take a look at the Functor typeclass,
which is basically for things that can be mapped over.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>trait FunctorOps[F[_],A] extends Ops[F[A]] {
  implicit <span class="function"><span class="keyword">def</span> <span class="title">F</span>:</span> Functor[F]
  ////
  <span class="keyword">import</span> Leibniz.===

  final <span class="function"><span class="keyword">def</span> <span class="title">map</span>[<span class="title">B</span>]<span class="params">(f: A =&gt; B)</span>:</span> F[B] = F.map(self)(f)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) map <span class="list">{_ + 1}</span>
res15: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)

scala&gt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) map <span class="list">{_ + 1}</span>
res28: (Int, Int, Int) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)

// Scalaz also defines Functor instance for Function1.
scala&gt; ((x: Int) =&gt; x + <span class="number">1</span>) map <span class="list">{_ * 7}</span>
res30: Int =&gt; Int = &lt;function1&gt;

scala&gt; res30(<span class="number">3</span>)
res31: Int = <span class="number">28</span>
</pre></td></tr></table></figure>

<p>in Haskell</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>-- fmap :: <span class="function"><span class="params">(a -&gt; b)</span> -&gt;</span> <span class="function"><span class="params">(r -&gt; a)</span> -&gt;</span> (r<span class="function"> -&gt;</span> b)
ghci&gt; fmap (*<span class="number">3</span>) (+<span class="number">100</span>) <span class="number">1</span>
<span class="number">303</span>
ghci&gt; (*<span class="number">3</span>) . (+<span class="number">100</span>) $ <span class="number">1</span>  
<span class="number">303</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="comment">// 注意 这是左结合</span>
scala&gt; (((_: Int) * <span class="number">3</span>) map {_ + <span class="number">100</span>}) (<span class="number">1</span>)
res40: Int = <span class="number">103</span>

<span class="comment">// scalaz defined in F[A]</span>
<span class="keyword">final</span> def map[B](f: A =&gt; B): F[B] = F.map(<span class="keyword">self</span>)(f)

<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) map {<span class="number">3</span>*}  <span class="comment">// res41: List[Int] = List(3, 6, 9)</span>

<span class="comment">// this is a Lift</span>
<span class="comment">// There are several neat functions under Functor typeclass</span>
scala&gt; Functor[<span class="keyword">List</span>].lift {(_: Int) * <span class="number">2</span>}
res45: <span class="keyword">List</span>[Int] =&gt; <span class="keyword">List</span>[Int] = &lt;function1&gt;

scala&gt; res45(<span class="keyword">List</span>(<span class="number">3</span>))
res47: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">6</span>)


<span class="comment">// functor 的一些其他用法</span>
scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &gt;| <span class="string">"x"</span>
res47: <span class="keyword">List</span>[String] = <span class="keyword">List</span>(x, x, x)

scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="keyword">as</span> <span class="string">"x"</span>
res48: <span class="keyword">List</span>[String] = <span class="keyword">List</span>(x, x, x)

scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).fpair
res49: <span class="keyword">List</span>[(Int, Int)] = <span class="keyword">List</span>((<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">3</span>))

scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).strengthL(<span class="string">"x"</span>)
res50: <span class="keyword">List</span>[(String, Int)] = <span class="keyword">List</span>((x,<span class="number">1</span>), (x,<span class="number">2</span>), (x,<span class="number">3</span>))

scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).strengthR(<span class="string">"x"</span>)
res51: <span class="keyword">List</span>[(Int, String)] = <span class="keyword">List</span>((<span class="number">1</span>,x), (<span class="number">2</span>,x), (<span class="number">3</span>,x))

scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).void
res52: <span class="keyword">List</span>[Unit] = <span class="keyword">List</span>((), (), ())
</pre></td></tr></table></figure>

<h1 id="applicative">Applicative</h1>
<p>So far, when we were mapping functions over functors,
we usually mapped functions that take only one parameter.
ut what happens when we map a function like *, which takes two parameters,
over a functor?</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) map {(_: <span class="built_in">Int</span>) * (_:<span class="built_in">Int</span>)}
&lt;console&gt;:<span class="number">14</span>: <span class="keyword">error</span>: type mismatch;
 found   : (<span class="built_in">Int</span>, <span class="built_in">Int</span>) =&gt; <span class="built_in">Int</span>
 required: <span class="built_in">Int</span> =&gt; ?
              List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) map {(_: <span class="built_in">Int</span>) * (_:<span class="built_in">Int</span>)}

scala&gt; List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) map {(_: <span class="built_in">Int</span>) * (_:<span class="built_in">Int</span>)}.curried
res11: List[<span class="built_in">Int</span> =&gt; <span class="built_in">Int</span>] = List(&lt;function1&gt;, &lt;function1&gt;, &lt;function1&gt;, &lt;function1&gt;)

scala&gt; res11 map {_(<span class="number">9</span>)}
res12: List[<span class="built_in">Int</span>] = List(<span class="number">9</span>, <span class="number">18</span>, <span class="number">27</span>, <span class="number">36</span>)
</pre></td></tr></table></figure>

<p>Meet the Applicative typeclass. It lies in the Control.
Applicative module and it defines two methods, pure and <code>&lt;*&gt;</code>.</p>
<p>Applicative 定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>trait Applicative[F[_]] extends Apply[F] { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">point</span>[<span class="title">A</span>]<span class="params">(a: =&gt; A)</span>:</span> F[A]

  /** alias <span class="keyword">for</span> `point` */
  <span class="function"><span class="keyword">def</span> <span class="title">pure</span>[<span class="title">A</span>]<span class="params">(a: =&gt; A)</span>:</span> F[A] = point(a)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span>point[<span class="keyword">List</span>]
res14: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">1</span>)

scala&gt; <span class="number">1.</span>point[Option]
res15: Option[Int] = Some(<span class="number">1</span>)

scala&gt; <span class="number">1.</span>point[Option] map <span class="list">{_ + 2}</span>
res16: Option[Int] = Some(<span class="number">3</span>)

scala&gt; <span class="number">1.</span>point[<span class="keyword">List</span>] map <span class="list">{_ + 2}</span>
res17: <span class="keyword">List</span>[Int] = <span class="keyword">List</span>(<span class="number">3</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="regexp">//</span> Applicative 继承了它
trait Apply[F[_]] extends Functor[F] { self<span class="function"> =&gt;</span>
  def ap[A,B](<span class="attribute">fa</span>:<span class="function"> =&gt;</span> F[A])(<span class="attribute">f</span>:<span class="function"> =&gt;</span> F[A<span class="function"> =&gt;</span> B]): F[B]
}

<span class="regexp">//</span> 可以这样使用
scala&gt;  <span class="number">9.</span>some &lt;*&gt; {(<span class="attribute">_</span>: Int) + <span class="number">3</span>}.some
<span class="attribute">res20</span>: Option[Int] = Some(<span class="number">12</span>)

scala&gt; <span class="number">1.</span>some &lt;* <span class="number">2.</span>some
<span class="attribute">res35</span>: Option[Int] = Some(<span class="number">1</span>)

scala&gt; none &lt;* <span class="number">2.</span>some
<span class="attribute">res36</span>: Option[Nothing] = None

scala&gt; <span class="number">1.</span>some *&gt; <span class="number">2.</span>some
<span class="attribute">res38</span>: Option[Int] = Some(<span class="number">2</span>)

scala&gt; none *&gt; <span class="number">2.</span>some
<span class="attribute">res39</span>: Option[Int] = None

cala&gt; <span class="number">9.</span>some &lt;*&gt; {(<span class="attribute">_</span>: Int) + <span class="number">3</span>}.some
<span class="attribute">res57</span>: Option[Int] = Some(<span class="number">12</span>)

scala&gt; <span class="number">3.</span>some &lt;*&gt; { <span class="number">9.</span>some &lt;*&gt; {(<span class="attribute">_</span>: Int) + (<span class="attribute">_</span>: Int)}.curried.some }
<span class="attribute">res58</span>: Option[Int] = Some(<span class="number">12</span>)

<span class="regexp">//</span> 更加简化的写法
scala&gt; ^(<span class="number">3.</span>some, <span class="number">5.</span>some) {_ + _}
<span class="attribute">res59</span>: Option[Int] = Some(<span class="number">8</span>)

scala&gt; ^(<span class="number">3.</span>some, none[Int]) {_ + _}
<span class="attribute">res60</span>: Option[Int] = None

<span class="regexp">//</span>还可以这样
scala&gt; (<span class="number">3.</span>some |@| <span class="number">5.</span>some) {_ + _}
<span class="attribute">res18</span>: Option[Int] = Some(<span class="number">8</span>)

<span class="regexp">//</span> List 作为 Apply
scala&gt; List<span class="function"><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span> &lt;*&gt; <span class="title">List</span><span class="params">((_: Int) * <span class="number">0</span>, (_: Int) + <span class="number">100</span>, (x: Int) =&gt; x * x)</span>
<span class="title">res61</span>: <span class="title">List</span>[<span class="title">Int</span>] = <span class="title">List</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>)</span>

<span class="title">scala</span>&gt; <span class="title">List</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span> &lt;*&gt; { <span class="title">List</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span> &lt;*&gt; <span class="title">List</span><span class="params">({(_: Int) + (_: Int)}.curried, {(_: Int) * (_: Int)}.curried)</span> }
<span class="title">res62</span>: <span class="title">List</span>[<span class="title">Int</span>] = <span class="title">List</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span>

<span class="title">scala</span>&gt; <span class="params">(List(<span class="string">"ha"</span>, <span class="string">"heh"</span>, <span class="string">"hmm"</span>) |@| List(<span class="string">"?"</span>, <span class="string">"!"</span>, <span class="string">"."</span>))</span> {<span class="title">_</span> + <span class="title">_</span>}
<span class="title">res63</span>: <span class="title">List</span>[<span class="title">String</span>] = <span class="title">List</span><span class="params">(ha?, ha!, ha., heh?, heh!, heh., hmm?, hmm!, hmm.)</span></span>
</pre></td></tr></table></figure>

<h2 id="-">一些有趣用法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>def sequenceA[F[_]: Applicative, A](<span class="keyword">list</span>: <span class="keyword">List</span>[F[A]]): F[<span class="keyword">List</span>[A]] = <span class="keyword">list</span> match {
  <span class="keyword">case</span> Nil     =&gt; (Nil: <span class="keyword">List</span>[A]).point[F]
  <span class="keyword">case</span> x :: xs =&gt; (x |@| sequenceA(xs)) {_ :: _} 
}

scala&gt; sequenceA(<span class="keyword">List</span>(<span class="number">1.</span>some, <span class="number">2.</span>some))
res82: Option[<span class="keyword">List</span>[Int]] = Some(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>))

scala&gt; sequenceA(<span class="keyword">List</span>(<span class="number">3.</span>some, none, <span class="number">1.</span>some))
res85: Option[<span class="keyword">List</span>[Int]] = None

scala&gt; sequenceA(<span class="keyword">List</span>(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)))
res86: <span class="keyword">List</span>[<span class="keyword">List</span>[Int]] = <span class="keyword">List</span>(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">4</span>), <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">5</span>), <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">6</span>), <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">4</span>), <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">5</span>), <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">6</span>), <span class="keyword">List</span>(<span class="number">3</span>, <span class="number">4</span>), <span class="keyword">List</span>(<span class="number">3</span>, <span class="number">5</span>), <span class="keyword">List</span>(<span class="number">3</span>, <span class="number">6</span>))
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="scalaz" scheme="http://zhpooer.github.io/tags/scalaz/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day63-医药集中采购平台 采购单]]></title>
    <link href="http://zhpooer.github.io/2014/07/28/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day63-%E5%8C%BB%E8%8D%AF%E9%9B%86%E4%B8%AD%E9%87%87%E8%B4%AD%E5%B9%B3%E5%8F%B0-%E9%87%87%E8%B4%AD%E5%8D%95/"/>
    <id>http://zhpooer.github.io/2014/07/28/传智播客day63-医药集中采购平台-采购单/</id>
    <published>2014-07-28T02:41:29.000Z</published>
    <updated>2014-07-28T07:30:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">业务分析</h1>
<p>供货商将药品目录整理完成, 供货商供货供货区域内的医院,
医院向所在区域供应药品的供货商创建采购单</p>
<ol>
<li>创建采购单(基本信息)</li>
<li>设置采购药品明细, 添加采购药品, 设置采购量</li>
<li>审核采购单, 由卫生室所在乡/镇卫生院审核提交的采购单<ul>
<li>审核通过, 供货商受理</li>
<li>审核不通过, 退回重新修改</li>
</ul>
</li>
<li>供应商受理, 发货</li>
<li>采购入库</li>
</ol>
<h1 id="-">采购单</h1>
<p>医院采购单(yycgd)</p>
<ul>
<li>id</li>
<li>采购单状态, (zt, 未提交, 已提交未审核, 审核通过, 不通过)</li>
<li>编号</li>
<li>医院id</li>
</ul>
<p>医院采购单明细(cgdmx), 存放采购单采购药品, 唯一约束(yygdid, ypxxid)</p>
<ul>
<li>采购单id</li>
<li>药品信息id, ypxxid</li>
<li>供货企业, ghqy</li>
<li>中标价</li>
<li>交易价</li>
<li>采购量</li>
</ul>
<p>动态分表: 
随着系统使用, 时间长了采购明细信息表中的记录非常多,
如果进行分析速度很慢. 按年分开存储, mysql分库存储, oracle分表存储.
根据业务需求, 按年, 月, 日分. 如 <code>yycgdmx2014</code> <code>yycgdmm2014</code></p>
<p><code>bm=4位年+6位流水号</code> 使用序列解决流水号问题, 由于采购单主表和明细表年分开,
序列也按年分开.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;<span class="keyword">select</span> id=<span class="string">"getYycgdBm"</span> parameterType=<span class="string">"string"</span> resultType=<span class="string">"string"</span>&gt;
  -- 采购单编号 sequence 生成
  <span class="keyword">select</span> <span class="string">'$value'</span>||yycgdbm${<span class="keyword">value</span>}.nextval <span class="keyword">from</span> dual
&lt;/<span class="keyword">select</span>&gt;
</pre></td></tr></table></figure>

<p>用户参数转换器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 注解驱动 --&gt;</span>
<span class="tag">&lt;<span class="title">mvc:annotation-driven</span> &gt;</span>
    <span class="tag">&lt;<span class="title">mvc:argument-resolvers</span>&gt;</span>
        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"yycg.base.action.filter.UserArgumentResolver"</span>/&gt;</span>
    <span class="tag">&lt;/<span class="title">mvc:argument-resolvers</span>&gt;</span>
<span class="tag">&lt;/<span class="title">mvc:annotation-driven</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title">WebArgumentResolver</span> {</span>
    <span class="keyword">public</span> Object <span class="title">resolveArgument</span>(MethodParameter methodParameter, NativeWebRequest webRequest) <span class="keyword">throws</span> Exception {
        <span class="comment">//如果conroller方法的参数类型是ActiveUser，则执行</span>
        <span class="keyword">if</span> (methodParameter.getParameterType().equals(ActiveUser.class)) {
            ActiveUser user =(ActiveUser)webRequest.getAttribute(Config.ACTIVEUSER_KEY, RequestAttributes.SCOPE_SESSION);
            <span class="comment">//return一个对象就是给controller参数赋值</span>
            <span class="keyword">return</span> user;
        }
        <span class="keyword">return</span> UNRESOLVED;
    }
}
</pre></td></tr></table></figure>

<p><code>@SessionAttributes</code> 该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。
该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 方法中通过形参获取activeUser，如下：</span>
<span class="comment">// 方法名(ActiveUser activeUser)</span>
@SessionAttributes(<span class="keyword">value</span>=<span class="string">"activeUser"</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Functional Programming in Scala-函数式编程入门]]></title>
    <link href="http://zhpooer.github.io/2014/07/28/functional-programming-in-scala-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/07/28/functional-programming-in-scala-函数式编程入门/</id>
    <published>2014-07-28T01:14:32.000Z</published>
    <updated>2014-07-28T12:50:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="what-is-functional-programming">What is Functional Programming</h1>
<p>In other words, functions that have no side effects.</p>
<p>Performing any of the following actions directly would involve a side effect:</p>
<ul>
<li>Reassigning a variable</li>
<li>Modifying a data structure in place</li>
<li>Setting a field on an object</li>
<li>Throwing an exception or halting with an error</li>
<li>Printing to the console or reading user input</li>
<li>Reading from or writing to a file</li>
<li>Drawing on the screen</li>
</ul>
<p>We find ways to structure code so that effects
occur but are not observable (For example, we can mutate data that is declared
locally in the body of some function if we ensure that it cannot be referenced
outside that function.)</p>
<p>A function with input type A and output type B (written in Scala as a single type: <code>A =&gt; B</code>) </p>
<p>什么是引用透明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>scala&gt; val <span class="built_in">x</span> = new StringBuilder(<span class="string">"Hello"</span>)
<span class="label">x:</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.StringBuilder</span> = Hello

scala&gt; val <span class="built_in">y</span> = <span class="built_in">x</span><span class="preprocessor">.append</span>(<span class="string">", World"</span>)
<span class="label">y:</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.StringBuilder</span> = Hello, World

scala&gt; val <span class="built_in">r1</span> = <span class="built_in">y</span><span class="preprocessor">.toString</span>
<span class="label">r1:</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.String</span> = Hello, World

scala&gt; val <span class="built_in">r2</span> = <span class="built_in">y</span><span class="preprocessor">.toString</span>
<span class="label">r2:</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.String</span> = Hello, World

// 有副作用的例子
scala&gt; val <span class="built_in">x</span> = new StringBuilder(<span class="string">"Hello"</span>)
<span class="label">x:</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.StringBuilder</span> = Hello

scala&gt; val <span class="built_in">r1</span> = <span class="built_in">x</span><span class="preprocessor">.append</span>(<span class="string">", World"</span>)<span class="preprocessor">.toString</span>
<span class="label">r1:</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.String</span> = Hello, World

scala&gt; val <span class="built_in">r2</span> = <span class="built_in">x</span><span class="preprocessor">.append</span>(<span class="string">", World"</span>)<span class="preprocessor">.toString</span>
<span class="label">r2:</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.String</span> = Hello, World, World
</pre></td></tr></table></figure>

<p>多态函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>[<span class="title">A</span>]<span class="params">(as: Array[A], key: A, gt: <span class="params">(A,A)</span> =&gt; Boolean)</span>:</span> Int = {
  <span class="decorator">@annotation.tailrec</span>
  <span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(low: Int, mid: Int, high: Int)</span>:</span> Int = {
    <span class="keyword">if</span> (low &gt; high) -mid - <span class="number">1</span>
    <span class="keyword">else</span> {
      val mid2 = (low + high) / <span class="number">2</span>
      val a = <span class="keyword">as</span>(mid2)
      val greater = gt(a, key)
      <span class="keyword">if</span> (!greater && !gt(key,a)) mid2
      <span class="keyword">else</span> <span class="keyword">if</span> (greater) go(low, mid2, mid2-<span class="number">1</span>)
      <span class="keyword">else</span> go(mid2 + <span class="number">1</span>, mid2, high)
    }
  }
  go(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">as</span>.length - <span class="number">1</span>)
}
</pre></td></tr></table></figure>

<p>Lift: We can simply lift them using the map function.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">lift</span>[<span class="title">A</span>,<span class="title">B</span>]<span class="params">(f: A =&gt; B)</span>:</span> Option[A] =&gt; Option[B] = _ map f
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.regex._

<span class="function"><span class="keyword">def</span> <span class="title">pattern</span><span class="params">(s: String)</span>:</span> Option[Pattern] =
  <span class="keyword">try</span> {
    Some(Pattern.compile(s))
  } catch {
    case e: PatternSyntaxException =&gt; <span class="keyword">None</span>
  }
}

<span class="function"><span class="keyword">def</span> <span class="title">mkMatcher</span><span class="params">(pat: String)</span>:</span> Option[String =&gt; Boolean] =
  pattern(pat) map (p =&gt; (s: String) =&gt; p.matcher(s).matches)

<span class="function"><span class="keyword">def</span> <span class="title">mkMatcher_1</span><span class="params">(pat: String)</span>:</span> Option[String =&gt; Boolean] =
  <span class="keyword">for</span> {
    p &lt;- pattern(pat)
  } <span class="keyword">yield</span> ((s: String) =&gt; p.matcher(s).matches)

<span class="function"><span class="keyword">def</span> <span class="title">doesMatch</span><span class="params">(pat: String, s: String)</span>:</span> Option[Boolean] =
  <span class="keyword">for</span> {
    p &lt;- mkMatcher_1(pat)
  } <span class="keyword">yield</span> p(s)

<span class="function"><span class="keyword">def</span> <span class="title">bothMatch</span><span class="params">(pat: String, pat2: String, s: String)</span>:</span> Option[Boolean] =
  <span class="keyword">for</span> {
    f &lt;- mkMatcher(pat)
    g &lt;- mkMatcher(pat2)
  } <span class="keyword">yield</span> f(s) && g(s)

// 翻译成这样
// mkMatcher(pat) flatMap (f =&gt;
//   mkMatcher(pat2) map (g =&gt;
//     f(s) && g(s)))
</pre></td></tr></table></figure>

<p>Either</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">mean</span><span class="params">(xs: IndexedSeq[Double])</span>:</span> Either[String, Double] =
  <span class="keyword">if</span> (xs.isEmpty)
    Left(<span class="string">"mean of empty list!"</span>)
  <span class="keyword">else</span>
    Right(xs.sum / xs.length)

// result <span class="keyword">in</span> Left(<span class="string">"invalid name"</span>)
<span class="keyword">for</span> {
  age &lt;- Right(<span class="number">42</span>)
  name &lt;- Left(<span class="string">"invalid name"</span>)
  salary &lt;- Right(<span class="number">1000000.0</span>)
} <span class="keyword">yield</span> employee(name, age, salary)
</pre></td></tr></table></figure>

<h1 id="strictness-and-laziness">strictness and laziness</h1>
<p>Each transformation will produce a temporary list that only ever gets used as input
to the next transformation and is then immediately discarded.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="built_in">map</span> (_ <span class="subst">+</span> <span class="number">10</span>) filter (_ <span class="subst">%</span> <span class="number">2</span> <span class="subst">==</span> <span class="number">0</span>) <span class="built_in">map</span> (_ <span class="subst">*</span> <span class="number">3</span>)
</pre></td></tr></table></figure>

<p>If the evaluation of an expression runs forever or throws an error
instead of returning a definite value, we say that the expression does
not terminate, or that it evaluates to bottom. A function f is strict if
the expression f(x) evaluates to bottom for all x that evaluate to
bottom.</p>
<p>To say a function is non-strict just means that the function may
choose not to evaluate one or more of its arguments.</p>
<p>the Boolean functions <code>&amp;&amp;</code> and <code>||</code> are non-strict.</p>
<p>The if function would be non-strict, since it
will not evaluate all of its arguments. To be more precise,
we would say that the if function is strict in its condition parameter, </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">def</span> pair2(i: =&gt; Int) = { <span class="keyword">lazy</span> <span class="keyword">val</span> j = i; (j, j) }
scala&gt; pair2 { println(<span class="string">"hi"</span>); <span class="number">1</span> + <span class="number">41</span> }
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala in Action-applications using Akka]]></title>
    <link href="http://zhpooer.github.io/2014/07/26/scala-in-action-application-usnig-scala/"/>
    <id>http://zhpooer.github.io/2014/07/26/scala-in-action-application-usnig-scala/</id>
    <published>2014-07-25T23:35:04.000Z</published>
    <updated>2014-07-27T03:53:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="the-philosophy-behind-akka">The philosophy behind Akka</h1>
<p>The philosophy behind Akka is simple:
make it easier for developers to build correct,
concurrent, scalable, and fault-tolerant applications.</p>
<p>At the core, Akka is an event-based platform and relies on actors for message
passing and scalability. Akka puts both local and remote actors at your disposal. </p>
<h1 id="simple-concurrency-with-akka">Simple concurrency with Akka</h1>
<ul>
<li>Actors, An actor is an object that processes messages asynchronously and encapsulates
state.</li>
<li>STM, Software transactional memory is a concurrency model analogous to database
transactions for controlling access to a shared state</li>
<li>Agents, Agents provide abstraction over mutable data. They only allow you to mutate the
data through an asynchronous write action.</li>
<li>Dataflow, This means that it behaves the same every
time you execute it. So if your problem deadlocks the first time,
it will always deadlock, helping you to debug the problem.</li>
</ul>
<p>You can model an application using actors, handle muta-
ble state with STM or agents, and use dataflow concurrency to compose multiple
concurrent processes. </p>
<h2 id="remote-actors">Remote actors</h2>
<p>Akka remote actors allow you to deploy actors in remote machines and
send messages back and forth transparently.</p>
<p>The messages are automatically serialized using the Google protocol buffer.
Think of the Google protocol buffer as XML but smaller and faster, and Netty
as a non-blocking I/O (NIO) implementation, which allows Akka to efficiently use
threads for I/O operations.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>resolvers ++= <span class="constant">Seq</span>(
  <span class="string">"Akka Repo"</span> at <span class="string">"http://akka.io/repository"</span>,
  <span class="string">"Typesafe Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/repo"</span>
)
libraryDependencies ++= <span class="constant">Seq</span>(
  <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-actor" %</span> <span class="string">"2.1.0"</span>,
  <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-remote %</span> <span class="string">"2.1.0"</span>
)
</pre></td></tr></table></figure>

<p>We will work with a list of URLs. The goal is to connect
to the URL and count all the words on the page. </p>
<h2 id="making-mutable-data-safe-with-stm">Making mutable data safe with STM</h2>
<p>STM is similar to database transactions, but is used for memory instead.</p>
<ul>
<li>Atomicity—This property states that all modifications should follow the “all or
nothing” rule. In STM, all the modification is done through an atomic transac-
tion, and if one change fails all the other changes are rolled back.</li>
<li>Consistency—This property ensures that an STM transaction takes the system
from one consistent state to another.</li>
<li>Isolation—This property requires that no other STM transaction sees partial
changes from other transactions.</li>
</ul>
<p>It rolls back from exceptions and is composable.</p>
<p>In STM, state is defined as the value that an entity
with a specific identity has at a particular point.</p>
<p>A value is something that doesn’t change (it’s immutable).
And identity is a stable reference to a value at a given point in time.
The mutable part here is the identity,
which gets associated with a series of values.
And STM makes the mutation of reference from one value to another atomic.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>resolvers += (<span class="string">"Typesafe Repository"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>)
libraryDependencies ++= <span class="constant">Seq</span>(
  <span class="string">"org.scala-stm"</span> <span class="string">%% "scala-stm" %</span> <span class="string">"0.7"</span>,
  <span class="string">"org.specs2"</span> <span class="string">%% "specs2" %</span> <span class="string">"1.13"</span> % <span class="string">"test"</span>
)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">// Refs are nothing but mutable references to values that you</span>
<span class="comment">// can share safely with multiple concurrent participants.</span>
val ref1 = Ref(HashMap[String, Any](
  <span class="string">"service1"</span> -&gt; <span class="string">"10"</span>,
  <span class="string">"service2"</span> -&gt; <span class="string">"20"</span>,
  <span class="string">"service3"</span> -&gt; <span class="keyword">null</span>))
val ref2 = Ref(HashMap[String, Int]())

def atomicInsert(key: String, <span class="keyword">value</span>: Int) = atomic { <span class="keyword">implicit</span> txn =&gt;
  val oldMap = ref2.<span class="keyword">get</span>
  val newMap = oldMap + ( key -&gt; <span class="keyword">value</span>)
  <span class="comment">// using swap to replace the old value with the new value.</span>
  ref2.swap(newMap)
}

<span class="comment">// The transform method allows you to transform the value</span>
<span class="comment">// referenced by Ref by applying the given function</span>
def atomicDelete(key: String): Option[Any] = atomic {
  val oldMap = ref1.<span class="keyword">get</span>
  val <span class="keyword">value</span> = oldMap.<span class="keyword">get</span>(key)
  ref1.transform(_ - key)
  <span class="keyword">value</span>
}
</pre></td></tr></table></figure>

<p>To perform any operation on Ref you have to use the atomic
method defined in the STM package by passing an in-transaction parameter. The Scala
STM library creates the transaction object and grants the caller permission to perform
transactional reads and writes. Any refs you change in the closure will be done in an
STM transaction. </p>
<p>The transaction parameter is marked as implicit so you
don’t have to pass it around.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// <span class="operator">wrap</span> both <span class="operator">the</span> atomicDelete <span class="operator">and</span> atomicInsert functions <span class="operator">in</span> <span class="operator">an</span> atomic <span class="function"><span class="keyword">function</span></span>

def atomicSwap(key: String) = atomic { implicit txn =&gt;
  val <span class="built_in">value</span>: Option[Any] = atomicDelete(key)
  atomicInsert(key, Integer.parseInt(<span class="built_in">value</span>.<span class="built_in">get</span>.toString))
}
</pre></td></tr></table></figure>

<h2 id="agents">Agents</h2>
<p>Agents provide asynchronous changes to any individual storage location bound to it.
An agent only lets you mutate the location by applying an action.
Actions in this case are functions that asynchronously are applied to
the state of Agent and in which the
return value of the function becomes the new value of Agent .</p>
<p>Reading a value from Agent is synchronous and instantaneous.
The difference between Ref and Agent is that Ref
is a synchronous read and write; Agent is reactive.</p>
<p>Akka provides two methods: send and sendOff. The send
method uses the reactive thread pool allocated for agents,
and sendOff uses a dedicated thread, ideal for a long-running processes.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>libraryDependencies ++= <span class="constant">Seq</span>(
  <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-actor" %</span> <span class="string">"2.1.0"</span>,
  <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-agent" %</span> <span class="string">"2.1.0"</span>,
  <span class="string">"org.specs2"</span> <span class="string">%% "specs2" %</span> <span class="string">"1.13"</span> % <span class="string">"test"</span>
)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>// <span class="operator">with</span> <span class="operator">a</span> <span class="built_in">file</span> writer that<span class="comment">
// logs messages to the log file through send actions</span>
import akka.agent.Agent
implicit val <span class="keyword">system</span> = ActorSystem(<span class="string">"agentExample"</span>)
val writer = <span class="built_in">new</span> FileWriter(<span class="string">"src/test/resources/log.txt"</span>)
val <span class="operator">a</span> = Agent(writer)
<span class="operator">a</span>.<span class="built_in">send</span> { w =&gt; w.<span class="built_in">write</span>(<span class="string">"This is a log message"</span>); w}<span class="comment">
// Shut Agent down</span>
<span class="operator">a</span>.<span class="built_in">close</span>
writer.<span class="built_in">close</span>
</pre></td></tr></table></figure>

<p>Agent will be running until you invoke the close method.
An actor system is created for the agent because,
behind the scenes, agents are implemented using actors. If
you have to do more than logging to a file,
something that will take time, use the sendOff method:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>a.sendOff <span class="list">{ someLongRunningProcess }</span>
</pre></td></tr></table></figure>

<p>Note that at any time, only one send action is invoked.
Even if actions are sent from multiple concurrent processes,
the actions will be executed in sequential order.</p>
<p>This is important because if you
have a side-effect action, like logging to a file,
you don’t want to do that with STM.
Why? Because if STM transactions fail,
they retry automatically, meaning your
sideeffecting operation is executed multiple times.</p>
<p>Agent is associated with data, and you send behavior to Agent
from outside, in the form of a function. In the case of actors,
the behavior is defined
inside the actor, and you send data in the form of a message.</p>
<h2 id="dataflow">Dataflow</h2>
<p>Dataflow concurrency is a deterministic concurrency model.
If you run it and it works,
it will always work without deadlock.
Alternatively, if it deadlocks the first time, it will
always deadlock. </p>
<p>The dataflow concurrency allows you to
write sequential code that performs parallel operations.
The limitation is that your code should be completely side-effect free.</p>
<p>Dataflow is implemented in Akka using Scala’s delimited continuations compiler
plug-in. <code>build.sbt</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>autoCompilerPlugins <span class="symbol">:</span>= <span class="keyword">true</span>

libraryDependencies &lt;+= scalaVersion { v =&gt; compilerPlugin(
<span class="string">"org.scala-lang.plugins"</span> % <span class="string">"continuations"</span> % v) }

scalacOptions += <span class="string">"-P:continuations:enable"</span>

libraryDependencies += <span class="string">"com.typesafe.akka."</span> <span class="string">%% " akka-dataflow" %</span> <span class="string">"2.1.0"</span>
</pre></td></tr></table></figure>

<p>A dataflow variable is like a single-assignment variable.
Once the value is bound, it won’t change,
and any subsequent attempt to bind a new value will be ignored.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>// dataflow variable
// Here Akka Promise is used to <span class="operator"><span class="keyword">create</span> a dataflow variable.
// A Promise <span class="keyword">is</span> a <span class="keyword">read</span> handle <span class="keyword">to</span> a <span class="keyword">value</span> that will
// be available <span class="keyword">at</span> <span class="keyword">some</span> point <span class="keyword">in</span> the future.
val messageFromFuture = Promise[String]()

// <span class="keyword">Any</span> dataflow operation <span class="keyword">is</span> performed <span class="keyword">in</span> the Future.flow block:
Future.flow {
  messageFromFuture()
}</span>
</pre></td></tr></table></figure>

<p>The preceding call will wait in a thread unless a value is bound to messageFromFuture.
Future.flow returns a Future so you can perform other operations without blocking
the main thread of execution. Think of a Future as a data structure to retrieve the
result of some concurrent operation. To assign a value to a dataflow variable, use the
<code>&lt;&lt;</code> method as in the following:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>Future<span class="preprocessor">.flow</span> {
  messsageFromFuture &lt;&lt; <span class="string">"Future looks very cool"</span>
}
</pre></td></tr></table></figure>

<p>Once a value is bound to a dataflow variable,
all the Futures that are waiting on the
value will be unblocked and able to continue with execution. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>importimportimportakka.actor._
akka.dispatch._
Future.flow

<span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  implicit <span class="keyword">val</span> system = ActorSystem(<span class="string">"dataflow"</span>)
  <span class="keyword">val</span> messageFromFuture, rawMessage, parsedMessage = Promise[String]()
  flow {
    messageFromFuture &lt;&lt; parsedMessage()
    println(<span class="string">"z = "</span> + messageFromFuture())
  }
  flow { rawMessage &lt;&lt; <span class="string">"olleh"</span> }
  flow { parsedMessage &lt;&lt; toPresentFormat(rawMessage()) }
  <span class="keyword">def</span> toPresentFormat (s: String) = s.reverse
}
</pre></td></tr></table></figure>

<h1 id="building-a-real-time-pricing-system-akkaoogle">Building a real-time pricing system: Akkaoogle</h1>
<p>You’ll build a large web-based product search site
called Akkaoogle (see figure 12.4). It will be similar to Google’s
product search application (www.google.com/products) except that,
instead of returning all products matching your criteria,
your application will only return the cheapest deal found on
the web.</p>
<p>It gets the product price from two types of vendors
that are offering the product.
You can pay money to Akkaoogle and become an
internal vendor.
In this case, the product information is stored in Akkaoogle,
and you pay a small service charge.
You can also sign up as external vendor,
in which case Akkaoogle makes a RESTful web
service call to fetch the price -- but the downside is
you pay a bigger service charge. </p>
<p>When the user is looking for the cheapest deal,
Akkaoogle checks with all the vendors (internal and external)
and finds the lowest price for the user.</p>
<p>You have to find the cheapest deal in no more than
200 to 300 milliseconds.</p>
<h2 id="the-high-level-architecture-of-akkaoogle">The high-level architecture of Akkaoogle</h2>
<p><img src="/img/akkaoogle.png" alt="akkaoogle"></p>
<ul>
<li>Request handler—This is an actor that handles HTTP requests from the user.
You’ll use an asynchronous HTTP library called Mist, provided by Akka, to
implement this actor.</li>
<li>Search cheapest product—This is the main entry point to execute a search to find
the cheapest deal. This actor will search both internal and external vendors.</li>
<li>Internal load balancer—This is a load-balancing actor that sends messages to
worker actors to find the cheapest product available in the internal database.</li>
<li>External load balancer—This actor invokes all the external vendor services and
finds the cheapest price among them.</li>
<li>Find product price and find vendor price —The worker actors do the work of finding
the price.</li>
<li>Monitor—A simple monitor actor logs the failures that happen in external ven-
dor services.</li>
<li>Data loader—An actor that loads data to the database. This could be used to
load product data for internal vendors.</li>
</ul>
<h2 id="setting-up-the-project-for-akkaoogle">Setting up the project for Akkaoogle</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="comment">// Build.scala</span>
<span class="class"><span class="keyword">object</span> <span class="title">H2TaskManager</span> {</span>
  <span class="keyword">var</span> process: Option[Process] = None
  <span class="keyword">lazy</span> <span class="keyword">val</span> H2 = config(<span class="string">"h2"</span>) extend(Compile)
  <span class="keyword">val</span> startH2 = TaskKey[Unit](<span class="string">"start"</span>, <span class="string">"Starts H2 database"</span>)
  <span class="keyword">val</span> startH2Task =
  startH2 in H2 &lt;&lt;= (fullClasspath in Compile) map { cp =&gt;
      startDatabase(cp.map(_.data).map(_.getAbsolutePath()).filter(_.contains(
      <span class="string">"h2database"</span>)))}
  <span class="keyword">def</span> startDatabase(paths: Seq[String]) = {
    process <span class="keyword">match</span> {
      <span class="keyword">case</span> None =&gt;
        <span class="keyword">val</span> cp = paths.mkString(System.getProperty(<span class="string">"path.seperator"</span>))
        <span class="keyword">val</span> command = <span class="string">"java -cp "</span> + cp + <span class="string">" org.h2.tools.Server"</span>
        println(<span class="string">"Starting Database with command: "</span> + command)
        process = Some(Process(command).run())
        println(<span class="string">"Database started ! "</span>)
      <span class="keyword">case</span> Some(_) =&gt;
        println(<span class="string">"H2 Database already started"</span>)
    }
  }
  <span class="keyword">val</span> stopH2 = TaskKey[Unit](<span class="string">"stop"</span>, <span class="string">"Stops H2 database"</span>)
  <span class="keyword">val</span> stopH2Task = stopH2 in H2 :={
    process <span class="keyword">match</span> {
      <span class="keyword">case</span> None =&gt; println(<span class="string">"Database already stopped"</span>)
      <span class="keyword">case</span> Some(_) =&gt;
        println(<span class="string">"Stopping database..."</span>)
        process.foreach{_.destroy()}
        process = None
        println(<span class="string">"Database stopped..."</span>)
    }
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">AkkaoogleBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> <span class="keyword">with</span> <span class="title">ConfigureScalaBuild</span> {</span>
  <span class="keyword">import</span> H2TaskManager._
  <span class="keyword">lazy</span> <span class="keyword">val</span> root = project(id = <span class="string">"akkaoogle"</span>, base = file(<span class="string">"."</span>))
    .settings(startH2Task, stopH2Task)
    .settings(
      organization := <span class="string">"scalainaction"</span>,
      scalaVersion := <span class="string">"2.10.0"</span>,
      scalacOptions ++= Seq(<span class="string">"-unchecked"</span>, <span class="string">"-deprecation"</span>),
      resolvers +=
      <span class="string">"Typesafe Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/repo"</span>,
      parallelExecution in Test := <span class="keyword">false</span>
    )
    .settings(
      libraryDependencies ++= Seq(
        <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-actor"</span> % <span class="string">"2.1.0"</span>,
        <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-remote"</span> % <span class="string">"2.1.0"</span>,
        <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-agent"</span> % <span class="string">"2.1.0"</span>,
        <span class="string">"org.specs2"</span> %% <span class="string">"specs2"</span> % <span class="string">"1.13"</span> % <span class="string">"test"</span>,
        <span class="string">"com.h2database"</span> % <span class="string">"h2"</span> % <span class="string">"1.2.127"</span>,
        <span class="string">"org.squery1"</span> % <span class="string">"squery1_2.10.0-RC5"</span> % <span class="string">"0.9.5-5"</span>,
        <span class="string">"org.eclipse.jetty"</span> % <span class="string">"jetty-distribution"</span> % <span class="string">"8.0.0.M2"</span>)
    )
}
</pre></td></tr></table></figure>

<p>I test drove most of the application,
but I won’t show you test cases here.
I encourage you to go through the test cases
in this chapter’s accompanying codebase.</p>
<h2 id="implementing-the-domain-models">Implementing the domain models</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="code"><pre><span class="comment">//  create a common trait called Model that extends the KeyedEntity trait</span>
<span class="comment">//  This trait provides an id field that acts as a primary key</span>

implicit <span class="keyword">val</span> transactionFailures: Table[TransactionFailure] = AkkaoogleSchema.transactionFailures
implicit <span class="keyword">val</span> vendors: Table[ExternalVendor] = AkkaoogleSchema.vendors
implicit <span class="keyword">val</span> products: Table[Product] = AkkaoogleSchema.products
<span class="class"><span class="keyword">trait</span> <span class="title">Model</span>[<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span> <span class="keyword">this</span>: A =&gt;
  <span class="keyword">val</span> id: Long = <span class="number">0</span>
  <span class="keyword">def</span> save(implicit table: Table[A]): Either[Throwable, String] = {
    tx {
      <span class="keyword">try</span> {
        table.insert(<span class="keyword">this</span>)
        Right(<span class="string">"Domain object is saved successfully"</span>)
      } <span class="keyword">catch</span> {
        <span class="keyword">case</span> exception =&gt; Left(exception)
      }
    }
  }

}

<span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(val description: String,
              val vendorName: String,
              val basePrice: Double,
              val plusPercent: Double)</span> <span class="keyword">extends</span> <span class="title">Model</span>[<span class="title">Product</span>] {</span>
  <span class="keyword">def</span> calculatePrice = basePrice + (basePrice * plusPercent / <span class="number">100</span>)
}
              
<span class="class"><span class="keyword">class</span> <span class="title">ExternalVendor</span><span class="params">(val name: String, val url: String)</span></span>
      <span class="keyword">extends</span> Model[ExternalVendor]

<span class="comment">//  You’ll log (to the database) every time a call to</span>
<span class="comment">// an external vendor service fails </span>
<span class="class"><span class="keyword">class</span> <span class="title">TransactionFailure</span><span class="params">(val vendorId: String,
        val message: String,
        val timestamp: Date)</span> <span class="keyword">extends</span> <span class="title">Model</span>[<span class="title">TransactionFailure</span>]</span>

<span class="class"><span class="keyword">object</span> <span class="title">TransactionFailure</span> {</span>
  <span class="keyword">def</span> findAll = tx {
    from(transactionFailures)(s =&gt; select(s)) map(s =&gt; s)
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">def</span> findByDescription(description: String): Option[Product] =
    tx {
      products.where(p =&gt; p.description like description).headOption
    }
}

<span class="class"><span class="keyword">object</span> <span class="title">ExternalVendor</span> {</span>
  <span class="keyword">def</span> findAll = tx {
    from(vendors)(s =&gt; select(s)) map(s =&gt; s)
  }
}
</pre></td></tr></table></figure>

<p>Schema</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>package com.akkaoogle.db
import org.squeryl._
import org.squeryl.adapters._
import org.squeryl.PrimitiveTypeMode._
import java.sql.DriverManager
import com.akkaoogle.db.models._

object AkkaoogleSchema extends Schema {
  val products = table[<span class="link_label">Product</span>](<span class="link_url">"PRODUCTS"</span>)
  val vendors = table[<span class="link_label">ExternalVendor</span>](<span class="link_url">"VENDORS"</span>)
  val transactionFailures = table[<span class="link_label">TransactionFailure</span>](<span class="link_url">"TRANSACTION_LOG"</span>)
  def init = {
<span class="code">    import org.squeryl.SessionFactory</span>
<span class="code">    Class.forName("org.h2.Driver")</span>
<span class="code">    if(SessionFactory.concreteFactory.isEmpty) {</span>
<span class="code">      SessionFactory.concreteFactory = Some(()=&gt;</span>
<span class="code">        Session.create(</span>
<span class="code">          DriverManager.getConnection("jdbc:h2:tcp://localhost/~/test", "sa", ""),</span>
<span class="code">          new H2Adapter))</span>
<span class="code">    }</span>
  }
  def tx[<span class="link_label">A</span>](<span class="link_url">a: =&gt;A</span>): A = {
<span class="code">    init</span>
<span class="code">    inTransaction(a)</span>
  }
  def createSchema() {
<span class="code">    tx { drop ; create }</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="implementing-the-core-with-actors">Implementing the core with actors</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">package</span> com.akkaoogle.calculators
<span class="comment">// deal on the web and track the availability of the external services for quality purposes</span>
<span class="class"><span class="keyword">object</span> <span class="title">messages</span> {</span>
  <span class="comment">// represents a request triggered by a user looking for the cheapest deal.</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">FindPrice</span><span class="params">(productDescription: String, quantity: Int)</span></span>
  <span class="comment">// The response of the FindPrice message</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">LowestPrice</span><span class="params">(vendorName: String,
  case class LogTimeout(actorId: String, msg: String)</span></span>
  <span class="comment">//  The FindStats and Stats messages are used for administration purposes</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">FindStats</span><span class="params">(actorId: String)</span></span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Stats</span><span class="params">(actorId: String, timeouts: Int)</span></span>
}
</pre></td></tr></table></figure>

<p>The InternalPriceCalculator actor calculates the lowest price by looking
up the product by description, shown in the following listing.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
</pre></td><td class="code"><pre><span class="keyword">package</span> com.akkaoogle.calculators
<span class="keyword">import</span> messages._
<span class="keyword">import</span> com.akkaoogle.db.models._
<span class="keyword">import</span> akka.actor._
<span class="class"><span class="keyword">class</span> <span class="title">InternalPriceCalculator</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> FindPrice(productDescription, quantity) =&gt;
      <span class="keyword">val</span> price = calculatePrice(productDescription, quantity)
      sender ! price
  }
  <span class="keyword">def</span> calculatePrice( productDescription: String, qty: Int): Option[LowestPrice] = {
    Product.findByDescription(productDescription) map { product =&gt;
      Some(
        LowestPrice(product.vendorName,
                    product.description,
                    product.calculatePrice * qty) )
    } getOrElse Option.empty[LowestPrice]
  }
}
<span class="comment">//  you can have many external vendors for your application, you can’t make</span>
<span class="comment">// the remote service calls sequentially</span>
<span class="comment">// set a timeout for each service so you can</span>
<span class="comment">// respond to the user within a reasonable time</span>
<span class="class"><span class="keyword">class</span> <span class="title">ExternalVendorProxyActor</span><span class="params">(val v: ExternalVendor)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">var</span> result: Option[LowestPrice] = Option.empty[LowestPrice]
    <span class="keyword">val</span> f = Future({
      <span class="keyword">val</span> params = <span class="string">"?pd="</span> + fp.productDescription + <span class="string">"&q="</span> + fp.quantity
      <span class="keyword">val</span> price = Source.fromURL(v.url + params).mkString.toDouble
      Some(LowestPrice(v.name, fp.productDescription, price * fp.quantity))
    }) recover { <span class="keyword">case</span> t =&gt; Option.empty[LowestPrice] }
    f pipeTo sender
  }
}

<span class="comment">// You need the actor in the following listing to broadcast</span>
<span class="comment">// the FindPrice message to each proxy actor</span>

<span class="comment">// The ExternalPriceCalculator actor is created with references to ExternalVendorProxyActor.</span>
<span class="comment">// The FindPrice message is broadcast to all the proxy actors using the ? method</span>
<span class="class"><span class="keyword">class</span> <span class="title">ExternalPriceCalculator</span><span class="params">(val proxies: Iterable[ActorRef])</span></span>
      <span class="keyword">extends</span> Actor {
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> FindPrice(productId, quantity) =&gt;
      <span class="keyword">val</span> futures = proxies map { proxy =&gt;
        <span class="keyword">val</span> fp = FindPrice(productId, quantity)
        
        (proxy ? fp).mapTo[Option[LowestPrice]] recover {
          <span class="keyword">case</span> e: AskTimeoutException =&gt;
            AkkaoogleActorServer.lookup(<span class="string">"monitor"</span>) ! LogTimeout(proxy.path.name, <span class="string">"Timeout for "</span> + fp)
            Option.empty[LowestPrice]
          }
      }
      <span class="keyword">val</span> lowestPrice: Future[Option[LowestPrice]] =
        findLowestPrice(futures)
      <span class="keyword">val</span> totalPrice: Future[Option[LowestPrice]] = lowestPrice.map {
        l =&gt; l.map(p =&gt; p.copy(price = p.price + (p.price * <span class="number">.02</span>)))
      }
      totalPrice pipeTo sender
  }
}  

<span class="keyword">def</span> findLowestPrice(futures: Iterable[Future[Option[LowestPrice]]]):
    Future[Option[LowestPrice]] = {
  <span class="keyword">val</span> f: Future[Option[LowestPrice]] = Future.fold(futures)(Option.empty[LowestPrice]) {
    (lowestPrice: Option[LowestPrice], currentPrice: Option[LowestPrice]) =&gt; {
      currentPrice <span class="keyword">match</span> {
        <span class="keyword">case</span> Some(first) <span class="keyword">if</span> (lowsetPrice.isEmpty) =&gt; Some(first)
        <span class="keyword">case</span> Some(c) <span class="keyword">if</span> (c.price &lt; lowestPrice.get.price) =&gt; Some(c)
        <span class="keyword">case</span> _ =&gt; lowestPrice
      }
    }
  }
  f
}

<span class="comment">// find the lowest price from both internal and external vendors and return the result.</span>
<span class="class"><span class="keyword">class</span> <span class="title">CheapestDealFinder</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> req: FindPrice =&gt;
      <span class="keyword">val</span> internalPrice =
        (AkkaoogleActorServer.lookup(<span class="string">"internal-load-balancer"</span>) ? req).mapTo[Option[LowestPrice]]
      <span class="keyword">val</span> externalPrice =
        (AkkaoogleActorServer.lookup(<span class="string">"external-load-balancer"</span>) ?
          req).mapTo[Option[LowestPrice]] recover {
            <span class="keyword">case</span> e: AskTimeoutException =&gt; Option.empty[LowestPrice]
        }
      <span class="keyword">val</span> lowestPrice: Future[Option[LowestPrice]] = findLowestPrice(internalPrice :: externalPrice :: Nil)
      lowestPrice pipeTo sender
  }
}
</pre></td></tr></table></figure>

<h2 id="increase-scalability-with-remote-actors-dispatchers-and-routers">Increase scalability with remote actors, dispatchers, and routers</h2>
<p>Akka comes with special kinds of actors called routers, which can
effectively route messages between multiple instances of actors. The router actor acts
as a gateway to a collection of actors. You send a message to the router actor, and the
router actor forwards the message to one of the actors, based on some routing policy.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>//  <span class="operator">the</span> SmallestMailboxRouter router routes messages based <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">mailbox</span>.</span><span class="comment">
// creates 10 instances of CheapestDealFinder actors and</span><span class="comment">
// creates a SmallestMailboxRouter to route messages to them</span>
val cheapestDealFinderLoadBalancer = <span class="keyword">system</span>.actorOf(
  Props[CheapestDealFinder].withRouter(SmallestMailboxRouter(nrOfInstances = <span class="number">10</span>)),
  name = <span class="string">"cheapest-deal-finder-balancer"</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">val</span> internalPriceCalculators: List[ActorRef] = createInternalPriceCalculators(<span class="number">10</span>)

<span class="comment">// RoundRobinRouter routes messages to actors in round-robin fashion. </span>
<span class="keyword">val</span> internalLoadBalancer = system.actorOf(<span class="number">1</span>
    Props[InternalPriceCalculator]
  .withRouter(RoundRobinRouter (routees = internalPriceCalculators)),
  name = <span class="string">"internal-load-balancer"</span>)
  
<span class="keyword">val</span> proxies = createExternalProxyActors(ExternalVendor.findAll)

<span class="keyword">val</span> externalPriceCalculators: List[ActorRef] = createExternalPriceCalculators(<span class="number">10</span>, proxies)

<span class="keyword">val</span> externalLoadBalancer = system.actorOf(
    Props [ExternalPriceCalculator]
  .withRouter(RoundRobinRouter(routees = externalPriceCalculators)),
  name=<span class="string">"external-load-balancer"</span>)
</pre></td></tr></table></figure>

<p>Instead of allowing the router to create the actor instances,
the instances are passed as a parameter(they are called routees).</p>
<h3 id="improve-performance-with-dispatchers">IMPROVE PERFORMANCE WITH DISPATCHERS</h3>
<p>Every actor system has a default dispatcher that’s used if nothing is configured.
In Akka, message dispatchers are the engine behind the actors that makes Actor run.</p>
<p>Think of a dispatcher as a service with a thread pool that knows how to execute actors
when a message is received.</p>
<p>But if you notice some contention on a single dispatcher, you can start creating
dedicated dispatchers for a group of actors. </p>
<p>Remember, all the actors are created from the same actor system.
You can easily configure the default dispatcher by adding more threads to it</p>
<ul>
<li>Dispatcher—The default dispatcher used by the actor system. It’s an event-based
dispatcher that binds actors to a thread pool. It creates one mailbox per actor.</li>
<li>PinnedDispatcher—Dedicates one thread per actor. It’s like creating thread-based actors.</li>
<li>BalancingDispatcher—This event-driven dispatcher redistributes work from busy
actors to idle actors. All the actors of the same type share one mailbox.</li>
<li>CallingThreadDispatcher—It runs the actor on the calling thread.
It doesn’t create any new thread. Great for unit testing purposes.</li>
</ul>
<p>Using dispatchers in Akka is a simple two-step process: first,
specify them in the configuration file, then set up the actor with the dispatcher. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>akkaoogle {
  dispatchers {
    external-price-calculator-actor-dispatcher {
      # Dispatcher is the name <span class="keyword">of</span> the event-based dispatcher
      <span class="class"><span class="keyword">type</span> =</span> Dispatcher
      # What kind <span class="keyword">of</span> ExecutionService <span class="keyword">to</span> <span class="keyword">use</span>
      executor = <span class="string">"fork-join-executor"</span>
      # Configuration <span class="keyword">for</span> the fork-join pool
      fork-join-executor {
        # Min number <span class="keyword">of</span> threads <span class="keyword">to</span> cap factor-based parallelism number <span class="keyword">to</span>
        parallelism-min = <span class="number">2</span>
        # Parallelism (threads) ... ceil(available processors * factor)
        parallelism-factor = <span class="number">2.0</span>
        # Max number <span class="keyword">of</span> threads <span class="keyword">to</span> cap factor-based parallelism number t
        parallelism-max = <span class="number">100</span>
      }
      # Throughput defines the maximum number <span class="keyword">of</span> messages <span class="keyword">to</span> be
      # processed per actor before the thread jumps <span class="keyword">to</span> the next actor.
      # Set <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">as</span> fair <span class="keyword">as</span> possible.
      throughput = <span class="number">100</span>
    }
    <span class="keyword">internal</span>-price-calculator-actor-dispatcher {
      # Dispatcher is the name <span class="keyword">of</span> the event-based dispatcher
      <span class="class"><span class="keyword">type</span> =</span> BalancingDispatcher
      # What kind <span class="keyword">of</span> ExecutionService <span class="keyword">to</span> <span class="keyword">use</span>
      executor = <span class="string">"thread-pool-executor"</span>
      thread-pool-executor {
        # Minnumber <span class="keyword">of</span> threads <span class="keyword">to</span> cap factor-based core number <span class="keyword">to</span>
        core-pool-size-min = <span class="number">5</span>
      }
    }

  }
}
</pre></td></tr></table></figure>

<p>To use these dispatchers you will use the withDispatcher method of Props, as in
the following:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">private</span> def <span class="title">createInternalPriceCalculators</span>(initialLoad: Int)
     (<span class="keyword">implicit</span> system: ActorSystem) = {
  (<span class="keyword">for</span> (i &lt;- <span class="number">0</span> until initialLoad) <span class="keyword">yield</span>
    system.actorOf(Props[InternalPriceCalculator]
      .withDispatcher(<span class="string">"dispatchers.internal-price-calculator-actor-dispatcher"</span>),
    name=(<span class="string">"internal-price-calculator"</span> + i))).toList
}

<span class="keyword">private</span> def <span class="title">createExternalPriceCalculators</span>(initialLoad: Int,
     proxies: List[ActorRef])(<span class="keyword">implicit</span> system: ActorSystem) = {
  (<span class="keyword">for</span> (i &lt;- <span class="number">0</span> until initialLoad) <span class="keyword">yield</span> system.actorOf(
    Props(<span class="keyword">new</span> ExternalPriceCalculator(proxies))
      .withDispatcher(<span class="string">"dispatchers.external-price-calculator-actor-dispatcher"</span>),
    name = (<span class="string">"external-price-calculator"</span> + i))).toList
}
</pre></td></tr></table></figure>

<h2 id="handling-shared-resources-with-agent">Handling shared resources with Agent</h2>
<p>The monitor actor needs to log any transaction failure with external vendors. You
can always extend its functionality for internal use, but for now it needs to handle the
following two message types:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">LogTimeout</span><span class="params">(actorId: String, msg: String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">FindStats</span><span class="params">(actorId: String)</span></span>
</pre></td></tr></table></figure>

<p>To build the monitoring piece for the Akkaoogle application, you have to rely on a
shared mutable state, and this section shows you how to put Agent to use.</p>
<p>The monitor actor needs to log any transaction failure with external vendors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">LogTimeout</span><span class="params">(actorId: String, msg: String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">FindStats</span><span class="params">(actorId: String)</span></span>
</pre></td></tr></table></figure>

<p>On receiving a LogTimeout message, it needs to save the transaction
failure information to the database and also keep track of
the number of times a particular service failed.</p>
<p>The side effect that’s saving information to the database
can’t be done safely within an STM transaction, because an STM transaction
could retry the operations in a transaction multiple times
if there’s any read/write inconsistency.
If you use Agent, it can participate in the STM transaction and
get executed only when the STM transaction completes successfully.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="keyword">package</span> com.akkaoogle.infrastructure
<span class="keyword">import</span> akka.agent.Agent
<span class="keyword">import</span> akka.actor.Actor
<span class="keyword">import</span> com.akkaoogle.calculators.messages.{Stats, FindStats, LogTimeout}
<span class="keyword">import</span> java.util.Date
<span class="keyword">import</span> com.akkaoogle.db.models._
<span class="class"><span class="keyword">class</span> <span class="title">MonitorActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">import</span> context._
  
  <span class="keyword">val</span> errorLogger = Agent(Map.empty[String, Int])
  <span class="comment">// ideally you may want to save the existing error count in some persistence</span>
  <span class="comment">// storage so you can fetch the errors for later use.</span>
  <span class="keyword">def</span> preRestart = errorLogger send { old =&gt; Map.empty[String, Int] }
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> LogTimeout(actorId, msg) =&gt;
      logTimeout(actorId, msg)
    <span class="keyword">case</span> FindStats(actorId) =&gt;
      <span class="keyword">val</span> timeouts = errorLogger().getOrElse(actorId, <span class="number">0</span>)
      sender ! Stats(actorId, timeouts = timeouts)
    }

  <span class="keyword">private</span> <span class="keyword">def</span> logTimeout(actorId: String, msg: String): Unit = {
    errorLogger send { errorLog =&gt;
      <span class="keyword">val</span> current = errorLog.getOrElse(actorId, <span class="number">0</span>)
      <span class="keyword">val</span> newErrorLog = errorLog + (actorId -&gt; (current + <span class="number">1</span>))
      <span class="keyword">val</span> l = <span class="keyword">new</span> TransactionFailure(actorId, msg, <span class="keyword">new</span> Date(System.currentTimeMillis))
      l.save
      newErrorLog
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="setting-up-play2-mini">Setting up Play2-mini</h2>
<p>Play2-mini is a lightweight REST framework on top of the Play2 framework. It maps an
HTTP request to a function that takes an HTTP request and returns a response.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">ConfigureScalaBuild</span> {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> typesafe = <span class="string">"Typesafe Repository"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> typesafeSnapshot = <span class="string">"Typesafe Snapshots Repository"</span> at <span class="string">"http://repo.typesafe.com/typesafe/snapshots/"</span>
  <span class="keyword">val</span> netty = Some(<span class="string">"play.core.server.NettyServer"</span>)
  <span class="keyword">def</span> scalaMiniProject(org: String, name: String, buildVersion: String,
        baseFile: java.io.File = file(<span class="string">"."</span>)) =
    Project(id = name, base = baseFile, settings = Project.defaultSettings).settings(
      version := buildVersion,
      organization := org,
      resolvers += typesafe,
      resolvers += typesafeSnapshot,
      libraryDependencies += <span class="string">"com.typesafe"</span> %% <span class="string">"play-mini"</span> % <span class="string">"2.1=RC2"</span>,
      mainClass in (Compile, run) := netty,
      ivyXML := &lt;dependencies&gt; &lt;exclude org=<span class="string">"org.springframework"</span>/&gt;&lt;/dependencies&gt;
    )
}

importimportsbt._
Keys._
<span class="class"><span class="keyword">object</span> <span class="title">AkkaoogleBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> <span class="keyword">with</span> <span class="title">ConfigureScalaBuild</span> {</span>
  <span class="keyword">import</span> H2TaskManager._
  <span class="keyword">lazy</span> <span class="keyword">val</span> root =
    scalaMiniProject(<span class="string">"com.akkaoogle"</span>,<span class="string">"akkaoogle"</span>,<span class="string">"1.0"</span>)
      .settings(startH2Task, stopH2Task)
      .settings(
        organization := <span class="string">"scalainaction"</span>,
        scalaVersion := <span class="string">"2.10.0"</span>,
        scalacOptions ++= Seq(<span class="string">"-unchecked"</span>, <span class="string">"-deprecation"</span>),
        resolvers += <span class="string">"Typesafe Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/repo"</span>,
        parallelExecution in Test := <span class="keyword">false</span>
      ).settings(
      libraryDependencies ++= Seq(
        <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-actor"</span> % <span class="string">"2.1.0"</span>,
        <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-remote"</span> % <span class="string">"2.1.0"</span>,
        <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-agent"</span> % <span class="string">"2.1.0"</span>,
        <span class="string">"com.h2database"</span> % <span class="string">"h2"</span> % <span class="string">"1.2.127"</span>,
        <span class="string">"org.squeryl"</span> % <span class="string">"squery1_2.10-RC5"</span> % <span class="string">"0.9.5-5"</span>,
        <span class="string">"org.specs2"</span> %% <span class="string">"specs2"</span> % <span class="string">"1.13"</span> % <span class="string">"test"</span>,
        <span class="string">"org.eclipse.jetty"</span> % <span class="string">"jetty-distribution"</span> % <span class="string">"8.0.0.M2"</span> % <span class="string">"test"</span>)
      )
}
</pre></td></tr></table></figure>

<h3 id="running-with-play2-mini">Running with Play2-mini</h3>
<p>Play2-mini–based application needs to implement <code>com.typesafe.play.mini.Setup</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">package</span> com.typesafe.play.mini
<span class="class"><span class="keyword">class</span> <span class="title">Setup</span><span class="params">(a: Application)</span> <span class="keyword">extends</span> <span class="title">GlobalSettings</span> {</span>
  ...
}
<span class="comment">// Think of Application as a controller of the MVC model that handles all the requests.</span>
<span class="keyword">package</span> com.typesafe.play.mini
<span class="class"><span class="keyword">trait</span> <span class="title">Application</span> {</span>
  <span class="comment">// you have to implement is the routes method</span>
  <span class="keyword">def</span> route: PartialFunction[RequestHeader, Handler]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>import <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.infrastructure</span>._
import org<span class="preprocessor">.h</span>2<span class="preprocessor">.tools</span><span class="preprocessor">.Server</span>
import <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.db</span><span class="preprocessor">.AkkaoogleSchema</span>._

//  <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.http</span><span class="preprocessor">.App</span> will handle all the HTTP requests for the Akkaoogle application. 
object Global extends <span class="keyword">com</span><span class="preprocessor">.typesafe</span><span class="preprocessor">.play</span><span class="preprocessor">.mini</span><span class="preprocessor">.Setup</span>(<span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.http</span><span class="preprocessor">.App</span>) {
  println(<span class="string">"initializing the Akkaoogle schema"</span>)
  //  initialize the various parts
  createSchema()
  AkkaoogleActorServer<span class="preprocessor">.run</span>()
}

package <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.http</span>
import <span class="keyword">com</span><span class="preprocessor">.typesafe</span><span class="preprocessor">.play</span><span class="preprocessor">.mini</span>._
import play<span class="preprocessor">.api</span><span class="preprocessor">.mvc</span>._
import play<span class="preprocessor">.api</span><span class="preprocessor">.mvc</span><span class="preprocessor">.Results</span>._
import <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.infrastructure</span>._
import akka<span class="preprocessor">.pattern</span>.{ ask, pipe, AskTimeoutException }
import <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.calculators</span><span class="preprocessor">.messages</span>._
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.concurrent</span>._
import scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConverters</span>._

object App extends Application {
  def route = {
    case GET(Path(<span class="string">"/"</span>)) =&gt; Action { request =&gt;
      Ok(views<span class="preprocessor">.index</span>())<span class="preprocessor">.as</span>(<span class="string">"text/html"</span>)
    }
    case GET(Path(<span class="string">"/akkaoogle/search"</span>)) & QueryString(qs) =&gt;
      Action { request =&gt;
        val desc = QueryString(qs, <span class="string">"productDescription"</span>)<span class="preprocessor">.get</span><span class="preprocessor">.asScala</span>
        val f =
          (AkkaoogleActorServer<span class="preprocessor">.lookup</span>(<span class="string">"cheapest-deal-finder-balancer"</span>) ?
             FindPrice(desc<span class="preprocessor">.head</span>, <span class="number">1</span>))<span class="preprocessor">.mapTo</span>[Option[LowestPrice]]
        val result = f<span class="preprocessor">.map</span>({
          case Some(lowestPrice) =&gt;
            Ok(lowestPrice<span class="preprocessor">.toString</span>)<span class="preprocessor">.as</span>(<span class="string">"text/html"</span>)
          case _ =&gt;
            Ok(<span class="string">"No price found"</span>)<span class="preprocessor">.as</span>(<span class="string">"text/html"</span>)
            Return
        })
        AsyncResult(result<span class="preprocessor">.asPromise</span>)
      }
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre></td><td class="code"><pre>package <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.infrastructure</span>

import <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.calculators</span>._
import akka<span class="preprocessor">.actor</span>._
import <span class="keyword">com</span><span class="preprocessor">.akkaoogle</span><span class="preprocessor">.db</span><span class="preprocessor">.models</span>._
import akka<span class="preprocessor">.actor</span>.{ActorRef, Actor}
import akka<span class="preprocessor">.routing</span>._
import <span class="keyword">com</span><span class="preprocessor">.typesafe</span><span class="preprocessor">.config</span><span class="preprocessor">.ConfigFactory</span>

object AkkaoogleActorServer {
  var system: Option[ActorSystem] = None
  def run(): Unit = {
    println(<span class="string">"starting the remote server..."</span>)
    system = Some(ActorSystem(<span class="string">"akkaoogle"</span>, ConfigFactory<span class="preprocessor">.load</span><span class="preprocessor">.getConfig</span>(<span class="string">"akkaoogle"</span>)))
    system<span class="preprocessor">.foreach</span>(s =&gt; register(s))
  }
  
  private def register(implicit system: ActorSystem) {
    val monitor = system<span class="preprocessor">.actorOf</span>(Props[MonitorActor], name = <span class="string">"monitor"</span>)
    
    val cheapestDealFinderLoadBalancer = system<span class="preprocessor">.actorOf</span>(
      Props[CheapestDealFinder]<span class="preprocessor">.withRouter</span>(SmallestMailboxRouter(nrOfInstances = <span class="number">10</span>)),
      name = <span class="string">"cheapest-deal-finder-balancer"</span>)
      
    val internalPriceCalculators: List[ActorRef] = createInternalPriceCalculators(<span class="number">10</span>)
    val internalLoadBalancer = system<span class="preprocessor">.actorOf</span>(
      Props[InternalPriceCalculator]<span class="preprocessor">.withRouter</span>(RoundRobinRouter(routees = internalPriceCalculators)),
      name = <span class="string">"internal-load-balancer"</span>)
      
    val proxies = createExternalProxyActors(ExternalVendor<span class="preprocessor">.findAll</span>)
    val externalPriceCalculators: List[ActorRef] = createExternalPriceCalculators(<span class="number">10</span>, proxies)
    val externalLoadBalancer = system<span class="preprocessor">.actorOf</span>(
      Props [ExternalPriceCalculator]<span class="preprocessor">.withRouter</span>(RoundRobinRouter(routees = externalPriceCalculators)),
      name=<span class="string">"external-load-balancer"</span>)
  }
  
  def lookup(name: String): ActorRef = {
    system map { s =&gt;
      val path = s / name
      s<span class="preprocessor">.actorFor</span>(path)
    } getOrElse(throw new RuntimeException(<span class="string">"No actor found"</span>))
  }
  
  def stop(){
    system<span class="preprocessor">.foreach</span>(_<span class="preprocessor">.shutdown</span>())
  }
  
  private def createExternalProxyActors(vendors: Iterable[ExternalVendor])(implicit system: ActorSystem) = {
    val proxies = for(v &lt;- vendors) yield {
      println(<span class="string">"Creating vendor proxies for "</span> + v<span class="preprocessor">.name</span>)
      val ref = system<span class="preprocessor">.actorOf</span>(Props(new ExternalVendorProxyActor(v))
          <span class="preprocessor">.withDispatcher</span>(<span class="string">"dispatchers.proxy-actor-dispatcher"</span>),name=v<span class="preprocessor">.name</span>)
      ref
    }
    proxies<span class="preprocessor">.toList</span>
  }

  private def createInternalPriceCalculators(initialLoad: Int)(implicit system: ActorSystem) = {
    (for (i &lt;- <span class="number">0</span> until initialLoad) yield
    system<span class="preprocessor">.actorOf</span>(
      Props [InternalPriceCalculator]<span class="preprocessor">.withDispatcher</span>(<span class="string">"dispatchers.internal-price-calculator-actor-dispatcher"</span>),
      name=(<span class="string">"internal-price-calculator"</span> + i)))<span class="preprocessor">.toList</span>
  }
  
  private def createExternalPriceCalculators(
    initialLoad: Int, proxies: List[ActorRef])(
    implicit system: ActorSystem) = {
      (for (i &lt;- <span class="number">0</span> until initialLoad)
        yield
      system<span class="preprocessor">.actorOf</span>(
        Props(new ExternalPriceCalculator(proxies))<span class="preprocessor">.withDispatcher</span>(<span class="string">"dispatchers.external-price-calculator-actor-dispatcher"</span>),
        name = (<span class="string">"external-price-calculator"</span> + i)))<span class="preprocessor">.toList</span>
  }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala in Action-Java integration]]></title>
    <link href="http://zhpooer.github.io/2014/07/25/scala-in-action-java-integration/"/>
    <id>http://zhpooer.github.io/2014/07/25/scala-in-action-java-integration/</id>
    <published>2014-07-25T12:51:27.000Z</published>
    <updated>2014-07-25T14:27:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="using-java-classes-in-scala">Using Java classes in Scala</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">import</span> org.joda.time.DateTime;
<span class="keyword">import</span> org.joda.time.Days;
<span class="keyword">import</span> java.util.Date;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateCalculator</span> {</span>
    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">daysBetween</span>(Date start, Date end) {
        Days d = Days.daysBetween(<span class="keyword">new</span> DateTime(start.getTime()),
        <span class="keyword">new</span> DateTime(end.getTime()));
        <span class="keyword">return</span> d.getDays();
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">import</span> chap11.java._
<span class="keyword">import</span> java.util.Date
<span class="class"><span class="keyword">class</span> <span class="title">PaymentCalculator</span><span class="params">(val payPerDay: Int = 100)</span> <span class="keyword">extends</span> <span class="title">DateCalculator</span> {</span>
    <span class="keyword">def</span> calculatePayment(start: Date, end: Date) = {
        daysBetween(start, end) * payPerDay
    }
}
</pre></td></tr></table></figure>

<h1 id="working-with-java-checked-exceptions">Working with Java checked exceptions</h1>
<p>he Scala compiler won’t force you. In cases where you think you should
catch the exception, don’t rethrow the exception from Scala. It’s a bad practice.
A better way is to create an instance of the Either or Option type. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(content: String)</span>:</span> Either[Exception, Boolean] = {
  val w = new Writer
  <span class="keyword">try</span> {
    w.writeToFile(content)
    Right(true)
  } catch {
    case e: java.io.IOException =&gt; Left(e)
  }
}
</pre></td></tr></table></figure>

<h1 id="working-with-java-generics-using-existential-types">Working with Java generics using existential types</h1>
<p><code>Vector&lt;?&gt;</code> could be represented as <code>Vector[T] forSome { type T }</code>
in Scala. Reading from left to right, this type
expression represents a vector of T for some type of T .
This type T is unknown and could be anything.
But T is fixed to some type for this vector.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.{ Vector =&gt; JVector }
<span class="function"><span class="keyword">def</span> <span class="title">printLanguages</span>[<span class="title">C</span> &lt;:</span> JVector[T] forSome { type T}](langs: C):Unit = {
  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until langs.size) println(langs.get(i))
}
</pre></td></tr></table></figure>

<p>There’s placeholder syntax for existential type <code>JVector[_]</code>. It means the same
thing as <code>JVector[T] forSome { type T }</code>. The preceding printLanguages method
could also be written as follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">printLanguages</span>[<span class="title">C</span> &lt;:</span> JVector[_]](langs: C):Unit = {
  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until langs.size) println(langs.get(i))
}
</pre></td></tr></table></figure>

<h2 id="working-with-java-collections">Working with Java collections</h2>
<p>The Scala library ships with two utility classes that do
exactly that for you:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConversions</span>
scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConverters</span>
</pre></td></tr></table></figure>

<p><code>JavaConversions</code> provides a series of implicit conversions that convert
between a Java collection and the closest corresponding Scala collection, and vice
versa. <code>JavaConverters</code> uses a “Pimp my Library” pattern to add the asScala
method to Java collection and asJava method to Scala collection types.</p>
<p>My recommendation would be to use JavaConverters because it makes the conversion
explicit.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; import java<span class="preprocessor">.util</span>.{ArrayList =&gt; JList }
import java<span class="preprocessor">.util</span>.{ArrayList =&gt; JList}
scala&gt; val jList = new JList[Int]()
<span class="label">jList:</span> java<span class="preprocessor">.util</span><span class="preprocessor">.ArrayList</span>[Int] = []
scala&gt; jList<span class="preprocessor">.add</span>(<span class="number">1</span>)
<span class="label">res1:</span> Boolean = true
scala&gt; jList<span class="preprocessor">.add</span>(<span class="number">2</span>)
<span class="label">res2:</span> Boolean = true
scala&gt; import scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConverters</span>._
import scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConverters</span>._
scala&gt; jList<span class="preprocessor">.asScala</span> foreach println
</pre></td></tr></table></figure>

<h1 id="building-web-applications-in-scala-using-java-frameworks">Building web applications in Scala using Java frameworks</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>mvn archetype:generate <span class="attribute">-DgroupId</span><span class="subst">=</span>scala<span class="built_in">.</span><span class="keyword">in</span><span class="built_in">.</span>action <span class="attribute">-DartifactId</span><span class="subst">=</span>top<span class="built_in">.</span>artists
<span class="attribute">-DarchetypeArtifactId</span><span class="subst">=</span>maven<span class="attribute">-archetype</span><span class="attribute">-webapp</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day63-医药集中采购平台 药品目录]]></title>
    <link href="http://zhpooer.github.io/2014/07/25/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day63-%E5%8C%BB%E8%8D%AF%E9%9B%86%E4%B8%AD%E9%87%87%E8%B4%AD%E5%B9%B3%E5%8F%B0-%E8%8D%AF%E5%93%81%E7%9B%AE%E5%BD%95/"/>
    <id>http://zhpooer.github.io/2014/07/25/传智播客day63-医药集中采购平台-药品目录/</id>
    <published>2014-07-25T01:04:29.000Z</published>
    <updated>2014-07-28T02:19:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">数据字典</h1>
<p>系统中定义的类型数据, 在数据字典表定义.</p>
<p>数据字典明细表 (dictinfo)</p>
<ul>
<li>info</li>
<li>typecode 外键关联</li>
</ul>
<p>数据字典类型表 (dicttype)</p>
<ul>
<li>typecode primary key</li>
<li>dictcode</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">-- 选择药品</span>
<span class="operator"><span class="keyword">select</span> * form dictinfo <span class="keyword">where</span> typecode=<span class="string">'001'</span>;</span>
</pre></td></tr></table></figure>

<p>应用</p>
<ol>
<li><p>将数据字典明细表中的id存储在业务表的字段中, 如医院信息(useryy)中的级别</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="operator"><span class="keyword">select</span> t.*,
  (<span class="keyword">select</span> info <span class="keyword">from</span> dictinfo <span class="keyword">where</span> id=t.jb)
t.rowid <span class="keyword">from</span> useryy t;</span>
</pre></td></tr></table></figure>
</li>
<li><p>将数据字典表中的dictcode字段存储在业务表中, 比如系统用户表中的groupid,
对应数据字典表中typecode为 01的 dictcode</p>
</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 系统配置接口 --&gt;</span>
<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">""</span> <span class="attribute">class</span>=<span class="value">"SystemConfigServiceImpl"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> UserAction {
    @RequestMapping(<span class="string">"/userquery"</span>)
    <span class="keyword">public</span> String <span class="title">userquery</span>(Model model) {
        List&lt;DictInfo&gt; grouplist = systemConfgiService.findDictInfoByType(<span class="string">"s01"</span>);
        model.addAttribut(<span class="string">"groupinfo"</span>, grouplist)
        <span class="keyword">return</span> <span class="string">"base/userquery"</span>;
    }
}
</pre></td></tr></table></figure>

<p>将 硬编码判断, 数据库用户预定义类型(1-&gt;info,2-&gt;info,3-&gt;info) 在数据库关联</p>
<h1 id="-">用户身份认证</h1>
<p>静态密码方式, 用户名对应的密码设置在系统, 以设置一边不再改变,
安全性低容易被木马窃取, 可以定期修改密码, 但是不容易记忆</p>
<p>动态密码: 短信密码</p>
<p>验证码, 防止恶意攻击</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> {</span>
    <span class="comment">// 登陆页面</span>
    <span class="annotation">@RequestMapping</span>(<span class="string">"/login"</span>)
    <span class="keyword">public</span> String <span class="title">login</span>(){
        <span class="keyword">return</span> <span class="string">"/base/login"</span>
    }
    <span class="comment">// 登陆提交</span>
    <span class="annotation">@RequestMapping</span>(<span class="string">"/loginsubmit"</span>)
    <span class="keyword">public</span> @ResponseBody SubmitResultInfo <span class="title">loginSubmit</span>(
        HttpSession session, 
        String userid, String pwd, String randomcode 
    ) {
        <span class="comment">// 校验验证码是否正确</span>
        String validateCode_session = session.getAttribute(<span class="string">"validateCode"</span>);
        <span class="keyword">if</span>(!validateCode_session.equals(randomcode)) {
            ResultUtil.throwException(ResultUtil.createFail(Config.MESSAGE, <span class="number">113</span>, <span class="keyword">null</span>));
        }
        <span class="comment">// 校验用户身份</span>
        ActiveUser activeUser = userManagerService.userloginCheck(userid, pwd);
        session.setAttribute(Config.ACTIVE_key, activeUser);
        <span class="keyword">return</span> ResultUtil.createSubmitResult(ResultUtil.createSuccess(Config.Message, <span class="number">107</span>, <span class="keyword">new</span> Object[]{activeUser.userId}));
    }
}

<span class="comment">// userManagerService</span>

<span class="comment">// 校验通过返回用户身份信息</span>
<span class="keyword">public</span> ActiveUser <span class="title">userloginCheck</span>(String userid, String pwd) {
    Sysuser sysuser = findSysuserByuserid(userid);
    <span class="keyword">if</span>(sysuser==<span class="keyword">null</span>) {
        ResultUtil.throwException(ResultUtil.createFail(Config.MESSAGE, <span class="number">110</span>, <span class="keyword">null</span>));
    }
    String pwd_md5 = <span class="keyword">new</span> MD5.getMD5ofStr(pwd);
    <span class="keyword">if</span>(!sysuser.getPwd().equals(pwd_md5)) {
        <span class="comment">// 提示 用户密码不正确</span>
        ResultUtil.throwException(ResultUtil.createFail(Config.MESSAGE, <span class="number">114</span>, <span class="keyword">null</span>)); 
    }
    ActiverUser activeUser = <span class="keyword">new</span> ActiveUser();
    activeUser.setGroupid(sysuser.getGroupid);
    activeUser.setUserId(); <span class="comment">// username, sysid</span>
    <span class="keyword">return</span> activeUser;
}

<span class="annotation">@Controller</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> {</span>
   <span class="annotation">@ResourceMapping</span>(<span class="string">"/logout"</span>)
   <span class="keyword">public</span> String <span class="title">logout</span>() {
       <span class="comment">// 清除session</span>
       session.setAtrribute(<span class="string">""</span>, <span class="keyword">null</span>);
       <span class="keyword">return</span> View.recirect(<span class="string">"login.action"</span>); <span class="comment">// "redirect:login.action"</span>
   }
}
</pre></td></tr></table></figure>

<h2 id="-">登陆拦截器</h2>
<p><code>anonimousAction.properties</code>, 配置用户无需登录就可操作的配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>login<span class="preprocessor">.action</span>
login<span class="preprocessor">.submit</span><span class="preprocessor">.action</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> {</span>
    <span class="comment">// 进入action方法之前调用</span>
    <span class="comment">// 权限管理</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preHandler</span>() {
        Activeuser activeUser = session.getAttribute();
        <span class="keyword">if</span>(activeUser!=<span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        List&lt;String&gt; open_url = ResourcesUtil.getKeyList(Config.ANONYMOUST_ACIOTNS);
        <span class="comment">// 获取请求地址</span>
        String url = request.getRequestURI();
        <span class="keyword">for</span>(String url_l : open_url){
            <span class="keyword">if</span>(url.contains(url_l)) {
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="comment">// request.getRequestDispatcher("login.jsp").forword(request, response);</span>
        <span class="comment">// 抛出一个异常信息, 由全局异常处理器同一执行</span>
            <span class="comment">// 如果异常代码为106, 跳转到登陆页面</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// 执行 action 之后, 返回视图之前</span>
    <span class="comment">// 给页面添加共有数据</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span>() {
    }
    <span class="comment">// 执行 action 之后</span>
    <span class="comment">// 捕获异常, 性能监视</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span>() {
    }
}
</pre></td></tr></table></figure>

<h1 id="-">药品目录</h1>
<p>药品目录: 通用名, 价格, 企业名称, 商品名称, 规格, 药品流水号(编号, 通用),
剂型(胶囊, 针剂), 规格(一个胶囊毫克), 转换系数(40片胶囊), 药品状态(1. 正常交易, 暂停交易)</p>
<p>药品目录表的记录id与业务表存在很多的外键关联, 规定药品目录不再删除, 进行逻辑删除,
更新药品交易状态为暂停交易</p>
<p>省级的药品目录通过接口将信息录入到市药品采购平台, 通过 excel 导出, excel 导入</p>
<p>excel需要导入导出模板</p>
<h2 id="poi">POI</h2>
<p>操作微软文档的 java api</p>
<p>HSSF, 只支持 excel 97-2003</p>
<p>XSSF, 支持2007以上的版本, <code>.xlsx</code>, 文件是基于xml存储的</p>
<h3 id="-">导出</h3>
<p>Workbook(工作簿), Sheet, Row(行), Cell(单元格)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// HSSF 操作</span>
Workbook wb = <span class="keyword">new</span> HSSFWorkbook();

Sheet sheet = wb.createSheet(<span class="string">"new sheet"</span>);
sheet.createRow((<span class="keyword">short</span>)<span class="number">0</span>);
<span class="comment">// row 表示单元格所在行, 创建时指定单元格所在列</span>
Cell cell = row.createCell(<span class="number">0</span>);
cell.setValue(<span class="number">1</span>);
</pre></td></tr></table></figure>

<p>HSSF导出数据如果数据量足够大, 可能会发生内存溢出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 关闭自动刷新, 100, 保持100条行在内存</span>
SXSSFWorkbook wb = <span class="keyword">new</span> SXSSWorkbook(-<span class="number">1</span>);
Sheet sh = createSheet();
Row row = sh.createRow(<span class="number">0</span>);
Cell cell = row.createCell(<span class="number">0</span>);

<span class="comment">// 刷入硬盘, 但是保留最后插入的100行</span>
<span class="comment">// 会被写入临时文件</span>
(SXSSSheet)sh.flushRows(<span class="number">100</span>); 

wb.dispose(); <span class="comment"><span class="xmlDocTag">///</span> 清除临时文件</span>
</pre></td></tr></table></figure>

<p>处理数据速度不快, 除非由大数据要求, 否则建议使用 XSSF</p>
<h2 id="-">导出药品目录</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre>
<span class="comment">// 药品信息</span>
<span class="annotation">@Controller</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YpxxActiona</span> {</span>
    <span class="comment">// 药品信息导出页面</span>
    <span class="annotation">@RequestMapping</span>(<span class="string">"/ypxxExport"</span>)
    <span class="keyword">public</span> String <span class="title">ypxxExport</span>(Model model) {
        <span class="comment">// 药品类别</span>
        List&lt;Dictinfo&gt; yplbList = systemConfigService.findDictinfoByType(<span class="string">"001"</span>);
        <span class="comment">// 交易状态</span>
        List&lt;Dictinfo&gt; jyztList = systemConfigService.findDictinfoByType(<span class="string">"003"</span>);
        model.addAttribute(<span class="string">"yplbList"</span>, yplbList);
        model.addAttribute(<span class="string">"jyztList"</span>, jyztList);
        
        <span class="keyword">return</span> View.toBusiness(<span class="string">"/ypml/ypxxExport"</span>);
    }
    <span class="annotation">@RequestMapping</span>(<span class="string">"/ypxxExportSubmit"</span>)
    <span class="keyword">public</span> @ResponseBody SubmitResultInfo <span class="title">ypxxExportSubmit</span>() {
        String webpath = ypmlservice.ypxxExport(ypxxQueryVo);
        <span class="comment">// 导出成功, 点击下载</span>
        <span class="keyword">return</span> ResultUtil.createSubmitResult(ResultUtil.createSuccess(Config.Message, <span class="number">318</span>, ))
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YpmlService</span> {</span>
    <span class="keyword">public</span> List&lt;YpxxCustom&gt; <span class="title">findYpxxList</span>(YpxxQueryVo ypxxQueryVo) {
       <span class="keyword">return</span> ypxxMapperCustom.findYpxxList(ypxxQeuryVo);
    }
    
    <span class="comment">// 药品信息导出</span>
    <span class="comment">// 导出后将下载的文件路径返回</span>
    <span class="keyword">public</span> String <span class="title">ypxxExport</span>(YpxxQeuryVo ypxxQueryVo) {
        List&lt;YpxxCustom&gt; list = <span class="keyword">this</span>.findYpxxList(ypxxQeuryVo);
        <span class="comment">// 调用封装类, 执行导出</span>
        
    }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>&lt;<span class="keyword">select</span> id=<span class="string">"findYpxxList"</span> parameterType=<span class="string">"YpxxQueryVO"</span> resultType=<span class="string">"YpxxCustom"</span>&gt;
    <span class="keyword">select</span> * <span class="keyword">from</span> ypxx.*,
        (<span class="keyword">select</span> form dictinfo <span class="keyword">where</span> dictcode=ypxx.jyzt <span class="keyword">and</span> typecode=<span class="comment">'003') jyztmc</span>
    <span class="keyword">from</span> ypxx
    &lt;<span class="keyword">where</span>&gt;
        &lt;<span class="keyword">if</span> test=<span class="string">"ypxxCustom!=null"</span>&gt;
           &lt;<span class="keyword">if</span> test=<span class="string">"ypxxCustom.bm!=null and ypxxCustom.bm!=''"</span>&gt;
               ypxx.bm=<span class="preprocessor">#{ypxxCustom.mc}</span>
           &lt;/<span class="keyword">if</span>&gt;
           <span class="keyword">and</span> ypxx.mc <span class="keyword">like</span> <span class="comment">''</span>
           <span class="keyword">and</span> ypxx.lb=<span class="comment">''</span>
           <span class="keyword">and</span> ypxx.jyzt=<span class="comment">''</span>
        &lt;/<span class="keyword">if</span>&gt;
    &lt;/<span class="keyword">where</span>&gt;
&lt;/<span class="keyword">select</span>&gt;
</pre></td></tr></table></figure>

<p>basicinfo表, 保存系统配置, 如 导出文件的保存路径</p>
<h2 id="-">药品信息的导入</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// 03版本读取, 只能读取xsl的文件,</span>
<span class="comment">// 如果使用用户驱动, 如果数据量过大, 内存溢出</span>
<span class="comment">// 但是可以使用 事件驱动机制 来避免 内存溢出, 但是速度不快,</span>
<span class="comment">// 需要程序员自定义 processRecord 方法去处理读取到的数据</span>
HSSFWorkbook wb = <span class="keyword">new</span> HSSFWorkbook(inputStream);
wb.getNumberOfSheets();
Sheet sheet = wb.getSheetAt(<span class="keyword">index</span>);
HSSFRow row = wb.getRow(rownum);
HSSFCell cell = row.getCell();
</pre></td></tr></table></figure>

<p>使用 XSSF 方式读取 excel 文件, 是基于 sax 方式, 属于事件驱动</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">//YpxxAction</span>
<span class="annotation">@RequestMapping</span>(<span class="string">"/ypxximport"</span>)
<span class="keyword">public</span> String ypxximport {
    <span class="comment">// 药品信息导入页面</span>
    <span class="keyword">return</span> View.toBusiness(<span class="string">"/ypxl/ypxximport"</span>);
}

<span class="annotation">@ReqeustMappng</span>(<span class="string">"/ypxximportstudent"</span>)
<span class="keyword">public</span> @ResponseBody SubmitResultInfo <span class="title">ypxximportsubmit</span>(MultipartFile ypxximportfile) {
    String filename = ypxximportfile.getOriginalFilename();
    File file = <span class="keyword">new</span> File(<span class="string">"d:/upload/"</span> + filename_original);
    <span class="keyword">if</span>(!file.exist()) {
        file.mkdirs(); <span class="comment">// 如果文件所在的路径不存在则创建</span>
    }
    <span class="comment">// 将内存中文件的数据写入磁盘</span>
    ypxximportfile.transferTo(file);
    <span class="comment">// 导入, 若导入失败, 形成失败记录文件, 返回给用户</span>
}
<span class="comment">// 上传多个文件</span>
<span class="comment">// public SubmitResultInfo ypxximportsubmit(@RequestParam("ypxximportfile") MultipartFile[] ypxximportfiles)</span>



<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YpxxImportServiceImpl</span> <span class="keyword">implements</span> <span class="title">HxlsOptRowsInterface</span> {</span>
    <span class="comment">// 流水号, 再插入时, 使用触发器自动生成</span>
}
</pre></td></tr></table></figure>

<p>内连接, 通过外键关联的两个表的查询, 也可以通过子查询,
不是外键关联可能会出现重复记录</p>
<h1 id="-">供货商药品目录</h1>
<p>供货商将自己供应的药品发布到供应商药品目录(gysypml)</p>
<ul>
<li>id</li>
<li>ypxxid</li>
<li>usergysid</li>
</ul>
<p>监督单位可以对供货商对应的药品进行控制, 允许供货或不允许供货(gysypml_control),
记录药品控制的状态(只更新, 不添加)</p>
<ul>
<li>id</li>
<li>ypxxid, 药品信息</li>
<li>usergysid, 供应商id</li>
<li>control, 监督机构控制状态(1. 正常, 2. 暂停)</li>
<li>advice, 监督机构意见</li>
</ul>
<p>两张表在数据库级别没有关系</p>
<p>供货商药品目录维护, 供货商在ypsypml表中添加, 删除记录</p>
<ul>
<li>添加, 供货商添加自己供应的药品</li>
<li>删除, 供货商删除自己不再供应的药品</li>
</ul>
<p>如果将控制状态设置在供货商商品目录表,
供应商添加一条记录, 监督单位更新一条记录(控制状态更新为暂停),
供货商删除一条记录, 删除的同时将监督单位的控制状态也删除了.
<strong>供货商操作影响了监督单位</strong></p>
<p>查询供货商药品目录和供货商药品目录控制表时, 通过供货商id和药品信息一块儿关联查询</p>
<h2 id="-">业务操作</h2>
<ul>
<li>供货商药品目录查询, 供货商 + 药品信息 + 状态</li>
<li>供货商添加药品查询, 药品总目录存在的药品, 但是在供货商目录没有的药品</li>
<li>确认添加药品, 到供货商药品目录</li>
<li>监督单位对供货商的药品进行控制<ol>
<li>查询所有供货商供应的药品的控制状态</li>
<li>进行控制, 选择要控制的对象, 选择供货状态, 点击确认提交</li>
</ol>
</li>
</ul>
<h2 id="-">供货商目录维护</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"findGysypmlList"</span> <span class="attribute">parameterType</span>=<span class="value">"GysypxxQeuryVo"</span> <span class="attribute">resultType</span>=<span class="value">"GysypmlCustom6"</span>&gt;</span>
select gysypml.*, ypxx.*,
      (seelct info from dictinfo where 控制状态),
      (seelct info from dictinfo where 交易状态)
    from gysypml, ypxx, gysyml_control
    where gysypml.ypxxid=ypxx.id
      and gysypml.ypxxid=gysyml_control.ypxxid
      and gysypml.usergysid=gysyml_control.usergysid;
    <span class="comment">&lt;!-- 药品信息查询条件  --&gt;</span>
    <span class="comment">&lt;!-- 控制状态条件 --&gt;</span>
    <span class="comment">&lt;!-- 分页条件, 参考 baseuser --&gt;</span>
<span class="tag">&lt;/<span class="title">select</span>&gt;</span>
<span class="tag">&lt;<span class="title">select</span> <span class="attribute">id</span>=<span class="value">"findGysypmlCount"</span> <span class="attribute">parameterType</span>=<span class="value">"GysypxxQeuryVo"</span> <span class="attribute">resultType</span>=<span class="value">"GysypmlCustom6"</span>&gt;</span>
select gysypml.*, ypxx.*,
      (seelct info from dictinfo where 控制状态),
      (seelct info from dictinfo where 交易状态)
    from gysypml, ypxx, gysyml_control
    where gysypml.ypxxid=ypxx.id
      and gysypml.ypxxid=gysyml_control.ypxxid
      and gysypml.usergysid=gysyml_control.usergysid;
    <span class="comment">&lt;!-- 药品信息查询条件  --&gt;</span>
    <span class="comment">&lt;!-- 控制状态条件 --&gt;</span>
<span class="tag">&lt;/<span class="title">select</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">// ypmlAction</span>
<span class="comment">// 供货商药品目录查询</span>
<span class="keyword">public</span> String <span class="title">gysypmlquery</span>(Model model, GyspmQeuryVo gyspmlQeuryVo) {
    
    <span class="keyword">return</span> View.toBusiness(<span class="string">"/ypml/gysypmlquery"</span>);
}

<span class="comment">// 供货商药品目录查询结果集</span>
<span class="annotation">@ResultMapping</span>(<span class="string">"/y"</span>)
<span class="keyword">public</span> @ResponseBody DatagridResultInfo <span class="title">findGysypmlCount</span>(
      GyspmQeuryVo gyspmlQeuryVo
      <span class="keyword">int</span> page,
      <span class="keyword">int</span> rows) {
    <span class="keyword">int</span> count = ypmlService.findGysymlcount(gysypmlQeuryVo);
    <span class="comment">// 分页</span>
    PageQuery pageQuery = <span class="keyword">new</span> PageQuery()
    pageQuery.setPageParams(count, rows, page);
    gpsymlQeuryVo.setPageQuery(pageQuery);

    List&lt;GysypmlCustom&gt; list = ypmlService.findGysymlList(gpsymlQeuryVo);
    DataGridResultInfo dinfo = <span class="keyword">new</span> DataGridResultInfo();
    dinfo.setTotal(count);
    dinfo.setRows(list);
    <span class="keyword">return</span> dinfo;
}
</pre></td></tr></table></figure>

<h2 id="-">数据范围权限</h2>
<p>企业控制范围权限</p>
<ul>
<li>身份用户认证</li>
<li>用户权限控制(功能操作)</li>
<li>数据范围权限(通过 sql 硬编码, 必须要有用户id传入)<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>在service层传入 用户id 和 <span class="keyword">query</span><span class="variable">Vo</span>, 然后再封装
</pre></td></tr></table></figure>

</li>
</ul>
<h2 id="-">供货商药品目录添加查询</h2>
<p>查找供应商允许添加的药品目录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>&lt;<span class="keyword">select</span> id=<span class="string">"findGysypmlAddList"</span> parameterType=<span class="string">"yycg.business.vo.GysypmlQueryVo"</span>
        resultType=<span class="string">"GysypmlCustom"</span>&gt;
    <span class="keyword">select</span> ypxx.*,
        (<span class="keyword">select</span> info <span class="keyword">from</span> dictinfo <span class="keyword">where</span> dictcode=ypxx.jyzt <span class="keyword">and</span> typecod=<span class="comment">'003') jyztmc</span>
    <span class="keyword">from</span> ypxx;
&lt;/<span class="keyword">select</span>&gt;
&lt;<span class="keyword">select</span> id=<span class="string">"findGysypmlAddListCount"</span>&gt;
&lt;/<span class="keyword">select</span>&gt;
</pre></td></tr></table></figure>

<h2 id="-">批量提交</h2>
<p>供货商选择药品添加药品到供货商药品目录(gysypml)</p>
<p>后置条件: 数据库操作, 在供货商药品目录表插入数据时, 同时向供货商药品目录控制表插入记录</p>
<p>Action 用 List 接收页面提交的数据, <code>String[] index</code>
接收被选择的序列</p>
<p>使用 hidden 命名规范 <code>gysypmls[index].ypxxid</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="keyword">public</span> @Response SubmitResultInfo <span class="title">gysypmladdsubmit</span>(
        GysymplQueryVo qgysypmlQueryVo, // 这里
        Sring[] index // 选择的行){
    List gyspmls = gysspmlQueryVo.getGysypmls();
    <span class="keyword">int</span> num = indexs.length;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) {
        <span class="keyword">int</span> index = Integer.parseInt(indexs[i]);
        gysypmls.<span class="keyword">get</span>(index);
        ypmlService.insertGysypl(usergysid, ypxxid);
    }
}
<span class="comment">// YmplService</span>
<span class="comment">// 根据供应商的id和药品信息id获取供应商目录表的一条记录</span>
<span class="keyword">public</span> Gysypml <span class="title">findGysypmlByYpxxAdnUsergysid</span>(String usergysid, String ypxxid) {
    GysypmlExample gysypmlExample = <span class="keyword">new</span> GysypmlExample();
    GysypmlExample.Createria c = gysypmlExample.createCriteria;
    c.andUsergysidEqualTo(usergysid);
    c.andYpxxidEqualTo(yapxixid);
    List list  = gysypmlMapper.selectByExample(gysypmlControlExample)
    <span class="keyword">return</span> list.<span class="keyword">get</span>(<span class="number">0</span>);
}
<span class="keyword">public</span> Gysypml <span class="title">findGysypmlControlByYpxxAdnUsergysid</span>(String usergysid, String ypxxid) {
    GysypmlExample gysypmlExample = <span class="keyword">new</span> GysypmlExample();
    GysypmlExample.Createria c = gysypmlExample.createCriteria;
    c.andUsergysidEqualTo(usergysid);
    c.andYpxxidEqualTo(yapxixid);
    List list  = gysypmlMapper.selectByExample(gysypmlControlExample);
    <span class="keyword">return</span> list.<span class="keyword">get</span>(<span class="number">0</span>);
}
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertGysypml</span>(String usergysid, String gyxxid) {
    Ypxx ypxx = ypxxMapper.selectByPrimaryKey(ypxxid);
    <span class="comment">// 校验记录是否重复</span>
    Gysypml gysypml = findGysypmlByYpxxAdnUsergysid(usergysid, ypxxid);
    <span class="keyword">if</span>(gysypml!=<span class="keyword">null</span>) {
        ResultUtil.throwException(createFail());
    }
    
    Gysypml gysympl_insert = <span class="keyword">new</span> Gysypml();
    gysypml_insert.setId(UUDIBuild.getUUID());
    gysypmlMapper.insert(gysypml_insert);

   <span class="comment">// 向供货商药品目录写一条表</span>
   <span class="comment">// 校验, 再添加</span>
}
</pre></td></tr></table></figure>

<h2 id="-">供货商删除供货商药品目录</h2>
<p>提交内容, 药品信息id</p>
<p>删除供货商药品目录提交</p>
<h2 id="-">监督单位对供货单位进行控制</h2>
<ul>
<li>查询被控制对象(gysypml_control)</li>
<li>进行控制, 供货商药品目录控制提交</li>
</ul>
]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala in Action-ScalaTest]]></title>
    <link href="http://zhpooer.github.io/2014/07/24/scala-in-action-scalatest/"/>
    <id>http://zhpooer.github.io/2014/07/24/scala-in-action-scalatest/</id>
    <published>2014-07-24T02:11:32.000Z</published>
    <updated>2014-07-25T12:45:29.000Z</updated>
    <content type="html"><![CDATA[<p>There are two kinds of automated tests: ones you write (the most common)
and ones you generate for your code.</p>
<p>If you’re a Java developer and have used JUnit before, using it to test your Scala
code is easy. Specs is a testing tool written in Scala for Scala and
provides more expressiveness in your tests.</p>
<p>Dependency injection is a design pattern used by developers to make their code
more testable.As a hybrid language, Scala provides a number of
abstraction techniques you can use to implement dependency injection.</p>
<p>Automated tests are tests that are recorded or prewritten and can be run by a machine
without any manual intervention.</p>
<p>In the agile software development process, teams don’t analyze and design the
application up front; they build it using an evolutionary design.</p>
<ul>
<li>What does evolving design have to do with automated testing?</li>
<li>Why is evolving the design better than designing the application up front?</li>
</ul>
<p>There are varied types of automated tests: specification-based, unit, integration,
functional, and regression, to name a few.</p>
<h1 id="automated-test-generation-using-scalacheck">Automated test generation using ScalaCheck</h1>
<p>In ScalaCheck, a property is a testable unit. To create a
new property in ScalaCheck, you have to make a statement that describes the behavior
you want to test.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>name := <span class="string">"ScalaCheckExample"</span>

<span class="built_in">version</span> := <span class="string">"1.0"</span>

organization := <span class="string">"Scala in Action"</span>

scalaVersion := <span class="string">"2.10.0"</span>

resolvers ++= Seq(
  <span class="string">"Sonatype Snapshots"</span> <span class="keyword">at</span> <span class="string">"http://oss.sonatype.org/content/repositories/snapshots"</span>,
  <span class="string">"Sonatype Releases"</span> <span class="keyword">at</span> <span class="string">"http://oss.sonatype.org/content/repositories/releases"</span>
)

libraryDependencies ++= Seq (
  <span class="string">"org.scalacheck"</span> %% <span class="string">"scalacheck"</span> % <span class="string">"1.10.0"</span> % <span class="string">"test"</span>
)
<span class="comment">
// append options passed to the Scala compiler</span>
scalacOptions ++= Seq(<span class="string">"-deprecation"</span>, <span class="string">"-unchecked"</span>, <span class="string">"-feature"</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// The job of ScalaCheck would be to falsify this statement</span>
<span class="comment">// by generating random test data. </span>
<span class="keyword">val</span> anyString = <span class="string">"some string value"</span>
anyString.reverse.reverse == anyString

<span class="keyword">import</span> org.scalacheck.Prop
Prop.forAll((a: String) =&gt; a.reverse.reverse == a)

<span class="keyword">package</span> checks
<span class="keyword">import</span> org.scalacheck._
<span class="comment">// The org.scalacheck.Properties represents a collection of ScalaCheck</span>
<span class="comment">// properties, and SBT has built-in support for running Properties:</span>
<span class="class"><span class="keyword">object</span> <span class="title">StringSpecification</span> <span class="keyword">extends</span> <span class="title">Properties</span><span class="params">(<span class="string">"String"</span>)</span> {</span>
  property(<span class="string">"reverse of reverse gives you same string back"</span>) =
    Prop.forAll((a: String) =&gt; a.reverse.reverse == a)
}
</pre></td></tr></table></figure>

<p>The ScalaCheck generators are responsible for generating test data, and the
org.scalacheck.Gen class represents them.</p>
<p>One in particular is quite important: the arbitrary generator. This is a special
generator that generates arbitrary values for any supported type.</p>
<h2 id="working-with-scalacheck">Working with ScalaCheck</h2>
<ol>
<li>Either will have value on either Left or Right, but not both at any point
in time.</li>
<li>fold on the Left should produce the value contained by Left.</li>
<li>fold on the Right should produce the value contained by Right.</li>
<li>swap returns the Left value to the Right and vice versa.</li>
<li>getOrElse on Left returns the value from Left or the given argument if this is
Right.</li>
<li>forAll on Right returns true if Left or returns the result of the application of
the given function to the Right value.</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre>import Gen._
import Arbitrary.arbitrary
//  creates a new instance of the Int type generator and
// maps it to <span class="operator"><span class="keyword">create</span> <span class="keyword">values</span> <span class="keyword">for</span> <span class="keyword">Left</span>
val leftValueGenerator = arbitrary[<span class="keyword">Int</span>].map(<span class="keyword">Left</span>(_))
val rightValueGenerator = arbitrary[<span class="keyword">Int</span>].map(<span class="keyword">Right</span>(_))

// randomly generate instances <span class="keyword">of</span> <span class="keyword">Left</span> <span class="keyword">or</span> <span class="keyword">Right</span>.
// methods <span class="keyword">like</span> oneOf <span class="keyword">or</span> frequency , called combinators.
// They allow you <span class="keyword">to</span> combine multiple generators.
implicit val eitherGenerator =
    oneOf(leftValueGenerator, rightValueGenerator)
    
// The generator you’ve defined here <span class="keyword">only</span> generates <span class="keyword">Int</span> <span class="keyword">values</span>,
// but <span class="keyword">if</span> you wanted <span class="keyword">to</span> play <span class="keyword">with</span> different types <span class="keyword">of</span> <span class="keyword">values</span>, you’d also
// define the generator <span class="keyword">like</span> this:
implicit def arbitraryEither[X, Y](implicit xa: Arbitrary[X],
      ya: Arbitrary[Y]): Arbitrary[Either[X, Y]] =
  Arbitrary[Either[X, Y]]( oneOf(arbitrary[X].map(<span class="keyword">Left</span>(_)), arbitrary[Y].map(<span class="keyword">Right</span>(_))) )

// <span class="keyword">If</span> you wanted <span class="keyword">to</span> use leftValueGenerator <span class="number">75</span>% <span class="keyword">of</span> the <span class="keyword">time</span> compared
// <span class="keyword">to</span> the rightValueGenerator, you could use Gen.frequency <span class="keyword">like</span> this:
implicit val eitherGenerator =
    frequency((<span class="number">3</span>, leftValueGenerator), (<span class="number">1</span>, rightValueGenerator))

// 测试代码
property(<span class="string">"isLeft or isRight not both"</span>) =
    Prop.forAll((e: Either[<span class="keyword">Int</span>, <span class="keyword">Int</span>]) =&gt; e.isLeft != e.isRight)

//  <span class="keyword">on</span> the <span class="keyword">Left</span> should produce the <span class="keyword">value</span> contained <span class="keyword">by</span> <span class="keyword">Left</span>
property(<span class="string">"left value"</span>) =
    Prop.forAll{(n: <span class="keyword">Int</span>) =&gt; <span class="keyword">Left</span>(n).fold(x =&gt; x, b =&gt; error(<span class="string">"fail"</span>)) == n }

// fold <span class="keyword">on</span> the <span class="keyword">Right</span> should produce the <span class="keyword">value</span> contained <span class="keyword">by</span> <span class="keyword">Right</span>
property(<span class="string">"Right value"</span>) =
    Prop.forAll{(n: <span class="keyword">Int</span>) =&gt; <span class="keyword">Right</span>(n).fold(b =&gt; error(<span class="string">"fail"</span>), x =&gt; x) == n }

//def fold[X](fa: A =&gt; X, fb: B =&gt; X) = this <span class="keyword">match</span> {
//  <span class="keyword">case</span> <span class="keyword">Left</span>(a) =&gt; fa(a)
//  <span class="keyword">case</span> <span class="keyword">Right</span>(b) =&gt; fb(b)
//}

// “swap returns the <span class="keyword">Left</span> <span class="keyword">value</span> <span class="keyword">to</span> <span class="keyword">Right</span> <span class="keyword">and</span> vice versa”
property(<span class="string">"swap values"</span>) = Prop.forAll{(e: Either[<span class="keyword">Int</span>, <span class="keyword">Int</span>]) =&gt; e <span class="keyword">match</span> {
    <span class="keyword">case</span> <span class="keyword">Left</span>(a) =&gt; e.swap.<span class="keyword">right</span>.<span class="keyword">get</span> == a
    <span class="keyword">case</span> <span class="keyword">Right</span>(b) =&gt; e.swap.<span class="keyword">left</span>.<span class="keyword">get</span> == b
  }
}

property(<span class="string">"getOrElse"</span>) =
  Prop.forAll{ (e: Either[<span class="keyword">Int</span>, <span class="keyword">Int</span>], <span class="keyword">or</span>: <span class="keyword">Int</span>) =&gt;
    e.<span class="keyword">left</span>.getOrElse(<span class="keyword">or</span>) == (e <span class="keyword">match</span> {
      <span class="keyword">case</span> <span class="keyword">Left</span>(a) =&gt; a
      <span class="keyword">case</span> <span class="keyword">Right</span>(_) =&gt; <span class="keyword">or</span>
    })
  }

property(<span class="string">"forall"</span>) = Prop.forAll {(e: Either[<span class="keyword">Int</span>, <span class="keyword">Int</span>]) =&gt;
  e.<span class="keyword">right</span>.forall(_ % <span class="number">2</span> == <span class="number">0</span>) == (e.isLeft || e.<span class="keyword">right</span>.<span class="keyword">get</span> % <span class="number">2</span> == <span class="number">0</span>)
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>// setting <span class="keyword">for</span> <span class="operator">the</span> minimum successful (-s) tests <span class="built_in">from</span> <span class="number">100</span> <span class="built_in">to</span> <span class="number">500</span> <span class="keyword">by</span> passing test arguments
&gt; test-only <span class="comment">-- -s 500</span>
</pre></td></tr></table></figure>

<h1 id="tdd">TDD</h1>
<p>Acceptance criteria:</p>
<pre><code>A 100 product code should use cost plus the percent amount.
Example: 150 (cost) + 20% = $180
All products whose ID starts with B should use an external price source to get
the price.
</code></pre><ul>
<li>Where should you implement the pricing logic?</li>
<li>Should you create a trait or start with a simple function?</li>
<li>What parameters will the function take?</li>
<li>How should you test the output?</li>
<li>Should it hit the database or filesystem to pull up the cost?</li>
</ul>
<p>The most common theme of TDD is to pick the simplest
solution that could possibly work. In this case the simplest solution would be to create
a function that takes a product code, looks it up in a Map, and returns the price using
the formula specified in the acceptance criterion.</p>
<p>Do the simplest thing that could possibly work, and
then incrementally design and build your application.</p>
<p>Once your test is running, you have the opportunity to refactor or clean up.
Refactoring (www.refactoring.com) is a technique you can use to improve the design of
existing code without changing the behavior.</p>
<p>Most popular: JUnit and Specs. JUnit is more
popular among Java developers and can be easily used to test Scala code.</p>
<h2 id="ci">CI</h2>
<ul>
<li>Jenkins CI</li>
<li>Jenkins SBT plugins</li>
<li>Code coverage</li>
</ul>
<p>You can also generate a <code>.POM</code> file (Maven build file) from
your SBT project using the make-pom action.</p>
<h2 id="using-junit">Using JUnit</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>libraryDependencies += <span class="string">"junit"</span> % <span class="string">"junit"</span> % <span class="string">"4.10"</span> % <span class="string">"test"</span>

libraryDependencies += <span class="string">"com.novocode"</span> % <span class="string">"junit-interface"</span> % <span class="string">"0.8"</span> % <span class="string">"test"</span>
</pre></td></tr></table></figure>

<h1 id="di">DI</h1>
<p>Dependency injection (DI) is a design pattern that separates
behavior from dependency resolution.</p>
<p>This example is about calculating the price of a product based on various pricing
rules. Typically any pricing system will have hundreds of rules, but to keep
things simple I will only talk about two:</p>
<ul>
<li>The cost-plus rule determines the price by adding a percentage of the cost.</li>
<li>Getting the price from an external pricing source.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span> {</span>
  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> CostPlusCalculator()
  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> ExternalPriceSourceCalculator()
  <span class="keyword">val</span> calculators = Map(
    <span class="string">"costPlus"</span> -&gt; calculate(costPlusCalculator) _ ,
    <span class="string">"externalPriceSource"</span> -&gt; calculate(externalPriceSourceCalculator) _)
    
  <span class="keyword">def</span> calculate(priceType: String, productId: String): Double = {
    calculators(priceType)(productId)
  }
  
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">def</span> calculate(c: Calculator)(productId: String):Double =
    c.calculate(productId)
}
<span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> {</span>
  <span class="keyword">def</span> calculate(productId: String): Double
}

<span class="class"><span class="keyword">class</span> <span class="title">CostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> {</span>
  <span class="keyword">def</span> calculate(productId: String) = {}
}

<span class="class"><span class="keyword">class</span> <span class="title">ExternalPriceSourceCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> {</span>
  <span class="keyword">def</span> calculate(productId: String) = {}
}
</pre></td></tr></table></figure>

<p>Dependency injection is a specific form of inversion of control where the
concern being inverted is the process of obtaining the needed dependencie</p>
<p>There are some potential problems with this,
in particular when your software is evolving.</p>
<p>Using DI, you can easily solve this problem. If the dependent calculators could be
passed in (injected) to the CalculatePriceService, then the service could be easily
configured with various implementations of calculators.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">// 通过构造器注入</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span><span class="params">(
    val costPlusCalculator: Calculator,
    val externalPriceSourceCalculator: Calculator)</span> {</span>
  TODO
}
</pre></td></tr></table></figure>

<h2 id="techniques-to-implement-di">Techniques to implement DI</h2>
<p>A measure of a good unit test is that it should be free of side effects,
the same as writing a pure function in functional programming.</p>
<p>If you follow TDD as a driver for your design, you don’t have to worry too much about
the coupling problem—your tests will force you to come up with a decoupled design.
You’ll notice that your functions, classes, and methods follow a DI pattern.</p>
<p>Techniques to implement dependency injection</p>
<ol>
<li>Cake pattern, Handles dependency using trait mixins and abstract members.</li>
<li>Structural typing, Uses structural typing to manage dependencies.
The Scala structural typing feature provides duck typinga in a type-safe manner.</li>
<li>Implicit parameters, Manages dependencies using implicit parameters so that
as a caller you don’t have to pass them.
In this case, dependencies could be easily controlled using scope.</li>
<li>Functional programming style, Uses function currying to control dependencies.</li>
<li>Using a DI framework</li>
</ol>
<h3 id="cake-pattern">Cake pattern</h3>
<p>A cake pattern 13 is a technique to build multiple layers of indirection in your applica-
tion to help with managing dependencies. </p>
<ul>
<li>Abstract members</li>
<li>Self type</li>
<li>Mixin Composition</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="comment">// The idea behind this Calculator trait is to have a component namespace that has all</span>
<span class="comment">// the calculators in your application.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">Calculators</span> {</span>
  <span class="keyword">val</span> costPlusCalculator: CostPlusCalculator
  <span class="keyword">val</span> externalPriceSourceCalculator: ExternalPriceSourceCalculator
  <span class="class"><span class="keyword">trait</span> <span class="title">Calculator</span> {</span>
    <span class="keyword">def</span> calculate(productId: String): Double
  }
  <span class="class"><span class="keyword">class</span> <span class="title">CostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> {</span>
    <span class="keyword">def</span> calculate(productId: String) = {
      ...
    }
  }
  <span class="class"><span class="keyword">class</span> <span class="title">ExternalPriceSourceCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> {</span>
    <span class="keyword">def</span> calculate(productId: String) = {
      ...
    }
  }
}

<span class="comment">// self type</span>
<span class="comment">// The benefit is that now you can reference both</span>
<span class="comment">// costPlusCalculator and externalPriceSourceCalculator freely.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">CalculatePriceServiceComponent</span> {</span><span class="keyword">this</span>: Calculators =&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span> {</span>
    <span class="keyword">val</span> calculators = Map(
      <span class="string">"costPlus"</span> -&gt; calculate(costPlusCalculator) _
      <span class="string">"externalPriceSource"</span> -&gt; calculate(externalPriceSourceCalculator) _)
    
    <span class="keyword">def</span> calculate(priceType: String, productId: String): Double = {
      calculators(priceType)(productId)
    }
    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">def</span> calculate(c: Calculator)(productId: String):Double =
      c.calculate(productId)
  }
}
<span class="comment">// Remember from the tests, you don’t want to use the calculators; instead you want to</span>
<span class="comment">// use a fake or TestDouble version of the calculators.</span>

<span class="comment">// For production mode you could create a pricing system by compos-</span>
<span class="comment">// ing all the real versions of these components, as in the following:</span>
<span class="class"><span class="keyword">object</span> <span class="title">PricingSystem</span> <span class="keyword">extends</span> <span class="title">CalculatePriceServiceComponent</span> <span class="keyword">with</span> <span class="title">Calculators</span> {</span>
  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> CostPlusCalculator
  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> ExternalPriceSourceCalculator
}

<span class="comment">// or testing the pricing could be created using the fake implementation</span>
<span class="class"><span class="keyword">trait</span> <span class="title">TestPricingSystem</span> <span class="keyword">extends</span> <span class="title">CalculatePriceServiceComponent</span> <span class="keyword">with</span> <span class="title">Calculators</span> {</span>
  <span class="class"><span class="keyword">class</span> <span class="title">StubCostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">CostPlusCalculator</span> {</span>
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">0.0</span>
  }
  
  <span class="class"><span class="keyword">class</span> <span class="title">StubExternalPriceSourceCalculator</span> <span class="keyword">extends</span> <span class="title">ExternalPriceSourceCalculator</span> {</span>
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">0.0</span>
  }
  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> StubCostPlusCalculator
  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> StubExternalPriceSourceCalculator
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">package</span> scala.book.cakepatterntest {
  <span class="keyword">import</span> junit.framework.Assert._
  <span class="keyword">import</span> org.junit.Test
  <span class="keyword">import</span> cakepattern._
  <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceTest</span> <span class="keyword">extends</span> <span class="title">TestPricingSystem</span> {</span>
    <span class="annotation">@Test</span>
    <span class="keyword">def</span> shouldUseCostPlusCalculatorWhenPriceTypeIsCostPlus() {
      <span class="keyword">val</span> calculatePriceService = <span class="keyword">new</span> CalculatePriceService
      <span class="keyword">val</span> price = calculatePriceService.calculate(<span class="string">"costPlus"</span>,<span class="string">"some product"</span>)
      assertEquals(<span class="number">5.0</span>D, price)
    }
  }
}
</pre></td></tr></table></figure>

<p>This is a common technique used by Scala developers to manage dependencies. In
smaller projects, it’s reasonable to have the wiring of dependencies implemented like
the PricingSystem and the TestPricingSystem, but for large projects it may become
difficult to manage them. For large projects it makes more sense to use a DI
framework that allows you to completely separate object creation
and injection from business logic.</p>
<h3 id="structural-typing">Structural typing</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">type</span> Calculators = {
  <span class="keyword">val</span> costPlusCalculator: Calculator
  <span class="keyword">val</span> externalPriceSourceCalculator: Calculator
}

<span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span><span class="params">(c: Calculators)</span> {</span>
  <span class="keyword">val</span> calculators = Map(
    <span class="string">"costPlus"</span> -&gt; calculate(c.costPlusCalculator) _ ,
    <span class="string">"externalPriceSource"</span> -&gt; calculate(c.externalPriceSourceCalculator) _)
  <span class="keyword">def</span> calculate(priceType: String, productId: String): Double = {
    calculators(priceType)(productId)
  }
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">def</span> calculate(c: Calculator)(productId: String):Double =
    c.calculate(productId)
}
</pre></td></tr></table></figure>

<p>The advantage of structural typing in Scala is that it’s immutable and type-safe.
The Scala compiler will ensure that the constructor
parameter of CalculatePriceService implements both the
abstract vals costPlusCalculator and externalPriceSourceCalculator .</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">ProductionConfig</span> {</span>
  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> CostPlusCalculator
  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> ExternalPriceSourceCalculator
  <span class="keyword">val</span> priceService = <span class="keyword">new</span> CalculatePriceService(<span class="keyword">this</span>)
}

<span class="class"><span class="keyword">object</span> <span class="title">TestConfig</span> {</span>
  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> CostPlusCalculator {
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">0.0</span>
  }
  
  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> ExternalPriceSourceCalculator {
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">0.0</span>
  }
  <span class="keyword">val</span> priceService = <span class="keyword">new</span> CalculatePriceService(<span class="keyword">this</span>)
}
</pre></td></tr></table></figure>

<p>You have the flexibility to pick the appropriate configuration.
Internally, structural typing is implemented using
reflection, so it’s slower compared to other approaches. Sometimes that’s acceptable,
but be aware of it when using structural typing.</p>
<h3 id="implicit-parameters">implicit parameters</h3>
<p>Implicit parameters provide a way to allow parameters to be found. Using this tech-
nique you can have the Scala compiler inject appropriate dependencies into your
code. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span><span class="params">(
  implicit val costPlusCalculator: CostPlusCalculator,
  implicit val externalPriceSourceCalculator: ExternalPriceSourceCalculator
)</span></span>

<span class="class"><span class="keyword">object</span> <span class="title">ProductionServices</span> {</span>
  implicit <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> CostPlusCalculator
  implicit <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> ExternalPriceSourceCalculator
}

<span class="class"><span class="keyword">object</span> <span class="title">ProductionConfig</span> {</span>
  <span class="keyword">import</span> ProductionServices._
  <span class="keyword">val</span> priceService = <span class="keyword">new</span> CalculatePriceService
}


<span class="class"><span class="keyword">object</span> <span class="title">TestServices</span> {</span>
  implicit <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> CostPlusCalculator {
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">0.0</span>
  }
  implicit <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> ExternalPriceSourceCalculator {
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">0.0</span>
  }
}
<span class="class"><span class="keyword">object</span> <span class="title">TestConfig</span> {</span>
  <span class="keyword">import</span> TestServices._
  <span class="keyword">val</span> priceService = <span class="keyword">new</span> CalculatePriceService
}
</pre></td></tr></table></figure>

<p>Using implicit to handle dependencies can easily get out of hand as your application grows
in size, unless they’re grouped together like the preceding configuration objects.</p>
<h3 id="dependency-injection-in-functional-style">Dependency injection in functional style</h3>
<p>If you consider a function as a component, then its dependencies are its parameters.
If you create function currying, you can also
hide the dependencies as you did with other patterns.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Calculators</span> {</span>
  <span class="comment">//  type Calculator is an alias of function that takes product ID and returns the price</span>
  <span class="keyword">type</span> Calculator = String =&gt; Double
  <span class="keyword">protected</span> <span class="keyword">val</span> findCalculator: String =&gt; Calculator
  <span class="keyword">protected</span> <span class="keyword">val</span> calculate: (Calculator, String) =&gt; Double =
    (calculator, productId) =&gt; calculator(productId)
}

<span class="comment">//  it created a function that takes Calculator and</span>
<span class="comment">// returns a function that calculates the price for a productid </span>
<span class="class"><span class="keyword">object</span> <span class="title">TestCalculators</span> <span class="keyword">extends</span> <span class="title">Calculators</span> {</span>
  <span class="keyword">val</span> costPlusCalculator: String =&gt; Double = productId =&gt; <span class="number">0.0</span>
  <span class="keyword">val</span> externalPriceSource: String =&gt; Double = productId =&gt; <span class="number">0.0</span>
  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">val</span> findCalculator = Map(
    <span class="string">"costPlus"</span> -&gt; costPlusCalculator,
    <span class="string">"externalPriceSource"</span> -&gt; externalPriceSource
  )
  <span class="keyword">def</span> priceCalculator(priceType: String): String =&gt; Double = {
    <span class="keyword">val</span> f: Calculator =&gt; String =&gt; Double = calculate.curried
    f(findCalculator(priceType))
  }
}

<span class="comment">// The benefit of doing this now is you have a function that knows</span>
<span class="comment">// how to calculate price but hides the Calculator from the users.</span>
</pre></td></tr></table></figure>

<p>The priceCalculator method returns a function that takes the productId and
returns the price of the product that encapsulates the dependencies used to compute
the price.</p>
<h3 id="using-a-dependency-injection-framework-spring">Using a dependency injection framework: Spring</h3>
<p>DI frameworks provide the following additional services
that aren’t available in these abstraction techniques above:</p>
<ul>
<li>They create a clean separation between object initialization and creation from
the business logic. This way, your wiring between components becomes
transparent from the code.</li>
<li>These frameworks help you to work with various other frameworks.
A DI framework will help to inject your Scala objects as dependencies.</li>
<li>Most of the DI frameworks, like Spring (www.springsource.org) and Guice
provide aspect-oriented programming ( AOP) support to handle cross-cutting
behaviors like transaction and logging out of the box.</li>
</ul>
<p>In the Spring world, all the dependencies are called beans, because all the objects
follow the JavaBean convention. According to this convention a class
should provide a default constructor, and class properties
should be accessible using get, set, and is methods.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">package</span> scala.book
<span class="keyword">import</span> scala.reflect._
<span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceService</span> {</span>
  <span class="annotation">@BeanProperty</span> <span class="keyword">var</span> costPlusCalculator: Calculator = _1
  <span class="annotation">@BeanProperty</span> <span class="keyword">var</span> externalPriceSourceCalculator: Calculator = _
}
<span class="annotation">@RunWith</span>(classOf[SpringJUnit4ClassRunner])
<span class="annotation">@ContextConfiguration</span>(locations =
    Array(<span class="string">"classpath:/application-context.xml"</span>))
<span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceTest</span> {</span>
  <span class="annotation">@Resource</span>
  <span class="keyword">var</span> calculatePriceService: CalculatePriceService = _
}
</pre></td></tr></table></figure>

<p>In large projects it’s recommended to have a test
version of a configuration file where you can configure
all your beans with fake implementations of their dependencies.</p>
<h1 id="behavior-driven-development-using-specs2">Behavior-driven development using Specs2</h1>
<p>Behavior-driven development (BDD ) is about implementing an application by describ-
ing the behavior from the point of view of stakeholders.</p>
<p>BDD is doing TDD the right way. The first
thing to notice is that the definition of BDD doesn’t talk about testing at all.
And BDD puts more emphasis on solving business problems.
In fact, it recommends looking at the application from the stakeholder’s perspective.</p>
<ul>
<li>Delivering value quickly—Because you’re focused on viewing the application
from the stakeholder’s point of view, you understand and deliver value quickly.</li>
<li>Focus on behavior—This is the most important improvement because at the end
of the day, behaviors that you implement are the ones your stakeholders want.</li>
</ul>
<p>Think of a specification as a list of examples.</p>
<h2 id="getting-started-with-specs2">Getting started with Specs2</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>scalaVersion <span class="symbol">:</span>= <span class="string">"2.10.0"</span>

libraryDependencies += <span class="string">"org.specs2"</span> <span class="string">%% "specs2" %</span> <span class="string">"1.13"</span> % <span class="string">"test"</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>
<span class="class"><span class="keyword">trait</span> <span class="title">TestPricingSystem</span> <span class="keyword">extends</span> <span class="title">CalculatePriceServiceComponent</span> <span class="keyword">with</span> <span class="title">Calculators</span> {</span>
  <span class="class"><span class="keyword">class</span> <span class="title">StubCostPlusCalculator</span> <span class="keyword">extends</span> <span class="title">CostPlusCalculator</span> {</span>
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">5.0</span>D
  }
  <span class="class"><span class="keyword">class</span> <span class="title">StubExternalPriceSourceCalculator</span> <span class="keyword">extends</span> <span class="title">ExternalPriceSourceCalculator</span> {</span>
    <span class="keyword">override</span> <span class="keyword">def</span> calculate(productId: String) = <span class="number">10.0</span>D
  }
  <span class="keyword">val</span> costPlusCalculator = <span class="keyword">new</span> StubCostPlusCalculator
  <span class="keyword">val</span> externalPriceSourceCalculator = <span class="keyword">new</span> StubExternalPriceSourceCalculator
}

<span class="keyword">package</span> scala.book

<span class="keyword">import</span> org.specs2.mutable._

<span class="class"><span class="keyword">class</span> <span class="title">CalculatePriceServiceSpecification</span> <span class="keyword">extends</span> <span class="title">Specification</span> {</span>
  <span class="string">"Calculate price service"</span> should {
    <span class="string">"calculate price for cost plus price type"</span> in {
      <span class="keyword">val</span> service = <span class="keyword">new</span> CalculatePriceService
      <span class="keyword">val</span> price: Double = service.calculate(<span class="string">"costPlus"</span>, <span class="string">"some product"</span>)
      price must beEqualTo(<span class="number">5.0</span>D)
    }
    <span class="string">"calculate price for external price source type"</span> in {
      <span class="keyword">val</span> service = <span class="keyword">new</span> CalculatePriceService
      <span class="keyword">val</span> price: Double = service.calculate(<span class="string">"externalPriceSource"</span>,<span class="string">"some product"</span>)
      price must be_==(<span class="number">10.0</span>D)
    }
  }

}
<span class="comment">// The must method is again added by Specs using implicit conversions to</span>
<span class="comment">// almost all the types to make the specification more readable.</span>

<span class="comment">// nest </span>
<span class="string">"calculate price for cost plus price type"</span> in {
  <span class="keyword">val</span> service = <span class="keyword">new</span> CalculatePriceService
  <span class="keyword">val</span> price: Double = service.calculate(<span class="string">"costPlus"</span>, <span class="string">"some product"</span>)
  price must beEqualTo(<span class="number">5.0</span>D)
  <span class="string">"for empty product id return 0.0"</span> in {
    <span class="keyword">val</span> service = <span class="keyword">new</span> CalculatePriceService
    service.calculate(<span class="string">"costPlus"</span>, <span class="string">""</span>) must beEqualTo(<span class="number">0.0</span>D)
  }
}
</pre></td></tr></table></figure>

<p>Another interesting way to declare specifications in Specs is to use data tables.
Data tables allow you to execute your example with a set of test data.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="string">"cost plus price is calculated using 'cost + 20% of cost + given service charge' rule"</span> <span class="function_or_atom">in</span> {
  <span class="string">"cost"</span> | <span class="string">"service charge"</span> | <span class="string">"price"</span> |&gt;
  <span class="number">100.0</span> <span class="exclamation_mark">!</span>  <span class="number">4</span>    <span class="exclamation_mark">!</span> <span class="number">124</span>  |
  <span class="number">200.0</span> <span class="exclamation_mark">!</span> <span class="number">4</span>     <span class="exclamation_mark">!</span> <span class="number">244</span>  |
  <span class="number">0.0</span>   <span class="exclamation_mark">!</span> <span class="number">2</span>     <span class="exclamation_mark">!</span> <span class="number">2</span>    | {
  (<span class="function_or_atom">cost</span>, <span class="function_or_atom">serviceCharge</span>, <span class="function_or_atom">expected</span>) =&gt;
    <span class="function_or_atom">applyCostPlusBusinessRule</span>(<span class="function_or_atom">cost</span>, <span class="function_or_atom">serviceCharge</span>) <span class="function_or_atom">must</span> <span class="function_or_atom">be_</span>==(<span class="function_or_atom">expected</span>)
}
</pre></td></tr></table></figure>

<h1 id="testing-asynchronous-messaging-systems">Testing asynchronous messaging systems</h1>
<p>Let’s see Awaitility work in a simple example.
Imagine that you have an order-placing service that saves orders to the
database asynchronously, and you place an order by sending a PlaceOrder message.
Here’s the dummy ordering service implemented as an actor:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">package</span> example.actors
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PlaceOrder</span><span class="params">(productId: String, quantity: Int, customerId: String)</span></span>
<span class="class"><span class="keyword">class</span> <span class="title">OrderingService</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> act = {
    react {
      <span class="keyword">case</span> PlaceOrder(productId, quantity, customer) =&gt;
    }
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">import</span> org.specs2.mutable._
<span class="keyword">import</span> example.actors._
<span class="keyword">import</span> com.jayway.awaitility.scala._
<span class="keyword">import</span> com.jayway.awaitility.Awaitility._
<span class="class"><span class="keyword">class</span> <span class="title">OrderServiceSpecification</span> <span class="keyword">extends</span> <span class="title">Specification</span> <span class="keyword">with</span> <span class="title">AwaitilitySupport</span> {</span>
  <span class="string">"Ordering system"</span> should {
    <span class="string">"place order asynchronously"</span> in {
      <span class="keyword">val</span> s = <span class="keyword">new</span> OrderingService().start
      s ! PlaceOrder(<span class="string">"product id"</span>, <span class="number">1</span>, <span class="string">"some customer id"</span>)
      <span class="comment">// waits until the order is saved into the database.</span>
      <span class="comment">// The default timeout for Awaitility is 10 seconds</span>
      await until {orderSavedInDatabase(<span class="string">"some customer id"</span>) }
      <span class="number">1</span> must_== <span class="number">1</span>
    }
    <span class="comment">// Inside the orderSavedInDatabase, you could go to the data source and</span>
    <span class="comment">// check whether the order is saved for a given customer ID</span>
    <span class="keyword">def</span> orderSavedInDatabase(customerId: String) = ...
  }

}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scala in Action-Concurrency programming]]></title>
    <link href="http://zhpooer.github.io/2014/07/23/scala-in-action-concurrency-programming/"/>
    <id>http://zhpooer.github.io/2014/07/23/scala-in-action-concurrency-programming/</id>
    <published>2014-07-23T12:17:00.000Z</published>
    <updated>2014-07-24T00:23:07.000Z</updated>
    <content type="html"><![CDATA[<p>Think of an actor as an object that processes a message (your request) and
encapsulates state (state is not shared with other actors).
The ability to perform an action in response to an incoming message
is what makes an object an actor. The actor model encourages no shared state architecture. </p>
<p>Think of Future as a proxy object that you can create for a result that will be avail-
able at some later time. You can use Promise to complete a Future by providing the
result. </p>
<h1 id="what-is-concurrent-programming-">What is concurrent programming?</h1>
<p>Concurrency is when more than one task can start and complete in overlapping time
periods.</p>
<p>In parallel programming, you can literally run multiple tasks
at the same time, and it’s possible with multicore processors.
A concurrent program sometimes becomes a parallel program when it’s running in a multicore environment.</p>
<p>But it’s hard to write a correct and bug-free concurrent program.</p>
<ul>
<li>Only a handful of programmers know how to write a correct,
concurrent application or program. The correctness of the program is important.</li>
<li>Debugging multithreaded programs is difficult. The same program that causes
deadlock in production might not have any locking issues when debugging
locally. Sometimes threading issues show up after years of running in production.</li>
<li>Threading encourages shared state concurrency, and it’s hard to make
programs run in parallel because of locks, semaphores, and dependencies between
threads.</li>
</ul>
<h1 id="new-trends-in-concurrency">New trends in concurrency</h1>
<ul>
<li>STM, Software transactional memory</li>
<li>Dataflow concurrency, The principle behind the dataflow concurrency is to share variables across multiple
tasks or threads.</li>
<li>Message passing concurrency, In this concurrency
model, components communicate by sending messages. Messages can be sent
both synchronously and asynchronously, but asynchronously sending messages to
other components is more common. </li>
</ul>
<h1 id="implementing-message-passing-concurrency-with-actors">Implementing message-passing concurrency with actors</h1>
<p>In this concurrency model, actors communicate with each other through sending and
receiving messages. An actor processes incoming messages and executes the actions
associated with it. Typically, these messages are immutable because you shouldn’t
share state between them for reasons discussed previously.</p>
<p>There are two main communication abstractions in actor: send and receive.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// sending msg to actor a
a ! msg

// receive operation
receive {
  case pattern1 =&gt;
  <span class="keyword">...</span>
  case pattern =&gt;
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.actor.Actor
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Name</span><span class="params">(name: String)</span></span>
<span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> Name(n) =&gt; println(<span class="string">"Hello "</span> + n)
  }
}
</pre></td></tr></table></figure>

<p>Before sending any messages to the GreetingsActor actor, the actor needs to be
instantiated by creating an ActorSystem. Think of an ActorSystem as the manager of
one or more actors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// libraryDependencies += <span class="string">"com.typesafe.akka"</span> %% <span class="string">"akka-actor"</span> % <span class="string">"2.1.0"</span>
import akka<span class="preprocessor">.actor</span><span class="preprocessor">.Props</span>
import akka<span class="preprocessor">.actor</span><span class="preprocessor">.ActorSystem</span>

val system = ActorSystem(<span class="string">"greetings"</span>)

val a = system<span class="preprocessor">.actorOf</span>(Props[GreetingsActor], name = <span class="string">"greetings-actor"</span>)
a ! Name(<span class="string">"Nilanjan"</span>)
// shuts down the infrastructure <span class="keyword">and</span> all its actors.
Thread<span class="preprocessor">.sleep</span>(<span class="number">50</span>)
system<span class="preprocessor">.shutdown</span>()
</pre></td></tr></table></figure>

<h2 id="actorsystem">ActorSystem</h2>
<p>An actor system is a hierarchical group of actors that share a common configuration.
It’s also the entry point for creating and looking up actors.</p>
<p>Similarly actors form a hierarchy where parent actors
spawn child actors to delegate work until
it is small enough to be handled by an individual actor.</p>
<p>An ActorSystem is a heavyweight structure that will allocate 1. . .N
threads, so create one per logical subsystem of your application. For example,
you can have one actor system to handle the backend database, another to
handle all the web service calls, and so forth. Actors are very cheap. A given
actor consumes only 300 bytes so you can easily create millions of them.</p>
<p>At the top of the hierarchy is the guardian actor, created automatically with each actor
system. All other actors created by the given actor system become the child of the
guardian actor. In the actor system, each actor has one supervisor (the parent actor)
that automatically takes care of the fault handling. So if an actor crashes, its parent
will automatically restart that actor (more about this later).</p>
<p>The simplest way to create an actor is to create an ActorSystem and use its actorOf
method:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">val</span> system = ActorSystem(name = <span class="string">"word-count"</span>)
<span class="keyword">val</span> m: ActorRef = system.actorOf(Props[SomeActor],
      name = <span class="string">"someActor"</span>)
</pre></td></tr></table></figure>

<p>Note here that when you create an actor in Akka, you never get the direct refer-
ence to the actor. Instead you get back a handle to the actor called ActorRef.
The foremost purpose of ActorRef is to send messages to the actor it rep-
resents.</p>
<p>An actor path uniquely identifies an actor in the actor system.
Because actors are created in a hierarchical structure, they form a similar
structure to a filesystem. 
As a path in a filesystem points to an individual resource,
an actor path identifies an actor reference in an actor system.</p>
<p>Uses the system / method to retrieve the actor
reference of the WordCountWorker actor:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>class WordCountWorker extends Actor { <span class="keyword">...</span> }
<span class="keyword">...</span>
val system = ActorSystem(name = <span class="string">"word-count"</span>)
system.actorOf(Props[WordCountWorker], name = <span class="string">"wordCountWorker"</span>)
<span class="keyword">...</span>
val path: ActorPath = system / <span class="string">"WordCountWorker"</span>
val actorRef: ActorRef = system.actorFor(path)
actorRef ! “some message”
</pre></td></tr></table></figure>

<p>If the actorFor fails to find an actor
pointed to by the path, it returns a reference to the dead-letter mailbox of the actor
system. It’s a synthetic actor where all the undelivered messages are delivered.</p>
<p>The parent actor first stops all the child actors and sends all unprocessed messages to the dead-letter mailbox before ter-
minating itself. </p>
<h3 id="how-do-scala-actors-work-">How do Scala actors work?</h3>
<p>Every actor system comes with a default MessageDispatcher component.
Its responsibility is to send a message to the actor’s mailbox
and execute the actor by invoking the receive block.</p>
<p>Every MessageDispatcher is backed by a thread pool, which is easily
configured using the configuration file.</p>
<p>To send a message to an actor mail-box the ActorRef</p>
<ul>
<li>first sends the message to the MessageDispatcher associated with the actor.</li>
<li>The MessageDispatcher immediately queues the message in the mailbox of the
actor.</li>
<li>The control is immediately returned to the sender of the message. </li>
</ul>
<p>Handling a message is a bit more involved</p>
<ol>
<li>When an actor receives a message in its mailbox, MessageDispatcher schedules
the actor for execution. Sending and handling messages happens in two differ-
ent threads. If a free thread is available in the thread pool that thread is
selected for execution of the actor. If all the threads are busy, the actor will be
executed when threads becomes available.</li>
<li>The available thread reads the messages from the mailbox.</li>
<li>The receive method of the actor is invoked by passing one message at a time.</li>
</ol>
<h1 id="divide-and-conquer-using-actors">Divide and conquer using actors</h1>
<p>In the following example, the challenge is to count the number of words in each file
in a given directory and sort them in ascending order. One way of doing it would be to
loop through all the files in a given directory in a single thread, count the words in
each file, and sort them all together. But that’s sequential. To make it concurrent, we
will implement the divide-and-conquer (also called a fork-join) pattern with actors.</p>
<p>Actor API</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>// <span class="keyword">If</span> a given message doesn’t match any pattern inside the receive method <span class="keyword">then</span> the
// unhandled method <span class="keyword">is</span> called <span class="keyword">with</span> the akka.actor.UnhandledMessage message. 
def unhandled(message: Any): Unit

// This field holds the actor reference <span class="keyword">of</span> this actor. 
val self: ActorRef

// This <span class="keyword">is</span> the ActorRef <span class="keyword">of</span> the actor that sent the last received message. 
final def sender: ActorRef

// This provides the contextual information <span class="keyword">for</span> the actor, the current message, <span class="keyword">and</span> the
// factory methods <span class="keyword">to</span> create child actors. 
val <span class="keyword">context</span>: ActorContext

// This supervisor strategy defines what will happen <span class="keyword">when</span> a failure <span class="keyword">is</span> detected <span class="keyword">in</span> an
// actor. You can override <span class="keyword">to</span> define your own supervisor strategy.
def supervisorStrategy: SupervisorStrategy

def preStart()

// his method <span class="keyword">is</span> called <span class="keyword">on</span> the current instance <span class="keyword">of</span> the actor. This <span class="keyword">is</span> a great place <span class="keyword">to</span>
// clean up. The <span class="keyword">default</span> implementation <span class="keyword">is</span> <span class="keyword">to</span> stop <span class="keyword">all</span> the child actors <span class="keyword">and</span> <span class="keyword">then</span> invoke
// the postStop method.
def preRestart()

// This method <span class="keyword">is</span> called <span class="keyword">after</span> the current actor instance <span class="keyword">is</span> stopped.
def postStop()

// <span class="keyword">Then</span> the postRestart <span class="keyword">is</span> invoked <span class="keyword">on</span> the fresh instance.
// The <span class="keyword">default</span> implementation <span class="keyword">is</span> <span class="keyword">to</span> invoke the preStart method
def postRestart()
</pre></td></tr></table></figure>

<p>you’ll create two actor classes: one that
will scan the directory for all the files and accumulate results, called WordCountMaster,
and another one called WordCountWorker to count words in each file. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="comment">// The docRoot will specify the location of the files and</span>
<span class="comment">// numActors will create the number of worker actors. </span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StartCounting</span><span class="params">(docRoot: String, numActors: Int)</span></span>

<span class="comment">// Message Class</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">FileToCount</span><span class="params">(fileName:String)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">WordCount</span><span class="params">(fileName:String, count: Int)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> countWords(fileName:String) = {
    <span class="keyword">val</span> dataFile = <span class="keyword">new</span> File(fileName)
    Source.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(_.split(<span class="string">" "</span>).size + _)
  }
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> FileToCount(fileName:String) =&gt;
      <span class="keyword">val</span> count = countWords(fileName)
      sender ! WordCount(fileName, count)
  }
  <span class="keyword">override</span> <span class="keyword">def</span> postStop(): Unit = {
    println(s<span class="string">"Worker actor is stopped: ${self}"</span>)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">WordCountMaster</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">var</span> fileNames: Seq[String] = Nil
  <span class="keyword">var</span> sortedCount : Seq[(String, Int)] = Nil
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> StartCounting(docRoot, numActors) =&gt;
      <span class="keyword">val</span> workers = createWorkers(numActors)
      fileNames = scanFiles(docRoot)
      beginSorting(fileNames, workers)
      
    <span class="keyword">case</span> WordCount(fileName, count) =&gt;
      sortedCount = sortedCount :+ (fileName, count)
      sortedCount = sortedCount.sortWith(_._2 &lt; _._2)
      <span class="keyword">if</span>(sortedCount.size == fileNames.size) {
        println(<span class="string">"final result "</span> + sortedCount)
        finishSorting()
      }
  }
  <span class="keyword">private</span> <span class="keyword">def</span> createWorkers(numActors: Int) = {
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numActors) <span class="keyword">yield</span>
    context.actorOf(Props[WordCountWorker], name = s<span class="string">"worker-${i}"</span>)
  }
  <span class="keyword">private</span> <span class="keyword">def</span> scanFiles(docRoot: String) =
    <span class="keyword">new</span> File(docRoot).list.map(docRoot + _)
    
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">def</span> beginSorting(fileNames: Seq[String], workers: Seq[ActorRef]) {
    fileNames.zipWithIndex.foreach( e =&gt; {
      workers(e._2 % workers.size) ! FileToCount(e._1)
    })
  }
  
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">def</span> finishSorting() {
    context.system.shutdown()
  }
}

<span class="keyword">def</span> main(args: Array[String]) {
  <span class="keyword">val</span> system = ActorSystem(<span class="string">"word-count-system"</span>)
  <span class="keyword">val</span> m = system.actorOf(Props[WordCountMaster], name=<span class="string">"master"</span>)
  m ! StartCounting(<span class="string">"src/main/resources/"</span>, <span class="number">2</span>)
}
</pre></td></tr></table></figure>

<h2 id="actordsl">ActorDSL</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.actor.ActorDSL._

<span class="keyword">val</span> testActor = actor(<span class="keyword">new</span> Act {
  become {
    <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; sender ! <span class="string">"pong"</span>
  }
})

<span class="comment">// Behind the scene Act extends the Actor trait and become adds the behavior of the receive block.</span>
<span class="comment">// Using this DSL syntax you no longer have to create a class.</span>

<span class="class"><span class="keyword">object</span> <span class="title">ActorDSLExample</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">import</span> akka.actor.ActorDSL._
  <span class="keyword">import</span> akka.actor.ActorSystem
  implicit <span class="keyword">val</span> system = ActorSystem(<span class="string">"actor-dsl"</span>)
  <span class="keyword">val</span> testActor = actor(<span class="keyword">new</span> Act {
    become {
      <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; sender ! <span class="string">"pong"</span>
    }
  })
  actor(<span class="keyword">new</span> Act {
    whenStarting { testActor ! <span class="string">"ping"</span>}
    become {
      <span class="keyword">case</span> x =&gt;
        println(x)
        context.system.shutdown()
    }
  })
}
</pre></td></tr></table></figure>

<h1 id="fault-tolerance-made-easy-with-a-supervisor">Fault tolerance made easy with a supervisor</h1>
<p>Think of this supervisor as an actor that links to supervised actors and restarts
them when one dies.</p>
<p>That way, if a node (machine) is down,
you can restart an actor in a different box. Always
remember to delegate the work so that if a crash occurs,
another supervisor can recover.</p>
<p>Akka comes with two restarting strategies: One-for-One and All-for-One.</p>
<p>In the One-for-One strategy, if one actor dies, it’s recreated.</p>
<p>If you have multiple actors that participate in one workflow, restarting a single actor
might not work. In that case, use the All-for-One restart strategy,
in which all actors supervised by a supervisor are restarted
when one of the actors dies.</p>
<p>When no supervisor strategy is defined, it uses the default strategy (OneForOne ),
which restarts the failing child actor in case of Exception.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.actor.SupervisorStrategy._
<span class="class"><span class="keyword">class</span> <span class="title">WordCountWorker</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="comment">//if no pattern matches, the fault is escalated to the parent. </span>
  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = OneForOneStrategy(maxNrOfRetries = <span class="number">3</span>,
        withinTimeRange = <span class="number">5</span> seconds) {
    <span class="keyword">case</span> _: Exception =&gt; Restart
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">WordCountMaster</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = AllForOneStrategy() {
    <span class="keyword">case</span> _: Exception =&gt;
      println(<span class="string">"Restarting..."</span>)
      Restart
  }
}
</pre></td></tr></table></figure>

<h1 id="future-and-promise">Future and Promise</h1>
<p>A Future is an object that can hold a value that may become available, as its name sug-
gests, at a later time.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> ExecutionContext.Implicits.<span class="keyword">global</span>

<span class="function"><span class="keyword">def</span> <span class="title">someFuture</span>[<span class="title">T</span>]:</span> Future[T] = Future {
  someComputation()
}
</pre></td></tr></table></figure>

<p>Since the Future is executed asynchronously we need to specify the
scala.concurrent.ExecutionContext. ExecutionContext is an abstraction over a
thread pool that is responsible for executing all the tasks submitted to it.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>someFuture.onComplete {
  <span class="reserved">case</span> Success<span class="function"><span class="params">(result)</span> =&gt;</span> println(result)
  <span class="reserved">case</span> Failure<span class="function"><span class="params">(t)</span> =&gt;</span> t.printStackTrace
}

val <span class="attribute">promise</span>: Promise[String] = Promise[String]()
val future = promise.future
...
val anotherFuture = Future {
  promise.success(<span class="string">"Done"</span>)
  doSomethingElse()
}

future.onSuccess { <span class="reserved">case</span> msg<span class="function"> =&gt;</span> startTheNextStep() }
</pre></td></tr></table></figure>

<p>A common use case of Future is to perform some computation concurrently without
needing the extra utility of an actor. The most compelling feature of the Scala Future
library is it allows us to compose concurrent operations, which is hard to achieve with
actors.</p>
<p>word count use future</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre>import scala.concurrent.<span class="number">_</span>
import ExecutionContext.Implicits.global
import scala.util.{Success, Failure}
import java.io.File
import scala.io.Source

object main {
  def main(args: Array[String]) {
    val promiseOfFinalResult = Promise[Se<span class="string">q[(String, Int)]</span>]()
    val path = <span class="string">"src/main/resources/"</span>
    val futureWithResult: Future[Se<span class="string">q[(String, Int)]</span>] = <span class="keyword">for</span> {
      files &lt;- scanFiles(path)
      result &lt;- processFiles(files)
    } yield {
      result
    }
    
    futureWithResult.onSuccess {
      case <span class="string">r =&gt;</span> promiseOfFinalResult.success(r)
    }
    promiseOfFinalResult.future.onComplete {
      case Success(result) =&gt; println(result)
      case Failure(t) =&gt; t.printStackTrace
    }
  }
  
  private def processFiles(fileNames: Se<span class="string">q[String]</span>): Future[Se<span class="string">q[(String,Int)]</span>] = {
    val futures: Se<span class="string">q[Future[(String, Int)]</span>] = fileNames.<span class="keyword">map</span>(<span class="string">name =&gt;</span>
        processFile(name))
    val singleFuture: Future[Se<span class="string">q[(String, Int)]</span>] =
    Future.sequence(futures)
    singleFuture.<span class="keyword">map</span>(<span class="string">r =&gt;</span> r.sortWith(<span class="number">_</span>._2 &lt; <span class="number">_</span>._2))
  }
  private def processFile(fileName: String): Future[(String, Int)] =
  Future {
    val dataFile = new File(fileName)
    val wordCount = Source.fromFile(dataFile).getLines.foldRight(<span class="number">0</span>)(<span class="number">_</span>.<span class="keyword">split</span>(<span class="string">"
    "</span>).size + <span class="number">_</span>)
    (fileName, wordCount)
  } recover {
    case e: java.io.<span class="string">IOException =&gt;</span>
    println(<span class="string">"Something went wrong "</span> + e)
    (fileName, <span class="number">0</span>)
  }
  
  private def scanFiles(docRoot: String):Future[Se<span class="string">q[String]</span>] = Future { new
    File(docRoot).list.<span class="keyword">map</span>(docRoot + <span class="number">_</span>) }
}
</pre></td></tr></table></figure>

<h2 id="mixing-future-with-actors">Mixing Future with actors</h2>
<ul>
<li>Send a message to an actor and receive a response from it. So far we have only
used fire-and-forget using the ! method. But getting a response is also a very
common use case (a.k.a ask pattern).</li>
<li>Reply to sender when some concurrent task ( Future) completes (a.k.a pipe
pattern).</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.pattern.{ask, pipe}
implicit <span class="keyword">val</span> timeout = Timeout(<span class="number">5</span> seconds)
<span class="class"><span class="keyword">class</span> <span class="title">GreetingsActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> messageActor = context.actorOf(Props[GreetingsChildActor])
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> name =&gt;
      <span class="keyword">val</span> f: Future[String] = (messageActor ask name).mapTo[String]
      f pipeTo sender
  }
}
<span class="class"><span class="keyword">class</span> <span class="title">GreetingsChildActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = { ...
  }
}
</pre></td></tr></table></figure>

<p>In this case we are using the ask method (you can use ? as well) of
the ActorRef to send and receive a response. Since messages are processed
asynchronously the ask method returns a Future.
The mapTo message allows us to transform
the message from Future[Any] to Future[String]. </p>
<p>The challenge is we don’t know
when the message will be ready so that we can send the reply to the sender. The
pipeTo pattern solves that problem by hooking up with the Future so that when the
future completes it can take the response inside the future and send it to the sender.</p>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
</feed>
