<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Poe's World]]></title>
  <subtitle><![CDATA[竹杖芒鞋轻胜马，一蓑烟雨任平生]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhpooer.github.io/"/>
  <updated>2014-08-14T00:36:27.110Z</updated>
  <id>http://zhpooer.github.io/</id>
  
  <author>
    <name><![CDATA[zhpooer]]></name>
    <email><![CDATA[zhpooer@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[传智播客day67-MapReduce]]></title>
    <link href="http://zhpooer.github.io/2014/08/13/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day67-MapReduce/"/>
    <id>http://zhpooer.github.io/2014/08/13/传智播客day67-MapReduce/</id>
    <published>2014-08-13T01:04:09.000Z</published>
    <updated>2014-08-13T09:02:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mapreduce">MapReduce</h1>
<p>MapReduce 计算海量数据, 将一个任务切分成多个小任务, 分给多个进程计算</p>
<ul>
<li>MapReduce 是一种分布式计算模型, 用户搜索领域, 解决海量数据计算的问题</li>
<li>MR由两个项目阶段组成: Map和Reduce, 用户只需要实现 <code>map()</code>和<code>reduce</code>两个函数,
即可以实现分布式计算</li>
<li>两个函数的形参是key、value对, 表示函数的输入信息</li>
</ul>
<h2 id="demo">Demo</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor"># 启动 NameNode DataNode</span>
start-dfs.sh
<span class="preprocessor"># 启动 ResourceManager</span>
start-yarn.sh

<span class="preprocessor"># 启动 DataNode 上启动 RunJar 和 NodeManager(DataNode 上)</span>
<span class="preprocessor"># 过程中启动 MRAppMaster, 监控任务(每个任务都会对应有一个), 监控 YarnChild</span>
<span class="preprocessor"># YarnChild(DataNode上), 运行计算任务</span>
hadoop jar hadoop-mapreduce-example.jar wordcount hdfs:<span class="comment">//itcast:9000/words  hdfs://itcast:9000/words-out</span>
</pre></td></tr></table></figure>

<p>运行流程</p>
<ol>
<li>RunJar 把jar包上传到 HDFS, 默认写10份.</li>
<li>客户端提供任务描述信息</li>
<li>ResourceManager 任务初始化, 将任务放到任务调度器</li>
<li>NodeManager 主动申请任务, 采用心跳机制(RPC)</li>
<li>NodeManager 启动 YarnChild进程, 进行计算, YarnChild 有Map, Reduce 对象</li>
</ol>
<h2 id="-mapreduce">编写 MapReduce</h2>
<p>TODO 插入 MapReduce 图片</p>
<p><code>[K1, V1]</code> Map <code>[k2, V2]</code> Shuffle <code>[K2, {V2...}]</code> Reduce <code>[K3, V3]</code></p>
<p>Map执行处理
1.读取输入文件的内容, 解析出 key value 对, 对输入的问价的每一行, 解析成key value对
每一个键值对调用一次 <code>map()</code></p>
<p>reduce任务处理 TODO</p>
<pre><code>输入数据
  hello world
  hello hadoop
Map阶段(key: 字符偏移量)
  &lt;0, &quot;hello world&quot;&gt;
  &lt;11, &quot;hello hadoop&quot;&gt;
  代码
    map(){
      String line = v1;
      String[] words = ling.split(&quot; &quot;);
      for(String w: words) {
        context.write(w, 1);
      }
    }
Reduce 阶段(数据已经按key字符排序)
  &lt;&quot;hello&quot;, 1, 1&gt;
  &lt;&quot;hadoop&quot;, 1&gt;
  &lt;&quot;world&quot;, 1&gt;
  代码:
    reduce(){
      String word = K2
      List list = V2
      for(int i : list) {
        counter += 1
      }
      context.write(word, counter)
    }
输出数据
  hello 2
  world 1
  hadoop 1
</code></pre><h2 id="-">编写代码</h2>
<p>导入jar包 <code>hadoop-common.jar</code>, <code>hadoop-mapreduce.jar</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre>public <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> {</span>
    public <span class="class"><span class="keyword">class</span> <span class="title">void</span> <span class="title">main</span><span class="params">()</span> {</span>
        <span class="comment">// 可以通过 conf 设置, 副本拷贝数 默认是 10</span>
        Configuration conf = <span class="keyword">new</span> Configuration();
        
        Job job = Job.getInstance(conf);
        
        <span class="comment">// 重要, 将 main 方法所在的类注册</span>
        job.setJarByClass(WordCount.<span class="keyword">class</span>);
        <span class="comment">// Mapper 类</span>
        job.setMapperClass(WCMapper.<span class="keyword">class</span>);
        <span class="comment">// 设置 K2 V2</span>
        job.setMapOutputKeyClass(Text.<span class="keyword">class</span>);
        job.setMapOutputValueClass(LongWritable.<span class="keyword">class</span>);
        <span class="comment">// 设置读取文件</span>
        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(<span class="string">"/word.txt"</span>));
        
        job.setReducerClass(WCReducer.<span class="keyword">class</span>);
        <span class="comment">// 最终将数据到hdfs 的key的类型</span>
        job.setOutputKeyClass(Text.<span class="keyword">class</span>);
        job.setOutputValueClass(LongWritable.<span class="keyword">class</span>);
        <span class="comment">// 设置输出文件, 如果文件已经存在, 抛错</span>
        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(<span class="string">"/wcount1"</span>));
        
        <span class="comment">// 不太好的方法job.submit();</span>
        <span class="comment">// true 打印执行详情</span>
        job.waitForComletion(<span class="keyword">true</span>);
    }
}

<span class="comment">// Hadoop 提供了自己序列化机制</span>
public <span class="class"><span class="keyword">class</span> <span class="title">WCMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt;{</span>
    <span class="keyword">protected</span> void map(LongWritable key, Text value, Context context) {
        String line = value.toString();
        String[] words = line.split(<span class="string">" "</span>);
        <span class="keyword">for</span>(String w : words) {
            context.write(<span class="keyword">new</span> Text(w), <span class="keyword">new</span> LongWritable(<span class="number">1</span>))
        }
    }
}

public <span class="class"><span class="keyword">class</span> <span class="title">WCReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context) {
        <span class="comment">// super.reduce</span>
        long count = <span class="number">0</span>;
        <span class="keyword">for</span>(LongWritable l : values) {
            counter += l.get();
        }
        context.write(key, <span class="keyword">new</span> LongWritable(counter));
    }
}
</pre></td></tr></table></figure>

<p>打成Jar包, 运行 <code>hadoop jar /root/mrs.jar</code></p>
<h1 id="debug-mapreduce-">Debug MapReduce 程序</h1>
<h2 id="-">本地调试</h2>
<p>在eclipse中调试, 并没有提交到集群</p>
<p>修改 <code>Path</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// 读取本地</span>
<span class="keyword">new</span> Path(<span class="string">"/root/words"</span>)
<span class="comment">// 或 读取 hdfs 上的</span>
<span class="keyword">new</span> Path(<span class="string">"hdfs://itcast:9000/words"</span>)
</pre></td></tr></table></figure>

<h2 id="mr-">MR流程</h2>
<ul>
<li>代码编写</li>
<li>作业配置<ul>
<li>在 <code>etc/mapred-site.xml</code> 配置全局变量</li>
<li>在 <code>Configuration</code> 中设置局部变量</li>
</ul>
</li>
<li>提交作业, <code>hadoop jar **.jar</code></li>
<li>初始化作业</li>
<li>分配任务</li>
<li>执行任务</li>
<li>更新状态和任务</li>
<li>完成作业</li>
</ul>
<p>TODO 运行状态图</p>
<h1 id="-">序列化</h1>
<p>序列化是把结构化对象转换为字节流</p>
<p>反序列化(Deserialization)将字节流转换为结构化的对象</p>
<p>因为 JDK 序列化机制效率太低, JDK序列化要记录额外的数据, 如继承结构, 而 Hadoop 需要只需要传递数据,
以至于 Hadoop 要重新实现序列化</p>
<p>Hadoop 序列化特点</p>
<ul>
<li>紧凑, 高效的使用存储空间</li>
<li>快速, 读写数据的额外开销小</li>
<li>可扩展, 透明读取老的数据格式</li>
<li>互操作, 支持多语言交互</li>
</ul>
<p>Hadoop 序列化要实现接口 <code>Writable</code></p>
<h1 id="demo-">Demo 统计用户上网流量</h1>
<p>测试数据</p>
<pre><code>电话号码     上行流量 下行流量
13888888888  2000      1000
13988888888  1000      6000
13988888888  2000      5000
13988888888  3000      4000
</code></pre><p>运行结果</p>
<pre><code>号码   上行流量    下行流量    总流量
138    2000        1000        3000
139    6000        15000       21000
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> DataCount {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        Configuration conf = <span class="keyword">new</span> Configuration();
        Job job = Job.getInstance(conf);
        job.setJarByClass(DataCount.class);

        job.setMapperClass(DCMapper.class);
        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(DataBean.class);
        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));

        job.setReducerClass(DCReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(DataBean.class);
        FileInputFormat.setOutputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));

        job.waitForCompletion(<span class="keyword">true</span>);
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> DataBean implements Writable {
    <span class="keyword">private</span> String account;
    <span class="keyword">private</span> String upPayLoad;
    <span class="keyword">private</span> String downPayLoad;
    <span class="keyword">private</span> String totalPayLoad;

    <span class="keyword">public</span> <span class="title">DataBean</span>(){}
    
    <span class="comment">// 构造函数</span>
    <span class="keyword">public</span> <span class="title">DataBean</span>(String account, <span class="keyword">long</span> upPayLoad, <span class="keyword">long</span> downPayLoad){
        super();
        <span class="keyword">this</span>.account = account;
        <span class="keyword">this</span>.upPayLoad = upPayLoad;
        <span class="keyword">this</span>.downPayLoad = downPayLoad;
        <span class="keyword">this</span>.totalPayLoad = upPayLoad + downPayLoad;
    }
    
    <span class="comment">// 在序列化时要注意 1. 类型, 2. 顺序</span>
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(DataOutput <span class="keyword">out</span>) {
        <span class="keyword">out</span>.writeUTF(account);
        <span class="keyword">out</span>.writeLong(upPayLoad);
        <span class="keyword">out</span>.writeLong(downPayLoad);
        <span class="keyword">out</span>.writeLong(totalPayLoad);
    }
    
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span>(DataInput <span class="keyword">in</span>) {
        account = <span class="keyword">in</span>.readUTF();
        upPayLoad = <span class="keyword">in</span>.readLong();
        downPayLoad = <span class="keyword">in</span>.readLong();
        totalPayLoad  = <span class="keyword">in</span>.readLong();
    }
    
    @Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span>(){
        <span class="comment">// TODO</span>
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> DCMapper extends Mapper&lt;LongWritable, Text, Text, DataBean&gt; {
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable key, Text <span class="keyword">value</span>, Context context) {
        String ling = <span class="keyword">value</span>.toString();
        String[] fields = line.split(<span class="string">"\t"</span>);
        String account = fields[<span class="number">1</span>];
        <span class="keyword">long</span> up = Long.parseLong(fields[<span class="number">8</span>]);
        <span class="keyword">long</span> down = Long.parseLong(fields[<span class="number">9</span>]);
        context.write(<span class="keyword">new</span> Text(account), <span class="keyword">new</span> DataBean(<span class="string">""</span>, up, down));
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> DCReduce extends Reducer&lt;Text, DataBean, Text, DataBean&gt; {
    @Override <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(Text key, Iterable&lt;DataBean&gt; values, Context context) {
        <span class="keyword">long</span> up_sum = <span class="number">0</span>;
        <span class="keyword">long</span> down_sum = <span class="number">0</span>;
        <span class="keyword">for</span>(DataBean bean : values) {
            up_sum +=  bean.getUpPayLoad();
            down_sum +=  bean.getDownPayLoad();
        }
        context.write(key, <span class="keyword">new</span> DataBean(key, upPayLoad, downPayLoad));
    }
}
</pre></td></tr></table></figure>

<p>如果想要在集群上运行, 安装 hadoop 插件</p>
<h1 id="-">源码分析</h1>
<ol>
<li>获取服务端代理对象</li>
<li>通过ResourceManager 获取 jar包路径, 和jobId</li>
<li>提交jar包</li>
<li>提交信息, jar包路径, jobId</li>
</ol>
]]></content>
    
    
      <category term="hadoop" scheme="http://zhpooer.github.io/tags/hadoop/"/>
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MIT Algorithm-算法分析]]></title>
    <link href="http://zhpooer.github.io/2014/08/12/mit-algorithm-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://zhpooer.github.io/2014/08/12/mit-algorithm-算法分析/</id>
    <published>2014-08-12T13:40:09.000Z</published>
    <updated>2014-08-13T01:04:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">算法分析</h1>
<p>关于计算机性能的研究 和 资源的利用</p>
<p>What&#39; more important than performance?</p>
<ul>
<li>User-friendly</li>
<li>Security</li>
<li>健壮性</li>
<li>简洁性</li>
</ul>
<p>为什么研究算法和性能?</p>
<ul>
<li>有时候用户友好和性能是正相关的</li>
<li>性能关系到 行和不行, 如实时计算, 空间的利用, 时间的花费</li>
<li>描述算法的领域语言</li>
</ul>
<p>像经济系统中的钞票, 为其他功能支付性能</p>
<p>java 比 C 花费了3倍性能</p>
<h1 id="problem-sorting">Problem: Sorting</h1>
<p>Input: Sequence<a1, a2,...,an></p>
<p>Output: 已经排序好的</p>
<h2 id="-">插入排序</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">Insert</span>.<span class="keyword">Sort</span>(An)
  for
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="algorithm" scheme="http://zhpooer.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Input with forms]]></title>
    <link href="http://zhpooer.github.io/2014/08/12/play-for-scala-input-with-forms/"/>
    <id>http://zhpooer.github.io/2014/08/12/play-for-scala-input-with-forms/</id>
    <published>2014-08-12T08:22:42.000Z</published>
    <updated>2014-08-12T13:05:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="forms-the-concept">Forms—the concept</h1>
<p>Play provides the so-called forms API. The term form isn’t just about HTML forms in
a Play application; it’s a more general concept. The forms API helps you to validate data,
manage validation errors, and map this data to richer data structures.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="reserved">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(</span>
  username : String,
  realname : Option[String],
  email    : String )

val userForm = Form(
  mapping(
    <span class="string">"username"</span><span class="function"> -&gt;</span> nonEmptyText(<span class="number">8</span>),
    <span class="string">"realname"</span><span class="function"> -&gt;</span> optional(text),
    <span class="string">"email"</span><span class="function"> -&gt;</span> email)(User.apply)(User.unapply))

def createUser() = Action { implicit request<span class="function"> =&gt;</span>
  userForm.bindFromRequest.fold(
    formWithErrors<span class="function"> =&gt;</span> BadRequest,
    user<span class="function"> =&gt;</span> Ok(<span class="string">"User OK!"</span>))
}
</pre></td></tr></table></figure>

<h1 id="forms-basics">Forms basics</h1>
<p>Play’s forms are powerful, but they’re built on a few simple ideas.</p>
<h2 id="mappings">Mappings</h2>
<p>A Mapping is an object that can construct something from the data in an HTTP
request. This process is called binding.</p>
<p>So a Mapping[User] can construct a User instance, and
a Mapping[Int] can create an Int.</p>
<p> If you submit an HTML form with an input tag
<code>&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;</code>, a <code>Mapping[Int]</code> can convert that age value,
which is submitted as a string, into a Scala Int.</p>
<p>The data from the HTTP request is transformed into a <code>Map[String, String]</code>, and
this is what the Mapping operates on.</p>
<p>But a Mapping can not only construct an object from a map of data;
it can also do the reverse operation of deconstructing an object
into a map of data.</p>
<p> A mapping is an object of type <code>Mapping[T]</code> that can take a
<code>Map[String, String]</code>, and use it to construct an object of type T ,</p>
<p>For example, <code>Forms.number</code> is a mapping of type <code>Mapping[Int]</code>,
whereas <code>Forms.text</code> is a mapping of type
<code>Mapping[String]</code>. There’s also <code>Forms.email</code>,
which is also of type <code>Mapping[String]</code>,
but it also contains a constraint that the
string must look like an email address.</p>
<h2 id="creating-a-form">Creating a form</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>val data = <span class="keyword">Map</span>(
  <span class="string">"name"</span> -&gt; <span class="string">"Box of paper clips"</span>,
  <span class="string">"ean"</span> -&gt; <span class="string">"1234567890123"</span>,
  <span class="string">"pieces"</span> -&gt; <span class="string">"300"</span>
)

// The <span class="keyword">type</span> <span class="keyword">of</span> mapping <span class="keyword">is</span>
// play.api.data.Mapping[(<span class="typename">String</span>, <span class="typename">String</span>, Int)]
// indicates the <span class="keyword">type</span> <span class="keyword">of</span> objects that this mapping can construct.
val mapping = Forms.tuple(
  <span class="string">"name"</span> -&gt; Forms.text,
  <span class="string">"ean"</span> -&gt; Forms.text,
  <span class="string">"pieces"</span> -&gt; Forms.number)

// This form <span class="keyword">is</span> <span class="keyword">of</span> <span class="keyword">type</span> Form[(<span class="typename">String</span>, <span class="typename">String</span>, Int)].
// Form has a single <span class="keyword">type</span> parameter, <span class="keyword">and</span> it has the same meaning.
// But a form <span class="keyword">not</span> only wraps a Mapping, it can also contain data.
val productForm = Form(mapping)
</pre></td></tr></table></figure>

<p>You can use the following Play-provided
basic mappings to start composing more complex mappings:</p>
<ul>
<li><code>boolean: Mapping[Boolean]</code></li>
<li><code>checked(msg: String): Mapping[Boolean]</code></li>
<li><code>date: Mapping[Date]</code></li>
<li><code>email: Mapping[String]</code></li>
<li><code>ignored[A](value: A): Mapping[A]</code></li>
<li><code>longNumber: Mapping[Long]</code></li>
<li><code>nonEmptyText: Mapping[String]</code></li>
<li><code>number: Mapping[Int]</code></li>
<li><code>sqlDate: Mapping[java.sql.Date]</code></li>
</ul>
<h2 id="processing-data-with-a-form">Processing data with a form</h2>
<p>The process of putting your data in the form is called binding,
and we use the bind method to do it:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>//  <span class="keyword">it</span> returns <span class="operator">a</span> <span class="built_in">new</span> Form—<span class="operator">a</span> copy <span class="operator">of</span> <span class="operator">the</span> original form populated <span class="operator">with</span> <span class="operator">the</span> data.
val processedForm = productForm.bind(data)

<span class="keyword">if</span>(!processedForm.hasErrors) {
  val productTuple = processedForm.<span class="built_in">get</span><span class="comment"> // Do something with the product</span>
} <span class="keyword">else</span> {
  val errors = processedForm.getErrors<span class="comment"> // Do something with the errors</span>
}
</pre></td></tr></table></figure>

<p><code>Form.fold</code> takes two parameters, where the first is a function that accepts the
“failure” result, and the second accepts the “success” result as the single parameter.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>val processedForm = productForm<span class="preprocessor">.bind</span>(data)
processedForm<span class="preprocessor">.fold</span> (
  formWithErrors =&gt; BadRequest,
  productTuple =&gt; {
    Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.product</span><span class="preprocessor">.show</span>(product))
  }
)
</pre></td></tr></table></figure>

<h3 id="either">Either</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>def getProduct(): Either[String, Product] = {
  if(validation<span class="preprocessor">.hasError</span>) {
    Left(validation<span class="preprocessor">.error</span>)
  } else {
    Right(Product())
  }
}
def showProduct() = Action {
  getProduct()<span class="preprocessor">.fold</span>(
    failureReason =&gt; InternalServerError(failureReason),
    product =&gt; Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.product</span><span class="preprocessor">.show</span>(product))
  )
}
</pre></td></tr></table></figure>

<h2 id="object-mapping">Object mapping</h2>
<p>To do so, we’ll have to provide the mapping with a function to construct the value.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">case</span> class Product(
  name: <span class="built_in">String</span>,
  ean: <span class="built_in">String</span>,
  pieces: Int)

<span class="keyword">import</span> play<span class="built_in">.</span>api<span class="built_in">.</span><span class="built_in">data</span><span class="built_in">.</span>Forms<span class="built_in">.</span>_

<span class="comment">// This makes the type of this mapping Mapping[Product].</span>
val productMapping <span class="subst">=</span> mapping(
  <span class="string">"name"</span> <span class="subst">-&gt; </span>text,
  <span class="string">"ean"</span> <span class="subst">-&gt; </span>text,
  <span class="string">"pieces"</span> <span class="subst">-&gt; </span>number)(Product<span class="built_in">.</span>apply)(Product<span class="built_in">.</span>unapply)

<span class="comment">// Using our Mapping[Product], we can now easily create a Form[Product]:</span>
val productForm <span class="subst">=</span> Form(productMapping)

productForm<span class="built_in">.</span>bind(<span class="built_in">data</span>)<span class="built_in">.</span>fold(
  formWithErrors <span class="subst">=&gt;</span> <span class="attribute">...</span>,
  product <span class="subst">=&gt;</span> 
)
</pre></td></tr></table></figure>

<h2 id="mapping-http-request-data">Mapping HTTP request data</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def processForm() = Action { request =&gt;
  productForm.bindFromRequest()(request).fold(
  <span class="keyword">...</span>
  )
}

// 加入 imlicit
def processForm() = Action { implicit request =&gt;
  productForm.bindFromRequest().fold(
    <span class="keyword">...</span>
  )
}
</pre></td></tr></table></figure>

<p>Browsers submit HTTP bodies with either an <code>application/x-www-form-urlencoded</code>
or a <code>multipart/form-data</code> content type, depending on the form, and it’s
also common to send JSON over the wire. The bindFromRequest method uses the
Content-Type header to determine a suitable decoder for the body.</p>
<h1 id="creating-and-processing-html-forms">Creating and processing HTML forms</h1>
<p>Play also provides helpers that generate forms and take the
tedium out of showing validation and error messages in the appropriate places.</p>
<h2 id="writing-html-forms-manually">Writing HTML forms manually</h2>
<p>model class:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="reserved">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span>(</span>
  <span class="attribute">ean</span>: Long,
  <span class="attribute">name</span>: String,
  <span class="attribute">description</span>: String,
  <span class="attribute">pieces</span>: Int,
  <span class="attribute">active</span>: Boolean)

val productForm = Form(mapping(
  <span class="string">"ean"</span><span class="function"> -&gt;</span> longNumber,
  <span class="string">"name"</span><span class="function"> -&gt;</span> nonEmptyText,
  <span class="string">"description"</span><span class="function"> -&gt;</span> text,
  <span class="string">"pieces"</span><span class="function"> -&gt;</span> number,
  <span class="string">"active"</span><span class="function"> -&gt;</span> boolean)(Product.apply)(Product.unapply))

def create() = Action { implicit request<span class="function"> =&gt;</span>
  productForm.bindFromRequest.fold(
    formWithErrors<span class="function"> =&gt;</span> BadRequest(<span class="string">"Oh noes, invalid submission!"</span>),
    value<span class="function"> =&gt;</span> Ok(<span class="string">"created: "</span> + value)
  )
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>@()
@main("Product Form") {
  <span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"@routes.Products.create()"</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"name"</span>&gt;</span>Product name<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">id</span>=<span class="value">"name"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"description"</span>&gt;</span>Description<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">id</span>=<span class="value">"description"</span> <span class="attribute">name</span>=<span class="value">"description"</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"ean"</span>&gt;</span>EAN Code<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"ean"</span> <span class="attribute">id</span>=<span class="value">"ean"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"pieces"</span>&gt;</span>Pieces<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"pieces"</span> <span class="attribute">id</span>=<span class="value">"pieces"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"active"</span>&gt;</span>Active<span class="tag">&lt;/<span class="title">label</span>&gt;</span>
      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">name</span>=<span class="value">"active"</span> <span class="attribute">value</span>=<span class="value">"true"</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"buttons"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">type</span>=<span class="value">"submit"</span>&gt;</span>Create Product<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">form</span>&gt;</span>
}
</pre></td></tr></table></figure>

<h2 id="generating-html-forms">Generating HTML forms</h2>
<p>Play provides helpers, template snippets that can render a form field for you, including
extra information like an indication when the value is required and an error message
if the field has an invalid value. The helpers are in the <code>views.template</code> package.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="at_rule">@(productForm:<span class="preprocessor"> Form</span>[Product])

@<span class="function">main(<span class="string">"Product Form"</span>)</span> {</span>
  <span class="at_rule">@helper.<span class="function">form(action = routes.GeneratedForm.create)</span> {</span>
    <span class="at_rule">@helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"name"</span>)</span>)</span>
    @helper.<span class="function">textarea(<span class="function">productForm(<span class="string">"description"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"ean"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"pieces"</span>)</span>)</span>
    @helper.<span class="function">checkbox(<span class="function">productForm(<span class="string">"active"</span>)</span>)</span>
    &lt;div<span class="preprocessor"> class</span>=<span class="string">"form-actions"</span>&gt;
      &lt;button<span class="preprocessor"> type</span>=<span class="string">"submit"</span>&gt;Create<span class="preprocessor"> Product</span>&lt;/button&gt;
    &lt;/div&gt;
  }
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>def createForm() = Action {
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.form</span>(productForm))
}
</pre></td></tr></table></figure>

<h2 id="input-helpers">Input helpers</h2>
<p>Play ships predefined helpers for the most common input types:</p>
<ul>
<li>inputDate—Generates an input tag with type date .</li>
<li>inputPassword—Generates an input tag with type password.</li>
<li>inputFile—Generates an input tag with type file .</li>
<li>inputText—Generates an input tag with type text .</li>
<li>select—Generates a select tag.</li>
<li>inputRadioGroup—Generates a set of input tags with type radio.</li>
<li>checkbox—Generates an input tag with type checkbox.</li>
<li>textarea—Generates a textarea element.</li>
<li>input—Creates a custom input.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>@*  notation '_class creates a <span class="type">Scala</span> <span class="type">Symbol</span> named _class *@
@helper.inputText(productForm(<span class="string">"name"</span>), '_class -&gt; <span class="string">"important"</span>, 'size -&gt; <span class="number">40</span>)
</pre></td></tr></table></figure>

<p>These are the extra symbols with underscores that you can use:</p>
<ul>
<li><code>_label</code>—Use to set a custom label</li>
<li><code>_id</code>—Use to set the id attribute of the dl element</li>
<li><code>_class</code>—Use to set the class attribute of the dl element</li>
<li><code>_help</code>—Use to show custom help text</li>
<li><code>_showConstraints</code>—Set to false to hide the constraints on this field</li>
<li><code>_error</code>—Set to a <code>Some[FormError]</code> instance to show a custom error</li>
<li><code>_showErrors</code>—Set to false to hide the errors on this field</li>
</ul>
<h2 id="customizing-generated-html">Customizing generated HTML</h2>
<p>Play allows you to customize the generated HTML in two ways. First, you
can customize which input element is generated, in case you need some special input
type. Second, you can customize the HTML elements around that input element.</p>
<p>Suppose we want to create an input with type datetime.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>@* the first <span class="keyword">is</span> the Field that we want to create the input <span class="keyword">for</span> *@
<span class="property">@helper</span>.input<span class="function"><span class="params">(myForm(<span class="string">"mydatetime"</span>))</span> { <span class="params">(id, name, value, args)</span> =&gt;</span>
  @* a type <span class="function"><span class="params">(String, String, Option[String], Map[Symbol,Any])</span> =&gt;</span> Html *@
  &lt;input type=<span class="string">"datetime"</span> name=<span class="string">"@name"</span> id=<span class="string">"@id"</span> value=<span class="string">"@value"</span> <span class="property">@toHtmlArgs</span>(args)&gt;
}
</pre></td></tr></table></figure>

<p>We use the toHtmlArgs method from the <code>play.api.templates.PlayMagic</code>
object to construct additional attributes from the args map.</p>
<p>They have an additional parameter list that takes an implicit <code>FieldConstructor</code> and a <code>Lang</code>.</p>
<p><code>FieldConstructor</code> is a trait with a single apply method that takes a
<code>FieldElements</code> object and returns Html. Play provides a <code>defaultFieldConstructor</code>
that generates the HTML we saw earlier, but you can implement
your own <code>FieldConstructor</code> if you want different HTML.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>@(elements: views.html.helper.FieldElements)

<span class="keyword">@import</span> play.api.i18n._
<span class="keyword">@import</span> views.html.helper._

&lt;div <span class="keyword">class</span>=<span class="string">"control-group @elements.args.get('_class)
  @if(elements.hasErrors) {error}"</span>
  id=<span class="string">"@elements.args.get('_id).getOrElse(elements.id + "</span>_field<span class="string">")"</span> &gt;
    &lt;label <span class="keyword">class</span>=<span class="string">"control-label"</span> <span class="keyword">for</span>=<span class="string">"@elements.id"</span>&gt;
      <span class="keyword">@elements</span>.label(elements.lang)
    &lt;/label&gt;
    &lt;div <span class="keyword">class</span>=<span class="string">"controls"</span>&gt;
      <span class="keyword">@elements</span>.input
      &lt;span <span class="keyword">class</span>=<span class="string">"help-inline"</span>&gt;
        <span class="keyword">@if</span>(elements.errors(elements.lang).nonEmpty) {
          <span class="keyword">@elements</span>.errors(elements.lang).mkString(<span class="string">", "</span>)
        } <span class="keyword">else</span> {
          <span class="keyword">@elements</span>.infos(elements.lang).mkString(<span class="string">", "</span>)
        }
      &lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">package</span> views.html.helper

<span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">bootstrap</span> {</span>
implicit <span class="keyword">val</span> fieldConstructor = <span class="keyword">new</span> FieldConstructor {
  <span class="keyword">def</span> apply(elements: FieldElements) =
    bootstrap.bootstrapFieldConstructor(elements)
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="at_rule">@(productForm:<span class="preprocessor"> Form</span>[Product])
@<span class="keyword">import</span><span class="preprocessor"> views.html.helper.bootstrap._</span>
@<span class="function">main(<span class="string">"Product Form"</span>)</span> {</span>
  <span class="at_rule">@helper.<span class="function">form(action = routes.GeneratedForm.create)</span> {</span>
    <span class="at_rule">@helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"name"</span>)</span>)</span>
    @helper.<span class="function">textarea(<span class="function">productForm(<span class="string">"description"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"ean"</span>)</span>)</span>
    @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"pieces"</span>)</span>)</span>
    @helper.<span class="function">checkbox(<span class="function">productForm(<span class="string">"active"</span>)</span>)</span>
    &lt;div<span class="preprocessor"> class</span>=<span class="string">"form-actions"</span>&gt;
      &lt;button<span class="preprocessor"> type</span>=<span class="string">"submit"</span>&gt;Create<span class="preprocessor"> Product</span>&lt;/button&gt;
    &lt;/div&gt;
  }
}</span>
</pre></td></tr></table></figure>

<h1 id="validation-and-advanced-mappings">Validation and advanced mappings</h1>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-View Template]]></title>
    <link href="http://zhpooer.github.io/2014/08/12/play-for-scala-view-template/"/>
    <id>http://zhpooer.github.io/2014/08/12/play-for-scala-view-template/</id>
    <published>2014-08-12T03:36:59.000Z</published>
    <updated>2014-08-12T08:21:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="the-why-of-a-template-engine">The why of a template engine</h1>
<p>Templates allow you to reuse pieces of your HTML when you need them, such as a
header and a footer section that are the same or similar on every page. </p>
<p>Another reason to use templates is because they help you to separate business logic
from presentation logic; separating these two concerns has several advantages.</p>
<h1 id="type-safety-of-a-template-engine">Type safety of a template engine</h1>
<p>Play Scala templates are HTML files containing snippets of Scala code,
which are compiled into plain Scala code before your application is started. </p>
<p>As an example, we’ll build a catalog application. The main page will be a list of all
the articles in the catalog, and every article on this page will have a hyperlink to a
details page for that article, where more information about that article is shown. </p>
<h2 id="a-type-safe-template-engine">A type-safe template engine</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">(articles:</span> Seq[models.Article])
&lt;hi&gt;Articles&lt;/hi&gt;
&lt;ul&gt;
@<span class="function">for(article &lt;- articles)</span> </span>{
  &lt;<span class="tag">li</span>&gt;
    <span class="at_rule">@<span class="keyword">article.name</span> -
    &lt;a href=<span class="string">"@controllers.routes.Aritcles.show(article.id)"</span>&gt;
      details
    &lt;/a&gt;
  &lt;/li&gt;
}
&lt;/ul&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Articles</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> index = Action {
    <span class="keyword">val</span> articles = Article.findAll()
    Ok(views.html.articles.index(articles))
  }
  <span class="keyword">def</span> show(id:Long) = Action {
    Articles.findById(id) <span class="keyword">match</span> {
      <span class="keyword">case</span> None =&gt; NotFound
      <span class="keyword">case</span> Some(article) =&gt; Ok(views.html.articles.show(article))
    }
  }
}
</pre></td></tr></table></figure>

<p>Play’s type-safe template engine will help you build a more robust application. Both
your IDE and Play itself will warn you when a refactoring causes type errors, even
before you render the template.</p>
<h1 id="template-basics-and-common-structures">Template basics and common structures</h1>
<p>In Scala templates, the <code>@</code> character marks the start of a Scala expression.</p>
<h2 id="-">特殊字符 @</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Hello <span class="decorator">@name!</span>
Your age <span class="keyword">is</span> <span class="decorator">@user.age.</span>
Next year, your age will be <span class="decorator">@(user.age + 1)</span>

<span class="decorator">@* 这样是错误的 *@</span>
Next year, your age will be <span class="decorator">@user.age + 1</span>

Next year, your age will be
<span class="decorator">@{val ageNextYear = user.age + 1; ageNextYear}</span>

<span class="decorator">@* 输出 @ 符号 *@</span>
username<span class="decorator">@@example.com</span>

<span class="decorator">@* 这是注释 *@</span>
</pre></td></tr></table></figure>

<h2 id="-">表达式</h2>
<p>Play also imports various things into the scope of your templates. The following are
automatically imported by Play:</p>
<ul>
<li><code>models._</code></li>
<li><code>controllers._</code></li>
<li><code>play.api.i18n._</code></li>
<li><code>play.api.mvc._</code>, makes MVC components available.</li>
<li><code>play.api.data._</code>, contains tools for dealing with forms and validation. </li>
<li><code>views.%format%._</code>,  is replaced by the template format that you’re using.</li>
</ul>
<h2 id="displaying-collections">Displaying collections</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>&lt;ul&gt;
<span class="keyword">@articles</span>.map { article =&gt;
  &lt;li&gt;<span class="keyword">@article</span>.name&lt;/li&gt;
}
&lt;/ul&gt;

@* The <span class="keyword">template</span> compiler automatically adds the yield keyword *@
&lt;ul&gt;
<span class="keyword">@for</span>(article &lt;- articles) {
  &lt;li&gt;<span class="keyword">@article</span>.name&lt;/li&gt;
}
&lt;/ul&gt;

<span class="keyword">@for</span>(article &lt;- articles) {
  Article name: <span class="keyword">@article</span>.name
}
</pre></td></tr></table></figure>

<p>If you’re interested in the details of the template engine,
you can take a look at the file <code>ScalaTemplateCompiler.scala</code> in the Play
framework source. </p>
<h3 id="adding-the-index-of-the-element">ADDING THE INDEX OF THE ELEMENT</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>&lt;ul&gt;
<span class="variable">@for</span>((article, <span class="keyword">index</span>) &lt;- articles.zipWithIndex) {
  &lt;li&gt;Best seller number <span class="variable">@(</span><span class="keyword">index</span> + <span class="number">1</span>): <span class="variable">@article</span>.name&lt;<span class="regexp">/li&gt;
}
&lt;/ul</span>&gt;

&lt;ul&gt;
<span class="variable">@for</span>((article, <span class="keyword">index</span>) &lt;- articles.zipWithIndex) {
  &lt;li class=<span class="string">"<span class="variable">@if</span>(index == 0){first}
    <span class="variable">@if</span>(index == articles.length - 1){last}"</span>&gt;
  Best seller number <span class="variable">@(</span><span class="keyword">index</span> + <span class="number">1</span>): <span class="variable">@article</span>.name&lt;<span class="regexp">/li&gt;
}
&lt;/ul</span>&gt;
</pre></td></tr></table></figure>

<h2 id="security-and-escaping">Security and escaping</h2>
<p>An application developer must always keep security in mind, and when dealing with
templates, avoiding cross-site scripting vulnerabilities is especially relevant. </p>
<h3 id="cross-site-scripting-vulnerabilities">CROSS-SITE SCRIPTING VULNERABILITIES</h3>
<p>HTML injection could lead to minor annoyances, like broken markup and invalid
HTML documents, but much more serious problems arise when a malicious user
inserts scripts in your web page. These scripts could, for example, steal other visitors’
cookies when they use your application, and send these cookies to a server under the
attacker’s control.</p>
<h3 id="escaping">ESCAPING</h3>
<p>Everything that you write literally in a template is considered HTML by Play, and is
output unescaped. This HTML is always written by the template author, so it’s consid-
ered safe. </p>
<p>But all Scala expressions are escaped.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>@* embedCode 在这里被当成 没有特殊字符的文本, 不会被转义 *@
<span class="property">@article</span>.embeddedVideo.map { embedCode<span class="function"> =&gt;</span>
  &lt;h3&gt;Product video&lt;/h3&gt;
  <span class="property">@Html</span>(embedCode)
}
</pre></td></tr></table></figure>

<h2 id="using-plain-scala">Using plain Scala</h2>
<p>As shown earlier, you can use plain Scala if you
create a block with <code>@()</code> or <code>@{}</code>.</p>
<p>By default, the output is escaped. If you want to prevent this, wrap the result in an Html.</p>
<p>Any scala.xml.NodeSeq is also rendered unescaped, so you
can use the following code:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>@{
  <span class="tag">&lt;<span class="title">b</span>&gt;</span>hello<span class="tag">&lt;/<span class="title">b</span>&gt;</span>
}
</pre></td></tr></table></figure>

<p>只调用 <code>article.countReview()</code> 一次, 值映射到 total</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="property">@defining</span>(article.countReview()) { total<span class="function"> =&gt;</span>
  &lt;h3&gt;This article has been reviewed <span class="property">@total</span> times&lt;/h3&gt;
  &lt;p&gt;@(article.countPositiveReviews()) out <span class="keyword">of</span> these
  <span class="property">@total</span> reviews were positive!&lt;/p&gt;
}
</pre></td></tr></table></figure>

<h1 id="structuring-pages-template-composition">Structuring pages: template composition</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>def catalog() = Action {
  val products = ProductDAO<span class="preprocessor">.list</span>
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.shop</span><span class="preprocessor">.catalog</span>(products))
}
</pre></td></tr></table></figure>

<p><code>views/navigation.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>@()
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"navigation"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@routes.Application.home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@routes.Shop.catalog"</span>&gt;</span>Catalog<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@routes.Application.contact"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p><code>views/catalog.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">&lt;!-- other code --&gt;</span>
<span class="comment">&lt;!-- 导入 navigation 模板 --&gt;</span>
  @navigation()
<span class="comment">&lt;!-- other code --&gt;</span>
</pre></td></tr></table></figure>

<h2 id="layouts">Layouts</h2>
<p><code>app/views/main.scala.html</code>, with a single parameter named content of type <code>Html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>@(content: Html)
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>paperclips.example.com<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"@routes.Assets.at("</span><span class="value">stylesheets</span>/<span class="attribute">main.css</span>")"
          <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Products<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    @navigation
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"content"</span>&gt;</span>
      @content
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">footer</span>&gt;</span>
      <span class="tag">&lt;<span class="title">p</span>&gt;</span>Copyright paperclips.example.com<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">footer</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<p>可以这样使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>@(products: Seq[Product])
<span class="keyword">@main</span> {
  &lt;h2&gt;Products&lt;/h2&gt;
  &lt;ul <span class="keyword">class</span>=<span class="string">"products"</span>&gt;
  <span class="keyword">@for</span>(product &lt;- products) {
    &lt;li&gt;
      &lt;h3&gt;<span class="keyword">@product</span>.name&lt;/h3&gt;
      &lt;p <span class="keyword">class</span>=<span class="string">"description"</span>&gt;<span class="keyword">@product</span>.description&lt;/p&gt;
    &lt;/li&gt;
  }
  &lt;/ul&gt;
}
</pre></td></tr></table></figure>

<p>可以这样定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>@* @(title="paperclips.example.com")(content: Html) 或这样*@
@(title: String)(content: Html)
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">title</span>&gt;</span>@title<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="comment">&lt;!-- any --&gt;</span>
</pre></td></tr></table></figure>

<p>这样使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="at_rule">@<span class="function">main(<span class="string">"Products"</span>)</span> {</span>
  <span class="comment">// content here</span>
}
</pre></td></tr></table></figure>

<h2 id="tags">Tags</h2>
<p><code>views/products/tags/productlist.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="variable">@(</span>products: Se<span class="string">q[Product]</span>)
&lt;ul class=<span class="string">"products"</span>&gt;
<span class="variable">@for</span>(product &lt;- products) {
  &lt;li&gt;
    &lt;h3&gt;<span class="variable">@product</span>.name&lt;<span class="regexp">/h3&gt;
    &lt;p class="description"&gt;@product.description&lt;/p</span>&gt;
  &lt;<span class="regexp">/li&gt;
}
&lt;/ul</span>&gt;
</pre></td></tr></table></figure>

<p><code>catalog.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="variable">@(</span>products: Se<span class="string">q[Product]</span>)
<span class="variable">@main</span> {
  &lt;h2&gt;Products&lt;<span class="regexp">/h2&gt;
  @views.html.products.tags.productlist(products)
}</span>
</pre></td></tr></table></figure>

<h1 id="reducing-repetition-with-implicit-parameters">Reducing repetition with implicit parameters</h1>
<p>Let’s continue with our web shop example. This time we’ll assume that we want to
maintain a shopping cart on the website, and in the top-right corner of every page we
want to show the number of items the visitor has in their shopping cart.</p>
<p><code>main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>@(cart: Cart)(content: Html)
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
    <span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">body</span>&gt;</span><span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<p>Now that the main template needs a Cart parameter, we’ll have to pass one to it,
which means adapting our catalog template. But this template doesn’t have a refer-
ence to a Cart object, so it’ll need to take one as a parameter as well:</p>
<p><code>cart.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="variable">@(</span>products: Se<span class="string">q[Product]</span>, cart: Cart)
<span class="variable">@main</span>(cart) {
  &lt;h2&gt;Catalog&lt;<span class="regexp">/h2&gt;
  @views.html.products.tags.productlist(products)
}</span>
</pre></td></tr></table></figure>

<p>We’ll also have to pass a Cart from the action:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">def</span> catalog() = Action { request =&gt;
  <span class="keyword">val</span> products = ProductDAO.list
  Ok(views.html.shop.catalog(products, cart(request)))
}

<span class="keyword">def</span> cart(request: Request) = {
  <span class="comment">// Get cart from session</span>
}
</pre></td></tr></table></figure>

<p>可以这样:</p>
<p>We can use an implicit parameter to change the method signature of our catalog
template as follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">@(</span>products: Se<span class="string">q[Product]</span>)(implicit cart: Cart)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def catalog() = Action { <span class="keyword">implicit</span> request =&gt;
  val products = ProductDAO.list
  Ok(views.html.shop.catalog(products))
}

<span class="keyword">implicit</span> def cart(<span class="keyword">implicit</span> request: RequestHeader) = {
  <span class="comment">// Get cart from session</span>
}
</pre></td></tr></table></figure>

<p>We can make our newly created cart method reusable, by moving it into a trait:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">WithCart</span> {</span>
  implicit <span class="keyword">def</span> cart(implicit request: RequestHeader) = {
    <span class="comment">// Get cart from session</span>
  }
}
</pre></td></tr></table></figure>

<p>If you have an implicit Request in
scope in your controller, you also have an implicit RequestHeader, Session,
Flash, and Lang in scope, because the Controller trait defines
implicit conversions for these types.</p>
<h1 id="using-less-and-coffeescript-the-asset-pipeline">Using LESS and CoffeeScript: the asset pipeline</h1>
<p>LESS is a stylesheet language that’s
transformed to CSS by a LESS interpreter or compiler,
whereas CoffeeScript is a scripting language that’s transformed into
JavaScript by a CoffeeScript compiler.</p>
<h2 id="less">LESS</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class">.header</span> <span class="rules">{
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#0b5c20</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.footer</span> <span class="rules">{
  <span class="rule"><span class="attribute">background-color</span>:<span class="value"><span class="hexcolor">#0b5c20</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.footer</span> <span class="tag">a</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>LESS:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="at_rule">@green: <span class="hexcolor">#0b5c20</span>;</span>
<span class="class">.header</span> {
  <span class="attribute">background-color</span><span class="value">:@green;</span>
}

<span class="class">.footer</span> {
  <span class="attribute">background-color</span><span class="value">:@green;</span>
  <span class="tag">a</span> {
    <span class="attribute">font-weight</span><span class="value">:bold;</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="coffeescript">CoffeeScript</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>math =
  <span class="attribute">root</span>: Math.sqrt
  <span class="attribute">square</span>: square
  <span class="attribute">cube</span>: <span class="function"><span class="params">(x)</span> -&gt;</span> x * square x
</pre></td></tr></table></figure>

<h2 id="the-asset-pipeline">The asset pipeline</h2>
<p>Play supports automatic build-time CoffeeScript and LESS compilation, and it
shows compilation errors in the familiar Play error page.</p>
<p>For example, if you place a CoffeeScript file in
<code>app/assets/javascripts/application.coffee</code>,
you can reference it from a template like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"@routes.Assets.at("</span><span class="value">javascripts</span>/<span class="attribute">application.js</span>")"&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>

<p>You can also use an automatically generated minified version of
your JavaScript file by changing <code>application.js</code> to <code>application.min.js</code> .</p>
<h1 id="internationalization">Internationalization</h1>
<p>Internationalization is a refactoring to remove locale-specific code from
your application. Localization is making a locale-specific version of an application. In
an internationalized web application, this means having one or more selectable
locale-specific versions.</p>
<p><code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>application<span class="preprocessor">.langs</span>=<span class="string">"en,en-US,nl"</span>
</pre></td></tr></table></figure>

<p><code>conf/messages</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>welcome = Welcome!
users.login = Log <span class="keyword">in</span>
shop.thanks = Thank you <span class="keyword">for</span> your <span class="keyword">order</span>
</pre></td></tr></table></figure>

<p>Play provides an implicit conversion from a Request to a Lang, which is more useful.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">Messages(<span class="string">"users.login"</span>)</span>(<span class="function">Lang(<span class="string">"en"</span>)</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">(implicit</span> request: Request)
&lt;h1&gt;@<span class="function">Messages(<span class="string">"welcome"</span>)</span>&lt;/h1&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">validation.required</span>=<span class="string">{0} is required</span>
</pre></td></tr></table></figure>

<p>You can substitute these by specifying more parameters to the call to Messages:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">Messages</span>(<span class="string">"validation.required"</span>, <span class="string">"email"</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>shop.basketcount=Your cart {<span class="number">0</span>,choice,<span class="number">0</span><span class="array">#is empty</span>|<span class="number">1</span><span class="array">#has one item</span>
  |<span class="number">1</span>&lt; has {<span class="number">0</span>} items}.
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">p</span>&gt;</span>@Messages("shop.basketcount", 0)<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>@Messages("shop.basketcount", 1)<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>@Messages("shop.basketcount", 10)<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="comment">&lt;!-- 输出 --&gt;</span>
<span class="comment">&lt;!-- Your cart is empty. --&gt;</span>
<span class="comment">&lt;!-- Your cart has one item. --&gt;</span>
<span class="comment">&lt;!-- Your cart has 10 items. --&gt;</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day66-Hadoop HDFS]]></title>
    <link href="http://zhpooer.github.io/2014/08/11/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day66-hadoop-hdfs/"/>
    <id>http://zhpooer.github.io/2014/08/11/传智播客day66-hadoop-hdfs/</id>
    <published>2014-08-11T00:54:29.000Z</published>
    <updated>2014-08-11T09:15:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-hdfs">分布式文件系统与HDFS</h1>
<p>客户端(Client) 查询 NameNode(记录文件存储信息), 将数据放入datanode(多个)或从中取出<br>数据在上传过程中要进行冗余保存, datanode 自行进行水平复制.(流水线复制)<br>上传过程中, 文件会被分块, 每块128M, 其实是对块的冗余存储</p>
<ul>
<li>数据量越来越多, 在多个操作系统中协调</li>
<li>允许文件通过网络在多台主机上分享文件系统, 增加机器数量来扩张</li>
<li>通透性, 在用户和程序看来, 就像访问本地的磁盘一样</li>
<li>容错, 某些节点脱机, 可以持续运作, 不会由数据损失</li>
<li>分布式文件管理系统有很多种, hdfs 只是其中一种. 适用于一次写入,
多次查询的情况, 不支持并发写(同一个文件分块同时上传), 小文件不合适</li>
</ul>
<p>分布式文件系统</p>
<ul>
<li>GFS</li>
<li>HDFS</li>
<li>Lustre</li>
<li>Ceph</li>
<li>GriddFs</li>
<li>TFS</li>
</ul>
<p>谷歌三大论文(BigTable, MapReduce, GFS)</p>
<h1 id="hdfs-shell-">HDFS的shell操作</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre><span class="preprocessor"># 启动 HDFS</span>
start-dfs.sh

<span class="preprocessor"># 列出文件</span>
hadoop fs -ls hdfs:<span class="comment">//itcast:9000/</span>

<span class="preprocessor"># 取出文件</span>
hadoop fs -<span class="keyword">get</span> hdfs:<span class="comment">//itcast:9000/jdk ~/temp/jdk</span>
<span class="preprocessor"># 也可以这么写</span>
hadoop fs -<span class="keyword">get</span> /jdk ~/temp/jdk

hadoop fs -cat /words.avi

<span class="preprocessor"># 追加文件到 word.avi</span>
hadoop fs -appendToFile ~/appendix /words.avi

<span class="preprocessor"># 查看ls 帮助</span>
hadoop fs -help ls
hadoop fs -ls /wc* -h
<span class="preprocessor"># 递归显示</span>
hadoop fs -ls /wc* -R

<span class="preprocessor"># 改变所属组和所属用户</span>
hadoop fs -chown supergroup:supergroup  /jdk
hadoop fs -chgrp root  /jdk

<span class="preprocessor"># 改变权限</span>
hadoop fs -chmode u+w /wcout
<span class="preprocessor"># 递归改变权限</span>
hadoop fs -chmode u+w /wcout -R

<span class="preprocessor"># 拷贝本地文件到 hdfs 相当于 put</span>
hadoop fs -copyFromLocal /home/hadoop/a.txt /
<span class="preprocessor"># 获得远程文件到本地</span>
hadoop fs -copyToLocal /a.txt /tmp/

<span class="preprocessor"># 列出文件数, 文件夹数, 总大小</span>
hadoop fs -count /

<span class="preprocessor"># 远程拷贝</span>
hadoop fs -cp /a.txt /b.txt

<span class="preprocessor"># 剪切</span>
hadoop fs -cp /a.txt /b.txt

hadoop fs -du
hadoop fs -df

hadoop fs -mkdir -p /abc
hadoop fs -rm /abc -r

<span class="preprocessor"># 合并 a.txt b.txt 到 c.txt</span>
hadoop fs -getmerge /a.txt /b.txt /tmp/c.txt

<span class="preprocessor"># 查看尾部内容</span>
hadoop fs -tail /a.txt

hadoop fs -text /a.txt | more

<span class="preprocessor"># 设置3个副本, 如果只有一台机器, 还是存了一份</span>
hadoop fs -setrep <span class="number">3</span> /a.txt
</pre></td></tr></table></figure>

<p>老版本中所有命令都包含在 <code>hadoop</code> 命令中, 新版本中<code>hdfs dfs</code>代替 <code>hadoop fs</code></p>
<h1 id="-">体系结构和基本概念</h1>
<ul>
<li>NameNode, 索引节点, 存放文件的描述性信息(medadata)</li>
<li>DataNode, 数据节点, 可以有许多个</li>
<li>Secodary NameNode, Name node的帮助节点, 在Hadoop 2.0中已经去除, 但是伪分布式中还会存在</li>
</ul>
<h2 id="-">元数据存储细节</h2>
<p>NameNode包含</p>
<ul>
<li>FileName</li>
<li>replicas</li>
<li>block-ids</li>
<li>id2host</li>
<li>其他</li>
</ul>
<pre><code>metadata: /test/a.log, 3, {blk_1, blk_2}, [{blk_1: [h0, h1, h3]}, {blk_2: [h0, h2, h4]}]
文件/test/a.log, 有三个副本, 分成两块{blk_1, blk_2}, 分别被存在 [h0....]
</code></pre><p>NameNode 是整个文件系统的管理节点. 维护着整个节点的目录树.
文件/目录的元数据和每个文件对应的数据块列表, 接受用户的操作请求.</p>
<p>文件包括:</p>
<ul>
<li>fsimage 元数据镜像文件, 存储着某一时段 NameNode 内存元数据信息.
序列化写入到磁盘; 1.0非实时同步, 但是2.0可以通过设置实现</li>
<li>edits, 操作日志文件, 记录用户的操作日志</li>
<li>fstime, 保存最近一次checkpoint的时间, 上一次数据同步的时间点; 内存数据和磁盘数据同步的时间点;</li>
</ul>
<p>工作特点</p>
<ul>
<li>始终在内存中保存metedata</li>
<li>有写请求到来时, namenode会首先写editlog到磁盘. 成功返回后, 修改内存(metedata), 返回客户端</li>
<li>namenode 维护 fsimage 文件, 不会随时与 metedata 同步, 每隔一段时间通过合并edits 文件来更新内容.
SecondaryNameNode 合并 fsimage 和 edits 来完成工作</li>
</ul>
<h2 id="secondarynamenode">SecondaryNameNode</h2>
<p>Hadoop2 中已经不使用这种方法同步</p>
<p>HA(高可靠性) 解决方案, 不支持热备份(数据实时同步)</p>
<p>执行过程, 从Namenode下载数据信息(fsimage, edits), 然后把二者合并,
生成新的fsimage, 返回给NameNode. 通常部署到两个节点</p>
<p>以下两个任意两个参数满足, 就会启动合并</p>
<ul>
<li><code>fs.checkpoint.period</code> 指定两次checkpoint的最大时间间隔, 默认 3600秒</li>
<li><code>fs.checkpoint.size</code>, edits size 的最大值, 默认为64M</li>
</ul>
<h2 id="datanode">DataNode</h2>
<p>提供真实文件的存储服务</p>
<p>文件块(block): 最基本的存储单位. Hdfs1.0默认大小为64M, Hdfs1.0默认大小为128M.</p>
<p>HDFS中, 如果一个文件不小于数据块大小, 并不会占用整个block</p>
<p>replication, 多副本, 默认3块</p>
<h1 id="java-api">java接口与常用API</h1>
<p>导入jar包 <code>hdfs.jar common.jar</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="keyword">class</span> HDFSDemo {

    FileSystem fs = <span class="keyword">null</span>;
    @Before <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>() {
        fs = FileSystem.<span class="keyword">get</span>(<span class="keyword">new</span> URI(<span class="string">"hdfs://itcast:9000"</span>), <span class="keyword">new</span> Configuration());
    }
    
    @Test <span class="keyword">public</span> <span class="keyword">void</span> testDownload{
        InputStream <span class="keyword">in</span> = fs.open(<span class="keyword">new</span> Path(<span class="string">"/jdk7"</span>));
        OutputStream <span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/jdk4"</span>);
        <span class="comment">// true, 拷贝完成自动关闭</span>
        IOUtils.copyBytes(<span class="keyword">in</span>, <span class="keyword">out</span>, <span class="number">4096</span>, <span class="keyword">true</span>);
    }

    @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span>() {
        InputStream <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/test"</span>);
        OutputStream <span class="keyword">out</span> = fs.create(<span class="keyword">new</span> Path(<span class="string">"/in.log"</span>));
        IOUtils.copyBytes(<span class="keyword">in</span>, <span class="keyword">out</span>, <span class="number">4096</span>, <span class="keyword">true</span>);
    }

    @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMkDir</span>() {
        fs.mkdirs(<span class="keyword">new</span> Path(<span class="string">"/itcast/shanghai"</span>));
    }

    @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDel</span>() {
        <span class="comment">// 是否递归删除</span>
        Boolean flag = fs.delete(<span class="keyword">new</span> Path(<span class="string">"/jdk7"</span>), <span class="keyword">false</span>);
    }

   @Test <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExist</span>() {
       fs.exists(<span class="keyword">new</span> Path(<span class="string">"/jdk7"</span>));
   }

}
</pre></td></tr></table></figure>

<h1 id="rpc-">RPC 机制</h1>
<p>RMI 效率低</p>
<p>Remote Procedure Call, 远程过程调用协议</p>
<p>datanode 与 namenode 之间通信(心跳检测)使用RPC</p>
<p>Client 与 namenode 之间通信使用RPC</p>
<p>Client 与 datanode 之间使用 HTTP</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bizable</span> {</span>
    <span class="comment">// 初始化时需要版本号</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> versionID = <span class="number">10010</span>l;
    <span class="keyword">public</span> String <span class="title">sysHi</span>(String name);
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> <span class="keyword">implements</span> <span class="title">Bizable</span>{</span>
    <span class="keyword">public</span> String <span class="title">sysHi</span>(String name) {
        <span class="keyword">return</span> <span class="string">"Hi ~"</span> + name;
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>() {
        Server serveer = <span class="keyword">new</span> RPC.Builder(<span class="keyword">new</span> Configuration())
                               .setInstance(<span class="keyword">new</span> RPCServer())
                               .setProtocol(Bizable.class)
                               .setBindAddress(<span class="string">"192.168.1.101"</span>)
                               .setPort(<span class="number">9527</span>)
                               .build();
        Server.start();
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span>() {</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>() {
        Bizable proxy = RPC.getProxy(Bizable.class, <span class="number">10010</span>,
                               <span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.1.101"</span>, <span class="number">9527</span>), <span class="keyword">new</span> Configuration());
        String result = proxy.sysHi(<span class="string">"world"</span>);
        RPC.stopProxy(proxy);
    }
}
</pre></td></tr></table></figure>

<p>NameNode 和 DataNode 都是一个 main 方法</p>
<h1 id="-">源码分析</h1>
<p><code>FileSystem</code> 通过反射生成 实际子类.</p>
<h1 id="-debug">远程debug</h1>
<p>JDPA, java远程调试框架</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>hadoop-deamon.sh <span class="operator"><span class="keyword">start</span> dataNode</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="hadoop" scheme="http://zhpooer.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-the persistence layer]]></title>
    <link href="http://zhpooer.github.io/2014/08/11/play-for-scala-the-persistence-layer/"/>
    <id>http://zhpooer.github.io/2014/08/11/play-for-scala-the-persistence-layer/</id>
    <published>2014-08-11T00:00:25.000Z</published>
    <updated>2014-08-12T03:33:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="what-are-anorm-and-squeryl-">What are Anorm and Squeryl?</h1>
<p>In order to talk to the database, you’ll have to create SQL at some point.
A modern object-relation mapper (ORM) like Hibernate or the Java Persistence API (JPA)
provides its own query language (HQL and JPQL, respectively), which is then translated
into the target database’s SQL dialect.</p>
<p>Anorm and Squeryl are at opposite ends of the SQL-generation/translation spectrum.</p>
<p>Squeryl generates SQL by providing a Scala domain-specific language ( DSL)
that’s similar to actual SQL. Anorm doesn’t generate any SQL, and instead
relies on the developer to write SQL. </p>
<ul>
<li>Anorm allows you to write any SQL that you can come up with, even using
proprietary extensions of the particular database that you’re using.</li>
<li>Squeryl’s DSL allows the compiler to check that your queries are correct, which
meshes well with Play’s emphasis on type safety.</li>
</ul>
<h2 id="configuring-your-database">Configuring your database</h2>
<p>Play comes with support for an H2 in-memory database out of the box, but there’s no
database configured by default. </p>
<p><code>conf/application.conf</code>, 要配置其他的数据库, 可以注释掉</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span>=org<span class="preprocessor">.h</span>2<span class="preprocessor">.Driver</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=<span class="string">"jdbc:h2:mem:play"</span>
</pre></td></tr></table></figure>

<p>An in-memory database is fine for development and testing but doesn’t cut it
for most production environments.</p>
<p><code>Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val appDependencies = Se<span class="string">q(
  jdbc,
  anorm,
  "postgresql" % "postgresql" % "9.1-901.jdbc4"
)</span>
</pre></td></tr></table></figure>

<p><code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>db<span class="preprocessor">.default</span><span class="preprocessor">.user</span>=user
db<span class="preprocessor">.default</span><span class="preprocessor">.password</span>=qwerty
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=<span class="string">"jdbc:postgresql://localhost:5432/paperclips"</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span>=org<span class="preprocessor">.postgresql</span><span class="preprocessor">.Driver</span>
</pre></td></tr></table></figure>

<h2 id="creating-the-schema">Creating the schema</h2>
<p>Anorm can’t create your schema for you because it doesn’t know anything about your model.
Squeryl can create your schema for you, but it’s unable to update it. This means
you’ll have to write the SQL commands to create (and later update) your schema yourself.</p>
<p>Play does offer some help in the form of evolutions. To use evolutions, you write an
SQL script for each revision of your database; Play will then automatically detect that a
database needs to be upgraded and will do so after asking for your permission.</p>
<p>Evolutions scripts should be placed in the <code>conf/evolutions/default</code> directory
and be named <code>1.sql</code> for the first revision, <code>2.sql</code> for the second, and so on.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre># <span class="comment">--- !Ups</span>
<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (
  id long,
  ean long,
  name <span class="keyword">varchar</span>,
  description <span class="keyword">varchar</span>);</span>
  
<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> warehouses (
  id long,
  name <span class="keyword">varchar</span>);</span>

<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_items (
  id long,
  product_id long,
  warehouse_id long,
  quantity long);</span>

# <span class="comment">--- !Downs</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> products;</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> warehouses;</span>
<span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> stock_items;</span>
</pre></td></tr></table></figure>

<p>Just click the red button labeled “Apply this script now!”</p>
<h1 id="using-anorm">Using Anorm</h1>
<p>Anorm lets you write SQL queries and provides an API to parse result sets. </p>
<p>When you retrieve data with Anorm, there are three ways to
process the results: the Stream API, pattern matching, and parser combinators. </p>
<h2 id="defining-your-model">Defining your model</h2>
<p>Therefore, your model is simply a bunch of classes that represent the entities
that you want to use in your application and store in the database.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="keyword">class</span> Product(
  id: <span class="built_in">Long</span>,
  ean: <span class="built_in">Long</span>,
  name: <span class="built_in">String</span>,
  description: <span class="built_in">String</span>)
<span class="keyword">case</span> <span class="keyword">class</span> Warehouse(id: <span class="built_in">Long</span>, name: <span class="built_in">String</span>)

<span class="keyword">case</span> <span class="keyword">class</span> StockItem(
  id: <span class="built_in">Long</span>,
  productId: <span class="built_in">Long</span>,
  warehouseId: <span class="built_in">Long</span>,
  quantity: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h2 id="using-anorm-s-stream-api">Using Anorm’s stream API</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">import</span> anorm.SQL
<span class="keyword">import</span> anorm.SqlQuery

// The apply method has an implicit parameter
// block that takes a java.sql.Connection
// which Play provides <span class="keyword">in</span> the form of DB.withConnection.
val sql: SqlQuery = SQL(<span class="string">"select * from products order by name asc"</span>)

<span class="keyword">import</span> play.api.Play.current
<span class="keyword">import</span> play.api.db.DB

<span class="function"><span class="keyword">def</span> <span class="title">getAll</span>:</span>List[Product] = DB.withConnection{
    implicity connection =&gt;
    sql().map(row =&gt;
        Product(row[Long](<span class="string">"id"</span>), row[Long](<span class="string">"ean"</span>),
                row[String](<span class="string">"name"</span>), row[String](<span class="string">"description"</span>))
    ).toList
}
</pre></td></tr></table></figure>

<p>The <code>row</code> variable in the function body passed to map is an <code>SqlRow</code> ,
which has an apply method that retrieves the requested field by name.</p>
<h2 id="pattern-matching-results">Pattern matching results</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">getAllWithPatterns</span>:</span> List[Product] = DB.withConnection {
  implicit connection =&gt;
  <span class="keyword">import</span> anorm.Row
  sql().collect {
    case Row(Some(id: Long), Some(ean: Long),
             Some(name: String), Some(description: String)) =&gt;
      Product(id, ean, name, description)
  }.toList
}
</pre></td></tr></table></figure>

<p>We’ve said before that the query’s apply method returns a standard Scala <code>Stream</code>.</p>
<p>Streams are simply lists that haven’t computed—or in this case retrieved—their
contents yet. This is why we had to convert
them to Lists with toList to actually retrieve the contents.</p>
<h2 id="parsing-results">Parsing results</h2>
<p>You can also parse results with parser combinators,1 a functional programming
technique for building parsers by combining other parsers,</p>
<h3 id="building-a-single-record-parser">BUILDING A SINGLE-RECORD PARSER</h3>
<p>We’ll need to retrieve (and therefore parse) our entities many times, so it’s a good
idea to build parsers for each of our entities.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">import</span> anorm.RowParser
val productParser: RowParser[Product] = {
  <span class="keyword">import</span> anorm.~
  <span class="keyword">import</span> anorm.SqlParser._
  long(<span class="string">"id"</span>) ~
  long(<span class="string">"ean"</span>) ~
  str(<span class="string">"name"</span>) ~
  str(<span class="string">"description"</span>) map {
    case id ~ ean ~ name ~ description =&gt;
      Product(id, ean, name, description)
  }
}

<span class="keyword">import</span> anorm.ResultSetParser
// Anorm needs a ResultSetParser 
val productsParser: ResultSetParser[List[Product]] = {
  productParser *
}

// 查询结果
<span class="function"><span class="keyword">def</span> <span class="title">getAllWithParser</span>:</span> List[Product] = DB.withConnection {
  implicit connection =&gt;
  sql.<span class="keyword">as</span>(productsParser)
}
</pre></td></tr></table></figure>

<h2 id="building-a-multirecord-parser">BUILDING A MULTIRECORD PARSER</h2>
<p>To fetch stock item data, we’ll use SQL to query the <code>products</code> and
<code>stock_items</code> database tables.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>val stockItemParser: RowParser[StockItem] = {
  <span class="keyword">import</span> anorm.SqlParser._
  <span class="keyword">import</span> anorm.~
  long(<span class="string">"id"</span>) ~ long(<span class="string">"product_id"</span>) ~
  long(<span class="string">"warehouse_id"</span>) ~ long(<span class="string">"quantity"</span>) map {
    case id ~ productId ~ warehouseId ~ quantity =&gt;
      StockItem(id, productId, warehouseId, quantity)
  }
}

<span class="function"><span class="keyword">def</span> <span class="title">productStockItemParser</span>:</span> RowParser[(Product, StockItem)] = {
  <span class="keyword">import</span> anorm.SqlParser._
  <span class="keyword">import</span> anorm.~
  // flatten (<span class="keyword">in</span> map (flatten) ) turns the given ~[Product, StockItem] into a standard tuple.
  productParser ~ StockItem.stockItemParser map (flatten)
}

<span class="function"><span class="keyword">def</span> <span class="title">getAllProductsWithStockItems</span>:</span> Map[Product, List[StockItem]] = {
  DB.withConnection { implicit connection =&gt;
    val sql = SQL(<span class="string">"select p.*, s.* "</span> +
                  <span class="string">"from products p "</span> +
                  <span class="string">"inner join stock_items s on (p.id = s.product_id)"</span>)
    val results: List[(Product, StockItem)] =
    sql.<span class="keyword">as</span>(productStockItemParser *)
    //  Map[Product, StockItem] =&gt;
    //  Map[Product, List[(Product, StockItem)]] =&gt; 
    //  Map[Product, List[StockItem]]
    results.groupBy { _._1 }.mapValues { _.map { _._2 } }
  }
}
</pre></td></tr></table></figure>

<h2 id="inserting-updating-and-deleting-data">Inserting, updating, and deleting data</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="keyword">def</span> insert(product: Product): Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> addedRows =
      SQL(<span class="string">"""insert
             into products
             values ({id}, {ean}, {name}, {description})"""</span>).on(
               <span class="string">"id"</span> -&gt; product.id,
               <span class="string">"ean"</span> -&gt; product.ean,
               <span class="string">"name"</span> -&gt; product.name,
               <span class="string">"description"</span> -&gt; product.description
      ).executeUpdate()
  addedRows == <span class="number">1</span>
}

<span class="keyword">def</span> update(product: Product):Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> updateRows =
      SQL(<span class="string">"""update products
             set name = {name},
             ean = {ean},
             description = {description},
             where id = {id}
      """</span>).on (
        <span class="string">"id"</span> -&gt; product.id,
        <span class="string">"name"</span> -&gt; product.name,
        <span class="string">"ean"</span> -&gt; product.ean,
        <span class="string">"description"</span> -&gt; product.description
      ).executeUpdate()
    updatedRows == <span class="number">1</span>
  }

<span class="keyword">def</span> delete(product: Product): Boolean =
  DB.withConnection { implicit connection =&gt;
    <span class="keyword">val</span> updatedRows = SQL(<span class="string">"delete from products where id = {id}"</span>).
    on(<span class="string">"id"</span> -&gt; product.id).executeUpdate()
    updatedRows == <span class="number">0</span>
  }
</pre></td></tr></table></figure>

<h1 id="using-squeryl">Using Squeryl</h1>
<p>This means that Squeryl is an ORM that gives you a feature that other
ORMs don’t: a type-safe query language.</p>
<p>You can write queries in a language that the Scala compiler understands,
and you’ll find out whether there are errors in your queries at compile time.</p>
<p>Contrast this with other ORMs (or Anorm—Anorm is not an ORM) that rely
on the database to tell you that there are errors in your query,
and don’t complain until the queries are actually run.</p>
<h2 id="plugging-squeryl-in">Plugging Squeryl in</h2>
<p><code>project/Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>val appDependencies = <span class="constant">Seq</span>(
  jdbc,
  <span class="string">"org.squeryl"</span> <span class="string">%% "squeryl" %</span> <span class="string">"0.9.5-6"</span>
)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.adapters.H2Adapter
<span class="keyword">import</span> org.squeryl.{Session, SessionFactory}
<span class="keyword">import</span> play.api.db.DB
<span class="keyword">import</span> play.api.{Application, GlobalSettings}

<span class="class"><span class="keyword">object</span> <span class="title">Global</span> <span class="keyword">extends</span> <span class="title">GlobalSettings</span> {</span>
  <span class="keyword">override</span> <span class="keyword">def</span> onStart(app: Application) {
    SessionFactory.concreteFactory = Some(() =&gt;
      Session.create(DB.getConnection()(app), <span class="keyword">new</span> H2Adapter) )
  }
}
<span class="comment">// DB.getConnection is intended to be used in an environment where an</span>
<span class="comment">// Application is available as an</span>
<span class="comment">// implicit, and you can call it without the second parameter list.</span>
implicit <span class="keyword">val</span> implicitApp = app
DB.getConnection()
</pre></td></tr></table></figure>

<h2 id="defining-your-model">Defining your model</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.KeyedEntity

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(
  id: Long,
  ean: Long,
  name: String,
  description: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>
  
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Warehouse</span><span class="params">(
  id: Long,
  name: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StockItem</span><span class="params">(
  id: Long,
  product: Long,
  location: Long,
  quantity: Long)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>]</span>
</pre></td></tr></table></figure>

<p>The only thing that’s different from vanilla case classes here is that
we’re extending <code>KeyedEntity</code>. This tells Squeryl that it can use the
id for updates and deletes.</p>
<h3 id="immutability-and-threads">IMMUTABILITY AND THREADS</h3>
<p>When an object is immutable, you can only change it by making a copy.
This ensures that other threads that have a
reference to the same object won’t be affected by the changes.</p>
<h3 id="defining-the-schema">DEFINING THE SCHEMA</h3>
<p><code>org.squeryl.Schema</code> contains some utility methods and will allow
us to group our entity classes in such a way that Squeryl can make sense of them.</p>
<p>We’ve defined three classes to contain records, and we’ve
told Squeryl which tables we want it to create and how to map them to our model.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.Schema
<span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._

<span class="class"><span class="keyword">object</span> <span class="title">Database</span> <span class="keyword">extends</span> <span class="title">Schema</span> {</span>
  <span class="comment">// The table method returns a table for the</span>
  <span class="comment">// class specified as the type parameter</span>
  <span class="keyword">val</span> productsTable: Table[Product] =
    table[Product](<span class="string">"products"</span>)
  <span class="keyword">val</span> stockItemsTable: Table[StockItem] =
    table[StockItem](<span class="string">"stock_items"</span>)
  <span class="keyword">val</span> warehousesTable: Table[Warehouse] =
    table[Warehouse](<span class="string">"warehouses"</span>)
    
  on(productsTable) { p =&gt; declare {
    p.id is(autoIncremented)
  }}
  
  on(stockItemsTable) { s =&gt; declare {
    s.id is(autoIncremented)
  }}
  
  on(warehousesTable) { w =&gt; declare {
    w.id is(autoIncremented)
  }}
}
</pre></td></tr></table></figure>

<p>Squeryl does define a create method that creates the schema when
called from the Database object.</p>
<h2 id="extracting-data-queries">Extracting data—queries</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._
<span class="keyword">import</span> org.squeryl.Table
<span class="keyword">import</span> org.squeryl.Query
<span class="keyword">import</span> collection.Iterable
object Product {
  <span class="keyword">import</span> Database.{productsTable, stockItemsTable}
  // product: Query result row name
  <span class="function"><span class="keyword">def</span> <span class="title">allQ</span>:</span> Query[Product] = <span class="keyword">from</span>(productsTable) {
    product =&gt; select(product) orderBy(product.name desc)
  }
}

// it also extends Iterable
<span class="function"><span class="keyword">def</span> <span class="title">findAll</span>:</span> Iterable[Product] = inTransaction {
  allQ.toList
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>def productsInWarehouse(<span class="attribute">warehouse</span>: Warehouse) = {
  join<span class="function"><span class="params">(productsTable, stockItemsTable)((product, stockItem) =&gt;
    where(stockItem.location === warehouse.id).
    select(product).
    <span class="literal">on</span>(stockItem.product === product.id)
  )</span>
}
<span class="title">def</span> <span class="title">productsInWarehouseByName</span><span class="params">(name: String, warehouse: Warehouse)</span>: <span class="title">Query</span>[<span class="title">Product</span>]= {
  <span class="title">from</span><span class="params">(productsInWarehouse(warehouse))</span>{ <span class="title">product</span> =&gt;</span>
    where(product.name like name).select(product)
  }
}
</pre></td></tr></table></figure>

<h2 id="saving-records">Saving records</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>def insert(product: <span class="keyword">Product</span>): <span class="keyword">Product</span> = inTransaction <span class="list">{
  productsTable.insert(product)
}</span>

def update(product: <span class="keyword">Product</span>) <span class="list">{
  inTransaction { productsTable.update(product) }</span>
}
</pre></td></tr></table></figure>

<p>如果不这样, 那么插入时会产生 原先的 id 会变</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(product: Product)</span>:</span> Product = inTransaction {
  val defensiveCopy = product.copy
  productsTable.insert(defensiveCopy)
}

val myImmutableObject = Product(<span class="number">0</span>, <span class="number">5010255079763l</span>,
  <span class="string">"plastic coated blue"</span>,
  <span class="string">"standard paperclip, coated with blue plastic"</span>)
Database.productsTable.insert(myImmutableObject)
// id 会变成 xxx
println(myImmutableObject)
</pre></td></tr></table></figure>

<h2 id="handling-transactions">Handling transactions</h2>
<p>In order to ensure your database’s data integrity, you’ll want to use transactions.
Databases that provide transactions guarantee that all write operations
in the same transaction will either succeed together or fail together.</p>
<p>Squeryl provides two methods for working with transactions: <code>transaction</code> and
<code>inTransaction</code>.</p>
<p>The difference is that transaction always makes its own transaction and
inTransaction only makes a transaction (and eventually commits) if it’s not already
in a transaction.</p>
<p>This means that because our DAO methods wrap everything in an
inTransaction, they themselves can be wrapped in a transaction and succeed or fail
together and never separately.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>import models.{ Database, Product, StockItem }
import org<span class="preprocessor">.squeryl</span><span class="preprocessor">.PrimitiveTypeMode</span><span class="preprocessor">.transaction</span>
import Database.{productsTable, stockItemsTable}

def addNewProductGood(product: Product, stockItem: StockItem) {
  transaction {
    productsTable<span class="preprocessor">.insert</span>(product)
    stockItemsTable<span class="preprocessor">.insert</span>(stockItem)
  }
}

// 不推荐
def addNewProductBad(product: Product, stockItem: StockItem) {
  productsTable<span class="preprocessor">.insert</span>(product)
  stockItemsTable<span class="preprocessor">.insert</span>(stockItem)
}
</pre></td></tr></table></figure>

<h2 id="entity-relations">Entity relations</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="keyword">import</span> org.squeryl.PrimitiveTypeMode._
<span class="keyword">import</span> org.squeryl.dsl.{OneToMany, ManyToOne}
<span class="keyword">import</span> org.squeryl.{Query, Schema, KeyedEntity, Table}

<span class="class"><span class="keyword">object</span> <span class="title">Database</span> <span class="keyword">extends</span> <span class="title">Schema</span> {</span>
  <span class="keyword">val</span> productsTable = table[Product](<span class="string">"products"</span>)
  <span class="keyword">val</span> warehousesTable = table[Warehouse](<span class="string">"warehouses"</span>)
  <span class="keyword">val</span> stockItemsTable = table[StockItem](<span class="string">"stockItems"</span>)

  <span class="keyword">val</span> productToStockItems =
    oneToManyRelation(productsTable, stockItemsTable).
      via((p,s) =&gt; p.id === s.productId)

  <span class="keyword">val</span> warehouseToStockItems =
    oneToManyRelation(warehousesTable, stockItemsTable).
      via((w,s) =&gt; w.id === s.warehouseId)
}


<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(
  id: Long,
  ean: Long,
  name: String,
  description: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> stockItems: OneToMany[StockItem] =
    Database.productToStockItems.left(<span class="keyword">this</span>)
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Warehouse</span><span class="params">(
  id: Long,
  name: String)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> stockItems: OneToMany[StockItem] =
    Database.warehouseToStockItems.left(<span class="keyword">this</span>)
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StockItem</span><span class="params">(
  id: Long,
  productId: Long,
  warehouseId: Long,
  quantity: Long)</span> <span class="keyword">extends</span> <span class="title">KeyedEntity</span>[<span class="title">Long</span>] {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> product: ManyToOne[Product] =
    Database.productToStockItems.right(<span class="keyword">this</span>)
  <span class="keyword">lazy</span> <span class="keyword">val</span> warehouse: ManyToOne[Warehouse] =
    Database.warehouseToStockItems.right(<span class="keyword">this</span>)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>def getStockItems(product: Product) =
  inTransaction {
    product<span class="preprocessor">.stockItems</span><span class="preprocessor">.toList</span>
  }

def getLargeStockQ(product: Product, quantity: Long) =
  from(product<span class="preprocessor">.stockItems</span>) ( s =&gt;
    where(s<span class="preprocessor">.quantity</span> gt quantity)
      select(s)
  )
</pre></td></tr></table></figure>

<p>Obviously, you need to be able to add stock items to products and warehouses. You
could set the foreign keys in each stock item by hand, which is simple enough, but
Squeryl offers some help here.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// 建立外键联系
product<span class="preprocessor">.stockItems</span><span class="preprocessor">.assign</span>(stockItem)
warehouse<span class="preprocessor">.stockItems</span><span class="preprocessor">.assign</span>(stockItem)
transaction { Database<span class="preprocessor">.stockItemsTable</span><span class="preprocessor">.insert</span>(stockItem) }

// The difference between assign <span class="keyword">and</span> associate is
// that associate also saves the stock item
transaction {
  product<span class="preprocessor">.stockItems</span><span class="preprocessor">.associate</span>(stockItem)
  warehouse<span class="preprocessor">.stockItems</span><span class="preprocessor">.associate</span>(stockItem)
}
</pre></td></tr></table></figure>

<h3 id="stateful-relations">STATEFUL RELATIONS</h3>
<p>Instead of providing queries, Squeryl’s stateful relations
provide collections of related entities that you can access directly.</p>
<p>You only need to change the call to
left to leftStateful and similarly right to rightStateful:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">lazy</span> <span class="keyword">val</span> stockItems =
  Database.productToStockItems.leftStateful(<span class="keyword">this</span>)
</pre></td></tr></table></figure>

<p>You’ll have problems instantiating entities out-
side of a transaction.</p>
<p><code>StatefulOneToMany</code> has an associate method that does the same thing as its non-
stateful counterpart, but it doesn’t have an assign method.</p>
<p>Apart from that, there’s a refresh method that refreshes the list from the database. </p>
<h1 id="caching-data">Caching data</h1>
<p>Any database worth its salt will cache results for queries it encounters often. But
you’re still dealing with the overhead of talking to the database, and there are usually
more queries hitting the database, which may push these results out of the cache or
invalidate them eagerly. </p>
<p>An application cache can be more useful than a database cache, because it knows
what it’s doing with the data and can make informed decisions about when to invali-
date what.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>def insert(product: Product) {
  val insertedProduct = Product.insert(product)
  Cache.set("product-" + product.id, product)
}

def show(productId: Long) {
  Cache.getAs[<span class="link_label">Product</span>](<span class="link_url">"product-" + productId</span>) match {
<span class="code">    case Some(product) =&gt; Ok(product)</span>
<span class="code">    case None =&gt; Ok(Product.findById(productId))</span>
  }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day65-Hadoop入门]]></title>
    <link href="http://zhpooer.github.io/2014/08/10/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day65-hadoop%E5%85%A5%E9%97%A8/"/>
    <id>http://zhpooer.github.io/2014/08/10/传智播客day65-hadoop入门/</id>
    <published>2014-08-10T01:04:39.000Z</published>
    <updated>2014-08-10T09:18:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">云计算</h1>
<!-- QQ群 316336020 -->
<!-- about.com -->

<p>熟悉java集合类(Vector, ArrayList, LinkedList), io, 并发编程(锁 Lock, synchronized)和熟悉jvm原理及内存管理,
对数据结构, 算法有深刻的理解</p>
<h1 id="-">项目简介</h1>
<p>作者 Doug Cuttng, 是 Lucene, Nutch, Hadoop 等项目发起人</p>
<p>解决问题</p>
<ul>
<li>海量数据的存储(HDFS)</li>
<li>海量数据的分析(MapReduce), 分布式计算模型</li>
<li>资源调度(YARN)</li>
</ul>
<p>受Google三篇论文的启发(GFS, MapReduce, BigTable)</p>
<p>hadoop 擅长日志分析, facebook利用Hive来进行日志分析, HiveSQL进行数据分析;
Pig可以做高级的数据处理, 推荐系统.</p>
<p>用廉价的服务器搭建搭建集群服务器</p>
<p>Storm + Hadoop 具有强大的优势</p>
<p>Hadoop缺点, 只能进行离线数据</p>
<p>Storm能进行实时数据处理</p>
<p>核心</p>
<ul>
<li>HDFS(Hadoop Distributed File System), 分布式文件系统,
通过水平扩展机器的数量来增加存放文件的能力, 将数据进行冗余存储(多分存储)</li>
<li>YARN(Yet Another Resource Negotiator), 资源调度管理系统,
可以运行其他的编程模型, 使实时处理出现了可能</li>
</ul>
<p>特点</p>
<ul>
<li>扩容能力强(scalable)</li>
<li>成本低(Economical): 通过普通机器组成的服务器来分发以及处理数据</li>
<li>高效(Efficient), 分发数据, 并行计算</li>
<li>可靠(Reliable), 失败任务的转移</li>
</ul>
<h2 id="-">生态圈</h2>
<p>TODO</p>
<p>nutch 抓取数据, HDFS存储数据, Lucence检索分析 , Zookeeper 进行管理</p>
<p>版本: Apache(2.4.1), Cloudera, HDP(Hortonworks Data Platform)</p>
<h1 id="hdfs-">HDFS的架构</h1>
<p>主从结构</p>
<ul>
<li>主节点, namenode</li>
<li>从节点, 很多个: datanode</li>
</ul>
<p>namenode 负责管理</p>
<ul>
<li>接受用户操作请求</li>
<li>维护文件系统的目录结构</li>
<li>管理文件与block之间关系,</li>
</ul>
<p>datanode 负责存储文件</p>
<ul>
<li>存储文件</li>
<li>文件被分成block存储在磁盘上</li>
<li>保证安全</li>
</ul>
<p>如何自己设计一个分布式文件系统?</p>
<blockquote>
<p>客户端(Client) 查询 NameNode(记录文件存储信息), 将数据放入datanode(多个)或从中取出<br>数据在上传过程中要进行冗余保存, datanode 自行进行水平复制.<br>上传过程中, 文件会被分成8块, 每块128M, 其实是对块的冗余存储</p>
</blockquote>
<p>如何解决海量数据的计算?</p>
<blockquote>
<p>求和 1+2+3+4+5+6=?<br>map: 1+2, 3+4, 5+6<br>reduce: 3 + 7 + 11</p>
</blockquote>
<h1 id="hadoop-">hadoop版本对比</h1>
<p><code>hadoop 1.0</code>: MapReduce + HDFS</p>
<p><code>hadoop 2.0</code>: MapReduce + YARN(资源管理) + Others + HDFS</p>
<h1 id="-hadoop">部署 Hadoop</h1>
<p>三种模式</p>
<ul>
<li>本地模式</li>
<li>伪分布式</li>
<li>集群模式</li>
</ul>
<h2 id="-">伪分布模式</h2>
<p>在centos环境下</p>
<p>fileziler, windows下ftp工具</p>
<p>secureCRT, windows下ssh工具</p>
<ul>
<li><p>修改主机名 <code>/etc/sysconfig/network</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">HOSTNAME</span>=<span class="string">itcast</span>
</pre></td></tr></table></figure>
</li>
<li><p>修改 IP, <code>/etc/sysconfig/network-script/ifcfg-eth0</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="setting">DEVICE=<span class="value"><span class="string">"eth0"</span></span></span>
<span class="setting">BOOTABLETO=<span class="value"><span class="string">"static"</span></span></span>
<span class="setting">HWADDR=<span class="value"><span class="string">""</span></span></span>
<span class="setting">IPV6INIT=<span class="value"><span class="string">"yes"</span></span></span>
<span class="setting">NM_controlled=<span class="value"><span class="string">"yes"</span></span></span>
<span class="setting">ONBOOT=<span class="value"><span class="string">"yes"</span></span></span>
<span class="setting">TYPE=<span class="value"><span class="string">"Ethernet"</span></span></span>
<span class="setting">UUID=<span class="value"><span class="string">""</span></span></span>
<span class="setting">IPADDR=<span class="value"><span class="string">"192.168.1.101"</span></span></span>
<span class="setting">NETMASK=<span class="value"><span class="string">"255.255.255.0"</span></span></span>
<span class="setting">GATEWAY=<span class="value"><span class="string">"192.168.1.1"</span></span></span>
<span class="setting">NDS1=<span class="value"><span class="string">"8.8.8.8"</span></span></span>
<span class="setting">NDS2=<span class="value"><span class="string">"4.4.4.4"</span></span></span>
</pre></td></tr></table></figure>
</li>
<li><p>主机名和ip的映射关系, <code>/etc/hosts</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>192.168.1.101 itcast
</pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>service iptables <span class="keyword">stop</span>
chkconfig iptables --list
chkconfig iptables <span class="keyword">off</span>
</pre></td></tr></table></figure>
</li>
<li><p>安装JDK 64位或32位</p>
</li>
<li><p>修改Hadoop配置文件</p>
<ol>
<li><p><code>hadoop-env.sh</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>export Java_Home=<span class="keyword">...</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>core-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- namenode 地址 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://itcast:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- 运行时产生文件,非临时, 重要! --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/tmp/hadoop<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>hdfs-site</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- hdfs副本的数量 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>1<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>mapred-site.xml.template</code> copy to <code>mapred-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="comment">&lt;!-- mapreduce运行在yarn上 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
<li><p><code>yarn-site.xml</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="comment">&lt;!-- 指定yarn的 ResourceManager 所在地址 --&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
  <span class="comment">&lt;!-- reduce 获取数据的方式 --&gt;</span>
  <span class="tag">&lt;<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
    <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>初始化 Hadoop, 初始化 HDFS, <em>只需要执行一次</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">## hadoop namenode -format, 已被舍弃</span>
hdfs namenode -<span class="built_in">format</span>
</pre></td></tr></table></figure>
</li>
<li><p>启动 Hadoop</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="preprocessor"># start-all.sh, 已过时</span>
start-dfs<span class="preprocessor">.sh</span>
start-yarn<span class="preprocessor">.sh</span>

<span class="preprocessor"># stop-all.sh 停止进程</span>
stop-dfs<span class="preprocessor">.sh</span>
stop-yarn<span class="preprocessor">.sh</span>
</pre></td></tr></table></figure>
</li>
<li><p>执行<code>jps</code>, 查看运行进程</p>
<pre><code>  NodeManager
  NameNode
  DataNode
  ResourceManager
  SecondaryNameNode
</code></pre></li>
<li>查看管理界面<ul>
<li>hdfs <code>http://192.168.1.101:50070</code></li>
<li>yarn <code>http://192.168.1.101:8088</code></li>
</ul>
</li>
</ul>
<p>Hadoop目录结构</p>
<ul>
<li><code>sbin</code>, 启动或停止hadoop相关进程的命令</li>
<li><code>bin</code>, 操作hadoop相关模块的一些命令</li>
<li><code>lib</code>, 动态库</li>
<li><code>share</code>, 相关jar包</li>
<li><code>etc</code>, 配置文件</li>
</ul>
<h2 id="-">测试</h2>
<p>hdfs操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="preprocessor">## 上传文件命名为 jdk</span>
hadoop fs -put /root/jdk_***.tar hdfs:<span class="comment">//itcast:9000/jdk</span>

<span class="preprocessor">## 查看文件, 也可以通过 htfs管理页面查看目录</span>
hadoop fs -ls hdfs:<span class="comment">//itcast:9000/</span>

<span class="preprocessor">## 下载文件</span>
hadoop fs -<span class="keyword">get</span> hdfs:<span class="comment">//itcast:9000/jdk /root/jdk_***.tar</span>
</pre></td></tr></table></figure>

<p>运行 mapreduce, 词频统计 <code>share/mapreduce/hadoop-example</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="preprocessor">## 将文件放入hdfs</span>
hadoop fs -put word-in.txt hdfs:<span class="comment">//itcast:9000/words</span>

<span class="preprocessor">## 查看 hdfs</span>
hadoop fs -cat hdfs:<span class="comment">//itcast:9000/words</span>

<span class="preprocessor">## 运行 wordcount 程序, 将 words 文件进行词频统计, 输出到 hdfs://itcast:9000/words-out 文件夹</span>
hadoop jar hadoop-mapreduce-example.jar wordcount hdfs:<span class="comment">//itcast:9000/words  hdfs://itcast:9000/words-out</span>

<span class="preprocessor">## 查看 正在运行的命令</span>
jps

<span class="preprocessor">## 查看运行后的结构</span>
hadoop fs -cat hdfs:<span class="comment">//itcast:9000/words-out/part-r-00000</span>
</pre></td></tr></table></figure>

<h1 id="ssh-">SSH 协议</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="preprocessor"># 登陆</span>
ssh <span class="number">192.168</span><span class="number">.1</span><span class="number">.208</span>

<span class="preprocessor"># 执行命令</span>
ssh <span class="number">192.168</span><span class="number">.1</span><span class="number">.208</span> mkdir /itcast1008

<span class="preprocessor"># 免密码登陆</span>
<span class="preprocessor"># 生成私钥和公钥</span>
ss-keygen -t rsa

<span class="preprocessor"># 拷贝公钥到远程服务器</span>
ssh-copy-id <span class="number">192.168</span><span class="number">.1</span><span class="number">.208</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="Hadoop" scheme="http://zhpooer.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Define Http interface]]></title>
    <link href="http://zhpooer.github.io/2014/08/09/play-for-scala-define-http-interface/"/>
    <id>http://zhpooer.github.io/2014/08/09/play-for-scala-define-http-interface/</id>
    <published>2014-08-09T08:20:51.000Z</published>
    <updated>2014-08-10T14:14:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="benefits-of-good-url-design">Benefits of good URL design</h1>
<p>If you don’t think changing the URL matters, then this is probably a good time to read
Cool URIs Don’t Change, which Tim Berners-Lee wrote in
1998 (<a href="http://www.w3.org/Provider/Style/URI.html" target="_blank">http://www.w3.org/Provider/Style/URI.html</a>),
adding to his 1992 WWW style guide, which is an important
part of the documentation for the web itself.</p>
<p>ervlet API URL
mapping is too limited to handle even our first three example URLs, because it only
lets you match URLs exactly, by prefix or by file extension. What’s missing is a notion
of path parameters that match variable segments of the URL, using URL templates:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>/product/{ean}/<span class="keyword">edit</span>
/product/(\d+)/<span class="keyword">edit</span>
</pre></td></tr></table></figure>

<p>Here are several benefits of good URL design:</p>
<ul>
<li>A consistent public API —The URL scheme makes your application easier to
understand by providing an alternative machine-readable interface.</li>
<li>The URLs don’t change—Avoiding implementation-specifics makes the URLs sta-
ble, so they don’t change when the technology does.</li>
<li>Short URLs—Short URLs are more usable; they’re easier to type or paste into
other media, such as email or instant messages.</li>
</ul>
<h1 id="controllers-the-interface-between-http-and-scala">Controllers—the interface between HTTP and Scala</h1>
<p>Controllers are the application components that handle HTTP requests for application
resources identified by URLs.</p>
<p>In Play, you use controller classes to make your application respond to HTTP
requests for URLs, such as the product catalog URLs:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>/products
/product/<span class="number">5010255079763</span>
/product/<span class="number">5010255079763</span>/<span class="keyword">edit</span>
</pre></td></tr></table></figure>

<h2 id="controller-classes-and-action-methods">Controller classes and action methods</h2>
<p>We’ll start by defining a Products controller class, which will contain four action
methods for handling different kinds of requests: list, details , edit, and update</p>
<p>A controller is a Scala object that’s a subclass of <code>play.api.mvc.Controller</code> ,
which provides various helpers for generating actions. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="class"><span class="keyword">object</span> <span class="title">Products</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> list(pageNumber: Int) = Action {
    NotImplemented
  }
  <span class="keyword">def</span> detail(ean: Long) = Action {
    NotImplemented
  }
  <span class="keyword">def</span> edit(ean: Long) = Action {
    NotImplemented
  }
  <span class="keyword">def</span> update(ean: Long) = Action {
    NotImplemented
  }
}
</pre></td></tr></table></figure>

<p><strong>GROUP CONTROLLERS BY MODEL ENTITY</strong></p>
<p>Create one controller for each of the
key entities in your application’s high-level data model. For example, the four
key entities—Product, Order, Warehouse, and User—might correspond to a
data model with more than a dozen entities. In this case, it’d probably be a
good idea to have four controller classes: Products, Orders, Warehouses, and
Users. </p>
<p>In Play, each controller is a Scala object that defines one or more actions. Play uses an
object instead of a class because the controller doesn’t have any state; the controller is
used to group some actions.</p>
<p><strong>DON’T DEFINE A var IN A CONTROLLER OBJECT</strong></p>
<p>Each action is a Scala function that takes an HTTP request and returns an HTTP result.
<code>Request[A] =&gt; Result</code></p>
<p>The controller layer is therefore the mapping between stateless HTTP requests and
responses and the object-oriented model. In MVC terms, controllers process events
(HTTP requests in this case), which can result in updates to the model. Controllers are
also responsible for rendering views. </p>
<h2 id="http-and-the-controller-layer-s-scala-api">HTTP and the controller layer’s Scala API</h2>
<p>Play models controllers, actions, requests, and responses as Scala traits in the
<code>play.api.mvc</code> package—the Scala API for the controller layer.</p>
<p>MVC API traits and classes correspond to HTTP concepts and act as
wrappers for the corresponding HTTP data:</p>
<ul>
<li><code>play.api.mvc.Cookie</code> —An HTTP cookie: a small amount of data stored on the client and sent with subsequent requests</li>
<li><code>play.api.mvc.Request</code> —An HTTP request: HTTP method, URL, headers, body, and cookies</li>
<li><code>play.api.mvc.RequestHeader</code> —Request metadata: a name-value pair</li>
<li><code>play.api.mvc.Response</code> —An HTTP response, with headers and a body; wraps a Play Result</li>
<li><code>play.api.mvc.ResponseHeader</code>  —Response metadata: a name-value pair</li>
</ul>
<p>Play controllers use the following concepts in addition
to HTTP concepts:</p>
<ul>
<li><code>play.api.mvc.Action</code> — A function that processes a client Request
and returns a Result</li>
<li><code>play.api.mvc.Call</code> — An HTTP request: the combination of an HTTP method
and a URL</li>
<li><code>play.api.mvc.Content</code> — An HTTP response body with a particular content type</li>
<li><code>play.api.mvc.Controller</code> — A generator for Action functions</li>
<li><code>play.api.mvc.Flash</code> — A short-lived HTTP data scope used to set data for
the next request</li>
<li><code>play.api.mvc.Result</code> — The result of calling an Action to process a Request,
used to generate an HTTP response</li>
<li><code>play.api.mvc.Session</code> — A set of string keys and values,
stored in an HTTP cookie</li>
</ul>
<h2 id="action-composition">Action composition</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>def <span class="keyword">list</span> = Action {
  <span class="comment">// Check authentication.</span>
  <span class="comment">// Check for a cached result.</span>
  <span class="comment">// Process request...</span>
  <span class="comment">// Update cache.</span>
}

<span class="comment">// 可以这样写</span>
def <span class="keyword">list</span> =
  Authenticated {
    Cached {
      Action {
        <span class="comment">// Process request...</span>
      }
    }
  }
</pre></td></tr></table></figure>

<p>This example uses Action to create an action function that’s passed as a parameter to
Cached, which returns a new action function. This, in turn, is passed as a parameter to
Authenticated, which decorates the action function again.</p>
<h1 id="routing-http-requests-to-controller-actions">Routing HTTP requests to controller actions</h1>
<p>Once you have controllers that contain actions, you need a way to map different
request URLs to different action methods.</p>
<p>In Play, mapping the combination of an HTTP method and a URL to an action
method is called routing. </p>
<h2 id="router-configuration">Router configuration</h2>
<p>The great thing about this approach is that your web application’s URLs—its public
HTTP interface—are all specified in one place, which makes it easier for you to
maintain a consistent URL design.</p>
<p>The routes file structure is line-based: each line is either a blank line, a comment line,
or a route definition. A route definition has three parts on one line, separated by
whitespace.</p>
<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>GET / controllers<span class="preprocessor">.Products</span><span class="preprocessor">.home</span>()

GET /products  controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>()

GET /products controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>(page: Int ?= <span class="number">1</span>) <span class="preprocessor">## Option[Int]</span>

GET /products controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>(page: Int = <span class="number">1</span>) <span class="preprocessor">## Int</span>

GET /product/:ean controllers<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(ean: Long)

GET /product/:ean/edit controllers<span class="preprocessor">.Products</span><span class="preprocessor">.edit</span>(ean: Long)
</pre></td></tr></table></figure>

<p>The benefit of this format is that you can see your whole URL design in one place,
which makes it more straightforward to manage than if the URLs were specified in
many different files.</p>
<h2 id="matching-url-path-parameters-that-contain-forward-slashes">Matching URL path parameters that contain forward slashes</h2>
<pre><code>/photo/5010255079763.jpg
/photo/customer-submissions/5010255079763/42.jpg
/photo/customer-submissions/5010255079763/43.jpg
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="preprocessor">## 这样上面的配置不会匹配 斜杠(slash)</span>
<span class="keyword">GET</span> /photo/:file controllers.Media.photo(file: <span class="built_in">String</span>)

<span class="preprocessor">## 必须这样</span>
<span class="keyword">GET</span> /photo/*file controllers.Media.photo(file: <span class="built_in">String</span>)
</pre></td></tr></table></figure>

<h2 id="constraining-url-path-parameters-with-regular-expressions">Constraining URL path parameters with regular expressions</h2>
<p>为如下的url做匹配</p>
<pre><code>/product/5010255079763
/product/paper-clips-large-plain-1000-pack
</code></pre><p>正则表达式要写在<code>&lt;&gt;</code>里面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>GET /product/$ean&lt;\d{<span class="number">13</span>}&gt; controllers<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(ean: Long)

GET /product/:alias controllers<span class="preprocessor">.Products</span><span class="preprocessor">.alias</span>(alias: String)
</pre></td></tr></table></figure>

<h2 id="binding-http-data-to-scala-objects">Binding HTTP data to Scala objects</h2>
<p>Play, along with other modern web frameworks such as Spring MVC, improves on
treating HTTP request parameters as strings by performing type conversion before it
attempts to call your action method. </p>
<p>Here’s what happens when Play’s router handles the request <code>PUT /product/5010255079763</code></p>
<ol>
<li>The router matches the request against configured routes and selects the route:
<code>PUT /product/:ean controllers.Products.update(ean: Long)</code></li>
<li>The router binds the ean parameter using one of the type-specific binders—in
this case, the Long binder converts 5010255079763 to a Scala Long object</li>
<li>The router invokes the selected route’s Products.update action, passing
<code>5010255079763L</code> as a parameter.</li>
</ol>
<p>If you send an HTTP request for <code>/product/x</code>,
the binding will fail because x isn’t a number, and Play
will return an HTTP response with the 400 (Bad Request)
status code and an error page</p>
<h1 id="generating-http-calls-for-actions-with-reverse-routing">Generating HTTP calls for actions with reverse routing</h1>
<p>In addition to mapping incoming URL requests to controller actions,
a Play application can do the opposite: map a particular action
method invocation to the corresponding URL.</p>
<h2 id="hardcoded-urls">Hardcoded URLs</h2>
<p>The interesting part is what happens next, after the product is deleted.
Let’s suppose that after deleting the product,
we want to show the updated product list. We could
render the product list page directly, but this exposes us to the double-submit
problem: if the user “reloads” the page in a web browser,
this could result in a second call
to the delete action, which will fail because the specified product no longer exists.</p>
<p>The standard solution to the double-submit problem is the redirect-after-POST pattern:
after performing an operation that updates the application’s persistent state, the
web application sends an HTTP response that consists of an HTTP redirect.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>def <span class="operator"><span class="keyword">delete</span>(ean: Long) = <span class="keyword">Action</span> {
  Product.<span class="keyword">delete</span>(ean)
  Redirect(<span class="string">"/proudcts"</span>)
}</span>
</pre></td></tr></table></figure>

<p>This looks like it will do the job, but it doesn’t smell too nice because
we’ve hardcoded the URL in a string.</p>
<p>解决办法如下</p>
<h2 id="reverse-routing">Reverse routing</h2>
<p>You can do reverse routing by writing Scala code.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>def <span class="operator"><span class="keyword">delete</span>(ean: Long) = <span class="keyword">Action</span> {
  Product.<span class="keyword">delete</span>(ean)
  Redirect(routes.Products.list())
}</span>
</pre></td></tr></table></figure>

<p>Keeping these two points in mind:</p>
<ul>
<li>Routing is when URLs are routed to actions—left to right in the routes file</li>
<li>Reverse routing is when call definitions are “reversed” into URL s—right to left</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>scala&gt; val call = controllers.routes.Products.list()
scala&gt; val (<span class="function"><span class="keyword">method</span>, <span class="title">url</span>) = <span class="params">(call.<span class="keyword">method</span>, call.url)</span></span>
</pre></td></tr></table></figure>

<h1 id="generating-a-response">Generating a response</h1>
<p>An HTTP response consists of an HTTP status code, optionally followed by response
headers and a response body. Play gives you total control over all three, which lets you
craft any kind of HTTP response you like, but it also gives you a convenient API for
handling common cases.</p>
<h2 id="debugging-http-responses">Debugging HTTP responses</h2>
<p>To use cURL, use the <code>--request</code> option to specify the HTTP method and
<code>--include</code> to include HTTP response headers in the output</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">curl</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">request</span> <span class="comment">GET</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">include</span> <span class="comment">http://localhost:9000/products</span>
</pre></td></tr></table></figure>

<h2 id="response-body">Response body</h2>
<p>The response body will consist of this representation, in some particular format.</p>
<ul>
<li>Plain text—Such as an error message, or a lightweight web service response</li>
<li>HTML —A web page, including a representation of the resource as well as
application user-interface elements, such as navigation controls</li>
<li>JSON —A popular alternative to XML that’s better suited to Ajax applications</li>
<li>XML —Data accessed via a web service</li>
<li>Binary data—Typically nontext media such as a bitmap image or audio</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="comment">// plain text</span>
<span class="keyword">def</span> version = Action {
  Ok(<span class="string">"Version 2.0"</span>)
}

<span class="comment">// html</span>
<span class="keyword">def</span> index = Action {
  Ok(views.html.index())
}

<span class="comment">// json</span>
<span class="keyword">def</span> json = Action {
  <span class="keyword">import</span> play.api.libs.json.Json
  <span class="keyword">val</span> success = Map(<span class="string">"status"</span> -&gt; <span class="string">"success"</span>)
  <span class="keyword">val</span> json = Json.toJson(success)
  Ok(json)
}

<span class="comment">// scala.xml.NodeSeq</span>
<span class="keyword">def</span> xml = Action {
  Ok(&lt;status&gt;success&lt;/status&gt;)
}
</pre></td></tr></table></figure>

<h3 id="binary-data">BINARY DATA</h3>
<p>In Play, returning a binary result to the
web browser is the same as serving other formats: as with XML and JSON, pass the
binary data to a result type. </p>
<p>条形码生成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>val appDependencies = Se<span class="string">q(
  "net.sf.barcode4j" % "barcode4j" % "2.0"
)</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>def ean13Barcode(ean: Long, mimeType: String): Array[Byte] = {
  import java<span class="preprocessor">.io</span><span class="preprocessor">.ByteArrayOutputStream</span>
  import java<span class="preprocessor">.awt</span><span class="preprocessor">.image</span><span class="preprocessor">.BufferedImage</span>
  import org<span class="preprocessor">.krysalis</span><span class="preprocessor">.barcode</span>4j<span class="preprocessor">.output</span><span class="preprocessor">.bitmap</span><span class="preprocessor">.BitmapCanvasProvider</span>
  import org<span class="preprocessor">.krysalis</span><span class="preprocessor">.barcode</span>4j<span class="preprocessor">.impl</span><span class="preprocessor">.upcean</span><span class="preprocessor">.EAN</span>13Bean
  
  val BarcodeResolution = <span class="number">72</span>
  val output: ByteArrayOutputStream = new ByteArrayOutputStream
  val canvas: BitmapCanvasProvider =
    new BitmapCanvasProvider(output, mimeType,
          BarcodeResolution, BufferedImage<span class="preprocessor">.TYPE</span>_BYTE_BINARY, false, <span class="number">0</span>)
  val barcode = new EAN13Bean()
  
  barcode<span class="preprocessor">.generateBarcode</span>(canvas, String valueOf ean)
  canvas<span class="preprocessor">.finish</span>
  output<span class="preprocessor">.toByteArray</span>
}

// GET /barcode/:ean controllers<span class="preprocessor">.Products</span><span class="preprocessor">.barcode</span>(ean: Long)
def barcode(ean: Long) = Action {
  import java<span class="preprocessor">.lang</span><span class="preprocessor">.IllegalArgumentException</span>
  val MimeType = <span class="string">"image/png"</span>
  try {
    val imageData: Array[Byte] = ean13Barcode(ean, MimeType)
    Ok(imageData)<span class="preprocessor">.as</span>(MimeType)
  } catch {
    case e: IllegalArgumentException =&gt;
      BadRequest(<span class="string">"Could not generate bar code. Error: "</span> + e<span class="preprocessor">.getMessage</span>)
  }
}
</pre></td></tr></table></figure>

<h2 id="http-status-codes">HTTP status codes</h2>
<p>The simplest possible response that you might want to generate consists of only an
HTTP status line that describes the result of processing the request. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>def <span class="keyword">list</span> = Action { request =&gt;
  NotImplemented
}

<span class="comment">// 等同于</span>
def <span class="keyword">list</span> = Action {
  <span class="keyword">new</span> Status(<span class="number">501</span>)
}
</pre></td></tr></table></figure>

<p><em>NotImplemented</em> is one of many HTTP status codes that are defined in the
<code>play.api.mvc.Controller</code> class via the <code>play.api.mvc.Results</code> trait.</p>
<h2 id="response-headers">Response headers</h2>
<p>In addition to a status, a response may also include response headers:
metadata that instructs HTTP clients how to handle the response</p>
<pre><code>HTTP/1.1 501 Not Implemented
Content-Length: 0
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Status(FOUND)<span class="preprocessor">.withHeaders</span>(LOCATION -&gt; url)

val url = routes<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(product<span class="preprocessor">.ean</span>)<span class="preprocessor">.url</span>
Created<span class="preprocessor">.withHeaders</span>(LOCATION -&gt; url)
</pre></td></tr></table></figure>

<h3 id="setting-the-content-type">SETTING THE CONTENT TYPE</h3>
<p>Every HTTP response that has a response body also has a Content-Type header,
whose value is the MIME type that describes the response body format.</p>
<p>Play automatically sets
the content type for supported types, such as text/html when rendering an HTML
template, or text/plain when you output a string response.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">val</span> json = <span class="string">"""{ "status": "success" }"""</span>
Ok(json).withHeaders(CONTENT_TYPE -&gt; <span class="string">"application/json"</span>)

<span class="comment">// 也可以这样</span>
Ok(<span class="string">"""{ "status": "success" }"""</span>).as(<span class="string">"application/json"</span>)

<span class="comment">//  JSON is defined in the play.api.http.ContentTypes trait</span>
<span class="comment">//  which Controller extends.</span>
Ok(<span class="string">"""{ "status": "success" }"""</span>).as(JSON)
</pre></td></tr></table></figure>

<p>Play sets the content type automatically for some more types:
Play selects <code>text/xml</code> for
<code>scala.xml.NodeSeq</code> values, and <code>application/json</code>
for <code>play.api.libs.json.JsValue</code> values.</p>
<h3 id="session-data">SESSION DATA</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Ok(results)<span class="preprocessor">.withSession</span>(
  request<span class="preprocessor">.session</span> + (<span class="string">"search.previous"</span> -&gt; query)
)

Ok(results)<span class="preprocessor">.withSession</span>(
  request<span class="preprocessor">.session</span> - <span class="string">"search.previous"</span>
)
</pre></td></tr></table></figure>

<p>The session is implemented as an HTTP session cookie, which means that
its total size is limited to a few kilobytes.</p>
<p><strong>DON’T CACHE DATA IN THE SESSION COOKIE</strong> Don’t try to use session data as a
cache to improve performance by avoiding fetching data from server-side
persistent storage. Apart from the fact that session data is limited to the 4 KB of data
that fits in a cookie, this will increase the size of subsequent HTTP requests,
which will include the cookie data, and may make performance worse overall.</p>
<p>The canonical use case for session cookies is to identify the currently authenticated
user.  You can load user-specific data from a persistent data model instead.</p>
<p>The session Play cookie is signed using the application secret key as a salt to pre-
vent tampering.</p>
<h3 id="flash-data">FLASH DATA</h3>
<p>Displaying a message when handling the next request, after a redirect, is such a
common use case that Play provides a special session scope called flash scope.</p>
<p>Flash scope works the same way as the session, except that any data
that you store is only available when processing the next HTTP request,
after which it’s automatically deleted. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>// 设置
Redirect(routes<span class="preprocessor">.Products</span><span class="preprocessor">.flash</span>())<span class="preprocessor">.flashing</span>(
  <span class="string">"info"</span> -&gt; <span class="string">"Product deleted!"</span>
)

// 获取
val message = request<span class="preprocessor">.flash</span>(<span class="string">"info"</span>)
</pre></td></tr></table></figure>

<h3 id="setting-cookies">SETTING COOKIES</h3>
<p>Cookies store small amounts of data in an HTTP client, such as a web browser on a
specific computer.</p>
<p>If you do need to use cookies, you can use the Play API to
create cookies and add them to the response, and to read them from the request.</p>
<p><strong>AVOID USING COOKIES</strong></p>
<h2 id="serving-static-content">Serving static content</h2>
<p>Not everything in a web application is dynamic content: a typical web application also
includes static files, such as images, JavaScript files, and CSS stylesheets. Play serves
these static files over HTTP the same way it serves dynamic responses: by routing an
HTTP request to a controller action.</p>
<h3 id="using-the-default-configuration">USING THE DEFAULT CONFIGURATION</h3>
<p>Put files and folders inside your application’s <code>public/</code> folder and access
them using the URL path <code>/assets</code>, followed by the path relative to public.</p>
<p><code>public/images/favicon.png</code> 访问 <code>http://localhost:9000/assets/images/favicon.png</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;link href=<span class="string">"/assets/images/favicon.png"</span> rel=<span class="string">"shortcut icon"</span> <span class="keyword">type</span>=<span class="string">"image/png"</span>/&gt;
</pre></td></tr></table></figure>

<p><code>conf/routes</code> 的默认配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>GET /assets/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public"</span>, <span class="type">file</span>)
GET /images/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public/images"</span>, <span class="type">file</span>)
GET /styles/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public/styles"</span>, <span class="type">file</span>)
</pre></td></tr></table></figure>

<h3 id="using-an-asset-s-reverse-route">USING AN ASSET’S REVERSE ROUTE</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>&lt;link href=<span class="string">"@routes.Assets.at("</span>images/favicon.png<span class="string">")"</span>
      rel=<span class="string">"shortcut icon"</span> <span class="class"><span class="keyword">type</span>=</span><span class="string">"image/png"</span>&gt;

&lt;link href=<span class="string">"@routes.Assets.at("</span>/<span class="keyword">public</span>/images<span class="string">", "</span>favicon.png<span class="string">")"</span>
      rel=<span class="string">"shortcut icon"</span> <span class="class"><span class="keyword">type</span>=</span><span class="string">"image/png"</span>&gt;
</pre></td></tr></table></figure>

<h3 id="caching-and-etags">CACHING AND ETAGS</h3>
<p>In addition to reverse routing, another benefit of using the assets controller
is its builtin caching support, using an HTTP Entity Tag (ET ag).
This allows a web client to make conditional HTTP requests for a resource
so that the server can tell the client it can
use a cached copy instead of returning a resource that hasn’t changed.</p>
<p>Once it has an ET ag value, an HTTP client can make a conditional request, which
means “only give me this resource if it hasn’t been modified since I got the version
with this ET ag.”</p>
<pre><code>If-None-Match: 978b71a4b1fef4051091b31e22b75321c7ff0541
</code></pre><p>When this header is included in the request, and the favicon.png file hasn’t been
modified (it has the same ETag value), then Play’s assets controller will return the fol-
lowing response, which means “you can use your cached copy”:</p>
<pre><code>HTTP/1.1 304 Not Modified
Content-Length: 0
</code></pre><h3 id="compressing-assets-with-gzip">COMPRESSING ASSETS WITH GZIP</h3>
<p>HTTP compression is a feature of modern web servers and web clients that helps
address page sizes by sending compressed versions of resources over HTTP .</p>
<p>The way this works is that the web browser indicates that it can handle a com-
pressed response by sending an HTTP request header such as <code>Accept-Encoding:gzip</code>
that specifies supported compression methods. </p>
<p>In Play, HTTP compression is transparently built into the assets controller, which can
automatically serve a compressed version of a static file, if it’s available, and if gzip is
supported by the HTTP client. This happens when all of the following are true:</p>
<ul>
<li>Play is running in prod mode (production mode is explained in chapter 9); HTTP
compression isn’t expected to be used during development.</li>
<li>Play receives a request that’s routed to the assets controller.</li>
<li>The HTTP request includes an Accept-Encoding: gzip header.</li>
<li>The request maps to a static file, and a file with the same name but with an
additional <code>.gz</code> suffix is found.</li>
</ul>
<p>所以必须要先运行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>gzip --best &lt; ui<span class="preprocessor">.js</span> &gt; ui<span class="preprocessor">.js</span><span class="preprocessor">.gz</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[传智播客day64-NoSql]]></title>
    <link href="http://zhpooer.github.io/2014/08/09/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2day64-nosql/"/>
    <id>http://zhpooer.github.io/2014/08/09/传智播客day64-nosql/</id>
    <published>2014-08-09T01:01:04.000Z</published>
    <updated>2014-08-10T01:04:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nosql-">NoSql 简介</h1>
<p>Not Only SQL, 一系列非关系型数据库的总称</p>
<p>关系型数据库中的表存储一些格式化数据结构,
每条记录的字段的组成都一样, 即使不是每条记录都需要所有字段</p>
<p>非关系型数据库以键值对存储, 结构不固定, 每一条记录可以有不一样的键,
每条记录可以根据需要增加一些自己的键值对.</p>
<p>常见的Nosql</p>
<ul>
<li>CouchDB</li>
<li>Redis</li>
<li>Neo4j</li>
<li>HBase</li>
<li>BigTable</li>
<li>Tair</li>
</ul>
<p>优势</p>
<ul>
<li>简单扩展</li>
<li>快速读写</li>
<li>低廉成本</li>
<li>灵活的数据模型 json</li>
</ul>
<p>不足</p>
<ul>
<li>不提供对SQL的支持</li>
<li>特性不够丰富</li>
<li>现有产品不够成熟</li>
<li>事务支持不够好</li>
</ul>
<h1 id="mongodb-">MongoDB 数据库</h1>
<p>C++语言编写, 高性能 易部署 易使用</p>
<ul>
<li>面向集合存储, json</li>
<li>模式自由</li>
<li>支持动态查询</li>
<li>支持完全索引</li>
<li>支持复制和故障恢复</li>
<li>使用高效的二进制数据存储, 包括大型对象</li>
<li>文件存储格式为 BSON</li>
</ul>
<p>关系型数据库和 mongodb 对应情况</p>
<table>
<thead>
<tr>
<th>关系数据库</th>
<th>mongodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库</td>
<td>数据库</td>
</tr>
<tr>
<td>表</td>
<td>集合</td>
</tr>
<tr>
<td>行</td>
<td>文档</td>
</tr>
</tbody>
</table>
<p>文档(document) 是 Mongodb 的最基本对象, 都有一个 objectId, <code>{&quot;id&quot;: ObjectId()}</code></p>
<p>集合(collection)是文档的聚合</p>
<p>0 和 1 也可以表示 true 或 false</p>
<p>数字类型64位浮点数, 整数都会被转换成64位浮点数</p>
<h2 id="-">安装</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="attribute">mongod --dbpath</span>=<span class="string">/var/any
mongo</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="preprocessor">## 创建或者切换</span>
use mydb1;
<span class="preprocessor">## 查看当前数据库</span>
db;
<span class="preprocessor">## 删除数据库</span>
db.dropDatabase();

<span class="preprocessor">## 查看所有数据库信息</span>
show dbs;
</pre></td></tr></table></figure>

<h2 id="-">建表</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="code"><pre><span class="preprocessor">## 查看集合</span>
show collections<span class="comment">;</span>
show tables<span class="comment">;</span>


<span class="preprocessor">## 创建集合</span>
db<span class="preprocessor">.createCollections</span>(<span class="string">"erdan"</span>)<span class="comment">;</span>
<span class="preprocessor">## 也可以这样创建集合, 隐式创建</span>
db<span class="preprocessor">.collectionName</span><span class="preprocessor">.insert</span>({})<span class="comment">;</span>

<span class="preprocessor">## 删除集合</span>
db<span class="preprocessor">.collectionName</span><span class="preprocessor">.drop</span>()<span class="comment">;</span>

<span class="preprocessor">## 插入文档</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.insert</span>({name:<span class="string">"xxx"</span>, age:<span class="number">18</span>, city:<span class="string">"shanghai"</span>})<span class="comment">;</span>

<span class="preprocessor">## 删除文档</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.remove</span>({name:<span class="string">"xxx"</span>, age:<span class="number">18</span>, city:<span class="string">"shanghai"</span>})<span class="comment">;</span>

<span class="preprocessor">## 查询</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="comment">;</span>

for(var i=<span class="number">1</span><span class="comment">;i&lt;=10000;1++) {</span>
   db<span class="preprocessor">.drhuo</span><span class="preprocessor">.insert</span>({name: <span class="string">"erhuo"</span>+i, age: i, city: <span class="string">"tokyo"</span>})<span class="comment">;</span>
}

<span class="preprocessor">## 显示name字段</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.findOne</span>({}, name:true)<span class="comment">;</span>
<span class="preprocessor">## 除了不显示name, 其他都显示</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.findOne</span>({}, {name: <span class="number">0</span>})<span class="comment">;</span>

<span class="preprocessor">## 删除名字为 erhuo1</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.remove</span>({name: <span class="string">"erhuo1"</span>})<span class="comment">;</span>

var m = db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="comment">;</span>
m<span class="preprocessor">.next</span>()<span class="comment">;</span>

<span class="preprocessor">## 条件查找</span>
<span class="preprocessor">## 大于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$gt:value}})<span class="comment">;</span>
<span class="preprocessor">## 小于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$lt:value}})<span class="comment">;</span>
<span class="preprocessor">## 大于等于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$gte:value}})<span class="comment">;</span>
<span class="preprocessor">## 小于等于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$lte:value}})<span class="comment">;</span>
<span class="preprocessor">## 不等于</span>
db<span class="preprocessor">.collection</span><span class="preprocessor">.find</span>({field:{$ne:value}})<span class="comment">;</span>

<span class="preprocessor">## 统计</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.count</span>()<span class="comment">;</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.count</span>()<span class="comment">;</span>
<span class="preprocessor">## 按age升序排序, -1 为降序</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.sort</span>({age:<span class="number">1</span>})<span class="comment">;</span>

<span class="preprocessor">## 分页</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.skip</span>(<span class="number">3</span>)<span class="preprocessor">.limit</span>(<span class="number">4</span>)<span class="comment">;</span>

<span class="preprocessor">## 不管分页, 列出所有数据的大小</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.skip</span>(<span class="number">3</span>)<span class="preprocessor">.limit</span>(<span class="number">4</span>)<span class="preprocessor">.count</span>(<span class="number">0</span>)<span class="comment">;</span>
<span class="preprocessor">## 列出分页数据</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>()<span class="preprocessor">.skip</span>(<span class="number">3</span>)<span class="preprocessor">.limit</span>(<span class="number">4</span>)<span class="preprocessor">.count</span>(<span class="number">1</span>)<span class="comment">;</span>

db<span class="preprocessor">.c</span>2<span class="preprocessor">.insert</span>({name:<span class="string">"user1"</span>, post:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]})<span class="comment">;</span>
<span class="preprocessor">## 查询包含关系</span>
<span class="preprocessor">## 全部满足</span>
db<span class="preprocessor">.c</span>2<span class="preprocessor">.find</span>({post:{$all:[<span class="number">1</span>, <span class="number">2</span>]}})
<span class="preprocessor">## 只要有一个满足</span>
db<span class="preprocessor">.c</span>2<span class="preprocessor">.find</span>({post:{$<span class="keyword">in</span>:[<span class="number">1</span>, <span class="number">2</span>]}})
<span class="preprocessor">## notin</span>
db<span class="preprocessor">.c</span>2<span class="preprocessor">.find</span>({post:{$nin:[<span class="number">1</span>, <span class="number">2</span>]}})

<span class="preprocessor">## 常用操作</span>
db<span class="preprocessor">.customer</span><span class="preprocessor">.find</span>({$<span class="keyword">or</span>:[{name: <span class="string">"a"</span>}, {age: <span class="number">11</span>}]})

<span class="preprocessor">## 1 表示存在, 0 表示不存在, 存在name字段的文档</span>
db<span class="preprocessor">.customer</span><span class="preprocessor">.find</span>({name: {$exist: <span class="number">1</span>}})<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="-">更新</h2>
<p><code>db.collection.update(criteria, objNew, upsert, multi)</code></p>
<ul>
<li><code>criteria</code>, 查询条件的对象</li>
<li><code>objNew</code>, 根系内容的对象</li>
<li><code>upsert</code>, 如果记录已经更新, 更新它, 否则新增一个记录</li>
<li><code>multi</code>, 如果符合多个记录是否全部更新</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>## 覆盖更新
<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">address</span>:<span class="value"><span class="string">"abc"</span></span></span></span>}, <span class="rules">{<span class="rule"><span class="attribute">address</span>:<span class="value"> <span class="string">"bj"</span></span></span></span>});

<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">name</span>:<span class="value"><span class="string">"user1"</span></span></span></span>}, <span class="rules">{<span class="rule">$<span class="attribute">set</span>:<span class="value">{address: <span class="string">"bj"</span></span></span></span>}}, 0, 1)

## <span class="tag">age</span> + 1
<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">name</span>:<span class="value"><span class="string">"user1"</span></span></span></span>}, <span class="rules">{<span class="rule">$<span class="attribute">inc</span>:<span class="value">{age: <span class="number">1</span></span></span></span>}}, 0, 1)

## 删除键
<span class="tag">db</span><span class="class">.itcast</span><span class="class">.update</span>(<span class="rules">{<span class="rule"><span class="attribute">name</span>:<span class="value"><span class="string">"user1"</span></span></span></span>}, <span class="rules">{<span class="rule">$<span class="attribute">unset</span>:<span class="value">{address: <span class="number">1</span></span></span></span>}}, 0, 1)
</pre></td></tr></table></figure>

<h1 id="-">索引</h1>
<p>用来加速查询速度的</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="preprocessor">## 查询性能</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>({name: <span class="string">"erhuo12"</span>})<span class="preprocessor">.explain</span>()<span class="comment">;</span>

<span class="preprocessor">## 给 name 创建普通索引</span>
db<span class="preprocessor">.erhuo</span><span class="preprocessor">.ensureIndex</span>({name:<span class="number">1</span>})<span class="comment">;</span>

<span class="preprocessor">## 查看系统表相关参数</span>
db<span class="preprocessor">.user</span><span class="preprocessor">.state</span>()<span class="comment">;</span>

db<span class="preprocessor">.erhuo</span><span class="preprocessor">.find</span>({name: <span class="string">"erhuo12"</span>})<span class="preprocessor">.explain</span>()<span class="comment">;</span>

<span class="preprocessor">## 查看生成的索引</span>
db<span class="preprocessor">.system</span><span class="preprocessor">.indexes</span><span class="preprocessor">.find</span>()<span class="comment">;</span>

<span class="preprocessor">## 删除索引</span>
<span class="preprocessor">## 如果删除集合, 那么也会删除索引</span>
db<span class="preprocessor">.user</span><span class="preprocessor">.dropIndex</span>({name:<span class="number">1</span>})<span class="comment">;</span>

<span class="preprocessor">## 创建唯一索引, 相当于唯一约束</span>
db<span class="preprocessor">.user</span><span class="preprocessor">.ensureIndex</span>({name:<span class="number">1</span>}, {unique:<span class="number">1</span>})<span class="comment">;</span>
</pre></td></tr></table></figure>

<h2 id="-">固定集合</h2>
<p>事先创建而且大小固定的集合, 如果空间不足最早的文旦会被删除,
适用于任何想要自动淘汰过期的属性的场景, 如日志</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>## <span class="keyword">size</span>指定文档大小 单位KB, <span class="keyword">max</span> 指文档数量
db.createCollection(<span class="string">"collectionName"</span>, {capped: true, <span class="keyword">size</span>:<span class="number">10000</span>, <span class="keyword">max</span>: <span class="number">100</span>});
</pre></td></tr></table></figure>

<h1 id="-">数据库备份和恢复</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">## 备份数据</span>
mongodump -h dbhose <span class="operator">-d</span> dbname -o dbdirectory

<span class="comment">## 恢复数据</span>
mongorestore -h localhost <span class="operator">-d</span> test dbdirectory
</pre></td></tr></table></figure>

<h1 id="-">导入和导出</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>mongoexport <span class="attribute">-h</span> dbhost <span class="attribute">-d</span> dbname <span class="attribute">-c</span> collectioName <span class="attribute">-o</span> output

mongoimport <span class="attribute">-h</span> dbhost <span class="attribute">-d</span> dbname <span class="attribute">-c</span> collectioName output
</pre></td></tr></table></figure>

<h1 id="-">安全和认证</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">use</span> <span class="title">admin</span>;
<span class="comment">## 创建超级管理员</span>
db.addUser(<span class="string">"root"</span>, <span class="string">"root"</span>);

<span class="keyword">use</span> <span class="title">test</span>;
db.addUser(<span class="string">"zhangshan"</span>, <span class="string">"123"</span>);
<span class="comment">## 创建只读用户</span>
db.addUser(<span class="string">"lisi"</span>, <span class="string">"123"</span>, <span class="keyword">true</span>);

<span class="comment">## 运行服务, 并且开启安全检查</span>
mongod --dbpath --auth

<span class="comment">## 登陆, 验证用户</span>
db.auth(<span class="string">"zhangshan"</span>, <span class="string">"123"</span>);
</pre></td></tr></table></figure>

<h1 id="-">配置集群 副本集</h1>
<p>实时更新 复制 备份</p>
<h2 id="-">主从复制</h2>
<p>主从复制是MongoDB最常用的复制方式。这种方式非常灵活，可用于备份、故障恢复、读
扩展等。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">##</span> <span class="comment">创建主节点</span>
<span class="comment">mongod</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dbpath=/tmp/master</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">10000</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">master</span>
<span class="comment">##</span> <span class="comment">创建从节点</span>
<span class="comment">mongod</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">dbpath=/tmp/slave</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">10001</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">slave</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">source</span> <span class="comment">localhost:10000</span>
</pre></td></tr></table></figure>

<p>启动成功后就可以连接主节点进行操作了，而这些操作会同步到从节点.</p>
<h2 id="-">副本集</h2>
<p>主从集群和副本集最大的区别就是副本集没有固定的“主节点”； 
整个集群会选出一个“主节点”，当其挂掉后，又在剩下的从节点 
中选中其他节点为“主节点”，副本集总有一个活跃点(primary)
和一个或多个备份节点(secondary)。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="preprocessor">## 启动节点一, 默认为主节点</span>
<span class="title">mongod</span> <span class="comment">--dbpath E:\mogodb\dbs\node1 --logpath E:\mogodb\logs\node1\logs.txt --logappend</span>
<span class="comment">--port 10001 --replSet itcast/localhost:10002,localhost:10003 --master</span>

<span class="preprocessor">## 启动节点二</span>
<span class="title">mongod</span> <span class="comment">--dbpath E:\mogodb\dbs\node2 --logpath E:\mogodb\logs\node2\logs.txt --logappend</span>
<span class="comment">--port 10002 --replSet itcast/localhost:10001</span>

<span class="preprocessor">## 启动节点三</span>
<span class="title">mongod</span> <span class="comment">--dbpath E:\mogodb\dbs\node3 --logpath E:\mogodb\logs\node3\logs.txt --logappend</span>
<span class="comment">--port 10003 --replSet itcast/localhost:10001,localhost:10002</span>

<span class="preprocessor">## 连上 节点一</span>
<span class="title">mongo</span> localhost:<span class="number">10001</span>/admin

<span class="preprocessor">## 初始化副本集</span>
<span class="title">db</span>.runCommand({<span class="string">"replSetInitiate"</span>:{<span class="string">"_id"</span>:<span class="string">"itcast"</span>,<span class="string">"members"</span>:[
   {<span class="string">"_id"</span>:<span class="number">1</span>,<span class="string">"host"</span>:<span class="string">"localhost:10001"</span>,<span class="string">"priority"</span>:<span class="number">3</span>},
   {<span class="string">"_id"</span>:<span class="number">2</span>,<span class="string">"host"</span>:<span class="string">"localhost:10002"</span>,<span class="string">"priority"</span>:<span class="number">2</span>},
   {<span class="string">"_id"</span>:<span class="number">3</span>,<span class="string">"host"</span>:<span class="string">"localhost:10003"</span>,<span class="string">"priority"</span>:<span class="number">1</span>}]}});

<span class="preprocessor">## 查询是否主库</span>
<span class="title">db</span>.$cmd.findOne ( {ismaster: <span class="number">1</span> } );
</pre></td></tr></table></figure>

<h2 id="-">分片</h2>
<p>分片(sharding)是指将数据拆分，将其分散存在不同的机器上的过程。有时也用分区
(partitioning)来表示这个概念。将数据分散到不同的机器上，不需要功能强大的大型计算机
就可以储存更多的数据，处理更多的负载。 </p>
<p>分片之前要运行一个路由进程，该进程名为 mongos。这个路由器知道所有数据
的存放位置，所以应用可以连接它来正常发送请求。对应用来说，它仅知道连接了一个普通
的 mongod。路由器知道数据和片的对应关系，能够转发请求到正确的片上。如果请求有了
回应，路由器将其收集起来回送给应用。</p>
<p>config 指明数据存放规则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="preprocessor">## 启动 config 配置服务</span>
mongod --dbpath E:\mogodb\sharding\config_node --port <span class="number">2222</span>

<span class="preprocessor">## 启动分片服务, 连接config服务</span>
mongos --port <span class="number">3333</span> --configdb=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">2222</span>

<span class="preprocessor">## 启动分片一 和 二</span>
mongod --dbpath E:\mogodb\sharding\mongod_node1 --port <span class="number">4444</span>
mongod --dbpath E:\mogodb\sharding\mongod_node2 --port <span class="number">5555</span>

<span class="preprocessor">## 连接分片服务器, 并添加分片一 和 分片二</span>
mongo localhost:<span class="number">3333</span>/admin
db.runCommand({<span class="string">"addshard"</span>:<span class="string">"localhost:4444"</span>,<span class="string">"allowLocal"</span>:<span class="literal">true</span>});
db.runCommand({<span class="string">"addshard"</span>:<span class="string">"localhost:5555"</span>,<span class="string">"allowLocal"</span>:<span class="literal">true</span>});

<span class="preprocessor">## 开启数据库 test 的分片服务</span>
db.runCommand({<span class="string">"enablesharding"</span>:<span class="string">"test"</span>});

<span class="preprocessor">## 指定分片的片键</span>
<span class="preprocessor">## 对test.person表进行分片, 根据 name 键, 进行分片</span>
db.runCommand({<span class="string">"shardcollection"</span>:<span class="string">"test.person"</span>,<span class="string">"key"</span>:{name:<span class="number">1</span>}});

<span class="preprocessor">## 查看分片情况</span>
db.printShardingStatus();
</pre></td></tr></table></figure>

<h1 id="java-mongodb">Java 操作 MongoDB</h1>
<p>导入 <code>mongo.jar</code></p>
<p>查找</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>Mongo mongo = <span class="keyword">new</span> Mongo(<span class="string">"localost"</span>, <span class="number">27017</span>);
DB db = mongo.getDB(<span class="string">"test"</span>);

<span class="comment">// 获得集合</span>
DBCollection collection = db.getCollection(<span class="string">"customers"</span>);
<span class="comment">// 获得结果集</span>
DBCursor dbCursor = collection.find();
<span class="keyword">while</span>(dbCursor.hasNext()) {
  DBObject dbObject = dbCursor.next();
  <span class="built_in">Object</span> name = dbObject.<span class="keyword">get</span>(<span class="string">"name"</span>);
  <span class="built_in">Object</span> age = dbObject.<span class="keyword">get</span>(<span class="string">"age"</span>);
}
<span class="comment">// 关闭资源</span>
mongo.close();
</pre></td></tr></table></figure>

<p>增加</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Mongo mongo = new Mongo(<span class="string">"localost"</span>, <span class="number">27017</span>)<span class="comment">;</span>
DB db = mongo<span class="preprocessor">.getDB</span>(<span class="string">"test"</span>)<span class="comment">;</span>

// 获得集合
DBCollection collection = db<span class="preprocessor">.getCollection</span>(<span class="string">"customers"</span>)<span class="comment">;</span>

DBObject db0 = new BasicDBObject()<span class="comment">;</span>
db0<span class="preprocessor">.put</span>(<span class="string">"name"</span>, <span class="string">"leo"</span>)<span class="comment">;</span>
db0<span class="preprocessor">.put</span>(<span class="string">"age"</span>, test)<span class="comment">;</span>
collection<span class="preprocessor">.insert</span>(db0)<span class="comment">;</span>

mongo<span class="preprocessor">.close</span>()<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>Mongo mongo = <span class="built_in">new</span> Mongo(<span class="string">"localhost"</span>,<span class="number"> 5555</span>);

DB db = mongo.getDB(<span class="string">"test"</span>);

DBCollection personCollection = db.getCollection(<span class="string">"person"</span>);

DBObject o= <span class="built_in">new</span> BasicDBObject();
o.put(<span class="string">"name"</span>, <span class="string">"erdan"</span>);
o.put(<span class="string">"age"</span>,<span class="number"> 30</span>);

<span class="comment">//更改的时候 ,如果以”_id去更改”,那么同样的要以传递ObjectId,</span>
<span class="comment">// 不能直接将id值以字符串的形式传过去</span>
DBObject q = <span class="built_in">new</span> BasicDBObject(<span class="string">"_id"</span>, <span class="built_in">new</span> ObjectId(<span class="string">"525f495bf422c198b9a69bbc"</span>));

<span class="comment">// update方法重载了很多次,这里以这个为例.</span>
WriteResult result = personCollection.update(q , o);

mongo.<span class="built_in">close</span>();
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="传智播客" scheme="http://zhpooer.github.io/tags/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2/"/>
    
      <category term="NoSql" scheme="http://zhpooer.github.io/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Deconstructing Play]]></title>
    <link href="http://zhpooer.github.io/2014/08/08/play-for-scala-deconstructing-play/"/>
    <id>http://zhpooer.github.io/2014/08/08/play-for-scala-deconstructing-play/</id>
    <published>2014-08-08T07:53:21.000Z</published>
    <updated>2014-08-09T08:05:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="drawing-the-architectural-big-picture">Drawing the architectural big picture</h1>
<p>When a web client sends HTTP requests to a Play application,
the request is handled by the embedded HTTP server,
which provides the Play framework’s network
interface. The server forwards the request data to the Play framework,
which generates a response that the server sends to the client.</p>
<h2 id="the-play-server">The Play server</h2>
<p>Play’s HTTP server is JBoss Netty, one of several Java NIO non-blocking servers.</p>
<p>When you use a web framework that’s based on the Java Servlet API,
you package your web application as some kind of archive that
you deploy to an application
server such as Tomcat, which runs your application. </p>
<p>With the Play framework it’s different:
Play includes its own embedded HTTP server, so you don’t need a separate
application server to run your application.</p>
<h2 id="mvc">MVC</h2>
<p>The MVC design pattern separates an application’s logic and data from the user
interface’s presentation and interaction,
maintaining a loose coupling between the separate components.</p>
<p>The Play framework achieves all of this with fewer layers than traditional Java EE
web frameworks by using the controller API to expose the HTTP directly, using HTTP
concepts, instead of trying to provide an abstraction on top of it. </p>
<h2 id="rest">REST</h2>
<p>REST is an architectural style that characterizes the way HTTP
works, featuring constraints such as stateless client-server
interaction and a uniform interface.</p>
<h1 id="application-configuration">Application configuration</h1>
<p>Play creates an initial configuration file for you, and almost all of the
many configuration parameters are optional, with sensible defaults,
so you don’t need to set them all yourself.</p>
<h2 id="creating-the-default-configuration">Creating the default configuration</h2>
<p><code>conf/application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>application<span class="preprocessor">.secret</span>=<span class="string">"l:2e&gt;xI9kj@GkHu?K9D[L5OU=Dc&lt;8i6jugIVE^[`?xSF]udB8ke"</span>
application<span class="preprocessor">.langs</span>=<span class="string">"en"</span>

logger<span class="preprocessor">.root</span>=ERROR
logger<span class="preprocessor">.play</span>=INFO
logger<span class="preprocessor">.application</span>=DEBUG
</pre></td></tr></table></figure>

<h2 id="configuration-file-format">Configuration file format</h2>
<p>Play uses the Typesafe config library (<a href="https://github.com/typesafehub/config" target="_blank">https://github.com/typesafehub/config</a>).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.Cache</span>=DEBUG
logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.CacheManager</span>=${logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.Cache</span>}
logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.store</span><span class="preprocessor">.MemoryStore</span>=${logger<span class="preprocessor">.net</span><span class="preprocessor">.sf</span><span class="preprocessor">.ehcache</span><span class="preprocessor">.Cache</span>}

log<span class="preprocessor">.directory</span> = /var/log
log<span class="preprocessor">.access</span> = ${log<span class="preprocessor">.directory</span>}/access<span class="preprocessor">.log</span>
log<span class="preprocessor">.errors</span> = ${log<span class="preprocessor">.directory</span>}/errors<span class="preprocessor">.log</span>
</pre></td></tr></table></figure>

<h3 id="include">include</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">db</span>: <span class="rules">{
  <span class="rule"><span class="attribute">default</span>:<span class="value"> {
    driver: <span class="string">"org.h2.Driver"</span>,
    url: <span class="string">"jdbc:h2:mem:play"</span>,
    user: <span class="string">"sa"</span>,
    password: <span class="string">""</span>,
  </span></span></span>}
}
</pre></td></tr></table></figure>

<p><code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>include <span class="string">"db-default.conf"</span>
<span class="preprocessor"># override user name and password</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.user</span> = products
db<span class="preprocessor">.default</span><span class="preprocessor">.password</span> = clippy
</pre></td></tr></table></figure>

<h3 id="merging-values-from-multiple-files">MERGING VALUES FROM MULTIPLE FILES</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="label">db:</span> {
  default: {
    user: <span class="string">"products"</span>
    password: <span class="string">"clippy must die!"</span>
    logStatements: true
  }
}
// 方式二, 加逗号
<span class="label">db:</span> {
  default: {
    user: <span class="string">"products"</span>,
    password: <span class="string">"clippy must die!"</span>,
    logStatements: true,
  }
}
// 方式三
db<span class="preprocessor">.default</span><span class="preprocessor">.driver</span> = org<span class="preprocessor">.h</span>2<span class="preprocessor">.Driver</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.url</span> = jdbc:h2:mem:play
db<span class="preprocessor">.default</span><span class="preprocessor">.user</span> = products
db<span class="preprocessor">.default</span><span class="preprocessor">.password</span> = <span class="string">"clippy must die!"</span>
db<span class="preprocessor">.default</span><span class="preprocessor">.logStatements</span> = true
</pre></td></tr></table></figure>

<p>The configuration format is specified in detail by the Human-Optimized Config
Object Notation (HOCON )
specification (<a href="https://github.com/typesafehub/config/blob/master/HOCON.md" target="_blank">https://github.com/typesafehub/config/blob/master/HOCON.md</a>).</p>
<h3 id="configuration-file-overrides">Configuration file overrides</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>start -Ddb<span class="preprocessor">.default</span><span class="preprocessor">.url</span>=postgres://localhost:products@clippy/products

run -Dconfig<span class="preprocessor">.file</span>=conf/production<span class="preprocessor">.conf</span>
run -Dconfig<span class="preprocessor">.file</span>=/etc/products/production<span class="preprocessor">.conf</span>
</pre></td></tr></table></figure>

<h3 id="custom-application-configuration">Custom application configuration</h3>
<p>For example, suppose you want to display version information in your web applica-
tion’s page footer.
<code>application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">application.revision </span>=<span class="string"> 42</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>@import play<span class="preprocessor">.api</span><span class="preprocessor">.Play</span><span class="preprocessor">.current</span>
&lt;footer&gt;
Revision @current<span class="preprocessor">.configuration</span><span class="preprocessor">.getString</span>(<span class="string">"application.revision"</span>)
&lt;/footer&gt;
</pre></td></tr></table></figure>

<p>The getString method returns an Option[String] rather than a String, but the
template outputs the value or an empty string, depending on whether the Option has
a value.</p>
<h1 id="the-model-adding-data-structures-and-business-logic">The model—adding data structures and business logic</h1>
<p>The model contains the application’s domain-specific data and logic.</p>
<p>This data is usually kept in persistent storage, such as a relational database,
in which case the model handles persistence.</p>
<p>In a layered application architecture, the domain-specific logic is usually called
business logic and doesn’t have a dependency on any of the application’s external inter-
faces, such as a web-based user interface.</p>
<h2 id="database-centric-design">Database-centric design</h2>
<p>One good way to design an application is to start with a logical data model,
as well as an actual physical database.</p>
<p>Database-centric design means starting with the data model: identifying entities
and their attributes and relationships. </p>
<p>For example, we can design a product catalog application by first designing a data-
base for all of the data that we’ll process.</p>
<ul>
<li>Product—A Product is a description of a manufactured product as it might appear
in a catalog, such as “Box of 1000 large plain paperclips,” but not an actual box
of paperclips. Attributes include a product code, name, and description.</li>
<li>Stock Item—A Stock Item is a certain quantity of some product at some location,
such as 500 boxes of a certain kind of paperclip, in a particular Warehouse.
Attributes include quantity and references to a Product and Warehouse.</li>
<li>Warehouse—A Warehouse is a place where Stock Items are stored. Attributes
include a name and geographic location or address.</li>
<li>Order—An Order is a request to transfer ownership of some quantity of one or
more Products, specified by Order Lines. Attributes include a date, seller, and
buyer.</li>
<li>Order Line—An Order Line specifies a certain quantity of some Product, as part
of an Order. Attributes include a quantity and a reference to an Order and
Product.</li>
</ul>
<p>The benefit of this approach is that you can use established data modeling techniques
to come up with a data model that consistently and unambiguously describes your
application’s domain.</p>
<h2 id="model-class-design">Model class design</h2>
<p>There’s more than one way to structure your model. Perhaps the most significant
choice is whether to keep your domain-specific data and logic separate or together.</p>
<p>Developers coming to Play and Scala from a Java EE background are likely
to have separated data and behavior in the past, whereas other developers may have
used a more object-oriented approach that mixes data and behavior in model classes.</p>
<p>More generally, the domain data model is specified by classes called
value objects that don’t contain any logic.</p>
<p><img src="/img/play_model_layer.png" alt="Two different ways to structure"></p>
<h2 id="defining-case-classes">Defining case classes</h2>
<p>We need case classes to represent quantities of various
products stored in warehouses.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">case</span> <span class="keyword">class</span> Product(
  id: <span class="built_in">Long</span>,
  ean: <span class="built_in">Long</span>,
  name: <span class="built_in">String</span>,
  description: <span class="built_in">String</span>)

<span class="keyword">case</span> <span class="keyword">class</span> Warehouse(id: <span class="built_in">Long</span>, name: <span class="built_in">String</span>)

<span class="keyword">case</span> <span class="keyword">class</span> StockItem(
  id: <span class="built_in">Long</span>,
  productId: <span class="built_in">Long</span>,
  warehouseId: <span class="built_in">Long</span>,
  quantity: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h2 id="persistence-api-integration">Persistence API integration</h2>
<p>You can use your case classes to persist the model using a persistence API. In a Play
application’s architecture, this is entirely separate from the web
tier; only the model uses (has a dependency on) the persistence API, which in turn
uses external persistent storage, such as a relational database.</p>
<p>Play includes the Anorm persistence API so that you can build a complete web
application, including SQL database access, without any additional libraries. But
you’re free to use alternative persistence libraries or approaches to persistent storage,
such as the newer Slick library.</p>
<h2 id="using-slick-for-database-access">Using Slick for database access</h2>
<p>Slick is intended as a Scala-based API for relational-database access.</p>
<p>The idea behind Slick is that you use it instead of using JDBC directly or adding
a complex object-relational mapping framework.
Instead, Slick uses Scala language featuresb
to allow you to map database tables to Scala collections and to execute queries.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>object Product extends Table[<span class="link_label">(Long, String, String)</span>](<span class="link_url">"products"</span>) {
  def ean = column[<span class="link_label">Long</span>](<span class="link_url">"ean", O.PrimaryKey</span>)
  def name = column[<span class="link_label">String</span>](<span class="link_url">"name"</span>)
  def description = column[<span class="link_label">String</span>](<span class="link_url">"description"</span>)
  def * = ean ~ name ~ description
}

// you define a query on the Product object:
val products = for {
  product <span class="xml"><span class="tag">&lt;<span class="title">-</span> <span class="attribute">Product.sortBy</span>(<span class="attribute">product</span> =&gt;</span></span> product.name.asc)
} yield (product)

// To execute the query, you can use the query object to generate a list of products,
// in a database session:
val url = "jdbc:postgresql://localhost/slick?user=slick&password=slick"
Database.forURL(url, driver = "org.postgresql.Driver") withSession {
  val productList = products.list
}
</pre></td></tr></table></figure>

<h1 id="controllers-handling-http-requests-and-responses">Controllers—handling HTTP requests and responses</h1>
<p>One aspect of designing your application is to design a URL scheme for HTTP
requests, hyperlinks, HTML forms, and possibly a public API.
In Play, you define this interface in an HTTP routes configuration and implement
the interface in Scala controller classes.</p>
<p>More specifically, controllers are the Scala classes that define your application’s
HTTP interface, and your routes configuration determines which controller method a
given HTTP request will invoke.</p>
<p>These controller methods are called actions—Play’s
architecture is in fact an MVC variant called action-based MVC—so
you can also think of a controller class as a collection of action methods.</p>
<h2 id="url-centric-design">URL-centric design</h2>
<p>This URL-centric design is an alternative to a database-centric design that starts
with the application’s data, or a UI-centric design that’s
based on how users will interact with its user interface.</p>
<p>URL-centric design isn’t better than data model–centric design or UI-centric design,
although it might make more sense for a developer who thinks in a certain way, or for
a certain kind of application.</p>
<h3 id="http-resources">Http resources</h3>
<p>URL-centric design means identifying your application’s resources, and operations on
those resources, and creating a series of URLs that provide HTTP access to those
resources and operations.</p>
<p>Once you have a solid design, you can add a user-interface
layer on top of this HTTP interface, and add a model that backs the HTTP resources.</p>
<p>The key benefit of this approach is that you can create a consistent public API for
your application that’s more stable than either the physical data model represented by
its model classes, or the user interface generated by its view templates.</p>
<p><strong>RESTful web services</strong></p>
<p>This kind of API is often called a RESTful web service, which means that the API is a
web service API that conforms to the architectural constraints of representational
state transfer (REST). </p>
<h3 id="resource-oriented-architecture">RESOURCE-ORIENTED ARCHITECTURE</h3>
<p>Modeling HTTP resources is especially useful if the HTTP API is the basis for more
than one external interface, in what can be called a resource-oriented architecture—a
REST -style alternative to service-oriented architecture based on addressable resources.</p>
<p>Resource-oriented architecture is an API-centric perspective on your application,
in which you consider that HTTP requests won’t necessarily come from your own
application’s web-based user interface.</p>
<h2 id="routing-http-requests-to-controller-action-methods">Routing HTTP requests to controller action methods</h2>
<p>For example, a URL -centric design for our product catalog might give us a URL
scheme with the following URLs:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">GET</span> /

<span class="keyword">GET</span> /products
<span class="keyword">GET</span> /products?page=<span class="number">2</span>
<span class="keyword">GET</span> /products?<span class="built_in">filter</span>=zinc

<span class="keyword">GET</span> /product/<span class="number">5010255079763</span>

<span class="keyword">GET</span> /product/<span class="number">5010255079763</span>/edit

PUT /product/<span class="number">5010255079763</span>
</pre></td></tr></table></figure>

<p>You create a conf/routes file like this</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>GET /                  controllers<span class="preprocessor">.Application</span><span class="preprocessor">.home</span>()
GET /products          controllers<span class="preprocessor">.Products</span><span class="preprocessor">.list</span>(page: Int ?= <span class="number">1</span>)
GET /product/:ean      controllers<span class="preprocessor">.Products</span><span class="preprocessor">.details</span>(ean: Long)
GET /product/:ean/edit controllers<span class="preprocessor">.Products</span><span class="preprocessor">.edit</span>(ean: Long)
PUT /product/$ean&lt;\d{<span class="number">13</span>}&gt;   controllers<span class="preprocessor">.Products</span><span class="preprocessor">.update</span>(ean: Long)
</pre></td></tr></table></figure>

<h2 id="binding-http-data-to-scala-objects">Binding HTTP data to Scala objects</h2>
<p>Action methods often have parameters, and you also need to be
able to map HTTP request data to those parameters.</p>
<h2 id="generating-different-types-of-http-response">Generating different types of HTTP response</h2>
<p>An HTTP response is not only a response body; the response also includes HTTP
status codes and HTTP headers that provide additional information about the
response.</p>
<h1 id="view-template-formatting-output">View template—formatting output</h1>
<p>A web framework’s approach to formatting output is a critical design
choice. View templates are a big deal; HTML templates in particular.</p>
<h2 id="ui-centric-design">UI-centric design</h2>
<p>URL-centric design that focuses on the application’s HTTP API.</p>
<p>UI-centric design starts with user-interface mockups and progressively adds detail
without starting on the underlying implementation until later, when the interface
design is established. This approach has become especially popular with the rise of
SAAS (software as a service) applications.</p>
<h3 id="saas-applications">SAAS APPLICATIONS</h3>
<p>37signals popularized UI-centric design in their
book Getting Real (<a href="http://gettingreal.37signals.com/ch09_Interface_First.php" target="_blank">http://gettingreal.37signals.com/ch09_Interface_First.php</a>),
which describes the approach as “interface first,” meaning
simply that you should “design the interface before you start programming.”</p>
<p>UI-centric design works well for software that focuses on simplicity and usability,
because functionality must literally compete for space in the UI, whereas functionality
that you can’t see doesn’t exist.</p>
<p>In this scenario, database-centric design may seem less
relevant because the database design gets less attention
than the UI design, for early versions of the software, at least.</p>
<h3 id="mobile-applications">MOBILE APPLICATIONS</h3>
<p>UI-centric design is also a good idea for mobile applications, because it’s better to
address mobile devices’ design constraints from the start than to attempt to squeeze a
desktop UI into a small screen later in the development process.</p>
<h2 id="html-first-templates">HTML-first templates</h2>
<p>There are two kinds of web framework templating systems, each addressing different
developer goals: component systems and raw HTML templates.</p>
<h3 id="user-interface-components">USER-INTERFACE COMPONENTS</h3>
<p>One approach minimizes the amount of HTML you write, usually by providing a
user-interface component library. </p>
<p>The idea is that you construct your user interface
from UI “building blocks” instead of writing HTML by hand.</p>
<p>In principle, the benefit of this approach is that it results in a more consistent UI
with less coding, and there are various frameworks that achieve this goal. But the risk
is that the UI components are a leaky abstraction, and that you’ll end up having to
debug invalid or otherwise non-working HTML and JavaScript after all.</p>
<h3 id="html-templates">HTML TEMPLATES</h3>
<p>A different kind of template system works by decorating HTML to make content
dynamic, usually with syntax that provides a combination of tags
for things like control structures and iteration, and an expression language
for outputting dynamic values.</p>
<p>The benefits of starting with HTML become apparent in practice, due to a combina-
tion of factors.</p>
<h3 id="javascript-widgets">JAVASCRIPT WIDGETS</h3>
<p>The opportunity to use a wide selection of JavaScript widgets is the most apparent
practical result of having control over your application’s HTML.</p>
<p>JavaScript widgets are different from framework-specific widgets, because they can
work with any server-side code that gives you control over your HTML and the HTTP
interface. </p>
<p>Being in control of the HTML your templates produce means that you have a rich choice of
JavaScript widgets.</p>
<h2 id="type-safe-scala-templates">Type-safe Scala templates</h2>
<p>Play includes a template engine that’s designed to output any kind of text-based
format, the usual examples being HTML, XML, and plain text.</p>
<h3 id="starting-with-a-minimal-template">STARTING WITH A MINIMAL TEMPLATE</h3>
<p>To start with, minimum interference means that all of the template syntax is optional.
<code>app/views/minimal.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="adding-dynamic-content">ADDING DYNAMIC CONTENT</h3>
<p><code>app/views/title.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>@(title:String)
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>@title<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="basic-template-syntax">BASIC TEMPLATE SYNTAX</h3>
<p>The parameter declaration, like all template syntax,
starts with the special <code>@</code> character,
which is followed by a normal Scala function parameter list.</p>
<p>In the body of a template, the <code>@</code> character can be followed by any Scala
expression or statement, whose value is inserted into the rendered template output.</p>
<h2 id="rendering-templates-scala-template-functions">Rendering templates—Scala template functions</h2>
<p>To use the template in the previous example, we first need to save it in a file in the
application, such as <code>app/views/products.scala.html</code>. Then we can render the
template in a controller by calling the template function:
<code>val html = views.html.title(&quot;New Arrivals&quot;)</code></p>
<p>This results in the following compiled template—a file in
<code>target/scala-2.10/src_managed/main/views/html/</code></p>
<h1 id="static-and-compiled-assets">Static and compiled assets</h1>
<p>A typical web application includes static content—images, JavaScript, stylesheets, and
downloads. In Play, these files are called assets.</p>
<h2 id="serving-assets">Serving assets</h2>
<p>Play provides an assets controller whose purpose is to serve static files.
There are two advantages to this approach: you use the usual routes configuration
and you get additional functionality in the assets controller.</p>
<p>Using the routes configuration for assets means that you have the same flexibility
in mapping URLs as you do for dynamic content.</p>
<p>On top of routing, the assets controller provides additional functionality
that’s useful for improving performance when serving static files:</p>
<ul>
<li>Caching support—Generating HTTP Entity Tags (ETags) to enable caching</li>
<li>JavaScript minification—Using Google Closure Compiler to reduce the size of
JavaScript files</li>
</ul>
<h2 id="compiling-assets">Compiling assets</h2>
<p>Play supports one of each:
LESS and CoffeeScript, languages that improve on CSS and JavaScript, respectively.</p>
<p>At compile time, LESS and CoffeeScript assets are compiled into CSS and
JavaScript files. HTTP requests for these assets are handled by the assets controller.</p>
<h1 id="jobs-starting-processes">Jobs—starting processes</h1>
<p>Sometimes an application has to run some code outside the normal HTTP request-
response cycle, either because it’s a long-running task that the web client doesn’t have
to wait for, or because the task must be executed on a regular cycle, independently of
any user or client interaction.
Today, architectures are frequently web-centric,
based around a web application or deployed on a cloud-based
application hosting service. These architectures mean that we need a way
to schedule and execute these jobs from within our web application.</p>
<h2 id="asynchronous-jobs">Asynchronous jobs</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>import java<span class="preprocessor">.util</span><span class="preprocessor">.Date</span>
import models<span class="preprocessor">.PickList</span>
import scala<span class="preprocessor">.concurrent</span>.{ExecutionContext, future}

def sendAsync(warehouse: String) = Action {
  import ExecutionContext<span class="preprocessor">.Implicits</span><span class="preprocessor">.global</span>
  future {
    // Use Scala future to execute block of code asynchronously
    val pickList = PickList<span class="preprocessor">.find</span>(warehouse)
    send(views<span class="preprocessor">.html</span><span class="preprocessor">.pickList</span>(warehouse, pickList, new Date))
  }
  // Build, render, <span class="keyword">and</span> send pick list somewhere
  Redirect(routes<span class="preprocessor">.PickLists</span><span class="preprocessor">.index</span>())
}
</pre></td></tr></table></figure>

<p>This time, the template rendering code is wrapped in a call
to <code>scala.concurrent.future</code>, which executes the code asynchronously. </p>
<h2 id="scheduled-jobs">Scheduled jobs</h2>
<p>Depending on how our warehouse works, it may be more useful to
automatically generate a new pick list every half hour.</p>
<p>To do this, we need a scheduled job that’s triggered automatically,
without needing anyone to click the button in the user interface.
Play doesn’t provide scheduling functionality directly, but instead integrates with
Akka, a library for actor-based concurrency that’s included with Play.</p>
<p><code>app/Global.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>import akka<span class="preprocessor">.actor</span>.{Actor, Props}
import models<span class="preprocessor">.Warehouse</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.concurrent</span><span class="preprocessor">.Akka</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.GlobalSettings</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.templates</span><span class="preprocessor">.Html</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.libs</span><span class="preprocessor">.concurrent</span><span class="preprocessor">.Execution</span><span class="preprocessor">.Implicits</span><span class="preprocessor">.defaultContext</span>

object Global extends GlobalSettings {
  override def onStart(application: play<span class="preprocessor">.api</span><span class="preprocessor">.Application</span>) {
    import scala<span class="preprocessor">.concurrent</span><span class="preprocessor">.duration</span>._
    import play<span class="preprocessor">.api</span><span class="preprocessor">.Play</span><span class="preprocessor">.current</span>
    // Run when Play application starts
    for (warehouse &lt;- Warehouse<span class="preprocessor">.find</span>()) {
      val actor = Akka<span class="preprocessor">.system</span><span class="preprocessor">.actorOf</span>(
        Props(new PickListActor(warehouse))
      )
      // Create actor for each warehouse
      Akka<span class="preprocessor">.system</span><span class="preprocessor">.scheduler</span><span class="preprocessor">.schedule</span>(
        <span class="number">0.</span>seconds, <span class="number">30.</span>minutes, actor, <span class="string">"send"</span>
      )
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="asynchronous-results-and-suspended-requests">Asynchronous results and suspended requests</h2>
<p><code>app/controllers/Dashboard.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="keyword">import</span> concurrent.{ExecutionContext, Future}

<span class="class"><span class="keyword">object</span> <span class="title">Dashboard</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>

  <span class="keyword">def</span> backlog(warehouse: String) = Action {
    <span class="keyword">import</span> ExecutionContext.Implicits.global
    <span class="keyword">val</span> backlog = scala.concurrent.future {
      models.Order.backlog(warehouse)
    }
    <span class="comment">// Get a promise of the order backlog without blocking</span>
    Async {
      backlog.map(value =&gt; Ok(value))
    }
  }
}
</pre></td></tr></table></figure>

<p>This is important because it allows
Play to release threads to a thread pool, making them available to process other HTTP
requests, so the application can serve a large number of requests
with a limited number of threads.</p>
<h1 id="modules-structuring-your-application">Modules—structuring your application</h1>
<p>A Play module is a Play application dependency—either reusable third-party code or
an independent part of your own application. The difference between a module and
any other library dependency is that a module depends on Play and can do the same
things an application can do. </p>
<h2 id="third-party-modules">Third-party modules</h2>
<p>Modules make it possible to extend Play with functionality
that you can use as if it were built-in,
without bloating the core framework with features that not everyone needs.</p>
<p>Here are a few examples of third-party modules that provide different kinds of
functionality:</p>
<ul>
<li>Deadbolt—Role-based authorization that allows you to restrict access
to controllers and views</li>
<li>Groovy templates—An alternative template engine that uses the Play 1.x
Groovy template syntax</li>
<li>PDF — Adds support for PDF output based on HTML templates</li>
<li>Redis—Integrates Redis to provide a cache implementation</li>
<li>Sass—Adds asset file compilation for Sass stylesheet files</li>
</ul>
<p>For more information about these and other modules, see the Play Framework
web site (<a href="http://www.playframework.org" target="_blank">http://www.playframework.org</a>).</p>
<h2 id="extracting-custom-modules">Extracting custom modules</h2>
<p>One way to approach custom modules is to think of them as a way to split your applica-
tions into separate reusable components, which helps keep individual applications
and modules simple.</p>
<h2 id="module-first-application-architecture">Module-first application architecture</h2>
<p>Another approach is to always add new application functionality in a module, when
you can, only adding to the main application when absolutely necessary.</p>
<p>With this approach, each application would consist of a smaller core of
modelspecific functionality and logic, plus a constellation of
modules that provide separate aspects of application functionality.
Some of these modules would inevitably be shared between applications.</p>
<h2 id="deciding-whether-to-write-a-custom-module">Deciding whether to write a custom module</h2>
<h2 id="module-architecture">Module architecture</h2>
<p>A module is almost the same thing as a whole application.
It provides the same kind of things an application has: models, view templates,
controllers, static files, or other utility
code. The only thing a module lacks is its own configuration; only the main application’s
configuration is used. This means that any module configuration properties must be set
in the application’s <code>conf/application.conf</code> file.</p>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Play for Scala-Getting Start]]></title>
    <link href="http://zhpooer.github.io/2014/08/07/play-for-scala-getting-start/"/>
    <id>http://zhpooer.github.io/2014/08/07/play-for-scala-getting-start/</id>
    <published>2014-08-07T08:35:31.000Z</published>
    <updated>2014-08-08T02:03:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="what-play-is">What Play is</h1>
<p>Play makes you more productive. Play is also a web framework whose HTTP interface is
simple, convenient, flexible, and powerful. Most importantly, Play improves on the
most popular non-Java web development languages and frameworks—PHP and Ruby
on Rails—by introducing the advantages of the Java Virtual Machine (JVM).</p>
<h1 id="hello-play">Hello Play</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">play</span> new hello
<span class="keyword">play</span> run
</pre></td></tr></table></figure>

<p>Files in a new Play application</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="preprocessor">.gitignore</span>
app/controllers/Application<span class="preprocessor">.scala</span>
app/views/index<span class="preprocessor">.scala</span><span class="preprocessor">.html</span>
app/views/main<span class="preprocessor">.scala</span><span class="preprocessor">.html</span>
conf/application<span class="preprocessor">.conf</span>
conf/routes
project/build<span class="preprocessor">.properties</span>
project/Build<span class="preprocessor">.scala</span>
project/plugins<span class="preprocessor">.sbt</span>
public/images/favicon<span class="preprocessor">.png</span>
public/javascripts/jquery-<span class="number">1.7</span><span class="number">.1</span><span class="preprocessor">.min</span><span class="preprocessor">.js</span>
public/stylesheets/main<span class="preprocessor">.css</span>
test/ApplicationSpec<span class="preprocessor">.scala</span>
test/IntegrationSpec<span class="preprocessor">.scala</span>
</pre></td></tr></table></figure>

<p><code>app/controllers/Application.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> </span>index = <span class="constant">Action</span> {
  <span class="constant">Ok</span>(<span class="string">"Hello world"</span>)
}
</pre></td></tr></table></figure>

<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>GET / controllers<span class="preprocessor">.Application</span><span class="preprocessor">.index</span>()
</pre></td></tr></table></figure>

<p>也可以这样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> </span>hello(<span class="symbol">name:</span> <span class="constant">String</span>) = <span class="constant">Action</span> {
  <span class="constant">Ok</span>(<span class="string">"Hello "</span> + name)
}

/<span class="regexp">/ 访问 http:/</span><span class="regexp">/localhost:9000/hello</span>?n=<span class="constant">Play</span>!
<span class="regexp">//</span> <span class="constant">GET</span> /hello controllers.<span class="constant">Application</span>.hello(<span class="symbol">n:</span> <span class="constant">String</span>)
</pre></td></tr></table></figure>

<h2 id="add-an-html-page-template">Add an HTML page template</h2>
<p><code>app/views/hello.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>@(name:String)
<span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">em</span>&gt;</span>@name<span class="tag">&lt;/<span class="title">em</span>&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>def hello(name: <span class="keyword">String</span>) = Action <span class="list">{
  Ok(views.html.hello(name))
}</span>
</pre></td></tr></table></figure>

<p><code>sbt console</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>views<span class="preprocessor">.html</span><span class="preprocessor">.hello</span><span class="preprocessor">.render</span>(<span class="string">"Play!"</span>)
</pre></td></tr></table></figure>

<h1 id="your-first-play-application">Your first Play application</h1>
<p>We’ll start with a simple list of products, each of which has a name
and a description.
This is a prototype, with a small number of products, so there isn’t
any functionality for filtering, sorting, or paging the list.</p>
<pre><code>Paperclips Large
  Large Plain Pack of 1000
Zebra Paperclips
  Zebra Length 28mm Assorted 150 Pack
</code></pre><p>To make the product list page work, we’ll need a combination of the following:</p>
<ul>
<li>A view template—A template that generates HTML</li>
<li>A controller action—A Scala function that renders the view</li>
<li>Route configuration—Configuration to map the URL to the action</li>
<li>The model—Scala code that defines the product structure, and some test data</li>
</ul>
<h2 id="getting-started">Getting started</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>play <span class="literal">new</span> products
rm products/<span class="keyword">public</span>/images/favicon<span class="built_in">.</span>png
rm products/<span class="keyword">public</span>/javascripts/jquery<span class="subst">-</span><span class="number">1.7</span><span class="number">.1</span><span class="built_in">.</span><span class="keyword">min</span><span class="built_in">.</span>js
</pre></td></tr></table></figure>

<p>copying <code>docs/assets/css/bootstrap.css</code> to our
application’s <code>public/stylesheets</code> directory.
Also copy <code>glyphicons-halflings-white.png</code> and <code>glyphicons-halflings.png</code> to
<code>public/img</code></p>
<p><code>main.css</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="tag">body</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value">black</span></span>; <span class="rule">}</span></span>
<span class="tag">body</span>, <span class="tag">p</span>, <span class="tag">label</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">15</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.label</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">13</span>px</span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"><span class="number">16</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.alert-info</span> <span class="rules">{ <span class="rule"><span class="attribute">border-color</span>:<span class="value">transparent</span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"><span class="hexcolor">#3A87AD</span></span></span>;
  <span class="rule"><span class="attribute">color</span>:<span class="value">white</span></span>; <span class="rule"><span class="attribute">font-weight</span>:<span class="value">bold</span></span>; <span class="rule">}</span></span>
<span class="tag">div</span><span class="class">.screenshot</span> <span class="rules">{ <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">800</span>px</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">20</span>px</span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"><span class="hexcolor">#D0E7EF</span></span></span>; <span class="rule">}</span></span>
<span class="class">.navbar-fixed-top</span> <span class="class">.navbar-inner</span> <span class="rules">{ <span class="rule"><span class="attribute">padding-left</span>:<span class="value"><span class="number">20</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.navbar</span> <span class="class">.nav</span> &gt; <span class="tag">li</span> &gt; <span class="tag">a</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#bbb</span></span></span>; <span class="rule">}</span></span>
<span class="class">.screenshot</span> &gt; <span class="class">.container</span> <span class="rules">{ <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">760</span>px</span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">20</span>px</span></span>; <span class="rule">}</span></span>
<span class="class">.navbar-fixed-top</span>, <span class="class">.navbar-fixed-bottom</span> <span class="rules">{ <span class="rule"><span class="attribute">position</span>:<span class="value">relative</span></span>; <span class="rule">}</span></span>
<span class="tag">h1</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">125</span>%</span></span>; <span class="rule">}</span></span>
<span class="tag">table</span> <span class="rules">{ <span class="rule"><span class="attribute">border-collapse</span>:<span class="value"> collapse</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100</span>%</span></span>; <span class="rule">}</span></span>
<span class="tag">th</span>, <span class="tag">td</span> <span class="rules">{ <span class="rule"><span class="attribute">text-align</span>:<span class="value">left</span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0.3</span>em <span class="number">0</span></span></span>;
  <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1</span>px solid white</span></span>; <span class="rule">}</span></span>
<span class="tag">tr</span><span class="class">.odd</span> <span class="tag">td</span> <span class="rules">{ <span class="rule">}</span></span>
<span class="tag">form</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>; <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> <span class="number">1</span>em</span></span>; <span class="rule">}</span></span>
<span class="tag">legend</span> <span class="rules">{ <span class="rule"><span class="attribute">border</span>:<span class="value"> none</span></span>; <span class="rule">}</span></span>
<span class="tag">fieldset</span> &gt; <span class="tag">div</span> <span class="rules">{ <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">12</span>px <span class="number">0</span></span></span>; <span class="rule">}</span></span>
<span class="class">.help-block</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>; <span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> middle</span></span>; <span class="rule">}</span></span>
<span class="class">.error</span> <span class="class">.help-block</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>; <span class="rule">}</span></span>
<span class="class">.error</span> <span class="class">.help-inline</span> <span class="rules">{ <span class="rule"><span class="attribute">padding-left</span>:<span class="value"> <span class="number">9</span>px</span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#B94A48</span></span></span>; <span class="rule">}</span></span>
<span class="tag">footer</span> <span class="rules">{ <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> right</span></span>; <span class="rule">}</span></span>
<span class="tag">dl</span><span class="class">.products</span> <span class="rules">{ <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule">}</span></span>
<span class="tag">dt</span> <span class="rules">{ <span class="rule"><span class="attribute">clear</span>:<span class="value"> right</span></span>; <span class="rule">}</span></span>
<span class="class">.barcode</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value">right</span></span>; <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">10</span>px</span></span>; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">4</span>px solid white</span></span>; <span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p><code>conf/application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="preprocessor">#  Be sure to use a different secret for your production</span>
<span class="preprocessor">#environment and never check that into your source code repository.</span>
application.secret=<span class="string">"Wd5HkNoRKdJP[kZJ@OV;HGa^&lt;4tDvgSfqn2PJeJnx4l0s77NTl"</span>
<span class="preprocessor"># application.langs="en,es,fr,nl"</span>
application.langs=<span class="string">"en"</span>
</pre></td></tr></table></figure>

<p>If you later want to copy entries from the default <code>application.conf</code> file,
you can find it in <code>$PLAY_HOME/framework/skeletons/scalaskel/conf/.</code></p>
<p>We’ll define in a messages file for each language:</p>
<ul>
<li><code>conf/messages—Default</code> messages for all languages, for messages not localized
for a particular language</li>
<li><code>conf/messages.es—Spanish</code> (which is called Español in Spanish)</li>
<li><code>conf/messages.fr—French</code> (Français in French)</li>
<li><code>conf/messages.nl—Dutch</code> (Nederlands in Dutch)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment"># conf/messages</span>
<span class="type">application</span>.<span class="property">name</span> = Product catalog
<span class="comment"># conf/messages.es</span>
<span class="type">application</span>.<span class="property">name</span> = Catálogo de productos
</pre></td></tr></table></figure>

<h2 id="adding-the-model">Adding the model</h2>
<p>We need to include three things in the example application’s model,</p>
<ul>
<li>A model class—The definition of the product and its attributes</li>
<li>A data access object (DAO)—Code that provides access to product data</li>
<li>Test data—A set of product objects</li>
</ul>
<p><code>app/models/Product.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">package</span> models
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Product</span><span class="params">(ean: Long, name: String, description: String)</span></span>

<span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">var</span> products = Set(Product(<span class="number">5010255079763</span>L, <span class="string">"Paperclips Large"</span>,<span class="string">"Large Plain Pack of 1000"</span>),
    Product(<span class="number">5018206244666</span>L, <span class="string">"Giant Paperclips"</span>,<span class="string">"Giant Plain 51mm 100 pack"</span>),
    Product(<span class="number">5018306332812</span>L, <span class="string">"Paperclip Giant Plain"</span>,<span class="string">"Giant Plain Pack of 10000"</span>),
    Product(<span class="number">5018306312913</span>L, <span class="string">"No Tear Paper Clip"</span>,<span class="string">"No Tear Extra Large Pack of 1000"</span>),
    Product(<span class="number">5018206244611</span>L, <span class="string">"Zebra Paperclips"</span>,<span class="string">"Zebra Length 28mm Assorted 150 Pack"</span>)
  )
  <span class="keyword">def</span> findAll = products.toList.sortBy(_.ean)
}
</pre></td></tr></table></figure>

<h2 id="product-list-page">Product list page</h2>
<p><code>app/views/products/list.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>&lt;!-- The implicit Lang parameter <span class="keyword">is</span> used <span class="keyword">for</span> the localized message --&gt;
&lt;!-- lookup performed by the Messages object. --&gt;
@(products: List[Product])(implicit lang: Lang)
<span class="keyword">@main</span>(Messages(<span class="string">"application.name"</span>)) {
  &lt;dl <span class="keyword">class</span>=<span class="string">"products"</span>&gt;
  <span class="keyword">@for</span>(product &lt;- products) {
    &lt;dt&gt;<span class="keyword">@product</span>.name&lt;/dt&gt;
    &lt;dd&gt;<span class="keyword">@product</span>.description&lt;/dd&gt;
  }
  &lt;/dl&gt;
}
</pre></td></tr></table></figure>

<h3 id="layout-template">Layout template</h3>
<p><code>app/views/main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>@(title: String)(content: Html)(implicit lang: Lang)

<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>@title<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>
      <span class="attribute">href</span>=<span class="value">'@routes.Assets.at("stylesheets/bootstrap.css")'</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>
      <span class="attribute">href</span>=<span class="value">"@routes.Assets.at("</span><span class="value">stylesheets</span>/<span class="attribute">main.css</span>")"&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"screenshot"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"navbar navbar-fixed-top"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"navbar-inner"</span>&gt;</span>
          <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"brand"</span> <span class="attribute">href</span>=<span class="value">"@routes.Application.index()"</span>&gt;</span>
              @Messages("application.name")
            <span class="tag">&lt;/<span class="title">a</span>&gt;</span>
          <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>@content<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<h3 id="controller-action-method">Controller action method</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}
<span class="keyword">import</span> models.Product

<span class="class"><span class="keyword">object</span> <span class="title">Products</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> list = Action { implicit request =&gt;
    <span class="keyword">val</span> products = Product.findAll
    Ok(views.html.products.list(products))
  }
}
</pre></td></tr></table></figure>

<h3 id="adding-a-routes-configuration">Adding a routes configuration</h3>
<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>GET / controllers.Application.index

GET /products controllers.Products.<span class="type">list</span>

GET /assets/*<span class="type">file</span> controllers.Assets.<span class="keyword">at</span>(path=<span class="string">"/public"</span>, <span class="type">file</span>)
</pre></td></tr></table></figure>

<h3 id="replacing-the-welcome-page-with-a-redirect">Replacing the welcome page with a redirect</h3>
<p><code>app/controllers/Application.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers
<span class="keyword">import</span> play.api.mvc.{Action, Controller}

<span class="class"><span class="keyword">object</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">def</span> index = Action {
    Redirect(routes.Products.list())
  }
}
</pre></td></tr></table></figure>

<p>Delete <code>app/views/index.scala.html</code> template.</p>
<h3 id="checking-the-language-localizations">Checking the language localizations</h3>
<p><code>app/views/debug.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>@()(implicit lang: Lang)

@import play<span class="preprocessor">.api</span><span class="preprocessor">.Play</span><span class="preprocessor">.current</span>

&lt;footer&gt;
  lang = @lang<span class="preprocessor">.code</span>,
  user = @current<span class="preprocessor">.configuration</span><span class="preprocessor">.getString</span>(<span class="string">"environment.user"</span>),
  date = @(new java<span class="preprocessor">.util</span><span class="preprocessor">.Date</span>()<span class="preprocessor">.format</span>(<span class="string">"yyyy-MM-dd HH:mm"</span>))
&lt;/footer&gt;
</pre></td></tr></table></figure>

<p><code>conf/application.conf</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment"># USER is an environment variable</span>
environment.user=<span class="variable">${USER}</span>
</pre></td></tr></table></figure>

<p><code>app/views/main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>&lt;div <span class="keyword">class</span>=<span class="string">"container"</span>&gt;
<span class="keyword">@content</span>
<span class="keyword">@debug</span>()
&lt;/div&gt;
</pre></td></tr></table></figure>

<h2 id="details-page">Details page</h2>
<p>The page’s URL, for example <code>/products/5010255079763</code>, includes the EAN code,
which is also used to generate a bar code image</p>
<ul>
<li>A new finder method—To fetch one specific product</li>
<li>A view template—To show this details page</li>
<li>An HTTP routing configuration—For a URL with a parameter</li>
<li>A bar code image—To display on the page</li>
</ul>
<h3 id="model-finder-method">Model finder method</h3>
<p><code>app/models/Product.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">def</span> findByEan(ean: Long) = products.find(_.ean == ean)
}
</pre></td></tr></table></figure>

<h3 id="details-page-template">Details page template</h3>
<p><code>app/views/products/details.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>@(product: Product)(implicit lang: Lang)
@main(Messages("products.details", product.name)) {
  <span class="tag">&lt;<span class="title">h2</span>&gt;</span>
    <span class="comment">&lt;!-- 生成横条码  --&gt;</span>
    @tags.barcode(product.ean)
    @Messages("products.details", product.name)
  <span class="tag">&lt;/<span class="title">h2</span>&gt;</span>

  <span class="tag">&lt;<span class="title">dl</span> <span class="attribute">class</span>=<span class="value">"dl-horizontal"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dt</span>&gt;</span>@Messages("ean"):<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dd</span>&gt;</span>@product.ean<span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dt</span>&gt;</span>@Messages("name"):<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dd</span>&gt;</span>@product.name<span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dt</span>&gt;</span>@Messages("description"):<span class="tag">&lt;/<span class="title">dt</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dd</span>&gt;</span>@product.description<span class="tag">&lt;/<span class="title">dd</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">dl</span>&gt;</span>

}
</pre></td></tr></table></figure>

<p><code>app/views/tags/barcode.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>@(ean: <span class="built_in">Long</span>)
&lt;img <span class="keyword">class</span>=<span class="string">"barcode"</span> alt=<span class="string">"@ean"</span> src=<span class="string">"@routes.Barcodes.barcode(ean)"</span>&gt;
</pre></td></tr></table></figure>

<h3 id="additional-message-localizations">Additional message localizations</h3>
<p><code>conf/messages</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="constant">ean</span> = EAN
<span class="constant">name</span> = Name
<span class="constant">description</span> = Description

products.details = Product: {0}
</pre></td></tr></table></figure>

<p><code>conf/messages.es</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="constant">ean</span> = EAN
<span class="constant">name</span> = Nombre
<span class="constant">description</span> = Descripción

products.details = Producto: {0}
</pre></td></tr></table></figure>

<h3 id="adding-a-parameter-to-a-controller-action">Adding a parameter to a controller action</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>def show(ean: Long) = Action { implicit request =&gt;
  Product<span class="preprocessor">.findByEan</span>(ean)<span class="preprocessor">.map</span> { product =&gt;
    Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.details</span>(product))
  }<span class="preprocessor">.getOrElse</span>(NotFound)
}
</pre></td></tr></table></figure>

<h3 id="adding-a-parameter-to-a-route">Adding a parameter to a route</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">GET</span> /products/:ean controllers.Products.show(ean: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h3 id="generating-a-bar-code-image">Generating a bar code image</h3>
<p><code>project/Build.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>val appDependencies = Se<span class="string">q(
  "net.sf.barcode4j" % "barcode4j" % "2.0"
)</span>
</pre></td></tr></table></figure>

<p><code>app/controllers/Barcodes.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="keyword">package</span> controllers

<span class="keyword">import</span> play.api.mvc.{Action, Controller}

<span class="class"><span class="keyword">object</span> <span class="title">Barcodes</span> <span class="keyword">extends</span> <span class="title">Controller</span> {</span>
  <span class="keyword">val</span> ImageResolution = <span class="number">144</span>
  <span class="comment">// Action that returns PNG response</span>
  <span class="keyword">def</span> barcode(ean: Long) = Action {
    <span class="keyword">import</span> java.lang.IllegalArgumentException
    <span class="keyword">val</span> MimeType = <span class="string">"image/png"</span>
    <span class="keyword">try</span> {
      <span class="keyword">val</span> imageData = ean13BarCode(ean, MimeType)
      Ok(imageData).as(MimeType)
    } <span class="keyword">catch</span> {
      <span class="keyword">case</span> e: IllegalArgumentException =&gt;
        BadRequest(<span class="string">"Couldn’t generate bar code. Error: "</span> + e.getMessage)
    }
  }
  <span class="keyword">def</span> ean13BarCode(ean: Long, mimeType: String): Array[Byte] = {
    <span class="keyword">import</span> java.io.ByteArrayOutputStream
    <span class="keyword">import</span> java.awt.image.BufferedImage
    <span class="keyword">import</span> org.krysalis.barcode4j.output.bitmap.BitmapCanvasProvider
    <span class="keyword">import</span> org.krysalis.barcode4j.impl.upcean.EAN13Bean
    <span class="keyword">val</span> output: ByteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream
    <span class="keyword">val</span> canvas: BitmapCanvasProvider =
      <span class="keyword">new</span> BitmapCanvasProvider(output, mimeType, ImageResolution,
        BufferedImage.TYPE_BYTE_BINARY, <span class="keyword">false</span>, <span class="number">0</span>)
    <span class="keyword">val</span> barcode = <span class="keyword">new</span> EAN13Bean()
    barcode.generateBarcode(canvas, String valueOf ean)
    canvas.finish
    output.toByteArray
  }
}
</pre></td></tr></table></figure>

<p><code>conf/routes</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">GET</span> /barcode/:ean controllers.Barcodes.barcode(ean: <span class="built_in">Long</span>)
</pre></td></tr></table></figure>

<h2 id="adding-a-new-product">Adding a new product</h2>
<h3 id="additional-message-localizations">Additional message localizations</h3>
<p><code>conf/messages</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>products<span class="preprocessor">.form</span> = Product details
products<span class="preprocessor">.new</span> = (new)
products<span class="preprocessor">.new</span><span class="preprocessor">.command</span> = New

products<span class="preprocessor">.new</span><span class="preprocessor">.submit</span> = <span class="keyword">Add</span>
products<span class="preprocessor">.new</span><span class="preprocessor">.success</span> = Successfully added product {<span class="number">0</span>}.

validation<span class="preprocessor">.errors</span> = Please correct the errors <span class="keyword">in</span> the form.
validation<span class="preprocessor">.ean</span><span class="preprocessor">.duplicate</span> = A product with this EAN code already exists
</pre></td></tr></table></figure>

<h3 id="form-object">Form object</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>import play<span class="preprocessor">.api</span><span class="preprocessor">.data</span><span class="preprocessor">.Form</span>
import play<span class="preprocessor">.api</span><span class="preprocessor">.data</span><span class="preprocessor">.Forms</span>.{mapping, longNumber, nonEmptyText}
import play<span class="preprocessor">.api</span><span class="preprocessor">.i</span>18n<span class="preprocessor">.Messages</span>

private val productForm: Form[Product] = Form(
  mapping(
    <span class="string">"ean"</span> -&gt; longNumber<span class="preprocessor">.verifying</span>(
      <span class="string">"validation.ean.duplicate"</span>, Product<span class="preprocessor">.findByEan</span>(_)<span class="preprocessor">.isEmpty</span>),
    <span class="string">"name"</span> -&gt; nonEmptyText,
    <span class="string">"description"</span> -&gt; nonEmptyTest
  )(Product<span class="preprocessor">.apply</span>)(Product<span class="preprocessor">.unapply</span>)
)
</pre></td></tr></table></figure>

<h3 id="form-template">Form template</h3>
<p><code>app/views/main.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container"</span>&gt;
  &lt;a <span class="type">class</span>=<span class="string">"brand"</span> href=<span class="string">"@routes.Application.index()"</span>&gt;
    @Messages(<span class="string">"application.name"</span>)
  &lt;/a&gt;
  &lt;ul <span class="type">class</span>=<span class="string">"nav"</span>&gt;
    &lt;li <span class="type">class</span>=<span class="string">"divider-vertical"</span>&gt;&lt;/li&gt;
    &lt;li <span class="type">class</span>=<span class="string">"active"</span>&gt;
      &lt;a href=<span class="string">"@routes.Products.list()"</span>&gt;
        @Messages(<span class="string">"products.list.navigation"</span>)
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li <span class="type">class</span>=<span class="string">"active"</span>&gt;
      &lt;a href=<span class="string">"@routes.Products.newProduct()"</span>&gt;
        &lt;i <span class="type">class</span>=<span class="string">"icon-plus icon-white"</span>&gt;&lt;/i&gt;
        @Messages(<span class="string">"products.new.command"</span>)
      &lt;/a&gt;
    &lt;/li&gt;
    &lt;li <span class="type">class</span>=<span class="string">"divider-vertical"</span>&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/<span class="keyword">div</span>&gt;

&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container"</span>&gt;
  @<span class="keyword">if</span>(flash.<span class="keyword">get</span>(<span class="string">"success"</span>).isDefined){
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"alert alert-success"</span>&gt;
      @flash.<span class="keyword">get</span>(<span class="string">"success"</span>)
    &lt;/<span class="keyword">div</span>&gt;
  }
  @<span class="keyword">if</span>(flash.<span class="keyword">get</span>(<span class="string">"error"</span>).isDefined){
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"alert alert-error"</span>&gt;
      @flash.<span class="keyword">get</span>(<span class="string">"error"</span>)
    &lt;/<span class="keyword">div</span>&gt;
  }
  @content
  @debug()
&lt;/<span class="keyword">div</span>&gt;
</pre></td></tr></table></figure>

<p><code>app/views/products/list.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"@controllers.routes.Products.newProduct()"</span> <span class="attribute">class</span>=<span class="value">"btn"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">i</span> <span class="attribute">class</span>=<span class="value">"icon-plus"</span>&gt;</span><span class="tag">&lt;/<span class="title">i</span>&gt;</span> @Messages("products.new.command")<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</pre></td></tr></table></figure>

<p><code>app/views/products/editProduct.scala.html</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="at_rule">@(productForm:<span class="preprocessor"> Form</span>[Product])(implicit<span class="preprocessor"> flash</span>:<span class="preprocessor"> Flash</span>,<span class="preprocessor"> lang</span>:<span class="preprocessor"> Lang</span>)

&lt;!--<span class="preprocessor"> Twitter</span><span class="preprocessor"> Bootstrap</span><span class="preprocessor"> helpers</span><span class="preprocessor"> --</span>&gt;
@<span class="keyword">import</span><span class="preprocessor"> helper._</span>
@<span class="keyword">import</span><span class="preprocessor"> helper.twitterBootstrap._</span>

@<span class="function">main(<span class="function">Messages(<span class="string">"products.form"</span>)</span>)</span> {</span>
  &lt;<span class="tag">h2</span>&gt;<span class="at_rule">@<span class="function">Messages(<span class="string">"products.form"</span>)</span>&lt;/h2&gt;

  @helper.<span class="function">form(action = routes.Products.<span class="function">save()</span>)</span> {</span>
    &lt;<span class="tag">fieldset</span>&gt;
      &lt;<span class="tag">legend</span>&gt;
        <span class="at_rule">@<span class="function">Messages(<span class="string">"products.details"</span>, <span class="function">Messages(<span class="string">"products.new"</span>)</span>)</span>
      &lt;/legend&gt;
      @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"ean"</span>)</span>)</span>
      @helper.<span class="function">inputText(<span class="function">productForm(<span class="string">"name"</span>)</span>)</span>
      @helper.<span class="function">textarea(<span class="function">productForm(<span class="string">"description"</span>)</span>)</span>
    &lt;/fieldset&gt;
    &lt;p&gt;&lt;input<span class="preprocessor"> type</span>=<span class="string">"submit"</span><span class="preprocessor"> class</span>=<span class="string">"btn primary"</span><span class="preprocessor"> value</span>=<span class="string">'@Messages("products.new.submit")'</span>&gt;&lt;/p&gt;
  }
}</span>
</pre></td></tr></table></figure>

<h3 id="saving-the-new-product">Saving the new product</h3>
<p><code>app/models/Product.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Product</span> {</span>
  <span class="keyword">def</span> add(product: Product) {
    products = products + product
  }
}
</pre></td></tr></table></figure>

<h3 id="validating-the-user-input">Validating the user input</h3>
<p><code>app/controllers/Products.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>import play<span class="preprocessor">.api</span><span class="preprocessor">.mvc</span><span class="preprocessor">.Flash</span>

def save = Action {implicit request =&gt;
  val newProductForm = productForm<span class="preprocessor">.bindFromRequest</span>()
  newProductForm<span class="preprocessor">.fold</span>(
    hasErrors = { form =&gt;
      Redirect(route<span class="preprocessor">.Products</span><span class="preprocessor">.newProduct</span>()).
        flashing(Flash(form<span class="preprocessor">.data</span>) +
          (<span class="string">"error"</span> -&gt; Messages(<span class="string">"validation.errors"</span>)))
    },
    success = { newProduct =&gt;
      Product<span class="preprocessor">.add</span>(newProduct)
      Redirect(routes<span class="preprocessor">.Products</span><span class="preprocessor">.show</span>(newProduct<span class="preprocessor">.ean</span>)).
        flashing(<span class="string">"success"</span> -&gt; message)
    }
  )
}

def newProduct = Action { implicit request =&gt;
  val form = if (flash<span class="preprocessor">.get</span>(<span class="string">"error"</span>)<span class="preprocessor">.isDefined</span>)
    productForm<span class="preprocessor">.bind</span>(flash<span class="preprocessor">.data</span>)
  else
    productForm
    
  Ok(views<span class="preprocessor">.html</span><span class="preprocessor">.products</span><span class="preprocessor">.editProduct</span>(form))
}
</pre></td></tr></table></figure>

<h3 id="adding-the-routes-for-saving-products">Adding the routes for saving products</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>POST /products controllers<span class="preprocessor">.Products</span><span class="preprocessor">.save</span>

GET /products/new controllers<span class="preprocessor">.Products</span><span class="preprocessor">.newProduct</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="play" scheme="http://zhpooer.github.io/tags/play/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Integration]]></title>
    <link href="http://zhpooer.github.io/2014/08/06/akka-in-action-integration/"/>
    <id>http://zhpooer.github.io/2014/08/06/akka-in-action-integration/</id>
    <published>2014-08-06T06:45:54.000Z</published>
    <updated>2014-08-07T02:17:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="message-endpoints">Message endpoints</h1>
<p>The implementation of an interface between two systems isn&#39;t always
easy, because the interface contains two areas: the transport layer and the data
which is sent over this transport layer.</p>
<p>For example, we are creating an order system for use in a book
stockroom, that processes orders from all kinds of customers. These customers can
order the books by visiting the store. The bookstore already uses an application to
sell and order books.  So the new system needs to exchange data with this existing
application.</p>
<p>Because you probably can&#39;t change the external
application, you have to create a component that can send and/or receive messages
from the existing application. This component is called an endpoint. Endpoints are
part of your system and are the glue between the external system and the rest of
your system.</p>
<p>There are a lot of different transport protocols to potentially
support: REST/HTTP, TCP, MQueues, or simple files. </p>
<h2 id="normalizer">Normalizer</h2>
<p>We have seen that our order system receives the orders from the bookshop
application, but it is possible that our system also receives orders from a web shop,
or by customers sending email.</p>
<p>We can use the Normalizer pattern to make these
different sources all feed into a single interface on the application side. The pattern
translates the different external messages to a common, canonical message.</p>
<p>We create three different endpoints to consume the different messages, but
translate them into the same message, which is sent to the rest of the system.</p>
<p><img src="/img/akka_order_system.png" alt="akka order system"></p>
<p>Translating the different messages into a common message is called the
Normalizer pattern.</p>
<p> Let us assume that
there is another bookshop that is connecting to this system using the same
messages but using MQueue to send those message.</p>
<p><img src="/img/akka_normalizer.png" alt="akka normalizer partern"></p>
<h2 id="canonical-data-model">Canonical Data Model</h2>
<p> But when the connectivity requirements between the systems
increases we need more and more endpoints.</p>
<p>To solve this problem, we can use the Canonical Data Model. This pattern
connects multiple applications using interface(s) that are independent of any
specific system.</p>
<p>When the Bookshop application
wants to send a message to the order system, the message is first translated to the
canonical format and then it is sent using the common transport layer.</p>
<p>The Normalizer
pattern is used to connect several similar clients to another system. But when the
number of integrated systems increases, we need the Canonical Data Model, which
looks like the Normalizer Pattern, because it also uses normalized messages.</p>
<p>The difference is that the Canonical Data Model provides an additional level of
indirection between the application&#39;s individual data formats and those used by the
remote systems. While the Normalizer is only within one application.</p>
<h1 id="camel-framework">Camel Framework</h1>
<p>Camel is an apache framework whose goal is to make integration easier and more
accessible. It makes it possible to implement the standard enterprise integration
patterns in a few lines of code. This is achieved by addressing three areas:</p>
<ol>
<li>Concrete implementations of the widely used Enterprise Integration Patterns</li>
<li>Connectivity to a great variety of transports and APIs</li>
<li>Easy to use Domain Specific Languages (DSLs) to wire EIPs and transports together</li>
</ol>
<p>The Camel module works internally with Camel classes. Important Camel
classes are the camel context and the ProducerTemplate. The CamelContext
represents a single Camel routing rule base, and the ProducerTemplate is needed
when producing messages.</p>
<h2 id="implement-a-consumer-endpoint">Implement a consumer endpoint</h2>
<p>The example we are going to implement is an Order System receiving messages
from a bookshop. 
Let&#39;s say the received messages are XML files in a
directory. The transport layer is in this case the file system. The endpoint of the
order system needs to track new files and when there is a new file it has to parse
the XML content and create a message the system can process.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">// Consumer Endpoint</span>

<span class="keyword">import</span> akka.camel.{CamelMessage, Consumer}

<span class="class"><span class="keyword">class</span> <span class="title">OrderConsumerXml</span><span class="params">(uri:String, next:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Consumer</span>{</span>
  <span class="comment">// override the endpointUri</span>
  <span class="keyword">def</span> endpointUri = uri

  <span class="comment">// receive the Camel message</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg:CamelMessage =&gt; {
      <span class="keyword">val</span> content = msg.bodyAs[String]
      <span class="keyword">val</span> xml = XML.loadString(content)
      <span class="keyword">val</span> order = xml\\<span class="string">"order"</span>
      <span class="keyword">val</span> customer = (order \\ <span class="string">"customerId"</span>).text
      <span class="keyword">val</span> productId = (order \\ <span class="string">"productId"</span>).text
      <span class="keyword">val</span> number = (order \\ <span class="string">"number"</span>).text.toInt
      next ! <span class="keyword">new</span> Order(customer, productId, number)
    }
  }
}

<span class="comment">// This Uri starts with the Camel component.</span>
<span class="comment">// http://camel.apache.org/components.html</span>
<span class="keyword">val</span> camelUri = <span class="string">"file:messages"</span>
</pre></td></tr></table></figure>

<p>When a new message is received, it comes to the Actor through its usual
method, as a CamelMessage. A CamelMessage contains a body, which is the
actual message received, and a map of headers. The content of these headers
depends on the protocol used. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">val</span> probe = TestProbe()
<span class="keyword">val</span> camelUri = <span class="string">"file:messages"</span>
<span class="keyword">val</span> consumer = system.actorOf(Props(<span class="keyword">new</span> OrderConsumerXml(camelUri, probe.<span class="keyword">ref</span>)))
</pre></td></tr></table></figure>

<p>Because we use the Camel Consumer trait, a lot of components are started and
we have to wait for these components before we can proceed with our test. To be
able detect that Camel&#39;s startup has finished, we need to use the CamelExtension.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>val camelExtention = CamelExtension(<span class="keyword">system</span>)
val activated =
  camelExtention.activationFutureFor(consumer)(timeout = <span class="number">10</span> <span class="built_in">seconds</span>, executor = <span class="keyword">system</span>.dispatcher)
Await.<span class="built_in">result</span>(activated, <span class="number">5</span> <span class="built_in">seconds</span>)


val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml =
  &lt;order&gt;
    &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
    &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
    &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
  &lt;/order&gt;
val msgFile = <span class="built_in">new</span> File(dir, <span class="string">"msg1.xml"</span>)
FileUtils.<span class="built_in">write</span>(msgFile, xml.toString())
probe.expectMsg(msg)
<span class="keyword">system</span>.stop(consumer)
</pre></td></tr></table></figure>

<h2 id="changing-the-transport-layer-of-our-consumer">CHANGING THE TRANSPORT LAYER OF OUR CONSUMER</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>val probe = TestProbe()
val camelUri = <span class="string">"mina:tcp://localhost:8888?textline=true&sync=false"</span>
val consumer = <span class="keyword">system</span>.actorOf(Props(<span class="built_in">new</span> OrderConsumerXml(camelUri, probe.ref)))

val activated =
  CamelExtension(<span class="keyword">system</span>).activationFutureFor(consumer)(timeout = <span class="number">10</span> <span class="built_in">seconds</span>, executor = <span class="keyword">system</span>.dispatcher)
  
Await.<span class="built_in">result</span>(activated, <span class="number">5</span> <span class="built_in">seconds</span>)
val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml = &lt;order&gt;
            &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
            &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
            &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
          &lt;/order&gt;
val xmlStr = xml.toString().<span class="built_in">replace</span>(<span class="string">"n"</span>, <span class="string">""</span>)

val sock = <span class="built_in">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8888</span>)
val ouputWriter = <span class="built_in">new</span> PrintWriter(sock.getOutputStream, <span class="constant">true</span>)
ouputWriter.println(xmlStr)
ouputWriter.flush()
probe.expectMsg(msg)
ouputWriter.<span class="built_in">close</span>()
<span class="keyword">system</span>.stop(consumer)
</pre></td></tr></table></figure>

<ul>
<li><code>textline=true</code>, This indicates that we are expecting plain text over this connection and that each message
is ended with a newline</li>
<li><code>sync=false</code>, This indicates that we don&#39;t create a response</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">def</span> receive = {
  <span class="keyword">case</span> msg: CamelMessage =&gt; {
    <span class="keyword">try</span> {
      <span class="keyword">val</span> content = msg.bodyAs[String]
      <span class="keyword">val</span> xml = XML.loadString(content)
      <span class="keyword">val</span> order = xml \ <span class="string">"order"</span>
      <span class="keyword">val</span> customer = (order \ <span class="string">"customerId"</span>).text
      <span class="keyword">val</span> productId = (order \ <span class="string">"productId"</span>).text
      <span class="keyword">val</span> number = (order \ <span class="string">"number"</span>).text.toInt
      next ! <span class="keyword">new</span> Order(customer, productId, number)
      sender ! <span class="string">"&lt;confirm&gt;OK&lt;/confirm&gt;"</span>
    } <span class="keyword">catch</span> {
      <span class="comment">// 如果是同步的通信, 发生错误, actor重启, 会失去发送者的信息</span>
      <span class="keyword">case</span> ex: Exception =&gt;
        sender ! <span class="string">"&lt;confirm&gt;%s&lt;/confirm&gt;"</span>.format(ex.getMessage)
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="using-the-camel-context">USING THE CAMEL CONTEXT</h2>
<p>For example when we want to use the ActiveMQ component. To be able to use
this we need to add the component to the Camel context and define the MQ broker.
This requires the camel context.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>// Component name should be used <span class="keyword">in</span> the Uri
val camelContext = CamelExtension(system)<span class="preprocessor">.context</span>
camelContext<span class="preprocessor">.addComponent</span>(<span class="string">"activemq"</span>,
  ActiveMQComponent<span class="preprocessor">.activeMQComponent</span>(
    <span class="string">"vm:(broker:(tcp://localhost:8899)?persistent=false)"</span>))

val camelUri = <span class="string">"activemq:queue:xmlTest"</span>
val consumer = system<span class="preprocessor">.actorOf</span>(
    Props(new OrderConsumerXml(camelUri, probe<span class="preprocessor">.ref</span>)))
val activated = CamelExtension(system)<span class="preprocessor">.activationFutureFor</span>(
    consumer)(timeout = <span class="number">10</span> seconds, executor = system<span class="preprocessor">.dispatcher</span>)
...
sendMQMessage(xml<span class="preprocessor">.toString</span>())
probe<span class="preprocessor">.expectMsg</span>(msg)
system<span class="preprocessor">.stop</span>(consumer)

// Because a broker is started, we also need to stop them when we are ready. 
// This can be done using the BrokerRegistry of ActiveMQ
val brokers = BrokerRegistry<span class="preprocessor">.getInstance</span>()<span class="preprocessor">.getBrokers</span>
brokers<span class="preprocessor">.foreach</span> { case (name, broker) =&gt; broker<span class="preprocessor">.stop</span>() }
</pre></td></tr></table></figure>

<h2 id="implement-a-producer-endpoint">Implement a producer endpoint</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.camel.Producer

<span class="class"><span class="keyword">class</span> <span class="title">SimpleProducer</span><span class="params">(uri: Strint)</span> <span class="keyword">extends</span> <span class="title">Producer</span> {</span>
  <span class="keyword">def</span> endpointUri = uri
}

implicit <span class="keyword">val</span> ExecutionContext = system.dispatcher
<span class="keyword">val</span> probe = TestProbe()
<span class="keyword">val</span> camelUri =
  <span class="string">"mina:tcp://localhost:8888?textline=true&sync=false"</span>
<span class="keyword">val</span> consumer = system.actorOf(
  Props(<span class="keyword">new</span> OrderConsumerXml(camelUri, probe.ref)))
  
<span class="keyword">val</span> producer = system.actorOf(
  Props(<span class="keyword">new</span> SimpleProducer(camelUri)))
<span class="keyword">val</span> activatedCons = CamelExtension(system).activationFutureFor(
  consumer)(timeout = <span class="number">10</span> seconds, executor = system.dispatcher)
<span class="keyword">val</span> activatedProd = CamelExtension(system).activationFutureFor(
  producer)(timeout = <span class="number">10</span> seconds, executor = system.dispatcher)
  
<span class="keyword">val</span> camel = Future.sequence(List(activatedCons, activatedProd))
Await.result(camel, <span class="number">5</span> seconds)
</pre></td></tr></table></figure>

<p>Here we can do the translation of our message to the expected XML</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderProducerXml</span><span class="params">(uri: String)</span> <span class="keyword">extends</span> <span class="title">Producer</span> {</span>
  <span class="keyword">def</span> endpointUri = uri
  <span class="keyword">override</span> <span class="keyword">def</span> oneway: Boolean = <span class="keyword">false</span>
  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> transformOutgoingMessage(message: Any): Any = {
    message <span class="keyword">match</span> {
      <span class="keyword">case</span> msg: Order =&gt; {
        <span class="keyword">val</span> xml = &lt;order&gt;
          &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
          &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
          &lt;number&gt;{ msg.number }&lt;/number&gt;
        &lt;/order&gt;
        
        xml.toString().replace(<span class="string">"n"</span>, <span class="string">""</span>)
      }
      <span class="keyword">case</span> other =&gt; message
    }
  }
  
  <span class="comment">// 反向序列化</span>
  <span class="keyword">override</span> <span class="keyword">def</span> transformResponse(message: Any): Any = {
    message <span class="keyword">match</span> {
      <span class="keyword">case</span> msg: CamelMessage =&gt; {
        <span class="keyword">try</span> {
          <span class="keyword">val</span> content = msg.bodyAs[String]
          <span class="keyword">val</span> xml = XML.loadString(content)
          (xml \ <span class="string">"confirm"</span>).text
        } <span class="keyword">catch</span> {
          <span class="keyword">case</span> ex: Exception =&gt;
            <span class="string">"TransformException: %s"</span>.format(ex.getMessage)
        }
      }
      <span class="keyword">case</span> other =&gt; message
    }
  }
}
</pre></td></tr></table></figure>

<p>There is a method called routeResponse.
This method is responsible for sending the received
response to the original sender. </p>
<h1 id="example-of-implementing-a-rest-interface">Example of implementing a REST interface</h1>
<p>REST is a standard protocol to expose intuitive interfaces
to systems. We are still creating an endpoint for our system.</p>
<p>Spray is an open-source toolkit for REST/HTTP and low-level network IO on
top of Scala and Akka.</p>
<p>We start by defining the
messages for both interfaces. The Order system will support two functions. The
first function is to add a new order and the second function is to get the status of an
order. The REST interface we are going to implement supports a POST and a GET.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">ProcssOrders</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  val orderList = <span class="keyword">new</span> mutable.HashMap[Long, TrackingOrder]
  val lastOrderId = <span class="number">0</span>L

  def receive = {
    <span class="keyword">case</span> order:Order =&gt; {
      lastOrderId += <span class="number">1</span>
      val newOrder = <span class="keyword">new</span> TrackingOrder(lastOrderId, <span class="string">"received"</span>, order)
      orderList += lastOrdered -&gt; newOrder
      sender ! newOrder
    }
    <span class="keyword">case</span> order:OrderId =&gt; {
      orderList.get(order.id) match {
        <span class="keyword">case</span> Some(intOrder) =&gt;
          sender ! intOrder.copy(status=<span class="string">"process"</span>)
        <span class="keyword">case</span> None =&gt; sender ! NoSuchOrder(order.id)
      }
    }
    <span class="keyword">case</span> <span class="string">"reset"</span> =&gt; {
      lastOrderId = <span class="number">0</span>
      orderList.clear()
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="implementing-a-rest-endpoint-with-spray">Implementing a Rest endpoint with Spray</h2>
<p>Spray also has it own test kit and is able to test your code without
building a complete application.</p>
<p>When you need REST/HTTP support, Spray is a great way to connect your Akka
applications to other Systems.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre>import spray.routing.HttpService

trait OrderService extends HttpService {
  val myRoute = path("orderTest") {
    get {
      parameters('id.as[Long]).as(OrderId) { orderId =&gt;
        complete {
          val askFuture = orderSystem ? orderId
          askFuture.map {
            case result:TrackingOrder =&gt; {
              <span class="tag">&lt;<span class="title">statusResponse</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{result.id}<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>{result.status}<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">statusResponse</span>&gt;</span>
            }
            case result:NoSuchOrder =&gt; {
              <span class="tag">&lt;<span class="title">statusResponse</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{result.id}<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>ID is unknown<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">statusResponse</span>&gt;</span>
            }
          }
        }
      }
    } ~
    post {
      //add order
      entity(as[String]) { body =&gt;
        val order = XMLConverter.createOrder(body.toString)
        complete {
          val askFuture = orderSystem ? order
          askFuture.map {
            case result: TrackingOrder =&gt; {
              <span class="tag">&lt;<span class="title">confirm</span>&gt;</span>
                <span class="tag">&lt;<span class="title">id</span>&gt;</span>{ result.id }<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>{ result.status }<span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">confirm</span>&gt;</span>.toString()
            }
            case result: Any =&gt; {
              <span class="tag">&lt;<span class="title">confirm</span>&gt;</span>
                <span class="tag">&lt;<span class="title">status</span>&gt;</span>
                  Response is unknown{ result.toString() }
                <span class="tag">&lt;/<span class="title">status</span>&gt;</span>
              <span class="tag">&lt;/<span class="title">confirm</span>&gt;</span>.toString()
            }
          }
        }
      }
    }
  }
}
class OrderServiceActor (val orderSystem:ActorRef) extends Actor with OrderService {
  // actorRefFactory used by Spray framework
  def actorRefFactory = context
  
  // use Spray Route
  def receive = runRoute(myRoute)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderHttpServer</span><span class="params">(host: String, portNr: Int, orderSystem: ActorRef)</span></span>
    <span class="keyword">extends</span> SprayCanHttpServerApp {
  <span class="comment">//create and start our service actor</span>
  <span class="keyword">val</span> service = system.actorOf(Props(
    <span class="keyword">new</span> OrderServiceActor(orderSystem)), <span class="string">"my-service"</span>)
  <span class="comment">//create a new HttpServer using our handler tell it where to bind to</span>
  <span class="keyword">val</span> httpServer = newHttpServer(service)
  httpServer ! Bind(interface = host, port = portNr)
  
  <span class="keyword">def</span> stop() {
    system.stop(httpServer)
    system.shutdown()
  }
}
</pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre>val orderSystem = <span class="keyword">system</span>.actorOf(Props[OrderSystem])
val orderHttp = <span class="built_in">new</span> OrderHttpServer(<span class="string">"localhost"</span>, <span class="number">8181</span>, orderSystem)

orderSystem ! <span class="string">"reset"</span>
val url = <span class="string">"http://localhost:8181/orderTest"</span>
val msg = <span class="built_in">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">10</span>)
val xml =
  &lt;order&gt;
    &lt;customerId&gt;{ msg.customerId }&lt;/customerId&gt;
    &lt;productId&gt;{ msg.productId }&lt;/productId&gt;
    &lt;<span class="built_in">number</span>&gt;{ msg.<span class="built_in">number</span> }&lt;/<span class="built_in">number</span>&gt;
  &lt;/order&gt;

val urlConnection = <span class="built_in">new</span> <span class="built_in">URL</span>(url)
val conn = urlConnection.openConnection()
conn.setDoOutput(<span class="constant">true</span>)
conn.setRequestProperty(<span class="string">"Content-type"</span>, <span class="string">"text/xml; charset=UTF-8"</span>)
val writer = <span class="built_in">new</span> OutputStreamWriter(conn.getOutputStream)
writer.<span class="built_in">write</span>(xml.toString())
writer.flush()
<span class="comment">
//check result</span>
val reader = <span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader((conn.getInputStream)))
val response = <span class="built_in">new</span> StringBuffer()
var <span class="built_in">line</span> = reader.readLine()
<span class="keyword">while</span> (<span class="built_in">line</span> != <span class="constant">null</span>) {
  response.append(<span class="built_in">line</span>)
  <span class="built_in">line</span> = reader.readLine()
}
writer.<span class="built_in">close</span>()
reader.<span class="built_in">close</span>()

conn.getHeaderField(<span class="constant">null</span>) must be(<span class="string">"HTTP/1.1 200 OK"</span>)
val responseXml = XML.loadString(response.toString)
val confirm = responseXml \ <span class="string">"confirm"</span>

(confirm \ <span class="string">"id"</span>).<span class="keyword">text</span> must be(<span class="string">"1"</span>)
(confirm \ <span class="string">"status"</span>).<span class="keyword">text</span> must be(<span class="string">"received"</span>)

val url2 = <span class="string">"http://localhost:8181/orderTest?id=1"</span>


val urlConnection2 = <span class="built_in">new</span> <span class="built_in">URL</span>(url2)
val conn2 = urlConnection2.openConnection()<span class="comment">
//Get response</span>
val reader2 = <span class="built_in">new</span> BufferedReader(<span class="built_in">new</span> InputStreamReader((conn2.getInputStream)))
val response2 = <span class="built_in">new</span> StringBuffer()
<span class="built_in">line</span> = reader2.readLine()
<span class="keyword">while</span> (<span class="built_in">line</span> != <span class="constant">null</span>) {
  response2.append(<span class="built_in">line</span>)
  <span class="built_in">line</span> = reader2.readLine()
}
reader2.<span class="built_in">close</span>()
<span class="comment">
// check response</span>
conn2.getHeaderField(<span class="constant">null</span>) must be(<span class="string">"HTTP/1.1 200 OK"</span>)
val responseXml2 = XML.loadString(response2.toString)
val status = responseXml2 \ <span class="string">"statusResponse"</span>

(status \ <span class="string">"id"</span>).<span class="keyword">text</span> must be(<span class="string">"1"</span>)
(status \ <span class="string">"status"</span>).<span class="keyword">text</span> must be(<span class="string">"processing"</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Working with Transactions]]></title>
    <link href="http://zhpooer.github.io/2014/08/06/akka-in-action-working-with-transactions/"/>
    <id>http://zhpooer.github.io/2014/08/06/akka-in-action-working-with-transactions/</id>
    <published>2014-08-06T01:47:35.000Z</published>
    <updated>2014-08-06T03:49:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="software-transactional-memory">Software Transactional Memory</h1>
<p>We have an event and we have a number of seats that multiple
threads want to lay claim to. Our shared data is a list of seats</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Seat</span><span class="params">(seatNumber:Int)</span></span>
<span class="keyword">val</span> availableSeats: Seq[Seat])

<span class="comment">// When we want to get a seat from the list we need to</span>
<span class="comment">// get the first available seat and update the list.</span>
<span class="keyword">val</span> head = availableSeats.head
availableSeats = availableSeats.tail
</pre></td></tr></table></figure>

<p>When we can&#39;t or want to use immutable messages
and just want to protect the shared data from becoming inconsistent.</p>
<h2 id="protecting-shared-data">Protecting Shared data</h2>
<p>The most common solution to protecting shared data is that when a thread wants to
access the shared data, we block all other threads from accessing the shared
structure.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>val reservedSeat = availableSeats<span class="preprocessor">.synchronized</span> {
  head = availableSeats<span class="preprocessor">.head</span>
  availableSeats = availableSeats<span class="preprocessor">.tail</span>
  head
}
</pre></td></tr></table></figure>

<p>A problem with this is that when a thread only wants to read all available seats
it still has to lock the list too.</p>
<p>All this locking decreases the performance of the system.</p>
<p>This is called &quot;pessimistic locking”.</p>
<p>Clearly, since there is &#39;pessimistic locking,&#39; there must also be &#39;optimistic
locking.&#39;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>import concurrent.stm.Ref
val availableSeats = Ref(Seq[<span class="link_label">Seat</span>](<span class="link_url"></span>))

//  update our availableSeats we can write
availableSeats() = availableSeats().tail

// When we want to protect the seat list, we get the following 
import concurrent.stm._
val availableSeats = Ref(seats)
val reservedSeat = atomic {implicit txn =&gt; {
  val head = availableSeats().head
  availableSeats() = availableSeats().tail
  head
}}
</pre></td></tr></table></figure>

<p>The critical section
will be executed only once when using synchronized, but using the STM atomic,
the critical section can be executed more than once. This is because at the end of
the block&#39;s execution, a check is done to see if there was a collision. </p>
<h2 id="using-the-stm-transactions">Using the STM transactions</h2>
<p>But when we
want to do a simple read of shared data we need to create an atomic block and this
means writing a lot of code just for a single, simple read. When using only one
reference, you could also use the View of a reference. The Ref.View enables you
to execute one action on one Reference.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>availableSeats<span class="preprocessor">.single</span><span class="preprocessor">.get</span>

val mySeat = atomic {implicit txn =&gt; {
    val head = availableSeats()<span class="preprocessor">.head</span>
    availableSeats() = availableSeats()<span class="preprocessor">.tail</span>
    head
  }}
}

val myseat = availableSeats<span class="preprocessor">.single</span><span class="preprocessor">.getAndTransform</span>(_<span class="preprocessor">.tail</span>)<span class="preprocessor">.head</span>
</pre></td></tr></table></figure>

<p>Using the Ref.View method makes the code a little bit more compact and also
makes the critical section smaller, which decreases the chance of a collision,
improving the total performance of the system.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>// 硬重试
// When the availableSeat list is empty, we call the retry,
// which triggers to execute the alternative atomic block.
val availableSeats = Ref(Seq[<span class="link_label">Seat</span>](<span class="link_url"></span>))
val mySeat = atomic { implicit txn =&gt; {
  val allSeats = availableSeats()
  if (allSeats.isEmpty)
<span class="code">    retry</span>
  val reservedSeat = allSeats.head
  availableSeats() = allSeats.tail
  Some(reservedSeat)
}}.orAtomic {implicit txn =&gt; {
  //else give up and do nothing
  // return a None to indicate we were unable to get a seat.
  None
}}
mySeat must be (None)
</pre></td></tr></table></figure>

<h1 id="agents-within-transactions">Agents within transactions</h1>
<p>When an Agent is used within a transaction, it isn&#39;t necessary to wrap it with an
STM reference to be able to use its data.</p>
<p>Our competing thread will update the agent every 50 ms and our test thread
tries to read the Agent&#39;s state twice within a transaction. When the Agent&#39;s state has
changed in the meantime, the transaction has to be retried.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">// Competing thread updating the agent</span>
<span class="keyword">val</span> seats = (<span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">15</span>) <span class="keyword">yield</span> Seat(i))
<span class="keyword">val</span> availableSeats = Agent(seats)
<span class="keyword">val</span> future = Future {
  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">10</span>) {
    availableSeats send (_.tail)
  }
  Thread.sleep(<span class="number">50</span>)
}

<span class="comment">// 获取线程</span>
<span class="keyword">var</span> nrRuns = <span class="number">0</span>
<span class="keyword">val</span> firstSeat = atomic { implicit txn =&gt; {
  nrRuns += <span class="number">1</span>
  <span class="keyword">val</span> currentList = availableSeats.get
  Thread.sleep(<span class="number">100</span>)
  availableSeats.get.head
}}
Await.ready(future, <span class="number">1</span> second)
nrRuns must be &gt; (<span class="number">1</span>)
firstSeat.seatNumber must be (<span class="number">10</span>)
</pre></td></tr></table></figure>

<p>In this example we see that the critical section is executed more than once,
because the value of the agent has changed during the transaction. </p>
<h2 id="updating-agents-within-a-transaction">Updating Agents within a transaction</h2>
<p>This means that
when we send an action, the action is held until the transaction is committed and
when if the transaction is rolled back, the action sent to the Agent is also rolled
back.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>val numberUpdates = Agent(<span class="number">0</span>)
val count = Ref(<span class="number">5</span>)
Future {
  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="number">10</span>) {
    atomic { <span class="keyword">implicit</span> txn =&gt; {
      count() = count() +<span class="number">1</span>
    }}
    Thread.sleep(<span class="number">50</span>)
  }
}
<span class="keyword">var</span> nrRuns = <span class="number">0</span>
val myNumber = atomic { <span class="keyword">implicit</span> txn =&gt; {
  nrRuns += <span class="number">1</span>
  numberUpdates send (_ + <span class="number">1</span>)
  val <span class="keyword">value</span> = count()
  Thread.sleep(<span class="number">100</span>)
  count()
}}

nrRuns must be &gt; (<span class="number">1</span>)
myNumber must be (<span class="number">15</span>)
Await.ready(numberUpdates.future(), <span class="number">1</span> second)
<span class="comment">// The agent is only one time updated</span>
numberUpdates.<span class="keyword">get</span>() must be (<span class="number">1</span>)
</pre></td></tr></table></figure>

<p> We can&#39;t use Agents and transactions to
solve the problem of transferring money. The problem is that the two actors are
completely unrelated.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(from: Agent[Int], to: Agent[Int], amount: Int)</span>:</span> Boolean = {
  atomic { txn =&gt; 
    <span class="keyword">if</span> (<span class="keyword">from</span>.get &lt; amount) false
    <span class="keyword">else</span> {
      <span class="keyword">from</span> send (_ - amount)
      to send (_ + amount)
      true
    }
  }
}
</pre></td></tr></table></figure>

<h1 id="actors-within-transactions">Actors within transactions</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.transactor.Coordinated
<span class="keyword">import</span> scala.concurrent.duration._
<span class="keyword">import</span> akka.util.Timeout


<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Withdraw</span><span class="params">(amount:Int)</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Deposit</span><span class="params">(amount:Int)</span></span>
<span class="class"><span class="keyword">object</span> <span class="title">GetBalance</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">InsufficientFunds</span><span class="params">(msg:String)</span> <span class="keyword">extends</span> <span class="title">Exception</span><span class="params">(msg)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> balance = Ref(<span class="number">0</span>)
  
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> coordinated @ Coordinated(Withdraw(amount)) {
      coordinated atomic { implicit t
        <span class="keyword">val</span> currentBalance = balance()
        <span class="keyword">if</span> ( currentBalance &lt; amount) {
          <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFunds( <span class="string">"Balance is too low: "</span>+ currentBalance)
        }
        balance() = currentBalance - amount
      }
    }
    <span class="keyword">case</span> coordinated @ Coordinated(Deposit(amount)) {
      coordinated atomic { implicit t
        balance() = balance() + amount
      }
    }
    <span class="keyword">case</span> GetBalance =&gt; sender ! balance.single.get
  }
  
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
    self ! Coordinated(Deposit(balance.single.get))(Timeout(<span class="number">5</span> seconds))
    <span class="keyword">super</span>.preRestart(reason, message)
  }
}

<span class="comment">// 测试代码</span>
implicit <span class="keyword">val</span> timeout = Timeout(<span class="number">5</span> seconds)
<span class="keyword">val</span> transaction = Coordinated()
transaction atomic { implicit t =&gt;
  account1 ! transaction(Deposit(amount = <span class="number">100</span>))
}

<span class="keyword">val</span> probe = TestProbe()
probe.send(account1, GetBalance)
probe.expectMsg(<span class="number">100</span>)

<span class="comment">// 更简洁的代码</span>
<span class="keyword">val</span> account1 = system.actorOf(Props[Account])
implicit <span class="keyword">val</span> timeout = <span class="keyword">new</span> Timeout(<span class="number">1</span> second)

account1 ! Coordinated(Deposit(amount = <span class="number">100</span>))

<span class="keyword">val</span> probe = TestProbe()
probe.send(account1, GetBalance)
probe.expectMsg(<span class="number">100</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 转账的代码</span>
def receive = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="keyword">from</span>, to) =&gt; {
    val transaction = Coordinated()
    transaction atomic { <span class="keyword">implicit</span> t
      <span class="keyword">from</span> ! transaction(Withdraw(amount))
      to ! transaction(Deposit(amount))
    }
    sender ! <span class="string">"done"</span>
  }
}
</pre></td></tr></table></figure>

<h2 id="creating-transactors">Creating transactors</h2>
<p>Transactors are actors that are capable of dealing with messages that comprise
Coordinated transactions.</p>
<p>All the functional code will been seen again in the example, only the
Coordinated part is removed, because the transactor will hide it from our code.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.transactor.Transactor
<span class="class"><span class="keyword">class</span> <span class="title">AccountTransactor</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Transactor</span> {</span>
  <span class="keyword">val</span> balance = Ref(<span class="number">0</span>)
  <span class="keyword">def</span> atomically = implicit txn =&gt; {
    <span class="keyword">case</span> Withdraw(amount) =&gt; {
      <span class="keyword">val</span> currentBalance = balance()
      <span class="keyword">if</span> ( currentBalance &lt; amount) {
        <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFunds(<span class="string">"Balance is too low: "</span>+ currentBalance)
      }
      balance() = currentBalance - amount
      
    <span class="keyword">case</span> Deposit(amount) =&gt; {
      balance() = balance() + amount
    }
  }
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message:Option[Any]) {
    <span class="comment">// 为了保存数据</span>
    self ! Deposit(balance.single.get)
    <span class="keyword">super</span>.preRestart(reason, message)
  }
  <span class="comment">// All messages which are implemented in the normally function,</span>
  <span class="comment">// will not be passed to the atomically function. </span>
  <span class="keyword">override</span> <span class="keyword">def</span> normally = {
    <span class="keyword">case</span> GetBalance =&gt; sender ! balance.single.get
  }
}

<span class="comment">// 测试代码</span>
<span class="keyword">val</span> account1 = system.actorOf(Props[AccountTransactor])
<span class="keyword">val</span> account2 = system.actorOf(Props[AccountTransactor])
<span class="keyword">val</span> transaction = Coordinated()
transaction atomic { implicit t
  account1 ! transaction(Withdraw(amount = <span class="number">50</span>))
  account2 ! transaction(Deposit(amount = <span class="number">50</span>))
}
</pre></td></tr></table></figure>

<p>When we deposit some
money in an account it doesn&#39;t need to be done in a Coordinated transaction. We
already saw that we can send a coordinated message without joining the
transaction, but when using a transactor, we can also send just the message.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>// These <span class="constant">two</span> <span class="keyword">lines</span> <span class="operator">of</span> code are equivalent when <span class="keyword">using</span> <span class="operator">a</span> transactor. 
account1 ! Coordinated(Deposit(amount = <span class="number">100</span>))
account1 ! Deposit(amount = <span class="number">100</span>)
</pre></td></tr></table></figure>

<p>The AccountTransactor only
acts within a transaction, but it doesn&#39;t include other actors within its transaction.
When the transfer Actor starts a coordinated transaction we need to include both
accounts in the transaction.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>override def coordinate = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="built_in">from</span>, <span class="built_in">to</span>) =&gt;
    sendTo(<span class="built_in">from</span> -&gt; Withdraw(amount),
    <span class="built_in">to</span> -&gt; Deposit(amount))
}<span class="comment">
// When you want to send the received message to the other actors, you can also use the include method:</span><span class="comment">
// sends the received Message to the three actors. </span>
override def coordinate = {
  <span class="keyword">case</span> msg:Message =&gt; <span class="built_in">include</span>(actor1, actor2, actor3)
}
</pre></td></tr></table></figure>

<p>For these kind of actions, a
transactor has two methods which can be overridden, the before and after method.
These methods are called just before and after the atomically method and are also
partial functions. For our example, we don&#39;t need the before method, but using the
after to be able to send the &quot;done&quot; message when the transaction has successfully
ended.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>override def <span class="keyword">after</span> = {
  <span class="keyword">case</span> TransferTransaction(amount, <span class="built_in">from</span>, <span class="built_in">to</span>) =&gt; sender ! <span class="string">"done"</span>
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Message Channels & Finite State Machines]]></title>
    <link href="http://zhpooer.github.io/2014/08/05/akka-in-action-message-channels/"/>
    <id>http://zhpooer.github.io/2014/08/05/akka-in-action-message-channels/</id>
    <published>2014-08-05T03:11:47.000Z</published>
    <updated>2014-08-05T14:26:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="chinnel-types">Chinnel types</h1>
<p>Other names which are often used for these kind of channels are EventQueue or
EventBus. Akka has an EventStream which implements a publish-subscribe
channel. But when this implementation isn&#39;t sufficient, then Akka has a collection
of traits which helps to implement an custom publish subscribe channel.</p>
<p>Next we describe two special channels. The first is the Dead Letter channel,
which contain message that couldn&#39;t be delivered.
This channel can help when debugging, why some messages
aren&#39;t processed or to monitor where there are problems.</p>
<h2 id="point-to-point">Point to Point</h2>
<p>The point-to-point channel sends the message to one receiver.</p>
<p><img src="/img/akka_point2point.png" alt="point 2 point img"></p>
<p>The round-robin
Router in section 7.3.1 is an example of the channel having multiple receivers. The
processing of the messages can be done concurrently by different Receivers, but
only one Receiver consumes any one message.</p>
<p>Because in Akka the ActorRef is the implementation of a point-to-point channel.
Because all the messages send will be delivered to one Actor.</p>
<h2 id="publish-subscribe">Publish subscribe</h2>
<p>The channel can also deliver the same message to multiple receivers.</p>
<p>To solve this problem we can use
the Publish-subscribe channel. The channel is able to send the same message to
multiple receivers, without the sender knows which receiver.</p>
<p>When a receiver is interested in a message of the publisher, it subscribes itself
to the channel.</p>
<p>The most easiest when needed a publish-subscribe channel,
is to use the EventStream.The EventStream can be seen as a
manager of multiple Publish-Subscribe channels.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// subscirbe <span class="built_in">to</span> <span class="operator">the</span> EventStream <span class="built_in">to</span> receive Order messages
<span class="keyword">system</span>.eventStream.subscribe(giftModule, classOf[Order])<span class="comment">
// unsubscribe</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule, classOf[Order])
<span class="comment">
// 取消订阅所有消息</span>
<span class="keyword">system</span>.eventStream.unsubscribe(giftModule.ref)<span class="comment">
// 发布消息</span>
<span class="keyword">system</span>.eventStream.publish(msg)
</pre></td></tr></table></figure>

<h2 id="custom-eventbus">CUSTOM EVENTBUS</h2>
<p>Let assume that we only want to send a gift when someone ordered more than one
book.</p>
<p> An EventBus is generalized so
that it can be used for all implementations of a publish-subscribe channel. In the
generalized form there are three entities.</p>
<ul>
<li>Event, This is the type of all events published on that bus. In the Akka EventStream all uses
AnyRef as event and therefor supports all type of messages</li>
<li>Subscriber, This is the type of subscribers allowed to register on that event bus. In the Akka
EventStream the subscribers are ActorRef&#39;s</li>
<li>Classifier, This defines the classifier to be used in selecting subscribers
for dispatching events. </li>
</ul>
<p>EventBus Interface</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>package akka.event
trait EventBus {
  type Event
  type Classifier
  type Subscriber
  /**
  * Attempts to register the subscriber to the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it was</span>
  * already subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(subscriber: Subscriber, to: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> the specified Classifier
  * <span class="decorator">@return true if successful and false if not (because it wasn't</span>
  * subscribed to that Classifier, <span class="keyword">or</span> otherwise)
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber, from: Classifier)</span>:</span> Boolean
  /**
  * Attempts to deregister the subscriber <span class="keyword">from</span> all Classifiers it may
  * be subscribed to
  */
  <span class="function"><span class="keyword">def</span> <span class="title">unsubscribe</span><span class="params">(subscriber: Subscriber)</span>:</span> Unit
  /**
  * Publishes the specified Event to this bus
  */
  <span class="function"><span class="keyword">def</span> <span class="title">publish</span><span class="params">(event: Event)</span>:</span> Unit
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> {</span>
  <span class="keyword">type</span> Event = Order
  <span class="comment">// chosen to classify the Order messages on the criteria "is Multiple</span>
  <span class="comment">// Book Order" and use a Boolean as classifier </span>
  <span class="keyword">type</span> Classifier = Boolean

}
</pre></td></tr></table></figure>

<p>Akka has three composable traits which can help in keeping
track of the subscribers.</p>
<ul>
<li>LookupClassification,  It maintain a set of subscribers for each
possible classifier and extract a classifier from each event.</li>
<li>SubchannelClassification, This trait is used when classifiers form a hierarchy
and it is desired that subscription can be possible not only at the leaf nodes,
but also to the higher nodes.</li>
<li>ScanningClassification,  it can be used when classifiers have an overlap. This
means that one Event can be part of more classifiers, for example if we give more gifts
when ordering more books.</li>
</ul>
<p>API of LookupClassification</p>
<ul>
<li>classify(event: Event): Classifier
This is used for extracting the classifier from the incoming events.</li>
<li>compareSubscribers(a: Subscriber, b: Subscriber): Int
This method must define a order over the subscribers, to be able to compare them just as
the java.lang.Comparable.compare method.</li>
<li>publish(event: Event, subscriber: Subscriber),
This method will be invoked for each event for all subscribers which registered
themselves for the events classifier.</li>
<li>mapSize: Int, This returns the expected number of the different classifiers.
This is used for the initial size of an internal data structure.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.event.ActorEventBus
<span class="keyword">import</span> akka.event.{ LookupClassification, EventBus }

<span class="class"><span class="keyword">class</span> <span class="title">OrderMessageBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> <span class="keyword">with</span> <span class="title">LookupClassification</span></span>
    <span class="keyword">with</span> ActorEventBus {  <span class="comment">//  defines that the subscriber is an ActorRef.</span>
  <span class="keyword">type</span> Event = Order
  <span class="keyword">type</span> Classifier = Boolean
  <span class="keyword">def</span> mapSize = <span class="number">2</span>
  
  <span class="keyword">protected</span> <span class="keyword">def</span> classify(event: StateEventBus#Event) = {
    event.number &gt; <span class="number">1</span>
  }
  
  <span class="comment">// publish method by sending the event to the subscriber</span>
  <span class="keyword">protected</span> <span class="keyword">def</span> publish(event: OrderMessageBus#Event,
      subscriber: OrderMessageBus#Subscriber) {
    subscriber ! event
  }

}


<span class="comment">// Test for event bus</span>
<span class="keyword">val</span> bus = <span class="keyword">new</span> OrderMessageBus
<span class="keyword">val</span> singleBooks = TestProbe()
bus.subscribe(singleBooks.ref, <span class="keyword">false</span>)

<span class="keyword">val</span> multiBooks = TestProbe()
bus.subscribe(multiBooks.ref, <span class="keyword">true</span>)

<span class="keyword">val</span> msg = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)
bus.publish(msg)

singleBooks.expectMsg(msg)
multiBooks.expectNoMsg(<span class="number">3</span> seconds)

<span class="keyword">val</span> msg2 = <span class="keyword">new</span> Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">3</span>)
bus.publish(msg2)
singleBooks.expectNoMsg(<span class="number">3</span> seconds)
multiBooks.expectMsg(msg2)
</pre></td></tr></table></figure>

<h1 id="specialize-channel">Specialize Channel</h1>
<p>DeadLetter channel,  Only failed message are put on this channel. Listening on this
channel can help to find problems in your system.</p>
<p>Guaranteed deliver channel, his channel guaranties
all messages which are send are also delivered</p>
<h2 id="dead-letter">Dead letter</h2>
<p>By monitoring this channel you know which messages aren&#39;t processed and can
take corrective actions.</p>
<p> To get these dead letter messages you
only need to subscribe your actor to the EventStream with the DeadLetter class as
the Classifier.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>val deadLetterMonitor: ActorRef

system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
  deadLetterMonitor,
  classOf[DeadLetter])

// 测试代码
val deadLetterMonitor = TestProbe()
system<span class="preprocessor">.eventStream</span><span class="preprocessor">.subscribe</span>(
    deadLetterMonitor<span class="preprocessor">.ref</span>,
    classOf[DeadLetter])
    
val actor = system<span class="preprocessor">.actorOf</span>(Props[EchoActor], <span class="string">"echo"</span>)
actor ! PoisonPill
val msg = new Order(<span class="string">"me"</span>, <span class="string">"Akka in Action"</span>, <span class="number">1</span>)

actor ! msg

//  wrapped also into a DeadLetter object
val dead = deadLetterMonitor<span class="preprocessor">.expectMsgType</span>[DeadLetter]
dead<span class="preprocessor">.message</span> must be(msg)
dead<span class="preprocessor">.sender</span> must be(testActor)
dead<span class="preprocessor">.recipient</span> must be(actor)
</pre></td></tr></table></figure>

<h1 id="guaranteed-delivery">Guaranteed delivery</h1>
<p>The guaranteed delivery channel is point-to-point channel with the guaranty that
the message is always delivered to the receiver.</p>
<p>This means that the channel must have
all kind of mechanism and checks to be able to guaranty the delivery, for example
the message has to be saved on disk in case the process crashes.</p>
<p>The general rule of message delivery is that messages are delivered
at-most-once. This means that Akka promise that messages are delivered once or
fails to deliver, Which means that the message is lost.</p>
<p>Sending local messages will not likely fails, because it is like a normal method
call. This fails only when there are catastrophic VM errors, like
StackOverflowError, OutOfMemoryError or a memory access violation.
So the guaranties when sending a message to a local actor, are pretty good
and reliable.</p>
<p>The problem of losing the messages is when using remote actors. When using
remote actors, it is a lot more likely for a message delivery failure to occur.</p>
<p>The Egress is an Actor which is started by the
ReliableProxy and both Actors implements the checks and resend functionality to
be able to keep track of which of the messages are delivered to the remote receiver.</p>
<p> One restriction of using the ReliableProxy is that the tunnel is only one-way
and for one receiver. This means that when the receiver replies to the sender the
tunnel is NOT used.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.contrib.pattern.ReliableProxy
<span class="keyword">val</span> echo = system.actorFor(node(server) / <span class="string">"user"</span> / <span class="string">"echo"</span>)
<span class="comment">// In the example we create a proxy using the echo reference.</span>
<span class="comment">// When failing to send a message it is retried after 500 milliseconds.</span>
<span class="keyword">val</span> proxy = system.actorOf(Props(<span class="keyword">new</span> ReliableProxy(echo, <span class="number">500.</span>millis)), <span class="string">"proxy"</span>)
</pre></td></tr></table></figure>

<p>We create a Multi-node test with two nodes, the client and server
node. On the server Node we create a EchoActor as receiver and on the client node
we run our actual test.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.remote.testkit.MultiNodeSpecCallbacks
<span class="keyword">import</span> akka.remote.testkit.MultiNodeConfig
<span class="keyword">import</span> akka.remote.testkit.MultiNodeSpec

<span class="class"><span class="keyword">trait</span> <span class="title">STMultiNodeSpec</span></span>
    <span class="keyword">extends</span> MultiNodeSpecCallbacks
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> BeforeAndAfterAll {
  <span class="keyword">override</span> <span class="keyword">def</span> beforeAll() = multiNodeSpecBeforeAll()
  <span class="keyword">override</span> <span class="keyword">def</span> afterAll() = multiNodeSpecAfterAll()
}

<span class="class"><span class="keyword">object</span> <span class="title">ReliableProxySampleConfig</span> <span class="keyword">extends</span> <span class="title">MultiNodeConfig</span> {</span>
  <span class="keyword">val</span> client = role(<span class="string">"Client"</span>)
  <span class="keyword">val</span> server = role(<span class="string">"Server"</span>)
  testTransport(on = <span class="keyword">true</span>)
}

<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode1</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
<span class="class"><span class="keyword">class</span> <span class="title">ReliableProxySampleSpecMultiJvmNode2</span> <span class="keyword">extends</span> <span class="title">ReliableProxySample</span></span>
</pre></td></tr></table></figure>

<p>TODO P257</p>
<h1 id="using-a-finite-state-machine">Using a Finite State Machine</h1>
<p>Finite-state machine (FSM), also called a state machine, is a common,
language-independent modeling technique.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p>The simplest example of a Finite State Machine is a device whose operation
proceeds through several states, transitioning from one to the next as certain events
occur.</p>
<p><img src="/img/akka_FSM.png" alt="fsm"></p>
<h2 id="creating-an-fsm-model">Creating an FSM Model</h2>
<p>The inventory Service gets requests for
specific books and sends a reply. When the book is in inventory, the order system
gets a reply that a book has been reserved. But it is possible that there aren&#39;t any
books left and that the inventory will have to ask the publisher for more books,
before it can service the order.</p>
<p><img src="/img/akka_FMS.png" alt="fms"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre></td><td class="code"><pre>
<span class="comment">// State, The super type of all state names</span>
<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForRequests</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessRequest</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">WaitForPublisher</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ProcessSoldOut</span> <span class="keyword">extends</span> <span class="title">State</span></span>

<span class="comment">// StateData, The type of the state data which are tracked by the FSM.</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateData</span><span class="params">(nrBooksInStore:Int,pendingRequests:Seq[BookRequest])</span></span>


<span class="keyword">import</span> akka.actor.{Actor, FSM}
<span class="class"><span class="keyword">class</span> <span class="title">Inventory</span><span class="params">()</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">FSM</span>[<span class="title">State</span>, <span class="title">StateData</span>] {</span>
  <span class="comment">// define the initial state and the initial StateData.</span>
  startWith(WaitForRequests, <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq()))

  <span class="comment">// Declare the transitions for state WaitForRequests</span>
  when(WaitForRequests) {
    <span class="comment">// Declare the possible Event when a BookRequest messages occur</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; 
      <span class="keyword">val</span> newStateData = data.copy(pendingRequests = data.pendingRequests :+ request)
      
      <span class="keyword">if</span> (newStateData.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest) using newStateData
      } <span class="keyword">else</span> {
        goto(WaitForPublisher) using newStateData
      }
    <span class="keyword">case</span> Event(PendingRequests, data:StateData) =&gt; 
      <span class="keyword">if</span> (data.pendingRequests.isEmpty) {
        stay
      } <span class="keyword">else</span> <span class="keyword">if</span>(data.nrBooksInStore &gt; <span class="number">0</span>) {
        goto(ProcessRequest)
      } <span class="keyword">else</span> {
        goto(WaitForPublisher)
      }
  }

  when(WaitForPublisher) {
    <span class="keyword">case</span> Event(supply:BookSupply, data:StateData) =&gt; {
      goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
    }
    <span class="keyword">case</span> Event(BookSupplySoldOut, _) =&gt; {
      goto(ProcessSoldOut)
    }
  }

  when(ProcessRequest) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(WaitForRequests) using data.copy(
          nrBooksInStore = data.nrBooksInStore - <span class="number">1</span>,
          pendingRequests = data.pendingRequests.tail)
    }
  }

  when(SoldOut) {
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      goto(ProcessSoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq(request))
    }
  }

  when(ProcessSoldOut) {
    <span class="keyword">case</span> Event(Done, data:StateData) =&gt; {
      goto(SoldOut) using <span class="keyword">new</span> StateData(<span class="number">0</span>,Seq())
    }
  }

  whenUnhandled {
    <span class="comment">// common code for all states</span>
    <span class="keyword">case</span> Event(request:BookRequest, data:StateData) =&gt; {
      <span class="comment">// Only update the stateData</span>
      stay using data.copy(pendingRequests = data.pendingRequests :+ request)
    }
    <span class="comment">// Log when the event isn't handled</span>
    <span class="keyword">case</span> Event(e, s) =&gt; {
      log.warning(<span class="string">"received unhandled request {} in state {}/{}"</span>, e, stateName, s)
      stay
    }
  }

  <span class="comment">// entry Action of the WaitForRequests state</span>
  onTransition {
    <span class="keyword">case</span> _ -&gt; WaitForRequests =&gt; {
      <span class="keyword">if</span> (!nextStateData.pendingRequests.isEmpty) {
        <span class="comment">// go to next state</span>
        self ! PendingRequests
      }
    }
    
    <span class="keyword">case</span> _ -&gt; WaitForPublisher =&gt; {
      publisher ! PublisherRequest
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessRequest =&gt; {
      <span class="keyword">val</span> request = nextStateData.pendingRequests.head
      reserveId += <span class="number">1</span>
      request.target ! <span class="keyword">new</span> BookReply(request.context, Right(reserveId))
      self ! Done
    }
    
    <span class="keyword">case</span> _ -&gt; ProcessSoldOut =&gt; {
      nextStateData.pendingRequests.foreach(request =&gt; {
        request.target ! <span class="keyword">new</span> BookReply(request.context, Left(<span class="string">"SoldOut"</span>))
      })
      self ! Done
    }
  }

}
</pre></td></tr></table></figure>

<h2 id="testing-the-fsm">TESTING THE FSM</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(totalNrBooks: Int, nrBooksPerRequest: Int)</span></span>
    <span class="keyword">extends</span> Actor {
  <span class="keyword">var</span> nrLeft = totalNrBooks
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> PublisherRequest =&gt; {
      <span class="keyword">if</span> (nrLeft == <span class="number">0</span>)
      sender ! BookSupplySoldOut
      <span class="keyword">else</span> {
        <span class="keyword">val</span> supply = min(nrBooksPerRequest, nrLeft)
        nrLeft -= supply
        sender ! <span class="keyword">new</span> BookSupply(supply)
      }
    }
  }
}

<span class="keyword">val</span> publisher = system.actorOf(Props(<span class="keyword">new</span> Publisher(<span class="number">2</span>,<span class="number">2</span>)))
<span class="keyword">val</span> inventory = system.actorOf(Props(<span class="keyword">new</span> Inventory(publisher)))
<span class="keyword">val</span> stateProbe = TestProbe()

<span class="comment">// 订阅状态变化信息</span>
inventory ! <span class="keyword">new</span> SubscribeTransitionCallBack(stateProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> CurrentState(inventory, WaitForRequests))

inventory ! <span class="keyword">new</span> BookRequest(<span class="string">"context1"</span>, replyProbe.ref)
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForRequests, WaitForPublisher))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, WaitForPublisher, ProcessRequest))
stateProbe.expectMsg(<span class="keyword">new</span> Transition(inventory, ProcessRequest, WaitForRequests))
replyProbe.expectMsg(<span class="keyword">new</span> BookReply(<span class="string">"context1"</span>, Right(<span class="number">1</span>)))
</pre></td></tr></table></figure>

<h2 id="timers-within-fsm">Timers within FSM</h2>
<p>When it is in the state &#39;WaitingForPublisher,&#39;
we don&#39;t wait forever for the publisher to reply.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">when</span>(WaitForPublisher, stateTimeout = <span class="number">5</span> seconds) {
  <span class="reserved">case</span> Event<span class="function"><span class="params">(supply:BookSupply, data:StateData)</span> =&gt;</span> {
    goto(ProcessRequest) using data.copy(nrBooksInStore = supply.nrBooks)
  }
  <span class="reserved">case</span> Event<span class="function"><span class="params">(BookSupplySoldOut, _)</span> =&gt;</span> {
    goto(ProcessSoldOut)
  }
  <span class="regexp">//</span> Define the timeout transition
  <span class="reserved">case</span> Event<span class="function"><span class="params">(StateTimeout,_)</span> =&gt;</span> goto(WaitForRequests)
}

<span class="regexp">//</span> 当测试时
<span class="regexp">//</span> stateProbe.expectMsg(<span class="number">6</span> seconds,<span class="keyword">new</span> Transition(inventory, WaitForPublisher, WaitForRequests))
</pre></td></tr></table></figure>

<p>The timer can also be set by specifying the next state using the
method forMax.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">goto</span><span class="params">(<span class="variable">WaitForPublisher</span>)</span> <span class="title">using</span> <span class="params">(new<span class="variable">Data</span>)</span> <span class="title">forMax</span> <span class="params">(<span class="number">5</span> seconds)</span></span>
</pre></td></tr></table></figure>

<h2 id="termination-of-fsm">Termination of FSM</h2>
<p>The FSM has an
specific handler for these cases: onTermination. This handler is also a partial
function and takes a StopEvent as an argument.</p>
<p>There are three possible reasons this can be received.</p>
<ul>
<li>Normal. This is received when there is a normal termination.</li>
<li>Shutdown. This is received when the FSM is stopped due to a shutdown.</li>
<li>Failure(cause: Any), This reason is received when the termination was caused by a failure</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="title">onTermination</span> {
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Normal</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Shutdown</span>, state, <span class="typedef"><span class="keyword">data</span>)</span>
  <span class="keyword">case</span> <span class="type">StopEvent</span>(<span class="type">FSM</span>.<span class="type">Failure</span>(cause), state, <span class="typedef"><span class="keyword">data</span>)</span>
}
</pre></td></tr></table></figure>

<h1 id="implement-shared-state-using-agents">Implement Shared state using agents</h1>
<p>Akka accomplishes this by sending
actions to the agent for each operation, where the messaging infrastructure will
preclude a race condition.</p>
<p>For our example, we need to share the number
of copies sold for each book, so we will create an Agent that contains this value.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">BookStatics</span><span class="params">(val nameBook: String, nrSold: Int)</span></span>
<span class="comment">// a BookStatics instance is created which is put into a map using the title as the key</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">StateBookStatics</span><span class="params">(val sequence: Long, books: Map[String, BookStatics])</span></span>
</pre></td></tr></table></figure>

<p>The state object contained by the agent must be immutable.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.global
<span class="keyword">import</span> akka.agent.Agent
<span class="keyword">val</span> stateAgent = <span class="keyword">new</span> Agent(<span class="keyword">new</span> StateBookStatics(<span class="number">0</span>,Map()))

<span class="keyword">val</span> currentBookStatics = stateAgent.get <span class="comment">// 使用 stateAgent() 效果一样</span>

<span class="comment">// 如果 agent 的值是依赖前一个状态的呢?</span>
<span class="keyword">val</span> newState = StateBookStatics(<span class="number">1</span>, Map(book -&gt; bookStat ))
stateAgent send newState

<span class="comment">// 可以这样</span>
<span class="keyword">val</span> book = <span class="string">"Akka in Action"</span>
<span class="keyword">val</span> nrSold = <span class="number">1</span>
stateAgent send( oldState =&gt; {
  <span class="keyword">val</span> bookStat = oldState.books.get(book) <span class="keyword">match</span> {
    <span class="keyword">case</span> Some(bookState) =&gt;
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="keyword">case</span> None =&gt; <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>, oldState.books + (book -&gt; bookStat ))
})
</pre></td></tr></table></figure>

<h2 id="waiting-for-the-state-update">Waiting for the state update</h2>
<p>In some cases, we need to update shared state and use the new state. For example,
we need to know which book is selling the most, and when a book becomes
popular, we want to notify the authors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>implicit val timeout = Timeout(<span class="number">1000</span>)

<span class="regexp">//</span> It works exactly as the send method only it returns a Future,
<span class="regexp">//</span> which can be used to wait <span class="keyword">for</span> the <span class="keyword">new</span> state.
val future = stateAgent alter( oldState<span class="function"> =&gt;</span> {
  val bookStat = oldState.books.get(book) match {
    <span class="reserved">case</span> Some<span class="function"><span class="params">(bookState)</span> =&gt;</span>
      bookState.copy(nrSold = bookState.nrSold + nrSold)
    <span class="reserved">case</span> None<span class="function"> =&gt;</span>
      <span class="keyword">new</span> BookStatics(book, nrSold)
  }
  oldState.copy(oldState.sequence+<span class="number">1</span>,oldState.books + (book<span class="function"> -&gt;</span> bookStat ))
})

val newState = Await.result(future, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<p> It is possible that there are multiple changes at
nearly the same time and we want the final state or another thread needs the final
state and only knows that the process before it may have updated the state. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>val <span class="keyword">future</span> = stateAgent.<span class="keyword">future</span>
val newState = <span class="keyword">Await</span>.<span class="keyword">result</span>(<span class="keyword">future</span>, <span class="number">1</span> second)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.ExecutionContext.Implicits.<span class="keyword">global</span>
val agent1 = Agent(<span class="number">3</span>)
// When using this notation, agent2 <span class="keyword">is</span> a newly created Agent that contains the
// value <span class="number">4</span> <span class="keyword">and</span> agent1 <span class="keyword">is</span> just the same <span class="keyword">as</span> before (it still contains the value <span class="number">3</span>).
val agent2 = agent1 map (_ + <span class="number">1</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-System Structure & Routing Messages]]></title>
    <link href="http://zhpooer.github.io/2014/08/04/akka-in-action-system-structure/"/>
    <id>http://zhpooer.github.io/2014/08/04/akka-in-action-system-structure/</id>
    <published>2014-08-04T10:47:29.000Z</published>
    <updated>2014-08-05T03:10:01.000Z</updated>
    <content type="html"><![CDATA[<p>One of the immediate implications of Actor based programming is how do we
model code that requires collaborators to work together if each unit of work is done
in parallel?</p>
<p>Akka allows us to use these design approaches while still making use of its
inherent concurrency.</p>
<ul>
<li>integration tools and platforms</li>
<li>messaging systems</li>
<li>WSO2, and SOA and Web-service based solutions</li>
</ul>
<h1 id="pipes-and-filters">Pipes and Filters</h1>
<p>The concept of piping refers to the ability for one process or thread to pump its
results to another processor for additional processing.</p>
<p>In many systems a single event will trigger a sequence of tasks.</p>
<p>It receives the photo and before the event is sent to central
processing, a number of checks are done. When no license plate is found in the
photo, the system is unable to process the message any further and therefore, it will
be discarded.  In this example we also discard the message when the speed is below
the maximum speed. Which means that only messages that contain the license
plate of a speeding vehicle end up getting to the central processor.</p>
<p>Each Filter consists of three parts, the inbound pipe where the message is
received, the processor of the message, and finally the outbound pipe where the
result of the processing is published.</p>
<p>An important restriction is that each filter must accept and
send the same messages, because the outbound pipe of a filter can be the inbound
pipe of any other filter in the pattern. </p>
<p>A Pipe with Two Filters Example</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Photo</span><span class="params">(license: String, speed: Int)</span></span>

<span class="class"><span class="keyword">class</span> <span class="title">SpeedFilter</span><span class="params">(minSpeed: Int, pipe: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>

  <span class="comment">// Filter all Photos which have a speed lower than the minimal speed</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: Photo =&gt;
      <span class="keyword">if</span> (msg.speed &gt; minSpeed) pipe ! msg
  }
}

<span class="comment">// Filter all Photos which have an empty license</span>
<span class="class"><span class="keyword">class</span> <span class="title">LicenseFilter</span><span class="params">(pipe: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: Photo =&gt;
      <span class="keyword">if</span> (!msg.license.isEmpty) pipe ! msg
  }
}


<span class="comment">// Pipe and filter test</span>

<span class="keyword">val</span> endProbe = TestProbe()
<span class="keyword">val</span> speedFilterRef = system.actorOf( Props(<span class="keyword">new</span> SpeedFilter(<span class="number">50</span>, endProbe.ref)))

<span class="keyword">val</span> licenseFilterRef = system.actorOf(Props(<span class="keyword">new</span> LicenseFilter(speedFilterRef)))
<span class="keyword">val</span> msg = <span class="keyword">new</span> Photo(<span class="string">"123xyz"</span>, <span class="number">60</span>)

licenseFilterRef ! msg
endProbe.expectMsg(msg)
licenseFilterRef ! <span class="keyword">new</span> Photo(<span class="string">""</span>, <span class="number">60</span>)

endProbe.expectNoMsg(<span class="number">1</span> second)
licenseFilterRef ! <span class="keyword">new</span> Photo(<span class="string">"123xyz"</span>, <span class="number">49</span>)
endProbe.expectNoMsg(<span class="number">1</span> second)
</pre></td></tr></table></figure>

<h1 id="scatter-gather-pattern">Scatter-Gather Pattern</h1>
<p>The first case is when the
tasks are functionally the same, but only one is passed through to the gather
component as the chosen result. The second scenario is when work is divided for
parallel processing and each processor submits its results which are then combined
into a result set by the aggregator. </p>
<h2 id="competing-tasks">Competing Tasks</h2>
<p>A client buys a product, let&#39;s say a book at a
web shop, but the shop doesn&#39;t have the requested book in stock, so it has to buy
the book from a supplier. But the shop is doing business with three different
suppliers and wants to pay the lowest price.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PhotoMessage</span><span class="params">(id: String,
    photo: String,
    creationTime: Option[Date] = None,
    speed: Option[Int] = None)</span></span>
    
<span class="comment">// task  handler</span>
<span class="class"><span class="keyword">class</span> <span class="title">GetSpeed</span><span class="params">(pipe:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg:PhotoMessage =&gt; {
      pipe ! msp.copy(speed = ImageProcessing.getSpeed(msg.photo))
    }
  }
}
<span class="class"><span class="keyword">class</span> <span class="title">GetTime</span><span class="params">(pipe: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: PhotoMessage =&gt; {
      pipe ! msg.copy(creationTime = ImageProcessing.getTime(msg.photo))
    }
  }
}

<span class="comment">// distribute received message to all processing tasks</span>
<span class="class"><span class="keyword">class</span> <span class="title">RecipientList</span><span class="params">(recipientList:Seq[ActorRef])</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: AnyRef =&gt; recipientList.foreach( _ ! msg)
  }
}

<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">TimeoutMessage</span><span class="params">(msg:PhotoMessage)</span></span>

<span class="comment">// 聚合, 等待两个actor消息, 当一个消息回来时, 接着等待另一个, 加上了定时功能</span>
<span class="class"><span class="keyword">class</span> <span class="title">Aggregator</span><span class="params">(timeout:Duration, pipe:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> messages = <span class="keyword">new</span> ListBuffer[PhotoMessage]
  implicit <span class="keyword">val</span> ec = context.system.dispatcher
  <span class="comment">// Send all the received messages to our own mailbox</span>

  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
    <span class="keyword">super</span>.preRestart(reason, message)
    messages.foreach(self ! _)
    messages.clear()
  }
  
  <span class="comment">// The first thing when receiving a message,</span>
  <span class="comment">// is to check if it is the first message or the second. </span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> rcvMsg: PhotoMessage =&gt; {
      messages.find(_.id == rcvMsg.id) <span class="keyword">match</span> {
        <span class="keyword">case</span> Some(alreadyRcvMsg) =&gt; {
        
          <span class="keyword">val</span> newCombinedMsg = <span class="keyword">new</span> PhotoMessage(
            rcvMsg.id,
            rcvMsg.photo,
            rcvMsg.creationTime.orElse(alreadyRcvMsg.creationTime),
            rcvMsg.speed.orElse(alreadyRcvMsg.speed) )
            
          pipe ! newCombinedMsg
          <span class="comment">//cleanup message</span>
          messages -= alreadyRcvMsg
        }
        <span class="keyword">case</span> None =&gt;{
          messages += rcvMsg
          <span class="comment">// 如果在规定的时间内没有收到信息</span>
          context.system.scheduler.scheduleOnce(
            timeout,
            self,
            <span class="keyword">new</span> TimeoutMessage(rcvMsg))
        }
    }
    <span class="keyword">case</span> TimeoutMessage(rcvMsg) =&gt; {
      messages.find(_.id == rcvMsg.id) <span class="keyword">match</span> {
        <span class="keyword">case</span> Some(alreadyRcvMsg) =&gt; {
          pipe ! alreadyRcvMsg
          messages -= alreadyRcvMsg
        }
        <span class="keyword">case</span> None =&gt; <span class="comment">//message is already processed</span>
    }
    <span class="keyword">case</span> ex: Exception =&gt; <span class="keyword">throw</span> ex
  }
}
</pre></td></tr></table></figure>

<p>Test Aggregator missing a message</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">val</span> endProbe = TestProbe()
<span class="keyword">val</span> actorRef = system.actorOf(Props(<span class="keyword">new</span> Aggregator(<span class="number">1</span> second, endProbe.<span class="keyword">ref</span>)))
<span class="keyword">val</span> photoStr = ImageProcessing.createPhotoString(<span class="keyword">new</span> Date(), <span class="number">60</span>)
<span class="keyword">val</span> msg1 = PhotoMessage(<span class="string">"id1"</span>, photoStr, Some(<span class="keyword">new</span> Date()), None)
actorRef ! msg1
actorRef ! <span class="keyword">new</span> IllegalStateException(<span class="string">"restart"</span>)
<span class="keyword">val</span> msg2 = PhotoMessage(<span class="string">"id1"</span>,photoStr, None, Some(<span class="number">60</span>))
actorRef ! msg2

<span class="keyword">val</span> combinedMsg = PhotoMessage(<span class="string">"id1"</span>, photoStr, msg1.creationTime, msg2.speed)
endProbe.expectMsg(combinedMsg)
</pre></td></tr></table></figure>

<h1 id="routing-messages">Routing Messages</h1>
<p>Akka’s routing feature lets you alter a message’s path from
sender to receiver.</p>
<p>Akka provides a set of standard routers that implement routing patterns that
frequently show up in those everyday problems.</p>
<h2 id="roundrobinrouter">RoundRobinRouter</h2>
<p>The RoundRobinRouter sends messages to the Actors for which it fronts in
a round-robin fashion.</p>
<h2 id="smallestmailboxrouter">SmallestMailboxRouter</h2>
<p>When a message comes into the Router, it decides to route the message to
the composed Actor whose Mailbox is the smallest.</p>
<p>The SmallestMailboxRouter is a pretty good choice when it comes to
balancing load among your composed Actors. </p>
<h2 id="configuring-a-router">Configuring a Router</h2>
<p>The configurations are specified in the akka.actor.deployment block. Be-
low is a simple configuration of a RoundRobinRouter, which would appear
in your application.conf file:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>akka {
  actor {
    deployment {
      /DatabaseConnectionRouter {
        router <span class="subst">=</span> <span class="string">"round-robin"</span>
        nr<span class="attribute">-of</span><span class="attribute">-instances</span> <span class="subst">=</span> <span class="number">20</span>
      }
    }
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.routing.FromConfig
<span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span> ...
}
<span class="keyword">val</span> dbRouter = system.actorOf(Props[DBConnection].withRouter(FromConfig(),
                              <span class="string">"DatabaseConnectionRouter"</span>), <span class="string">"DBRouter"</span>)
</pre></td></tr></table></figure>

<p>The dbRouter will be an instance of a RoundRobinRouter that will rep-
resent the database connection, and it will also be the parent of 20 instances
of the DBConnection Actor.</p>
<h2 id="routers-and-children">Routers and Children</h2>
<p>Routers route to routees. You can create those routees dynamically by the
Router, or you can assign them to it from an already created set. </p>
<p>These two different methods of assigning routees have an impact
on the relationship and supervision of those routees.</p>
<h2 id="letting-the-router-create-the-routees">Letting the Router Create the Routees</h2>
<p>Advantages</p>
<ul>
<li>The Router handles the Supervision.</li>
<li>It works well with configuration.</li>
</ul>
<p>Disadvantages</p>
<ul>
<li>You’ll have a difficult time constructing anything but a single type of
Actor.</li>
<li>You can’t name them the way you might like.</li>
</ul>
<h2 id="passing-the-router-pre-created-actors">Passing the Router Pre-Created Actors</h2>
<ul>
<li>You have to have parents for them.</li>
<li>It’s not as flexible from a configuration perspective. </li>
</ul>
<h2 id="the-router-and-its-children-s-life-cycles">The Router and Its Children’s Life Cycles</h2>
<p>When the Router creates the routees, they are its children, which means that
the Router must manage their life cycles. The Router will assign a
supervisorStrategy that always escalates the decision to its parent.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>val dbRouter = system<span class="preprocessor">.actorOf</span>(Props<span class="preprocessor">.empty</span><span class="preprocessor">.withRouter</span>(RoundRobinRouter(
    nrOfInstances = <span class="number">5</span>,
    supervisorStrategy = OneForOneStrategy {
    // define your Decider here
    }), <span class="string">"DBRouter"</span>)

// you can assign that easily enough:
val dbRouter = system<span class="preprocessor">.actorOf</span>(Props<span class="preprocessor">.empty</span><span class="preprocessor">.withRouter</span>(RoundRobinRouter(
    nrOfInstances = <span class="number">5</span>,
    supervisorStrategy = SupervisorStrategy<span class="preprocessor">.defaultStrategy</span>
    ), <span class="string">"DBRouter"</span>)
</pre></td></tr></table></figure>

<h2 id="routers-on-a-plane">Routers on a Plane</h2>
<p>A BroadcastRouter would make the perfect component for allowing the passengers
to receive important information, such as “Fasten Seat Belts,”.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>zzz<span class="preprocessor">.akka</span><span class="preprocessor">.avionics</span> {
  passengers = [
    [ <span class="string">"Kelly Franqui"</span>, <span class="string">"01"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Tyrone Dotts"</span>, <span class="string">"02"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Malinda Class"</span>, <span class="string">"03"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Kenya Jolicoeur"</span>, <span class="string">"04"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Christian Piche"</span>, <span class="string">"10"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Neva Delapena"</span>, <span class="string">"11"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Alana Berrier"</span>, <span class="string">"12"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Malinda Heister"</span>, <span class="string">"13"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Carlene Heiney"</span>, <span class="string">"14"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Erik Dannenberg"</span>, <span class="string">"15"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Jamie Karlin"</span>, <span class="string">"20"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Julianne Schroth"</span>, <span class="string">"21"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Elinor Boris"</span>, <span class="string">"22"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Louisa Mikels"</span>, <span class="string">"30"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Jessie Pillar"</span>, <span class="string">"31"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Darcy Goudreau"</span>, <span class="string">"32"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Harriett Isenhour"</span>, <span class="string">"33"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Odessa Maury"</span>, <span class="string">"34"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Malinda Hiett"</span>, <span class="string">"40"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Darcy Syed"</span>, <span class="string">"41"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Julio Dismukes"</span>, <span class="string">"42"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Jessie Altschuler"</span>, <span class="string">"43"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Tyrone Ericsson"</span>, <span class="string">"44"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Mallory Dedrick"</span>, <span class="string">"50"</span>, <span class="string">"C"</span> ],
    [ <span class="string">"Javier Broder"</span>, <span class="string">"51"</span>, <span class="string">"A"</span> ],
    [ <span class="string">"Alejandra Fritzler"</span>, <span class="string">"52"</span>, <span class="string">"B"</span> ],
    [ <span class="string">"Rae Mcaleer"</span>, <span class="string">"53"</span>, <span class="string">"C"</span> ]
  ]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Passenger</span> {</span>
  <span class="comment">// These are notifications that tell the Passenger</span>
  <span class="comment">// to fasten or unfasten their seat belts</span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">FastenSeatbelts</span></span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">UnfastenSeatbelts</span></span>
  <span class="comment">// Regular expression to extract Name-Row-Seat tuple</span>
  <span class="keyword">val</span> SeatAssignment = <span class="string">"""([\w\s_]+)-(\d+)-([A-Z])"""</span>.r
}

<span class="comment">// The DrinkRequestProbability trait defines some</span>
<span class="comment">// thresholds that we can modify in tests to</span>
<span class="comment">// speed things up.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">DrinkRequestProbability</span> {</span>
  <span class="comment">// Limits the decision on whether the passenger</span>
  <span class="comment">// actually asks for a drink</span>
  <span class="keyword">val</span> askThreshold = <span class="number">0.9</span>f
  
  <span class="comment">// The minimum time between drink requests</span>
  <span class="keyword">val</span> requestMin = <span class="number">20.</span>minutes
  
  <span class="comment">// Some portion of this (0 to 100</span>
  <span class="comment">// to requestMin</span>
  <span class="keyword">val</span> requestUpper = <span class="number">30.</span>minutes
  <span class="comment">// Gives us a 'random' time within the previous</span>
  <span class="comment">// two bounds</span>
  <span class="keyword">def</span> randomishTime(): Duration = {
    requestMin + scala.util.Random.nextInt(requestUpper.toMillis.toInt).millis
  }
}

<span class="comment">// The idea behind the PassengerProvider is old news at this point.</span>
<span class="comment">// We can use it in other classes to give us the ability to slide</span>
<span class="comment">// in different Actor types to ease testing.</span>
<span class="class"><span class="keyword">trait</span> <span class="title">PassengerProvider</span> {</span>
  <span class="keyword">def</span> newPassenger(callButton: ActorRef): Actor =
    <span class="keyword">new</span> Passenger(callButton) <span class="keyword">with</span> DrinkRequestProbability
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Passenger</span><span class="params">(callButton: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">this</span>: DrinkRequestProbability =&gt;
  <span class="keyword">import</span> Passenger._
  <span class="keyword">import</span> FlightAttendant.{GetDrink, Drink}
  <span class="keyword">import</span> scala.collection.JavaConverters._
  
  <span class="comment">// We'll be adding some randomness to our Passenger,</span>
  <span class="comment">// and this shortcut will make things a little more</span>
  <span class="comment">// readable.</span>
  <span class="keyword">val</span> r = scala.util.Random
  
  <span class="comment">// It's about time that someone actually asked for a</span>
  <span class="comment">// drink since our Flight Attendants have been coded</span>
  <span class="comment">// to serve them up</span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">CallForDrink</span></span>
  
  <span class="comment">// The name of the Passenger can't have spaces in it,</span>
  <span class="comment">// since that's not a valid character in the URI</span>
  <span class="comment">// spec. We know the name will have underscores in</span>
  <span class="comment">// place of spaces, and we'll convert those back</span>
  <span class="comment">// here.</span>
  <span class="keyword">val</span> SeatAssignment(myname, _, _) =
    self.path.name.replaceAllLiterally(<span class="string">"_"</span>, <span class="string">" "</span>)
    
  <span class="comment">// We'll be pulling some drink names from the</span>
  <span class="comment">// configuration file as well</span>
  <span class="keyword">val</span> drinks = context.system.settings.config.getStringList(<span class="string">"zzz.akka.avionics.drinks"</span>).asScala.toIndexedSeq
  
  <span class="comment">// A shortcut for the scheduler to make things look</span>
  <span class="comment">// nicer later</span>
  <span class="keyword">val</span> scheduler = context.system.scheduler
  
  <span class="comment">// We've just sat down, so it's time to get a drink</span>
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
    self ! CallForDrink
  }

  <span class="comment">// This method will decide whether or not we actually</span>
  <span class="comment">// want to get a drink using some randomness to</span>
  <span class="comment">// decide</span>
  <span class="keyword">def</span> maybeSendDrinkRequest(): Unit = {
    <span class="keyword">if</span> (r.nextFloat() &gt; askThreshold) {
      <span class="keyword">val</span> drinkname = drinks(r.nextInt(drinks.length))
      callButton ! GetDrink(drinkname)
    }
    scheduler.scheduleOnce(randomishTime(), self, CallForDrink)
  }

  <span class="comment">// Standard message handler</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> CallForDrink =&gt;
      maybeSendDrinkRequest()
    <span class="keyword">case</span> Drink(drinkname) =&gt;
      log.info(<span class="string">"{} received a {} - Yum"</span>, myname, drinkname)
    <span class="keyword">case</span> FastenSeatbelts =&gt;
      log.info(<span class="string">"{} fastening seatbelt"</span>, myname)
    <span class="keyword">case</span> UnfastenSeatbelts =&gt;
      log.info(<span class="string">"{} UNfastening seatbelt"</span>, myname)
  }
}
</pre></td></tr></table></figure>

<p>Testing and the Event Stream</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">TestDrinkRequestProbability</span> <span class="keyword">extends</span> <span class="title">DrinkRequestProbability</span> {</span>
  <span class="keyword">override</span> <span class="keyword">val</span> askThreshold = <span class="number">0</span>f
  <span class="keyword">override</span> <span class="keyword">val</span> requestMin = <span class="number">0.</span>milliseconds
  <span class="keyword">override</span> <span class="keyword">val</span> requestUpper = <span class="number">2.</span>milliseconds
}

<span class="class"><span class="keyword">class</span> <span class="title">PassengersSpec</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(ActorSystem()</span>) <span class="keyword">with</span> <span class="title">ImplicitSender</span> {</span>
  <span class="keyword">import</span> akka.event.Logging.Info
  <span class="keyword">import</span> akka.testkit.TestProbe
  <span class="keyword">var</span> seatNumber = <span class="number">9</span>
  
  <span class="keyword">def</span> newPassenger(): ActorRef = {
    seatNumber += <span class="number">1</span>
    system.actorOf(Props(<span class="keyword">new</span> Passenger(testActor) <span class="keyword">with</span> TestDrinkRequestProbability), s<span class="string">"Pat_Metheny-$seatNumber-B"</span>)
  }
  
  <span class="string">"Passengers"</span> should {
    <span class="string">"fasten seatbelts when asked"</span> in {
      <span class="keyword">val</span> a = newPassenger()
      <span class="keyword">val</span> p = TestProbe()
      <span class="comment">// This says that we want the TestProbe’s ActorRef (p.ref) to be the handle</span>
      <span class="comment">// to the subscribed Actor, and that we want it to receive events that match the</span>
      <span class="comment">// class akka.event.Logger.Info. </span>
      system.eventStream.subscribe(p.ref, classOf[Info])
      
      a ! FastenSeatbelts
      p.expectMsgPF() {
        <span class="keyword">case</span> Info(_, _, m) =&gt;
          m.toString must include (<span class="string">"fastening seatbelt"</span>)
      }
    }
  }
}
</pre></td></tr></table></figure>

<h3 id="the-passenger-router">The Passenger Router</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">PassengerSupervisor</span> {</span>
  <span class="comment">// Allows someone to request the BroadcastRouter</span>
  <span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GetPassengerBroadcaster</span></span>
  <span class="comment">// Returns the BroadcastRouter to the requestor</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">PassengerBroadcaster</span><span class="params">(broadcaster: ActorRef)</span></span>
  <span class="comment">// Factory method for easy construction</span>
  <span class="keyword">def</span> apply(callButton: ActorRef) = <span class="keyword">new</span> PassengerSupervisor(callButton)
        <span class="keyword">with</span> PassengerProvider
}

<span class="class"><span class="keyword">class</span> <span class="title">PassengerSupervisor</span><span class="params">(callButton: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">this</span>: PassengerProvider =&gt;
  <span class="keyword">import</span> PassengerSupervisor._
  <span class="comment">// We'll resume our immediate children instead of restarting them</span>
  <span class="comment">// on an Exception</span>
  <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = OneForOneStrategy() {
    <span class="keyword">case</span> _: ActorKilledException =&gt; Escalate
    <span class="keyword">case</span> _: ActorInitializationException =&gt; Escalate
    <span class="keyword">case</span> _ =&gt; Resume
  }
  
  <span class="comment">// Internal messages we use to communicate between this Actor</span>
  <span class="comment">// and its subordinate IsolatedStopSupervisor</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">GetChildren</span><span class="params">(forSomeone: ActorRef)</span></span>

  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Children</span><span class="params">(children: Iterable[ActorRef], childrenFor: ActorRef)</span></span>
  
  <span class="comment">// We use preStart() to create our IsolatedStopSupervisor</span>
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
    context.actorOf(Props(<span class="keyword">new</span> Actor {
      <span class="keyword">val</span> config = context.system.settings.config
      
      <span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy = OneForOneStrategy() {
        <span class="keyword">case</span> _: ActorKilledException =&gt; Escalate
        <span class="keyword">case</span> _: ActorInitializationException =&gt; Escalate
        <span class="keyword">case</span> _ =&gt; Stop
      }
      <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
        <span class="keyword">import</span> scala.collection.JavaConverters._
        <span class="keyword">import</span> com.typesafe.config.ConfigList
        <span class="comment">// Get our passenger names from the configuration</span>
        <span class="keyword">val</span> passengers = config.getList(<span class="string">"zzz.akka.avionics.passengers"</span>)
        
        <span class="comment">// Iterate through them to create the passenger children</span>
        passengers.asScala.foreach { nameWithSeat =&gt;
          <span class="keyword">val</span> id = nameWithSeat.asInstanceOf[ConfigList].unwrapped().asScala.mkString(<span class="string">"-"</span>).replaceAllLiterally(<span class="string">" "</span>, <span class="string">"_"</span>)
          <span class="comment">// Convert spaces to underscores to comply with URI standard</span>
          context.actorOf(Props(newPassenger(callButton)), id)
        }
      }
    
      <span class="keyword">override</span> <span class="keyword">def</span> receive = {
        <span class="keyword">case</span> GetChildren(forSomeone: ActorRef) =&gt;
          sender ! Children(context.children, forSomeone)
      }
    }), <span class="string">"PassengersSupervisor"</span>)
  }

  <span class="keyword">def</span> receive = noRouter

  <span class="comment">// TODO: This noRouter method could be made simpler by using a Future.</span>
  <span class="comment">// We'll have to refactor this later.</span>
  <span class="keyword">def</span> noRouter: Receive = {
    <span class="keyword">case</span> GetPassengerBroadcaster =&gt;
      context.actorFor(<span class="string">"PassengersSupervisor"</span>) ! GetChildren(sender)
    <span class="keyword">case</span> Children(passengers, destinedFor) =&gt;
      <span class="keyword">val</span> router = context.actorOf(Props().withRouter(
        BroadcastRouter(passengers.toSeq)), <span class="string">"Passengers"</span>)
        
      destinedFor ! PassengerBroadcaster(router)
      context.become(withRouter(router))
  }
  
  <span class="keyword">def</span> withRouter(router: ActorRef): Receive = {
    <span class="keyword">case</span> GetPassengerBroadcaster =&gt;
      sender ! PassengerBroadcaster(router)
  }

}
</pre></td></tr></table></figure>

<h3 id="using-the-passenger-router">Using the Passenger Router</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="code"><pre><span class="keyword">package</span> zzz.akka.avionics

<span class="keyword">import</span> akka.actor.{ActorSystem, Actor, ActorRef, Props}
<span class="keyword">import</span> akka.testkit.{TestKit, ImplicitSender}
<span class="keyword">import</span> scala.concurrent.util.duration._
<span class="keyword">import</span> com.typesafe.config.ConfigFactory
<span class="keyword">import</span> org.scalatest.{WordSpec, BeforeAndAfterAll}
<span class="keyword">import</span> org.scalatest.matchers.MustMatchers


<span class="comment">// ActorSystem so we have a known quantity we can test with</span>
<span class="class"><span class="keyword">object</span> <span class="title">PassengerSupervisorSpec</span> {</span>
  <span class="keyword">val</span> config = ConfigFactory.parseString(<span class="string">"""
    zzz.akka.avionics.passengers = [
      [ "Kelly Franqui", "23", "A" ],
      [ "Tyrone Dotts", "23", "B" ],
      [ "Malinda Class", "23", "C" ],
      [ "Kenya Jolicoeur", "24", "A" ],
      [ "Christian Piche", "24", "B" ]
    ]
  """</span>)
}

<span class="comment">// We don't want to work with "real" passengers.</span>
 This mock
<span class="comment">// passenger will be much easier to verify things with</span>
<span class="class"><span class="keyword">trait</span> <span class="title">TestPassengerProvider</span> <span class="keyword">extends</span> <span class="title">PassengerProvider</span> {</span>
  <span class="keyword">override</span> <span class="keyword">def</span> newPassenger(callButton: ActorRef): Actor =
    <span class="keyword">new</span> Actor {
      <span class="keyword">def</span> receive = {
        <span class="keyword">case</span> m =&gt; callButton ! m
      }
    }
}

<span class="comment">// The Test class injects the configuration into the</span>
<span class="comment">// ActorSystem</span>
<span class="class"><span class="keyword">class</span> <span class="title">PassengerSupervisorSpec</span> <span class="keyword">extends</span></span>
    TestKit(ActorSystem(<span class="string">"PassengerSupervisorSpec"</span>, PassengerSupervisorSpec.config))
        <span class="keyword">with</span> ImplicitSender
        <span class="keyword">with</span> WordSpec
        <span class="keyword">with</span> BeforeAndAfterAll
        <span class="keyword">with</span> MustMatchers {
  <span class="keyword">import</span> PassengerSupervisor._
  <span class="comment">// Clean up the system when all the tests are done</span>
  <span class="keyword">override</span> <span class="keyword">def</span> afterAll() {
    system.shutdown()
  }

  <span class="string">"PassengerSupervisor"</span> should {
    <span class="string">"work"</span> in {
      <span class="comment">// Get our SUT</span>
      <span class="keyword">val</span> a = system.actorOf(Props(<span class="keyword">new</span> PassengerSupervisor(testActor) <span class="keyword">with</span> TestPassengerProvider))
      
      <span class="comment">// Grab the BroadcastRouter</span>
      a ! GetPassengerBroadcaster
      <span class="keyword">val</span> broadcaster = expectMsgPF() {
        <span class="keyword">case</span> PassengerBroadcaster(b) =&gt;
          <span class="comment">// Exercise the BroadcastRouter</span>
          b ! <span class="string">"Hithere"</span>
          
          <span class="comment">// All 5 passengers should say "Hithere"</span>
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          expectMsg(<span class="string">"Hithere"</span>)
          
          <span class="comment">// And then nothing else!</span>
          expectNoMsg(<span class="number">100.</span>milliseconds)
          <span class="comment">// Return the BroadcastRouter</span>
          b
      }
      
      <span class="comment">// Ensure that the cache works</span>
      a ! GetPassengerBroadcaster
      expectMsg(PassengerBroadcaster(`broadcaster`))
    }
  }
}
</pre></td></tr></table></figure>

<p>TODO</p>
]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Distribute Akka App]]></title>
    <link href="http://zhpooer.github.io/2014/08/04/akka-in-action-distribute-akka-app/"/>
    <id>http://zhpooer.github.io/2014/08/04/akka-in-action-distribute-akka-app/</id>
    <published>2014-08-04T01:58:24.000Z</published>
    <updated>2014-08-04T08:55:32.000Z</updated>
    <content type="html"><![CDATA[<p>We&#39;ll scale the goticks.com app out to two nodes; a frontend
and a backend server.
The REST Interface will run
on a frontend node. The BoxOffice and all TicketSellers will run on a backend
node. Both nodes have a static reference to each other&#39;s network addresses. </p>
<p><img src="/img/akka_network_topologies.png" alt="net work topologies"></p>
<p>Messages between the nodes are sent over the transport protocol and
need to be encoded and decoded into network specific protocol data units. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-multi-node-testkit" %</span> akkaV % <span class="string">"test"</span>,
<span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-testkit" %</span> akkaV % <span class="string">"test"</span>,
</pre></td></tr></table></figure>

<h1 id="remote-repl-action">Remote REPL action</h1>
<p>Akka provides two ways to get a reference to an actor on a remote node. One is to
look up the actor by its path, the other is to create the actor, get its reference and
deploy it remotely.</p>
<p><code>sbt console</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">// Select the Remote ActorRef Provider to bootstrap remoting</span>
<span class="comment">// the configuration section for remoting</span>
<span class="comment">// 建立一个远程的 Actor</span>
<span class="keyword">val</span> conf = <span class="string">"""
  akka {
    actor {
      provider = "akka.remote.RemoteActorRefProvider"
    }
    remote {
      enabled-transports = ["akka.remote.netty.tcp"]
      netty.tcp {
        hostname = "0.0.0.0"
        port = 2551
      }
    }
  }
"""</span>

<span class="keyword">import</span> com.typesafe.config._
<span class="keyword">import</span> akka.actor._
<span class="keyword">val</span> config = ConfigFactory.parseString(conf)
<span class="comment">// Create the ActorSystem with the parsed Config object.</span>
<span class="keyword">val</span> backend = ActorSystem(<span class="string">"backend"</span>, config)

<span class="class"><span class="keyword">class</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> m =&gt; println(s<span class="string">"received $m!"</span>)
  }
}
<span class="comment">// Create the simple actor in the backend actor system with the name "simple"</span>
backend.actorOf(Props[Simple], <span class="string">"simple"</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">// 建立一个前端的 Actor</span>
<span class="keyword">val</span> conf = <span class="string">"""
  akka {
    actor {
      provider = "akka.remote.RemoteActorRefProvider"
    }
    remote {
      enabled-transports = ["akka.remote.netty.tcp"]
      netty.tcp {
        hostname = "0.0.0.0"
        port = 2552
      }
    }
  }
"""</span>
<span class="keyword">import</span> com.typesafe.config._
<span class="keyword">import</span> akka.actor._
<span class="keyword">val</span> config = ConfigFactory.parseString(conf)
<span class="keyword">val</span> frontend= ActorSystem(<span class="string">"frontend"</span>, config)

<span class="comment">// Select the actor with an ActorSelection</span>
<span class="comment">// the guardian actor is aways called 'user'</span>
<span class="keyword">val</span> path = <span class="string">"akka.tcp://backend@0.0.0.0:2551/user/simple"</span>
<span class="comment">// Think of the actorSelection method as a query in the actor hierarchy</span>
<span class="keyword">val</span> simple = frontend.actorSelection(path)
</pre></td></tr></table></figure>

<p><code>scala&gt; simple ! &quot;Hello Remote World!&quot;</code></p>
<h1 id="remote-lookup">Remote Lookup</h1>
<p>Instead of directly creating a BoxOffice actor in the RestInterface actor we will
look it up on the backend node.</p>
<h2 id="version-1">version 1</h2>
<p>Creator of BoxOffice</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">BoxOfficeCreator</span> {</span> <span class="keyword">this</span>: Actor =&gt;
  <span class="keyword">def</span> createBoxOffice:ActorRef = {
    context.actorOf(Props[BoxOffice], <span class="string">"boxOffice"</span>)
  }
}
<span class="class"><span class="keyword">class</span> <span class="title">RestInterface</span> <span class="keyword">extends</span> <span class="title">HttpServiceActor</span> <span class="keyword">with</span> <span class="title">RestApi</span> {</span>
  <span class="keyword">def</span> receive = runRoute(routes)
}

<span class="class"><span class="keyword">trait</span> <span class="title">RestApi</span> <span class="keyword">extends</span> <span class="title">HttpService</span></span>
    <span class="keyword">with</span> ActorLogging
    <span class="keyword">with</span> BoxOfficeCreator { actor: Actor =&gt;
  <span class="comment">// BoxOffice is created using the createBoxOffice method</span>
  <span class="keyword">val</span> boxOffice = createBoxOffice
  <span class="comment">// rest of the code of the RestApi</span>
}
</pre></td></tr></table></figure>

<h2 id="version-2">version 2</h2>
<p>A RemoteBoxOfficeCreator trait will override the default behavior of which
the details will follow shortly.</p>
<p>A SingleNodeMain, FrontendMain and a
BackendMain are created to start the app in single node mode or to start a
frontend and backend separately.</p>
<p>load from the files singlenode.conf, frontend.conf and backend.conf respectively</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// 同一台机子上</span>
<span class="comment">//Snippet from SingleNodeMain</span>
<span class="keyword">val</span> system = ActorSystem(<span class="string">"singlenode"</span>, config)
<span class="keyword">val</span> restInterface = system.actorOf(Props[RestInterface], <span class="string">"restInterface"</span>)

<span class="comment">// 前端</span>
<span class="comment">//Snippet from FrontendMain</span>
<span class="keyword">val</span> system = ActorSystem(<span class="string">"frontend"</span>, config)
<span class="class"><span class="keyword">class</span> <span class="title">FrontendRestInterface</span> <span class="keyword">extends</span> <span class="title">RestInterface</span> <span class="keyword">with</span> <span class="title">RemoteBoxOfficeCreator</span></span>
  
<span class="keyword">val</span> restInterface = system.actorOf(Props[FrontendRestInterface], <span class="string">"restInterface"</span>)

<span class="comment">// 后端</span>
<span class="comment">//Snippet from BackendMain</span>
<span class="keyword">val</span> system = ActorSystem(<span class="string">"backend"</span>, config)
<span class="keyword">val</span> config = ConfigFactory.load(<span class="string">"backend"</span>)
<span class="keyword">val</span> system = ActorSystem(<span class="string">"backend"</span>, config)

system.actorOf(Props[BoxOffice], <span class="string">"boxOffice"</span>)
</pre></td></tr></table></figure>

<p>The RemoteBoxOfficeCreator loads these extra configuration properties:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>backend {
  host = <span class="string">"0.0.0.0"</span>
  port = <span class="number">2552</span>
  protocol = <span class="string">"akka.tcp"</span>
  <span class="keyword">system</span> = <span class="string">"backend"</span>
  actor = <span class="string">"user/boxOffice"</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">RemoteBoxOfficeCreator</span> {</span>
  <span class="keyword">val</span> config = ConfigFactory.load(<span class="string">"frontend"</span>).getConfig(<span class="string">"backend"</span>)
  <span class="keyword">val</span> host = config.getString(<span class="string">"host"</span>)
  <span class="keyword">val</span> port = config.getInt(<span class="string">"port"</span>)
  <span class="keyword">val</span> protocol = config.getString(<span class="string">"protocol"</span>)
  <span class="keyword">val</span> systemName = config.getString(<span class="string">"system"</span>)
  <span class="keyword">val</span> actorName = config.getString(<span class="string">"actor"</span>)
}

<span class="class"><span class="keyword">trait</span> <span class="title">RemoteBoxOfficeCreator</span> <span class="keyword">extends</span> <span class="title">BoxOfficeCreator</span> {</span> <span class="keyword">this</span>:Actor =&gt;
  <span class="keyword">import</span> RemoteBoxOfficeCreator._
  <span class="keyword">def</span> createPath:String = {
    s<span class="string">"$protocol://$systemName@$host:$port/$actorName"</span>
  }
  <span class="keyword">override</span> <span class="keyword">def</span> createBoxOffice = {
  <span class="keyword">val</span> path = createPathcontext.actorOf(Props(classOf[RemoteLookup],path),
      <span class="string">"lookupBoxOffice"</span>)
  }
}
</pre></td></tr></table></figure>

<p>The RemoteBoxOfficeCreator creates a separate RemoteLookup Actor to
lookup the boxOffice.</p>
<p>The RemoteLookup actor is a state machine that can only be in one of two
states we have defined: identify or active. It uses the become method to switch its
receive method to identify or active. The RemoteLookup tries to get a valid
ActorRef to the BoxOffice when it does not have one yet in the identify state or it
forwards all messages sent to a valid ActorRef to the BoxOffice in the active state.</p>
<p>If the RemoteLookup detects that the BoxOffice has been terminated it tries to get
a valid ActorRef again when it receives no messages for a while. We&#39;ll use Remote
Deathwatch for this. Sounds like something new but from the perspective of API
usage it&#39;s exactly the same thing as normal actor monitoring/watching.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.concurrent.duration._

<span class="class"><span class="keyword">class</span> <span class="title">RemoteLookup</span><span class="params">(path:String)</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="comment">// Send a ReceiveTimeout message if no message has</span>
  <span class="comment">// been received for 3 seconds</span>
  context.setReceiveTimeout(<span class="number">3</span> seconds)
  sendIdentifyRequest()
  <span class="keyword">def</span> sendIdentifyRequest(): Unit = {
    <span class="keyword">val</span> selection = context.actorSelection(path)
    selection ! Identify(path)
  }

  <span class="comment">// The actor is initially in identify receive state</span>
  <span class="keyword">def</span> receive = identify

  <span class="keyword">def</span> identify: Receive = {
    <span class="keyword">case</span> ActorIdentity(`path`, Some(actor)) =&gt;
      <span class="comment">// No longer send a ReceiveTimeout if the actor</span>
      <span class="comment">// gets not messges since it is now active.</span>
      context.setReceiveTimeout(Duration.Undefined)
      log.info(<span class="string">"switching to active state"</span>)
      <span class="comment">// Change to active receive state</span>
      context.become(active(actor))
      context.watch(actor)
    <span class="keyword">case</span> ActorIdentity(`path`, None) =&gt;
      log.error(s<span class="string">"Remote actor with path $path is not available."</span>)
    <span class="keyword">case</span> ReceiveTimeout =&gt;
      sendIdentifyRequest()
    <span class="keyword">case</span> msg:Any =&gt;
      log.error(s<span class="string">"Ignoring message $msg, not ready yet."</span>)
  }

  <span class="keyword">def</span> active(actor: ActorRef): Receive = {
    <span class="keyword">case</span> Terminated(actorRef) =&gt;
      log.info(<span class="string">"Actor $actorRef terminated."</span>)
      context.become(identify)
      log.info(<span class="string">"switching to identify state"</span>)
      context.setReceiveTimeout(<span class="number">3</span> seconds)
      sendIdentifyRequest()
    <span class="keyword">case</span> msg:Any =&gt; actor forward msg
  }
}
</pre></td></tr></table></figure>

<h2 id="remote-deployment">Remote Deployment</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// creates <span class="operator">and</span> deploys <span class="operator">the</span> boxOffice remotely <span class="built_in">to</span> <span class="operator">the</span> backend <span class="keyword">as</span><span class="comment">
// well. The Props configuration object specifies a remote scope for deployment.</span>
val uri = <span class="string">"akka.tcp://backend@0.0.0.0:2552"</span>
val backendAddress = AddressFromURIString(uri)
val props = Props[BoxOffice].withDeploy( Deploy(scope = RemoteScope(backendAddress)) )
context.actorOf(props, <span class="string">"boxOffice"</span>)
</pre></td></tr></table></figure>

<p>When we use configured remote deployment all
we have to do is tell the frontend actor system that when an actor is created with
the path <code>/restInterface/boxOffice</code> it should not create it locally but
remotely.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>actor {
  provider = <span class="string">"akka.remote.RemoteActorRefProvider"</span>
  deployment {
    <span class="regexp">/restInterface/box</span>Office {
      remote = <span class="string">"akka.tcp://backend@0.0.0.0:2552"</span>
    }
  }
}
</pre></td></tr></table></figure>

<p>TODO</p>
<h1 id="configuration">Configuration</h1>
<p>Akka uses the Typesafe Config Library, which sports a pretty state-of-the-art set of
capabilities.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">val config </span>=<span class="string"> ConfigFactory.load()</span>
</pre></td></tr></table></figure>

<p>Since the library supports a number of different configuration formats,
it looks for different files, in the following order:</p>
<ul>
<li>application.properties</li>
<li>application.json</li>
<li>application.conf</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">// application.conf</span>
hostname=<span class="string">"localhost"</span>
<span class="comment">// If there is an env var, override, otherwise, leave it with the value we just assigned</span>
hostname=${?HOST_NAME}
MyAppl {
  <span class="keyword">version</span> = <span class="number">10</span>
  description = <span class="string">"My application"</span>
  database {
    connect=<span class="string">"jdbc:mysql://${hostname}/mydata"</span>
    user=<span class="string">"me"</span>
  }
}
</pre></td></tr></table></figure>

<p>usage</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">val</span> applicationVersion = config.getInt(<span class="string">"MyAppl.version"</span>)
<span class="keyword">val</span> databaseConnectSting = config.getString(<span class="string">"MyAppl.database.connect"</span>)
</pre></td></tr></table></figure>

<h2 id="using-defaults">Using Defaults</h2>
<p>The configuration library contains a fall-back mechanism;
the defaults are placed into a configuration object.</p>
<p>It to provide the defaults we need, we have to know how to configure them.
They are configured in the file reference.conf and placed in the root of the jar file; the idea is
that every library contains its own defaults.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// This way it doesn't try to load application.{conf,json,properties},</span>
<span class="comment">// but myapp.{conf,json,properties}</span>
<span class="keyword">val</span> config = ConfigFactory.load(<span class="string">"myapp"</span>)
</pre></td></tr></table></figure>

<p>Another option is to use system properties.
Sometimes, this is the easiest thing
because you can just create a bash script and set a property and the app will pick it
up and start using it</p>
<ul>
<li>config.resource specifies a resource name - not a base-name, i.e. application.conf not
application</li>
<li>config.file specifies a file system path, again it should include the extension</li>
<li>config.url specifies a URL</li>
</ul>
<h2 id="akka-configuration">Akka Configuration</h2>
<p>default configuration</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">val</span> system = ActorSystem(<span class="string">"mySystem"</span>)

<span class="comment">// supply the configuration while creating an ActorSystem</span>
<span class="keyword">val</span> configuration = ConfigFactory.load(<span class="string">"mysystem"</span>)
<span class="keyword">val</span> systemA = ActorSystem(<span class="string">"mysystem"</span>,configuration)

<span class="comment">//  it can be found in the settings of the ActorSystem.</span>
<span class="keyword">val</span> mySystem = ActorSystem(<span class="string">"myAppl"</span>)
<span class="comment">// Once the ActorSystem is constructed, we can get the config</span>
<span class="comment">// just by referencing it using this path</span>
<span class="keyword">val</span> config = mySystem.settings.config
<span class="keyword">val</span> applicationDescription = config.getString(<span class="string">"myAppl.name"</span>)
</pre></td></tr></table></figure>

<h2 id="mutiple-systems">Mutiple Systems</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// baseConfig.conf</span>
MyAppl {
  version = <span class="number">10</span>
  description = <span class="string">"My application"</span>
}

<span class="comment">// subAppl.conf</span>
<span class="keyword">include</span> <span class="string">"baseConfig"</span>
MyAppl {
  description = <span class="string">"Sub Application"</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>MyAppl {
  <span class="built_in">version</span> = <span class="number">10</span>
  description = <span class="string">"My application"</span>
}

subApplA {
  MyAppl {
    description = <span class="string">"Sub application"</span>
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">val</span> configuration = ConfigFactory.load(<span class="string">"combined"</span>)
<span class="keyword">val</span> subApplACfg = configuration.getConfig(<span class="string">"subApplA"</span>)
<span class="comment">// subApplA 覆盖 原始配置</span>
<span class="keyword">val</span> config = subApplACfg.withFallback(configuration)
</pre></td></tr></table></figure>

<h1 id="logging">Logging</h1>
<p>The Akka toolkit has implemented a logging adapter to be able to support all
kinds of logging frameworks and also minimize the dependencies on other
libraries. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">val</span> log = Logging(context.system, <span class="keyword">this</span>)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>akka {
  <span class="comment"># Event handlers to register at boot time</span>
  <span class="comment"># (Logging$DefaultLogger logs to STDOUT)</span>
  
  <span class="comment"># This eventHandler doesn't use a log framework,</span>
  <span class="comment"># but logs all the received messages to standard out.</span>
  event-handlers = [<span class="string">"akka.event.Logging<span class="variable">$DefaultLogger</span>"</span>]
  <span class="comment"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p>When you want to create your own eventhandler you
have to create an Actor which handles several messages. An example of such
handler is</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="reserved">import</span> akka.event.Logging.InitializeLogger
<span class="reserved">import</span> akka.event.Logging.LoggerInitialized
<span class="reserved">import</span> akka.event.Logging.Error
<span class="reserved">import</span> akka.event.Logging.Warning
<span class="reserved">import</span> akka.event.Logging.Info
<span class="reserved">import</span> akka.event.Logging.Debug
<span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">extends</span> <span class="title">Actor</span>{</span>
  def receive = {
    <span class="reserved">case</span> InitializeLogger<span class="function"><span class="params">(_)</span> =&gt;</span>
      sender ! LoggerInitialized
    <span class="reserved">case</span> Error<span class="function"><span class="params">(cause, logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"ERROR "</span> + message)
    <span class="reserved">case</span> Warning<span class="function"><span class="params">(logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"WARN "</span> + message)
    <span class="reserved">case</span> Info<span class="function"><span class="params">(logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"INFO "</span> + message)
    <span class="reserved">case</span> Debug<span class="function"><span class="params">(logSource, logClass, message)</span> =&gt;</span>
      println( <span class="string">"DEBUG "</span> + message)
  }
}
</pre></td></tr></table></figure>

<p>The Akka toolkit has two
implementations of this logging eventHandler. The first is already mentioned and
that is the default logger to STDOUT. The second implementation is using SLF4J.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="preprocessor"># import akka-slf4j.jar.</span>
akka {
  <span class="keyword">event</span>-handlers = [<span class="string">"akka.event.slf4j.Slf4jEventHandler"</span>]
  <span class="preprocessor"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p>For convenience you can also use the ActorLogging trait to mix-in the log member into actors.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  ...
}
</pre></td></tr></table></figure>

<p>The adapter also supports the ability to use placeholders in the message.
Placeholders prevent you from having to check logging levels.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">log</span>.debug(<span class="string">"two parameters: {}, {}"</span>, <span class="string">"one"</span>,<span class="string">"two"</span>)
</pre></td></tr></table></figure>

<h2 id="controlling-akka-s-logging">Controlling Akka&#39;s logging</h2>
<p>Akka provides a simple configuration layer that allows you to exert
some control over what it outputs to the log, and as we are both using the pubsub
attached to a single adapter, once we change these settings, we will see the results
in whatever our chosen appenders are.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>akka
{
  # logging must be <span class="operator"><span class="keyword">set</span> <span class="keyword">to</span> DEBUG <span class="keyword">to</span> use <span class="keyword">any</span> <span class="keyword">of</span> the options below
  loglevel = DEBUG
  
  # Log the complete configuration <span class="keyword">at</span> INFO <span class="keyword">level</span> <span class="keyword">when</span> the actor
  # system <span class="keyword">is</span> started. This <span class="keyword">is</span> useful <span class="keyword">when</span> you <span class="keyword">are</span> uncertain <span class="keyword">of</span>
  # what configuration <span class="keyword">is</span> used.
  log-config-<span class="keyword">on</span>-<span class="keyword">start</span> = <span class="keyword">on</span>
  debug {
    # logging <span class="keyword">of</span> <span class="keyword">all</span> <span class="keyword">user</span>-<span class="keyword">level</span> messages that <span class="keyword">are</span> processed <span class="keyword">by</span>
    # Actors that use akka.event.LoggingReceive enable function <span class="keyword">of</span>
    # LoggingReceive, which <span class="keyword">is</span> <span class="keyword">to</span> log <span class="keyword">any</span> received message <span class="keyword">at</span>
    # DEBUG <span class="keyword">level</span>
    receive = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> <span class="keyword">all</span> AutoReceiveMessages
    # (Kill, PoisonPill <span class="keyword">and</span> the <span class="keyword">like</span>)
    autoreceive = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> actor lifecycle changes
    # (restarts, deaths etc)
    lifecycle = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> <span class="keyword">all</span> LoggingFSMs <span class="keyword">for</span> events,
    # transitions <span class="keyword">and</span> timers
    fsm = <span class="keyword">on</span>
    
    # enable DEBUG logging <span class="keyword">of</span> subscription (subscribe/unsubscribe)
    # changes <span class="keyword">on</span> the eventStream
    event-stream = <span class="keyword">on</span>
  }
  remote {
    # <span class="keyword">If</span> this <span class="keyword">is</span> <span class="string">"on"</span>, Akka will log <span class="keyword">all</span> outbound messages <span class="keyword">at</span>
    # DEBUG <span class="keyword">level</span>, <span class="keyword">if</span> off <span class="keyword">then</span> they <span class="keyword">are</span> <span class="keyword">not</span> logged
    log-sent-messages = <span class="keyword">on</span>
    # <span class="keyword">If</span> this <span class="keyword">is</span> <span class="string">"on,"</span> Akka will log <span class="keyword">all</span> inbound messages <span class="keyword">at</span>
    # DEBUG <span class="keyword">level</span>, <span class="keyword">if</span> off <span class="keyword">then</span> they <span class="keyword">are</span> <span class="keyword">not</span> logged
    log-received-messages = <span class="keyword">on</span>
  }
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// Now when you set the property akka.debug.receive to on, the messages</span>
<span class="comment">// received by our actor will be logged.</span>
<span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">def</span> receive = LoggingReceive {
    <span class="keyword">case</span> ... =&gt; ...
  }
}
</pre></td></tr></table></figure>

<h1 id="deploying-stand-alone-application">Deploying Stand-alone application</h1>
<p>To create a stand alone application we use the MicroKernel of Akka combined
with the akka-plugin to create a distribution.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg:String =&gt;
      <span class="keyword">val</span> hello = <span class="string">"Hello %s"</span>.format(msg)
      sender ! hello
      log.info(<span class="string">"Sent response {}"</span>,hello)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCaller</span><span class="params">(timer:Duration, actor:ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">TimerTick</span><span class="params">(msg:String)</span></span>
  <span class="comment">// Using the Akka scheduler to send messages to yourself</span>
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {
    <span class="keyword">super</span>.preStart()
    context.system.scheduler.schedule(
      timer, <span class="comment">// The duration before the schedule is triggered for the first time</span>
      timer, <span class="comment">// The duration between the scheduled triggers</span>
      self,  <span class="comment">// The message which is sent</span>
      <span class="keyword">new</span> TimerTick(<span class="string">"everybody"</span>))
  }
  
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> msg: String =&gt; log.info(<span class="string">"received {}"</span>,msg)
    <span class="keyword">case</span> tick: TimerTick =&gt; actor ! tick.msg
  }
}


<span class="keyword">import</span> akka.actor.{ Props, ActorSystem }
<span class="keyword">import</span> akka.kernel.Bootable
<span class="keyword">import</span> scala.concurrent.duration._
<span class="comment">// Extends the Bootable trait to be able to be called when starting the application</span>
<span class="class"><span class="keyword">class</span> <span class="title">BootHello</span> <span class="keyword">extends</span> <span class="title">Bootable</span> {</span>
  <span class="keyword">val</span> system = ActorSystem(<span class="string">"hellokernel"</span>)
  <span class="keyword">def</span> startup = {
    <span class="keyword">val</span> actor = system.actorOf(Props[HelloWorld])
    <span class="keyword">val</span> config = system.settings.config
    <span class="keyword">val</span> timer = config.getInt(<span class="string">"helloWorld.timer"</span>)
    system.actorOf(Props( <span class="keyword">new</span> HelloWorldCaller( timer millis, actor)))
  }
  <span class="keyword">def</span> shutdown = {
    system.shutdown()
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="preprocessor"># reference.conf</span>
helloWorld {
  timer=<span class="number">5000</span>
}
</pre></td></tr></table></figure>

<p>application.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>akka {
  <span class="keyword">event</span>-handlers = [<span class="string">"akka.event.slf4j.Slf4jEventHandler"</span>]
  <span class="preprocessor"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p><code>project/plugins.sbt</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>resolvers += <span class="string">"Typesafe Repository"</span> <span class="keyword">at</span> <span class="string">"http://repo.akka.io/releases/"</span>
addSbtPlugin(<span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-sbt-plugin"</span> % <span class="string">"2.0.1"</span>)
</pre></td></tr></table></figure>

<p><code>project/HelloKernelBuild.scala</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="keyword">import</span> sbt._
<span class="keyword">import</span> Keys._
<span class="keyword">import</span> akka.sbt.AkkaKernelPlugin
<span class="keyword">import</span> akka.sbt.AkkaKernelPlugin.{ Dist, outputDirectory, distJvmOptions }
<span class="class"><span class="keyword">object</span> <span class="title">HelloKernelBuild</span> <span class="keyword">extends</span> <span class="title">Build</span> {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> HelloKernel = Project(
    id = <span class="string">"hello-kernel-book"</span>,
    base = file(<span class="string">"."</span>),
    settings = defaultSettings ++ AkkaKernelPlugin.distSettings ++ Seq(
      libraryDependencies ++= Dependencies.helloKernel,
      distJvmOptions in Dist := <span class="string">"-Xms256M -Xmx1024M"</span>,
      outputDirectory in Dist := file(<span class="string">"target/helloDist"</span>)
    )
  )
  
  <span class="keyword">lazy</span> <span class="keyword">val</span> buildSettings = Defaults.defaultSettings ++ Seq(
    organization := <span class="string">"com.manning"</span>,
    version := <span class="string">"0.1-SNAPSHOT"</span>,
    scalaVersion := <span class="string">"2.9.1"</span>,
    crossPaths := <span class="keyword">false</span>,
    organizationName := <span class="string">"Mannings"</span>,
    organizationHomepage := Some(url(<span class="string">"http://www.mannings.com"</span>))
  )
  
  <span class="keyword">lazy</span> <span class="keyword">val</span> defaultSettings = buildSettings ++ Seq(
    resolvers += <span class="string">"Typesafe Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,
    <span class="comment">// compile options</span>
    scalacOptions ++= Seq(<span class="string">"-encoding"</span>, <span class="string">"UTF-8"</span>,<span class="string">"-deprecation"</span>,<span class="string">"-unchecked"</span>),
    javacOptions ++= Seq(<span class="string">"-Xlint:unchecked"</span>,<span class="string">"-Xlint:deprecation"</span>)
  )
}
<span class="comment">// Dependencies</span>
<span class="class"><span class="keyword">object</span> <span class="title">Dependencies</span> {</span>
  <span class="keyword">import</span> Dependency._
  <span class="keyword">val</span> helloKernel = Seq(
    akkaActor, akkaKernel,
    akkaSlf4j, slf4jApi, slf4jLog4j,
    Test.junit, Test.scalatest, Test.akkaTestKit)
}
<span class="class"><span class="keyword">object</span> <span class="title">Dependency</span> {</span>
  <span class="comment">// Versions</span>
  <span class="class"><span class="keyword">object</span> <span class="title">V</span> {</span>
    <span class="keyword">val</span> Scalatest = <span class="string">"1.6.1"</span>
    <span class="keyword">val</span> Slf4j = <span class="string">"1.6.4"</span>
    <span class="keyword">val</span> Akka = <span class="string">"2.0"</span>
  }
  <span class="comment">// Compile</span>
  <span class="keyword">val</span> commonsCodec = <span class="string">"commons-codec"</span> % <span class="string">"commons-codec"</span>% <span class="string">"1.4"</span>
  <span class="keyword">val</span> commonsIo = <span class="string">"commons-io"</span> % <span class="string">"commons-io"</span> % <span class="string">"2.0.1"</span>
  <span class="keyword">val</span> commonsNet = <span class="string">"commons-net"</span> % <span class="string">"commons-net"</span> % <span class="string">"3.1"</span>
  <span class="keyword">val</span> slf4jApi = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-api"</span> % V.Slf4j
  <span class="keyword">val</span> slf4jLog4j = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-log4j12"</span>% V.Slf4j
  <span class="keyword">val</span> akkaActor = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-actor"</span> % V.Akka
  <span class="keyword">val</span> akkaKernel = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-kernel"</span> % V.Akka
  <span class="keyword">val</span> akkaSlf4j = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-slf4j"</span> % V.Akka
  <span class="keyword">val</span> scalatest = <span class="string">"org.scalatest"</span> %% <span class="string">"scalatest"</span> % V.Scalatest
  
  <span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
    <span class="keyword">val</span> junit = <span class="string">"junit"</span> % <span class="string">"junit"</span> % <span class="string">"4.5"</span> % <span class="string">"test"</span>
    <span class="keyword">val</span> scalatest = <span class="string">"org.scalatest"</span> %% <span class="string">"scalatest"</span> % V.Scalatest % <span class="string">"test"</span>
    <span class="keyword">val</span> akkaTestKit =<span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-testkit"</span> % V.Akka % <span class="string">"test"</span>
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sbt dist
</pre></td></tr></table></figure>

<p>After this, SBT has created a distribution in the directory <code>/target/helloDist</code>. This
directory contains 4 subdirectories</p>
<ul>
<li>bin, This contains the start script. One for windows and one for Unix</li>
<li>config, This directory contains the configuration files needed to run our application.</li>
<li>deploy, This directory is where our jar file placed</li>
<li>lib, This directory contains all the jar files our application depends upon.</li>
</ul>
<h2 id="akka-with-a-web-application">Akka with a web application</h2>
<p>There are a number of options for deploying Akka in a webapp,
we are showing play-mini because it is very simple and lightweight.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="comment">// Just by extending Application, we bring a lot of functionality in here.</span>
<span class="class"><span class="keyword">object</span> <span class="title">PlayMiniHello</span> <span class="keyword">extends</span> <span class="title">Application</span> {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> system = ActorSystem(<span class="string">"webhello"</span>)
  <span class="keyword">lazy</span> <span class="keyword">val</span> actor = system.actorOf(Props[HelloWorld])
  <span class="keyword">val</span> writeForm = Form(<span class="string">"name"</span> -&gt; text(<span class="number">1</span>,<span class="number">10</span>))
  
  <span class="keyword">def</span> route = {
    <span class="keyword">case</span> GET(Path(<span class="string">"/test"</span>)) =&gt; Action {
      Ok(<span class="string">"TEST @ %s\n"</span>.format(System.currentTimeMillis))
    }
    <span class="keyword">case</span> GET(Path(<span class="string">"/hello"</span>)) =&gt; Action { implicit request =&gt;
      <span class="keyword">val</span> name = <span class="keyword">try</span> {
        <span class="comment">// Bind our form to the implicit request and get the result</span>
        writeForm.bindFromRequest.get
      } <span class="keyword">catch</span> {
        <span class="keyword">case</span> ex:Exception =&gt; {
          log.warning(<span class="string">"no name specified"</span>)
          system.settings.config.getString(<span class="string">"helloWorld.name"</span>)
        }
      }
      <span class="comment">//  Instead of returning our response directly, we create an AsyncResult.</span>
      AsyncResult {
        <span class="comment">// Translate the AskTimeoutException into the string "Timeout"</span>
        <span class="keyword">val</span> resultFuture = actor ? name recover {
          <span class="keyword">case</span> ex:AskTimeoutException =&gt; <span class="string">"Timeout"</span>
          <span class="keyword">case</span> ex:Exception =&gt; {
            log.error(<span class="string">"recover from "</span>+ex.getMessage)
            <span class="string">"Exception:"</span> + ex.getMessage
          }
        }
        <span class="keyword">val</span> promise = resultFuture.asPromise
        promise.map {
          <span class="keyword">case</span> res:String =&gt; {
            Ok(res)
          }
          <span class="keyword">case</span> ex:Exception =&gt; {
            log.error(<span class="string">"Exception "</span>+ex.getMessage)
            Ok(ex.getMessage)
          }
          <span class="keyword">case</span> _ =&gt; {
            Ok(<span class="string">"Unexpected message"</span>)
          }
        }
      }
    }
  }
}

<span class="comment">//  This allows us to use the onStart and onStop methods</span>
<span class="comment">// which create and stop the Actor system.</span>
<span class="class"><span class="keyword">object</span> <span class="title">Global</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">typesafe</span>.<span class="title">play</span>.<span class="title">mini</span>.<span class="title">Setup</span><span class="params">(ch04.PlayMiniHello)</span></span>
</pre></td></tr></table></figure>

<p>reference.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="attribute">helloWorld {
  name</span>=<span class="string">world
}</span>
</pre></td></tr></table></figure>

<p>application.conf</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>helloWorld {
  name=<span class="string">"world!!!"</span>
}
akka {
  <span class="keyword">event</span>-handlers = [<span class="string">"akka.event.slf4j.Slf4jEventHandler"</span>]
  <span class="preprocessor"># Options: ERROR, WARNING, INFO, DEBUG</span>
  loglevel = <span class="string">"DEBUG"</span>
}
</pre></td></tr></table></figure>

<p>Build.scala</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>importimportimportsbt._
Keys._
PlayProject._
<span class="class"><span class="keyword">object</span> <span class="title">Build</span> <span class="keyword">extends</span> <span class="title">Build</span> {</span>
  <span class="keyword">lazy</span> <span class="keyword">val</span> root = Project(id = <span class="string">"playminiHello"</span>,base = file(<span class="string">"."</span>), settings = Project.defaultSettings)
    .settings(
      resolvers += <span class="string">"Typesafe Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,
      resolvers += <span class="string">"Typesafe Snapshot Repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/snapshots/"</span>,
      libraryDependencies ++= Dependencies.hello,
      mainClass in (Compile, run) := Some(<span class="string">"play.core.server.NettyServer"</span>))
}

<span class="class"><span class="keyword">object</span> <span class="title">Dependencies</span> {</span>
  <span class="keyword">import</span> Dependency._
  <span class="keyword">val</span> hello = Seq(akkaActor, akkaSlf4j, playmini)
  <span class="comment">// slf4jLog4j,</span>
}
<span class="class"><span class="keyword">object</span> <span class="title">Dependency</span> {</span>
  <span class="comment">// Versions</span>
  <span class="class"><span class="keyword">object</span> <span class="title">V</span> {</span>
    <span class="keyword">val</span> Slf4j =<span class="string">"1.6.4"</span>
    <span class="keyword">val</span> Akka  = <span class="string">"2.0"</span>
  }
  
  <span class="comment">// Compile</span>
  <span class="keyword">val</span> slf4jLog4j = <span class="string">"org.slf4j"</span> % <span class="string">"slf4j-log4j12"</span>% V.Slf4j
  <span class="keyword">val</span> akkaActor  = <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-actor"</span> % V.Akka
  <span class="keyword">val</span> playmini   = <span class="string">"com.typesafe"</span> %% <span class="string">"play-mini"</span> % <span class="string">"2.0-RC3"</span>
  <span class="keyword">val</span> akkaSlf4j  =  <span class="string">"com.typesafe.akka"</span> % <span class="string">"akka-slf4j"</span> % V.Akka
}

<span class="comment">// sbt run</span>
<span class="comment">// At this moment the application is running and listening on port 9000</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Testing Actors & Fault tolerance]]></title>
    <link href="http://zhpooer.github.io/2014/08/03/akka-in-action-testing-actors/"/>
    <id>http://zhpooer.github.io/2014/08/03/akka-in-action-testing-actors/</id>
    <published>2014-08-03T07:20:54.000Z</published>
    <updated>2014-08-04T01:57:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="difficult-in-testing-actors">difficult in testing Actors</h1>
<ul>
<li>Timing - Sending messages is asynchronous, so it is difficult to know when
to assert expected values in the unit test.</li>
<li>Asynchronicity - Actors are meant to be run in parallel on several threads.</li>
<li>Statelessness - An actor hides its internal state and does not allow access to
this state.</li>
<li>Collaboration/Integraton - If you want to do an integration test of a couple
of actors, you would need to eavesdrop in between the actors to assert that
the messages have the expected values.</li>
</ul>
<h1 id="akka-testkit">akka-testkit</h1>
<p>Akka provides the akka-testkit module.The testkit module makes a
couple of different types of tests possible:</p>
<ul>
<li>Single threaded unit testing </li>
<li>Multi-threaded unit testing,  The testkit module provides the TestKit
and TestProbe classes, which make it possible to receive replies from
actors, inspect messages and set timing bounds for particular messages to
arrive.</li>
<li>Multiple JVM testing, comes in handy when you want to test remote actor systems.</li>
</ul>
<p>The TestKit has the TestActorRef extending the LocalActorRef class
and sets the dispatcher to a CallingThreadDispatcher that is built for
testing only.</p>
<h1 id="preparing-to-test">Preparing to Test</h1>
<p>The TestKit exposes a system value, which can be accessed
in the test to create actors and everything else you would like to do with the system.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">import</span> org.scalatest.{ Suite, BeforeAndAfterAll }
<span class="keyword">import</span> akka.testkit.TestKit

<span class="comment">// Stop the system after all tests are done</span>
<span class="class"><span class="keyword">trait</span> <span class="title">StopSystemAfterAll</span> <span class="keyword">extends</span> <span class="title">BeforeAndAfterAll</span> {</span>
  <span class="keyword">this</span>: TestKit <span class="keyword">with</span> Suite =&gt;
  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> afterAll() {
    <span class="keyword">super</span>.afterAll()
    system.shutdown()
  }
}
</pre></td></tr></table></figure>

<h1 id="one-way-messages">One-way messages</h1>
<p>There are a three variations that we will look at:</p>
<ul>
<li>SilentActor - An actor&#39;s behavior is not directly observable from the
outside, it might be an intermediate step that the actor takes to create some
internal state.</li>
<li>SendingActor - An actor sends a message to another actor (or possibly
many actors) after it is done processing the received message.</li>
<li>SideEffectingActor - An actor receives a message and interacts with a
normal object in some kind of way.</li>
</ul>
<h2 id="silentactor-examples">SilentActor Examples</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">SilentActorProtocol</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">SilentMessage</span><span class="params">(data: String)</span></span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">GetState</span><span class="params">(receiver: ActorRef)</span></span>
}
<span class="class"><span class="keyword">class</span> <span class="title">SilentActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">import</span> SilentActorProtocol._
  <span class="keyword">var</span> internalState = Vector[String]()
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> SilentMessage(data) =&gt;
      internalState = internalState :+ data
    <span class="keyword">case</span> GetState(receiver) =&gt; receiver ! internalState
  }
  <span class="keyword">def</span> state = internalState
}

<span class="class"><span class="keyword">class</span> <span class="title">SilentActor01Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(ActorSystem(<span class="string">"testsystem"</span>)</span>)</span>
    <span class="keyword">with</span> WordSpec         <span class="comment">// WordSpec provides an easy to read DSL for testing in the BDD style</span>
    <span class="keyword">with</span> MustMatchers     <span class="comment">// MustMatchers provides easy to read assertions</span>
    <span class="keyword">with</span> StopSystemAfterAll {
  <span class="comment">// MustMatchers provides easy to read assertions</span>
  <span class="string">"A Silent Actor"</span> must {
    <span class="string">"change state when it receives a message, single threaded"</span> in {
      <span class="keyword">import</span> SilentActorProtocol._
      <span class="keyword">val</span> silentActor = TestActorRef[SilentActor]
      silentActor ! SilentMessage(<span class="string">"whisper"</span>)
      <span class="comment">// Get the underlying actor and assert the state</span>
      silentActor.underlyingActor.state must (contain(<span class="string">"whisper"</span>))
    }
    
    <span class="string">"change state when it receives a message, multi-threaded"</span> in {
      <span class="keyword">import</span> SilentActorProtocol._
      <span class="keyword">val</span> silentActor = system.actorOf(Props[SilentActor], <span class="string">"s3"</span>)
      silentActor ! SilentMessage(<span class="string">"whisper1"</span>)
      silentActor ! SilentMessage(<span class="string">"whisper2"</span>)
      silentActor ! GetState(testActor)
      <span class="comment">// Used to check what message(s) have been sent to the testActor</span>
      expectMsg(Vector(<span class="string">"whisper1"</span>, <span class="string">"whisper2"</span>))
      
      <span class="comment">//Write the test, first fail</span>
      fail(<span class="string">"not implemented yet"</span>)
    }
  }
}
</pre></td></tr></table></figure>

<h2 id="sendingactor-example">SendingActor Example</h2>
<p>Returning to our ticketing example from Chapter 1, we need to test the fact that
when we buy a Ticket to an Event , the count of available tickets is properly
decremented. </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="string">"A Sending Actor"</span> must {
  <span class="string">"send a message to an actor when it has finished"</span> in {
    <span class="keyword">import</span> Kiosk01Protocol._
    <span class="keyword">val</span> props = Props(<span class="keyword">new</span> Kiosk01(testActor))
    <span class="keyword">val</span> sendingActor = system.actorOf(props, <span class="string">"kiosk1"</span>)
    <span class="keyword">val</span> tickets = Vector(Ticket(<span class="number">1</span>), Ticket(<span class="number">2</span>), Ticket(<span class="number">3</span>))
    <span class="keyword">val</span> game = Game(<span class="string">"Lakers vs Bulls"</span>, tickets)
    sendingActor ! game
    <span class="comment">// the testActor should receive one ticket less</span>
    <span class="comment">// expect Message Partial function</span>
    expectMsgPF() {
      <span class="keyword">case</span> Game(_, tickets) =&gt;
        tickets.size must be(game.tickets.size - <span class="number">1</span>)
    }
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Kiosk01Protocol</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Ticket</span><span class="params">(seat: Int)</span></span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Game</span><span class="params">(name: String, tickets: Seq[Ticket])</span></span>
}

<span class="class"><span class="keyword">class</span> <span class="title">Kiosk01</span><span class="params">(nextKiosk: ActorRef)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">import</span> Kiosk01Protocol._
  <span class="keyword">def</span> receive = {
  <span class="keyword">case</span> game @ Game(_, tickets) =&gt;
    nextKiosk ! game.copy(tickets = tickets.tail)
  }
}
</pre></td></tr></table></figure>

<p>Let&#39;s write a test for the FilteringActor. 
The FilteringActor that we are going to build should filter out
duplicate events.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="code"><pre><span class="string">"filter out particular messages"</span> in {
  <span class="keyword">import</span> FilteringActorProtocol._
  <span class="keyword">val</span> props = Props(<span class="keyword">new</span> FilteringActor(testActor, <span class="number">5</span>))
  <span class="keyword">val</span> filter = system.actorOf(props, <span class="string">"filter-1"</span>)
  
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">2</span>)
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">3</span>)
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">4</span>)
  filter ! Event(<span class="number">5</span>)
  filter ! Event(<span class="number">5</span>)
  <span class="comment">//  Event(6) does not match the pattern in the case statement</span>
  filter ! Event(<span class="number">6</span>)
  
  <span class="comment">// The receiveWhile method returns the collected items as they are returned in</span>
  <span class="comment">// the partial function as a list, which is not allowed to have any duplicates. </span>
  <span class="keyword">val</span> eventIds = receiveWhile() {
    <span class="keyword">case</span> Event(id) <span class="keyword">if</span> id &lt;= <span class="number">5</span> =&gt; id
  }
  
  eventIds must be(List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))
  <span class="comment">// Assert that the duplicates are not in the result</span>
  expectMsg(Event(<span class="number">6</span>))
}



<span class="class"><span class="keyword">object</span> <span class="title">FilteringActorProtocol</span> {</span>
  <span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Event</span><span class="params">(id: Long)</span></span>
}

<span class="comment">// The oldest message that was received is discarded when a max</span>
<span class="comment">// bufferSize is reached to prevent the lastMessages list from growing too</span>
<span class="comment">// large and possibly causing us to run out of space.</span>

<span class="class"><span class="keyword">class</span> <span class="title">FilteringActor</span><span class="params">(nextActor: ActorRef,
      bufferSize: Int)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
    <span class="keyword">import</span> FilteringActorProtocol._
    <span class="keyword">var</span> lastMessages = Vector[Event]()
    <span class="keyword">def</span> receive = {
      <span class="keyword">case</span> msg: Event =&gt;
        <span class="keyword">if</span> (!lastMessages.contains(msg)) {
          lastMessages = lastMessages :+ msg
          nextActor ! msg
          <span class="keyword">if</span> (lastMessages.size &gt; bufferSize) {
            <span class="comment">// discard the oldest</span>
            lastMessages = lastMessages.tail
          }
        }
    }
}

<span class="string">"filter out particular messages using expectNoMsg"</span> in {
  <span class="keyword">import</span> FilteringActorProtocol._
  <span class="keyword">val</span> props = Props(<span class="keyword">new</span> FilteringActor(testActor, <span class="number">5</span>))
  <span class="keyword">val</span> filter = system.actorOf(props, <span class="string">"filter-2"</span>)
  filter ! Event(<span class="number">1</span>)
  filter ! Event(<span class="number">2</span>)
  expectMsg(Event(<span class="number">1</span>))
  expectMsg(Event(<span class="number">2</span>))
  filter ! Event(<span class="number">1</span>)
  expectNoMsg
  filter ! Event(<span class="number">3</span>)
  expectMsg(Event(<span class="number">3</span>))
  filter ! Event(<span class="number">1</span>)
  expectNoMsg
  filter ! Event(<span class="number">4</span>)
  filter ! Event(<span class="number">5</span>)
  filter ! Event(<span class="number">5</span>)
  expectMsg(Event(<span class="number">4</span>))
  expectMsg(Event(<span class="number">5</span>))
  expectNoMsg()
}
</pre></td></tr></table></figure>

<p>The TestProbe class is very much like the TestKit, only you
can use this class without having to extend from it.
Simply create a TestProbe with <code>TestProbe()</code> and start using it.</p>
<h2 id="sideeffectingactor-example">SideEffectingActor Example</h2>
<p>It does just one thing: its Greeter receives
a message and outputs it to the console.</p>
<p>The SideEffectingActor allows us to test scenarios such as these:
where the effect of the action is not directly accessible.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">import</span> Greeter01Test._
<span class="comment">// Create a system with a configuration that attaches a test event listener</span>
<span class="class"><span class="keyword">class</span> <span class="title">Greeter01Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(testSystem)</span></span>
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> StopSystemAfterAll {
  <span class="string">"The Greeter"</span> must {
    <span class="string">"say Hello World! when a Greeting("</span>World<span class="string">") is sent to it"</span> in {
      <span class="keyword">val</span> dispatcherId = CallingThreadDispatcher.Id
      <span class="comment">// Single threaded environment</span>
      <span class="keyword">val</span> props = Props[Greeter].withDispatcher(dispatcherId)
      <span class="keyword">val</span> greeter = system.actorOf(props)
      <span class="comment">// Intercept the log messages that were logged</span>
      EventFilter.info(message = <span class="string">"Hello World!"</span>, occurrences = <span class="number">1</span>).intercept {
        <span class="comment">// The filter is applied when the intercept code block is executed,</span>
        <span class="comment">// which is when we send the message.</span>
        greeter ! Greeting(<span class="string">"World"</span>)
      }
    }
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Greeter01Test</span> {</span>
  <span class="keyword">val</span> testSystem = {
    <span class="comment">// parse a configuration file from a String, in this case we only override the event handlers list.</span>
    <span class="keyword">val</span> config = ConfigFactory.parseString(<span class="string">"""akka.event-handlers = ["akka.testkit.TestEventListener"]"""</span>)
    ActorSystem(<span class="string">"testsystem"</span>, config)
  }
}

<span class="comment">// 注册一个监听器</span>
<span class="class"><span class="keyword">class</span> <span class="title">Greeter02</span><span class="params">(listener: Option[ActorRef] = None)</span></span>
    <span class="keyword">extends</span> Actor <span class="keyword">with</span> ActorLogging {
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> Greeting(who) =&gt;
      <span class="keyword">val</span> message = <span class="string">"Hello "</span> + who + <span class="string">"!"</span>
      log.info(message)
      listener.foreach(_ ! message)
  }
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Greeter02Test</span> <span class="keyword">extends</span> <span class="title">TestKit</span><span class="params">(ActorSystem(<span class="string">"testsystem"</span>)</span>)</span>
    <span class="keyword">with</span> WordSpec
    <span class="keyword">with</span> MustMatchers
    <span class="keyword">with</span> StopSystemAfterAll {
    
  <span class="string">"The Greeter"</span> must {
    <span class="string">"say Hello World! when a Greeting("</span>World<span class="string">") is sent to it"</span> in {
      <span class="keyword">val</span> props = Props(<span class="keyword">new</span> Greeter02(Some(testActor)))
      <span class="keyword">val</span> greeter = system.actorOf(props, <span class="string">"greeter02-1"</span>)
      greeter ! Greeting(<span class="string">"World"</span>)
      expectMsg(<span class="string">"Hello World!"</span>)
    }
  <span class="string">"say something else and see what happens"</span> in {
      <span class="keyword">val</span> props = Props(<span class="keyword">new</span> Greeter02(Some(testActor)))
      <span class="keyword">val</span> greeter = system.actorOf(props, <span class="string">"greeter02-2"</span>)
      <span class="comment">// 获取没有处理的 信息</span>
      system.eventStream.subscribe(testActor, classOf[UnhandledMessage])
      greeter ! <span class="string">"World"</span>
      expectMsg(UnhandledMessage(<span class="string">"World"</span>, system.deadLetters, greeter))
    }
  }
}
</pre></td></tr></table></figure>

<h1 id="two-way-messages">Two-way messages</h1>
<p>Two-way messages are quite easy to test in a black box fashion, a request
should result in a response, which you can simply assert. In the following test we
will test an EchoActor , an actor that echoes any request back in a response.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="string">"Reply with the same message it receives without ask"</span> in {
  val <span class="keyword">echo</span> = system.actorOf(Props[EchoActor], <span class="string">"echo2"</span>)
  <span class="comment">// Call tell with the testActor as the sender</span>
  <span class="keyword">echo</span>.tell(<span class="string">"some message"</span>, testActor)
  expectMsg(<span class="string">"some message"</span>)
}

<span class="class"><span class="keyword">class</span> <span class="title">EchoActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  def receive = {
    <span class="keyword">case</span> msg =&gt;
      sender ! msg
  }
}
</pre></td></tr></table></figure>

<h1 id="what-is-fault-tolerance">What is fault tolerance</h1>
<p>A fault should be contained to a part of the system and not escalate to a total
crash.</p>
<p>Isolating a faulty component means that some structure needs to exist to
isolate it from; the system will need a defined structure in which active parts
can be isolated.</p>
<p>A backup component should be able to take over when a component fails.</p>
<p>If a faulty component can be isolated we can also replace it in the structure.
The other parts of the system should be able to communicate with the
replaced component just as they did before with the failed component.</p>
<p>If a component gets into an incorrect state, we need to have the ability to get
it back to a defined initial state. </p>
<p>A faulty component needs to be isolated and if it cannot recover it should be
terminated and removed from the system or re-initialized with a correct
starting state.</p>
<p>When a component fails we would like all calls to the component to be
suspended until the component is fixed or replaced so that when it is, the new
component can continue the work without dropping a beat.</p>
<p>It would be great if the fault recovery code could be separated from the
normal processing code. </p>
<h2 id="plain-old-objects-and-exceptions">Plain old objects and exceptions</h2>
<ul>
<li>Recreating objects and their dependencies and replacing these in the application structure
is not available as a first-class feature.</li>
<li>Objects communicate with each other directly so it is hard to isolate them.</li>
<li>The fault recovery code and the functional code are tangled up with each other.</li>
</ul>
<h2 id="let-it-crash">Let it crash</h2>
<p>Instead of using one flow to handle both normal code and recovery code Akka
provides two separate flows; one for normal logic and one for fault recovery logic.</p>
<p>The normal flow consists of actors that handle normal messages, the recovery flow
consists of actors that monitor the actors in the normal flow. Actors that monitor
other actors are called supervisors.</p>
<p>The actor code only contains normal processing logic and no error handling or fault
recovery logic, so its effectively not part of the recovery process, which keeps
things much clearer. The mailbox for a crashed actor is suspended until the
supervisor in the recovery flow has decided what to do with the exception.</p>
<p>Akka has chosen to enforce parental
supervision , meaning that any actor that creates actors automatically becomes the
supervisor of those actors.</p>
<p>The supervisor has 4 options when deciding what to do with the actor:</p>
<ul>
<li>Restart; the actor must be recreated from its Props. after it is restarted (or rebooted if you
will) the actor will continue to process messages. Since the rest of the application uses an
ActorRef to communicate with the actor the new actor instance will automatically get the
next messages.</li>
<li>Resume; the same actor instance should continue to process messages, the crash is
ignored.</li>
<li>Stop; the actor must be terminated. It will no longer take part in processing messages.</li>
<li>Escalate; the supervisor does not know what to do with it and escalates the problem to its
parent, which is also a supervisor.
<img src="/img/akka_recover.png" alt="Normal and recovery flow in the logs processing application"></li>
</ul>
<p>Akka chooses not to provide the failing message to the mailbox again after
a restart, but there is a way to do this yourself if you are absolutely sure that the
message did not cause the error, which we will discuss later.</p>
<h1 id="actor-life-cycle">Actor life-cycle</h1>
<p>During the life cycle of an actor there are three types of events:</p>
<ol>
<li>The actor is created and started, for simplicity we
will refer to this as the Start event.</li>
<li>The actor is restarted on the Restart event.</li>
<li>The actor is stopped by the Stop event.</li>
</ol>
<h2 id="start-event">Start event</h2>
<p>An actor is created and automatically started with the actorOf method. Top level
actors are created with the actorOf method on the ActorSystem . A parent actor
creates a child actor using the actorOf on its ActorContext .</p>
<p>The preStart hook is called just before the actor is started. To use this trigger we
have to override the preStart method.</p>
<h2 id="stop-event">Stop event</h2>
<p>An actor can be stopped using the stop method on the
ActorSystem and ActorContext objects, or by sending a PoisonPill
message to an actor.</p>
<p>The postStop hook is called just before the actor is terminated.</p>
<p>A stopped actor is disconnected from its ActorRef. After the actor is
stopped, the ActorRef is redirected to the deadLetters ActorRef of the actor
system, which is a special ActorRef that receives all messages that are sent to dead
actors.</p>
<h2 id="restart-event">Restart event</h2>
<p>When a restart occurs the preRestart method of the crashed actor instance
is called.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
  println(<span class="string">"preRestart"</span>)
  <span class="keyword">super</span>.preRestart(reason, message)
}
</pre></td></tr></table></figure>

<p>The default implementation of the
preRestart method stops all the child actors of the actor and then calls the
postStop hook. If you forget to call super.preRestart this default
behavior will not occur.</p>
<p>Remember that actors are (re)created from a Props
object. The Props object eventually calls the constructor of the actor.</p>
<p>A stopped actor is disconnected from its
ActorRef and redirected to the deadLetters ActorRef as described by the stop
event.</p>
<p>The preRestart method takes two arguments: the reason for the restart and
optionally the message that was being processed when the actor crashed. </p>
<p>The super.postRestart can be omitted if you are certain that you
don&#39;t want the preStart to be called when restarting, in most cases though this
is not going to be the case.</p>
<h2 id="putting-the-life-cycle-pieces-together">Putting the Life cycle Pieces Together</h2>
<p><img src="/img/akka_lifecycle.png" alt="akka_lifecycle"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">LifeCycleHooks</span> <span class="keyword">extends</span> <span class="title">Actor</span> <span class="keyword">with</span> <span class="title">ActorLogging</span>{</span>
  System.out.println(<span class="string">"Constructor"</span>)
  <span class="keyword">override</span> <span class="keyword">def</span> preStart() {println(<span class="string">"preStart"</span>)}
  <span class="keyword">override</span> <span class="keyword">def</span> postStop() {println(<span class="string">"postStop"</span>)}
  <span class="keyword">override</span> <span class="keyword">def</span> preRestart(reason: Throwable, message: Option[Any]) {
    println(<span class="string">"preRestart"</span>)
    <span class="keyword">super</span>.preRestart (reason, message)
  }
  <span class="keyword">override</span> <span class="keyword">def</span> postRestart(reason: Throwable) {
    println(<span class="string">"postRestart"</span>)
    <span class="keyword">super</span>.postRestart(reason)
  }
  <span class="keyword">def</span> receive = {
    <span class="keyword">case</span> <span class="string">"restart"</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"force restart"</span>)
    <span class="keyword">case</span> msg: AnyRef =&gt; println(<span class="string">"Receive"</span>)
  }
}
</pre></td></tr></table></figure>

<h1 id="monitoring-the-lifecycle">Monitoring the lifecycle</h1>
<p>The supervision hierarchy is fixed for the lifetime of a child. Once the child is
created by the parent it will fall under the supervision of that parent as long as it
lives, there is no such thing as adoption in Akka.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">LogProcessingApp</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> sources = Vector(<span class="string">"file:///source1/"</span>, <span class="string">"file:///source2/"</span>)
  <span class="keyword">val</span> system = ActorSystem(<span class="string">"logprocessing"</span>)
  <span class="comment">// create the props and dependencies</span>
  <span class="keyword">val</span> con = <span class="keyword">new</span> DbCon(<span class="string">"http://mydatabase"</span>)
  <span class="keyword">val</span> writerProps = Props(<span class="keyword">new</span> DbWriter(con))
  <span class="keyword">val</span> dbSuperProps = Props(<span class="keyword">new</span> DbSupervisor(writerProps))
  <span class="keyword">val</span> logProcSuperProps = Props(<span class="keyword">new</span> LogProcSupervisor(dbSuperProps))
  <span class="keyword">val</span> topLevelProps = Props(<span class="keyword">new</span> FileWatchingSupervisor(
    sources,logProcSuperProps))
  system.actorOf(topLevelProps)
}
</pre></td></tr></table></figure>

<p>Props objects are passed as recipes to the actors so that
they can create their children without knowing the details of
the dependencies of the child actors.</p>
<h2 id="predefined-strategies">Predefined strategies</h2>
<p> There are two predefined strategies available in the
SupervisorStrategy object; the defaultStrategy and the
stoppingStrategy .</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">final</span> val defaultStrategy: SupervisorStrategy = {
  def defaultDecider: Decider = { <span class="comment">//</span>
    <span class="keyword">case</span> _: ActorInitializationException =&gt; Stop <span class="comment">//</span>
    <span class="keyword">case</span> _: ActorKilledException =&gt; Stop
    <span class="keyword">case</span> _: <span class="keyword">Exception</span> =&gt; Restart
  }
  OneForOneStrategy()(defaultDecider) <span class="comment">//</span>
}
</pre></td></tr></table></figure>

<p>In some cases you might want to only stop the child actor that failed.
In other cases you might want to stop all child actors if one of them fails, maybe because they all
depend on a particular resource.</p>
<p> The OneForOneStrategy determines that child actors will not share the
same fate, only the crashed child will be decided upon by the Decider. The other
option is to use an AllForOneStrategy which uses the same decision for all
child actors even if only one crashed.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>final val stoppingStrategy: SupervisorStrategy = {
  <span class="function"><span class="keyword">def</span> <span class="title">stoppingDecider</span>:</span> Decider = {
    case _: Exception =&gt; Stop //
  }
  OneForOneStrategy()(stoppingDecider)
}
</pre></td></tr></table></figure>

<h2 id="custom-strategies">Custom Strategies</h2>
<p>First we&#39;ll look at the exceptions that can occur in the log processing
application.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre></td><td class="code"><pre>@<span class="type">SerialVersionUID</span>(<span class="number">1</span>L)
// <span class="type">An</span> unrecoverable <span class="type">Error</span> that occurs when the disk for the source has crashed
<span class="class"><span class="keyword">class</span> <span class="type">DiskError</span><span class="container">(<span class="title">msg</span>: <span class="type">String</span>)</span> extends <span class="type">Error</span><span class="container">(<span class="title">msg</span>)</span> with <span class="type">Serializable</span>

@<span class="type">SerialVersionUID</span><span class="container">(1L)</span>
// <span class="type">An</span> <span class="type">Exception</span> that occurs when the log file is corrupt and cannot be processed.
<span class="keyword">class</span> <span class="type">CorruptedFileException</span><span class="container">(<span class="title">msg</span>: <span class="type">String</span>, <span class="title">val</span> <span class="title">file</span>: <span class="type">File</span>)</span>
  extends <span class="type">Exception</span><span class="container">(<span class="title">msg</span>)</span> with <span class="type">Serializable</span>
  
@<span class="type">SerialVersionUID</span><span class="container">(1L)</span>
// <span class="type">An</span> <span class="type">Exception</span> that occurs when the database connection is broken.
<span class="keyword">class</span> <span class="type">DbBrokenConnectionException</span><span class="container">(<span class="title">msg</span>: <span class="type">Striing</span>)</span>
  extends <span class="type">Exception</span><span class="container">(<span class="title">msg</span>)</span> with <span class="type">Serializable</span>


object <span class="type">LogProcessingProtocol</span> {
  // represents a new log file
  case <span class="keyword">class</span> <span class="type">LogFile</span><span class="container">(<span class="title">file</span>: <span class="type">File</span>)</span>
  // <span class="type">A</span> line in the log file parsed by the <span class="type">LogProcessor</span> <span class="type">Actor</span>
  case <span class="keyword">class</span> <span class="type">Line</span><span class="container">(<span class="title">time</span>: <span class="type">Long</span>, <span class="title">message</span>: <span class="type">String</span>, <span class="title">messageType</span>: <span class="type">String</span>)</span>
}

<span class="keyword">class</span> <span class="type">DbWriter</span><span class="container">(<span class="title">connection</span>: <span class="type">DbCon</span>)</span> extends <span class="type">Actor</span> {
  import <span class="type">LogProcessingProtocol</span>._
  def receive = {
    case <span class="type">Line</span><span class="container">(<span class="title">time</span>, <span class="title">message</span>, <span class="title">messageType</span>)</span> =&gt;
      connection.write<span class="container">(<span class="type">Map</span>('<span class="title">time</span> -&gt; <span class="title">time</span>,
        '<span class="title">message</span> -&gt; <span class="title">message</span>,
        '<span class="title">messageType</span> -&gt; <span class="title">messageType</span>)</span>)
  }
}

/// <span class="type">Send</span> the parsed lines to the dbSupervisor which in turn will forward the message
// to the dbWriter.
<span class="keyword">class</span> <span class="type">DbSupervisor</span><span class="container">(<span class="title">writerProps</span>: <span class="type">Props</span>)</span> extends <span class="type">Actor</span> {
  override def supervisorStrategy = <span class="type">OneForOneStrategy</span><span class="container">()</span> {
    case _: <span class="type">DbBrokenConnectionException</span> =&gt; <span class="type">Restart</span>
  }
  val writer = context.actorOf<span class="container">(<span class="title">writerProps</span>)</span>
  def receive = {
    case m =&gt; writer forward <span class="container">(<span class="title">m</span>)</span>
  }
}

<span class="keyword">class</span> <span class="type">LogProcessor</span><span class="container">(<span class="title">dbSupervisor</span>: <span class="type">ActorRef</span>)</span> extends <span class="type">Actor</span> with <span class="type">LogParsing</span> {
  import <span class="type">LogProcessingProtocol</span>._
  def receive = {
    case <span class="type">LogFile</span><span class="container">(<span class="title">file</span>)</span> =&gt;
      val lines = parse<span class="container">(<span class="title">file</span>)</span>
      lines.foreach<span class="container">(<span class="title">dbSupervisor</span> ! <span class="title">_</span>)</span>
  }
}


<span class="keyword">class</span> <span class="type">LogProcSupervisor</span><span class="container">(<span class="title">dbSupervisorProps</span>: <span class="type">Props</span>)</span>
    extends <span class="type">Actor</span> {
  override def supervisorStrategy = <span class="type">OneForOneStrategy</span><span class="container">()</span> {
    case _: <span class="type">CorruptedFileException</span> =&gt; <span class="type">Resume</span>
  }
  val dbSupervisor = context.actorOf<span class="container">(<span class="title">dbSupervisorProps</span>)</span>
  val logProcProps = <span class="type">Props</span><span class="container">(<span class="title">new</span> <span class="type">LogProcessor(dbSupervisor)</span>)</span>
  val logProcessor = context.actorOf<span class="container">(<span class="title">logProcProps</span>)</span>
  def receive = {
    case m =&gt; logProcessor forward <span class="container">(<span class="title">m</span>)</span>
  }
}

<span class="keyword">class</span> <span class="type">FileWatcher</span><span class="container">(<span class="title">sourceUri</span>: <span class="type">String</span>, <span class="title">logProcSupervisor</span>: <span class="type">ActorRef</span>)</span>
    extends <span class="type">Actor</span> with <span class="type">FileWatchingAbilities</span> {
  // <span class="type">Registers</span> on a source uri in the file watching <span class="type">API</span>.
  register<span class="container">(<span class="title">sourceUri</span>)</span>
  import <span class="type">FileWatcherProtocol</span>._
  import <span class="type">LogProcessingProtocol</span>._
  def receive = {
    case <span class="type">NewFile</span><span class="container">(<span class="title">file</span>, <span class="title">_</span>)</span> =&gt;
      logProcSupervisor ! <span class="type">LogFile</span><span class="container">(<span class="title">file</span>)</span>
    case <span class="type">SourceAbandoned</span><span class="container">(<span class="title">uri</span>)</span> if uri == sourceUri =&gt;
      self ! <span class="type">PoisonPill</span>
  }
}

<span class="keyword">class</span> <span class="type">FileWatchingSupervisor</span><span class="container">(<span class="title">sources</span>: <span class="type">Vector</span>[<span class="type">String</span>], <span class="title">logProcSuperProps</span>: <span class="type">Props</span>)</span>
    extends <span class="type">Actor</span> {
  var fileWatchers: <span class="type">Vector</span>[<span class="type">ActorRef</span>] = sources.map { source =&gt;
    val logProcSupervisor = context.actorOf<span class="container">(<span class="title">logProcSuperProps</span>)</span>
    //  <span class="type">Watch</span> the file watchers for termination.
    val fileWatcher = context.actorOf<span class="container">(<span class="type">Props</span>(
          <span class="title">new</span> <span class="type">FileWatcher</span>(<span class="title">source</span>, <span class="title">logProcSupervisor</span>)</span>))
    context.watch<span class="container">(<span class="title">fileWatcher</span>)</span>
    fileWatcher
  }
  override def supervisorStrategy = <span class="type">AllForOneStrategy</span><span class="container">()</span> {
    case _: <span class="type">DiskError</span> =&gt; <span class="type">Stop</span>
  }
  def receive = {
    case <span class="type">Terminated</span><span class="container">(<span class="title">fileWatcher</span>)</span> =&gt;
      fileWatchers = fileWatchers.filterNot<span class="container">(<span class="title">w</span> =&gt; <span class="title">w</span> == <span class="title">fileWatcher</span>)</span>
      if <span class="container">(<span class="title">fileWatchers</span>.<span class="title">isEmpty</span>)</span> self ! <span class="type">PoisonPill</span>
  }
}


<span class="keyword">class</span> <span class="type">DbImpatientSupervisor</span><span class="container">(<span class="title">writerProps</span>: <span class="type">Props</span>)</span> extends <span class="type">Actor</span> {
  // <span class="type">Escalate</span> the issue if the problem has not been resolved within 60 seconds or it has
  // failed to be solved within 5 restarts.
  override def supervisorStrategy = <span class="type">OneForOneStrategy</span><span class="container">(
      <span class="title">maxNrOfRetries</span> = 5,
      <span class="title">withinTimeRange</span> = 60 <span class="title">seconds</span>)</span> {
    case _: <span class="type">DbBrokenConnectionException</span> =&gt; <span class="type">Restart</span>
  }
  val writer = context.actorOf<span class="container">(<span class="title">writerProps</span>)</span>
  
  def receive = {
    case m =&gt; writer forward <span class="container">(<span class="title">m</span>)</span>
  }
}</span>
</pre></td></tr></table></figure>

<h1 id="futures">Futures</h1>
<p>TODO</p>
]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="akka" scheme="http://zhpooer.github.io/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in Action-Introduce]]></title>
    <link href="http://zhpooer.github.io/2014/08/03/akka-in-action-introducing/"/>
    <id>http://zhpooer.github.io/2014/08/03/akka-in-action-introducing/</id>
    <published>2014-08-03T03:15:32.000Z</published>
    <updated>2014-08-03T14:19:47.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">启动案例</h1>
<p>Akka is based on the Actor programming model.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>git clone https://github<span class="preprocessor">.com</span>/RayRoestenburg/akka-<span class="keyword">in</span>-action<span class="preprocessor">.git</span>
sbt assembly
java -jar target/scala-<span class="number">2.10</span>/goticks-server<span class="preprocessor">.jar</span>
</pre></td></tr></table></figure>

<h1 id="-">模板</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>name <span class="symbol">:</span>= <span class="string">"goticks"</span>

version <span class="symbol">:</span>= <span class="string">"0.1-SNAPSHOT"</span>

organization <span class="symbol">:</span>= <span class="string">"com.goticks"</span>

scalaVersion <span class="symbol">:</span>= <span class="string">"2.10.0"</span>

resolvers ++=
  <span class="constant">Seq</span>(<span class="string">"repo"</span> at <span class="string">"http://repo.typesafe.com/typesafe/releases/"</span>,
    <span class="string">"Spray Repository"</span> at <span class="string">"http://repo.spray.io"</span>,
    <span class="string">"Spray Nightlies"</span> at <span class="string">"http://nightlies.spray.io/"</span>)

libraryDependencies ++= {
  val akkaVersion = <span class="string">"2.1.2"</span>
  val sprayVersion = <span class="string">"1.1-20130123"</span>
  <span class="constant">Seq</span>(
    <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-actor" %</span> akkaVersion,
    <span class="string">"io.spray"</span> % <span class="string">"spray-can"</span> % sprayVersion,
    <span class="string">"io.spray"</span> % <span class="string">"spray-routing"</span> % sprayVersion,
    <span class="string">"io.spray"</span> <span class="string">%% "spray-json" %</span> <span class="string">"1.2.3"</span>,
    <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-slf4j" %</span> akkaVersion,
    <span class="string">"ch.qos.logback"</span> % <span class="string">"logback-classic"</span> % <span class="string">"1.0.10"</span>,
    <span class="string">"com.typesafe.akka"</span> <span class="string">%% "akka-testkit" %</span> akkaVersion % <span class="string">"test"</span>,
    <span class="string">"org.scalatest"</span> <span class="string">%% "scalatest" %</span> <span class="string">"1.9.1"</span> % <span class="string">"test"</span>
  )
}
</pre></td></tr></table></figure>

<h1 id="goticks-com">GoTicks.com</h1>
<p>Our ticket selling service which will allow customers to buy tickets to all sorts of
events, concerts, sports games and the like.</p>
<p>Once all the tickets are sold for an event the server should respond with a 404 (Not
Found) HTTP status code.</p>
<p>REST API</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>Http Method</th>
<th>URL</th>
<th>Body</th>
<th>Response exammple</th>
</tr>
</thead>
<tbody>
<tr>
<td>create an event with a number of tickets</td>
<td>PUT</td>
<td>/events</td>
<td>{event:rhcp, nrOfTickets:250}</td>
<td>Http 200 OK</td>
</tr>
<tr>
<td>Get an overview of all events and the number of tickets available.</td>
<td>GET</td>
<td>/events</td>
<td></td>
<td>[ { event : &quot;RHCP&quot;, nrOfTickets : 249}, { event : &quot;Radiohead&quot;, nrOfTickets : 130}, ]</td>
</tr>
<tr>
<td>Buy a ticket</td>
<td>GET</td>
<td>/ticket/:eventName</td>
<td></td>
<td>{ event: &quot;RHCP&quot;, nr: 1 } or HTTP 404</td>
</tr>
</tbody>
</table>
<p>启动服务器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>sbt <span class="command">run</span>
</pre></td></tr></table></figure>

<h1 id="structure-of-the-app">Structure of the App</h1>
<p><img src="/img/akka_buy_tickets.png" alt="Structure of the App"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">package</span> com.goticks
<span class="keyword">import</span> spray.can.server.SprayCanHttpServerApp
<span class="keyword">import</span> akka.actor.Props
<span class="keyword">import</span> com.typesafe.config.ConfigFactory
<span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> <span class="keyword">with</span> <span class="title">SprayCanHttpServerApp</span> {</span>
  <span class="keyword">val</span> config = ConfigFactory.load()
  <span class="keyword">val</span> host = config.getString(<span class="string">"http.host"</span>)
  <span class="keyword">val</span> port = config.getInt(<span class="string">"http.port"</span>)
  <span class="keyword">val</span> api = system.actorOf(
    Props(<span class="keyword">new</span> RestInterface()),
    <span class="string">"httpInterface"</span>
  )
  newHttpServer(api) ! Bind(interface = host, port = port)
}
</pre></td></tr></table></figure>

<p>REST Interface Message Classes</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">// Message to create an event</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Event</span><span class="params">(event:String, nrOfTickets:Int)</span></span>
<span class="comment">// Message for requesting the state of all events</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">GetEvents</span></span>
<span class="comment">// Response message that contains current status of all events</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Events</span><span class="params">(events:List[Event])</span></span>
<span class="comment">// Signal event to indicate an event was created</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">EventCreated</span></span>
<span class="comment">// Request for a ticket for a particular event</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">TicketRequest</span><span class="params">(event:String)</span></span>
<span class="comment">// Signal event that the event is sold out</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SoldOut</span></span>
<span class="comment">// New tickets for an Event, created by BoxOffice</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Tickets</span><span class="params">(tickets:List[Ticket])</span></span>
<span class="comment">// Message to buy a ticket from the TicketSeller</span>
<span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">BuyTicket</span></span>
<span class="comment">// The numbered ticket to an event</span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Ticket</span><span class="params">(event:String, nr:Int)</span></span>
</pre></td></tr></table></figure>

<p>Akka is going to get
these parts to go together with immutable messages, so the Actors have to be
designed to get all the information they need, and produce all that is needed if they
enlist any collaborators. </p>
<h2 id="the-actor-that-handles-the-sale-ticketseller">The Actor that handles the sale: TicketSeller</h2>
<p>The TicketSeller is created by the BoxOffice and just simply keeps a list of tickets.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>package com.goticks
import akka.actor.{PoisonPill, Actor}
<span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  import TicketProtocol._
  <span class="keyword">var</span> tickets = Vector[Ticket]()
  def receive = {
    <span class="keyword">case</span> GetEvents =&gt; sender ! tickets.size
    <span class="keyword">case</span> Tickets(newTickets) =&gt;
      tickets = tickets ++ newTickets
    <span class="keyword">case</span> BuyTicket =&gt;
      <span class="keyword">if</span> (tickets.isEmpty) {
        sender ! SoldOut
        <span class="comment">// cleans up the actor </span>
        <span class="keyword">self</span> ! PoisonPill
      }
      tickets.headOption.<span class="keyword">foreach</span> { ticket =&gt;
        tickets = tickets.tail
        sender ! ticket
      }

  }
}
</pre></td></tr></table></figure>

<h2 id="boxoffice">BoxOffice</h2>
<p>The BoxOffice needs to create TicketSeller children for every event and delegates
the selling to them.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="regexp">//</span> create Event
<span class="reserved">case</span> Event<span class="function"><span class="params">(name, nrOfTickets)</span> =&gt;</span>
  <span class="regexp">//</span> If TicketSellers have <span class="keyword">not</span> been created already
  <span class="keyword">if</span>(context.child(name).isEmpty) {
    <span class="regexp">//</span> create the actor
    val ticketSeller = context.actorOf(Props[TicketSeller], name)
    val tickets = Tickets((<span class="number">1</span> to nrOfTickets).map{
      nr=&gt; Ticket(name, nr)).toList
    }
    ticketSeller ! tickets
  }
  sender ! EventCreated
<span class="regexp">//</span> buy ticket
<span class="reserved">case</span> TicketRequest<span class="function"><span class="params">(name)</span> =&gt;</span>
  context.child(name) match {
    <span class="reserved">case</span> Some<span class="function"><span class="params">(ticketSeller)</span> =&gt;</span> ticketSeller.forward(BuyTicket)
    <span class="reserved">case</span> None<span class="function"> =&gt;</span> sender ! SoldOut
  }
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">import</span> akka.pattern.ask
val capturedSender = sender

<span class="function"><span class="keyword">def</span> <span class="title">askEvent</span><span class="params">(ticketSeller:ActorRef)</span>:</span> Future[Event] = {
  val futureInt = ticketSeller.ask(GetEvents).mapTo[Int]
  futureInt.map { nrOfTickets =&gt;
    Event(ticketSeller.actorRef.path.name, nrOfTickets)
  }
}

val futures = context.children.map { ticketSeller =&gt;
  askEvent(ticketSeller)
}

// sends an Events message back to the sender once all responses
// have been handled.
Future.sequence(futures).map { events =&gt;
  capturedSender ! Events(events.toList)
}
</pre></td></tr></table></figure>

<h2 id="rest-interface">REST Interface</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre>// <span class="type">Creation</span> <span class="keyword">of</span> the <span class="type">BoxOffice</span> <span class="type">Actor</span>
<span class="title">val</span> <span class="type">BoxOffice</span> = context.actorOf(<span class="type">Props</span>[<span class="type">BoxOffice</span>])

// stays around for the lifetime <span class="keyword">of</span> the <span class="type">HTTP</span> request
<span class="title">def</span> createResponder(requestContext:<span class="type">RequestContext</span>) = {
  context.actorOf(<span class="type">Props</span>(new <span class="type">Responder</span>(requestContext, <span class="type">BoxOffice</span>)))
}

//  a snippet <span class="keyword">of</span> the <span class="type">DSL</span> that is used to handle <span class="type">HTTP</span> requests:
<span class="title">path</span>(<span class="string">"ticket"</span>) {
  get {
      entity(<span class="keyword">as</span>[<span class="type">TicketRequest</span>]) { ticketRequest =&gt; requestContext =&gt;
        val responder = createResponder(requestContext)
        <span class="type">BoxOffice</span>.ask(ticketRequest).pipeTo(responder)
    }
  }
}
<span class="class">
<span class="keyword">class</span> <span class="type">Responder</span><span class="container">(<span class="title">requestContext</span>:<span class="type">RequestContext</span>, <span class="type">BoxOffice</span>:<span class="type">ActorRef</span>)</span>
    extends <span class="type">Actor</span> with <span class="type">ActorLogging</span> {
  import <span class="type">TicketProtocol</span>._
  import spray.httpx.<span class="type">SprayJsonSupport</span>._
  
  def receive = {
    case ticket:<span class="type">Ticket</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">OK</span>, <span class="title">ticket</span>)</span>
      self ! <span class="type">PoisonPill</span>
    case <span class="type">EventCreated</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">OK</span>)</span>
      self ! <span class="type">PoisonPill</span>
    case <span class="type">SoldOut</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">NotFound</span>)</span>
      self ! <span class="type">PoisonPill</span>
    case <span class="type">Events</span><span class="container">(<span class="title">events</span>)</span> =&gt;
      requestContext.complete<span class="container">(<span class="type">StatusCodes</span>.<span class="type">OK</span>, <span class="title">events</span>)</span>
      self ! <span class="type">PoisonPill</span>
  }
}</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="Akka" scheme="http://zhpooer.github.io/tags/Akka/"/>
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim spf13 快捷键小记]]></title>
    <link href="http://zhpooer.github.io/2014/08/02/vim-%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%B0%8F%E8%AE%A1/"/>
    <id>http://zhpooer.github.io/2014/08/02/vim-快捷键小计/</id>
    <published>2014-08-02T13:31:16.000Z</published>
    <updated>2014-08-03T02:08:48.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://vim.spf13.com/" target="_blank">spf13 intro</a></p>
<p><a href="http://coolshell.cn/articles/5426.html" target="_blank">简明vim攻略</a></p>
<p><a href="http://coolshell.cn/articles/1679.html" target="_blank">vim分屏功能</a></p>
<p><a href="http://coolshell.cn/articles/11312.html" target="_blank">无插件vim编程技巧</a></p>
<p>Toggle comments using <code>&lt;Leader&gt;c&lt;space&gt;</code></p>
<p>mechanism to load files from the file system <code>&lt;c-p&gt;</code></p>
<p>Use <code>&lt;C-E&gt;</code> to toggle NERDTree</p>
<p>Use <code>&lt;leader&gt;e</code> or <code>&lt;leader&gt;nt</code> to load NERDTreeFind</p>
<p><code>&lt;leader&gt;gs</code> :Gstatus</p>
<p><code>&lt;leader&gt;gd</code> :Gdiff</p>
<p><code>&lt;leader&gt;gc</code> :Gcommit</p>
<p><code>&lt;leader&gt;gb</code> :Gblame</p>
<p><code>&lt;leader&gt;gl</code> :Glog</p>
<p><code>&lt;leader&gt;gp</code> :Git push</p>
<p><code>&lt;Leader&gt;a=</code> :Tabularize /=</p>
<p><code>&lt;Leader&gt;a:</code> :Tabularize /:</p>
<p><code>&lt;Leader&gt;a:</code>: :Tabularize /:\zs</p>
<p><code>&lt;Leader&gt;a,</code> :Tabularize /,</p>
<p><code>&lt;Leader&gt;a&lt;Bar&gt;</code> :Tabularize /</p>
<p>EasyMotion is triggered using the normal movements, but prefixing them with <code>,,w</code></p>
<p><code>map &lt;leader&gt;tn :tabnew&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;to :tabonly&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;tc :tabclose&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;tm :tabmove</code></p>
<p><code>map &lt;leader&gt;te :tabedit &lt;c-r&gt;=expand(&quot;%:p:h&quot;)&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;cd :cd %:p:h&lt;cr&gt;:pwd&lt;cr&gt;</code></p>
<p><code>map &lt;leader&gt;g :vimgrep // **/*.&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;&lt;left&gt;</code></p>
<p><code>map &lt;leader&gt;&lt;space&gt; :vimgrep // &lt;C-R&gt;%&lt;C-A&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;&lt;right&gt;</code></p>
<p>关闭当前窗口 <code>Ctrl+W c</code></p>
<p>关闭当前窗口，如果只剩最后一个了，则退出Vim <code>Ctrl+W q</code></p>
<p>让所有的屏都有一样的高度 <code>Ctrl+W =</code></p>
<p>增加高度 <code>Ctrl+W +</code></p>
<p>减少高度。 <code>Ctrl+W -</code></p>
<p>宽度你可以使用 <code>[Ctrl+W &lt;]</code>或是<code>[Ctrl+W &gt;]</code></p>
<p>buffernext <code>:bn</code> bufferprevious <code>:bp</code></p>
]]></content>
    
    
      <category term="vim" scheme="http://zhpooer.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[learning scalaz 进阶3]]></title>
    <link href="http://zhpooer.github.io/2014/07/30/learning-scalaz-%E8%BF%9B%E9%98%B63/"/>
    <id>http://zhpooer.github.io/2014/07/30/learning-scalaz-进阶3/</id>
    <published>2014-07-30T06:43:47.000Z</published>
    <updated>2014-08-01T02:51:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="origami-programming">Origami programming</h1>
<p>The dual of folding is unfolding.
The Haskell standard List library deﬁnes
the function unfoldr for generating lists.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Prelude <span class="built_in">Data</span><span class="built_in">.</span><span class="built_in">List</span><span class="subst">&gt;</span> unfoldr (<span class="subst">\</span>b <span class="subst">-&gt; </span><span class="keyword">if</span> b <span class="subst">==</span> <span class="number">0</span> then Nothing <span class="keyword">else</span> Just (b, b<span class="subst">-</span><span class="number">1</span>)) <span class="number">10</span>
<span class="preprocessor">[</span><span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span><span class="preprocessor">]</span><span class="markup"></span>
</pre></td></tr></table></figure>

<h2 id="dlist">DList</h2>
<p>There’s a data structure called DList that supports <code>DList.unfoldr</code>.
DList, or difference list, is a data structure that supports
constant-time appending.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; DList.unfoldr<span class="function"><span class="params">(<span class="number">10</span>, { (x: Int) =&gt; <span class="keyword">if</span> (x == <span class="number">0</span>) none <span class="keyword">else</span> (x, x - <span class="number">1</span>).some })</span>
<span class="title">res50</span>: <span class="title">scalaz</span>.<span class="title">DList</span>[<span class="title">Int</span>] = <span class="title">scalaz</span>.<span class="title">DListFunctions$$anon$3</span>@70627153

<span class="title">scala</span>&gt; <span class="title">res50</span>.<span class="title">toList</span>
<span class="title">res51</span>: <span class="title">List</span>[<span class="title">Int</span>] = <span class="title">List</span><span class="params">(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span></span>
</pre></td></tr></table></figure>

<h2 id="folds-for-streams">Folds for Streams</h2>
<p>In Scalaz unfold defined in StreamFunctions is introduced by <code>import Scalaz._</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; unfold<span class="function"><span class="params">(<span class="number">10</span>)</span> { <span class="params">(x)</span> =&gt;</span> <span class="keyword">if</span> (x == <span class="number">0</span>) none <span class="keyword">else</span> (x, x - <span class="number">1</span>).some }
<span class="attribute">res36</span>: Stream[Int] = Stream(<span class="number">10</span>, ?)

scala&gt; res36.toList
<span class="attribute">res37</span>: List[Int] = List(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)
</pre></td></tr></table></figure>

<h2 id="the-essence-of-the-iterator-pattern">The Essence of the Iterator Pattern</h2>
<p>In 2006 the same author wrote <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf" target="_blank">The Essence of the Iterator Pattern</a>.
This paper discusses applicative style by breaking down the GoF Iterator
pattern into two aspects: mapping and accumulating.</p>
<h2 id="monoidal-applicatives">Monoidal applicatives</h2>
<p>Scalaz implements Monoid[m].applicative to turn any monoids into
an applicative.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; Monoid[Int]<span class="preprocessor">.applicative</span><span class="preprocessor">.ap</span>2(<span class="number">1</span>, <span class="number">1</span>)(<span class="number">0</span>)
<span class="label">res99:</span> Int = <span class="number">2</span>

scala&gt; Monoid[List[Int]]<span class="preprocessor">.applicative</span><span class="preprocessor">.ap</span>2(List(<span class="number">1</span>), List(<span class="number">1</span>))(Nil)
<span class="label">res100:</span> List[Int] = List(<span class="number">1</span>, <span class="number">1</span>)
</pre></td></tr></table></figure>

<h2 id="combining-applicative-functors">Combining applicative functors</h2>
<p>Like monads, applicative functors are closed under products;
so two independent idiomatic effects can generally be fused into one,
their product.</p>
<p>In Scalaz, product is implemented under Applicative typeclass</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; Applicative[<span class="keyword">List</span>].product[Option]
res0: scalaz.Applicative[[α](<span class="keyword">List</span>[α], Option[α])] = scalaz.Applicative$$anon$<span class="number">2</span>@<span class="number">211</span>b3c6a

scala&gt; Applicative[<span class="keyword">List</span>].product[Option].point(<span class="number">1</span>)
res1: (<span class="keyword">List</span>[Int], Option[Int]) = (<span class="keyword">List</span>(<span class="number">1</span>),Some(<span class="number">1</span>))

// The product seems to be implemented as a Tuple2. 
scala&gt; ((<span class="keyword">List</span>(<span class="number">1</span>), <span class="number">1.</span>some) |@| (<span class="keyword">List</span>(<span class="number">1</span>), <span class="number">1.</span>some)) <span class="list">{_ |+| _}</span>
res2: (<span class="keyword">List</span>[Int], Option[Int]) = (<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">1</span>),Some(<span class="number">2</span>))

scala&gt; ((<span class="keyword">List</span>(<span class="number">1</span>), <span class="number">1.</span>success[<span class="keyword">String</span>]) |@| (<span class="keyword">List</span>(<span class="number">1</span>), <span class="string">"boom"</span>.failure[Int])) <span class="list">{_ |+| _}</span>
res6: (<span class="keyword">List</span>[Int], scalaz.Validation[<span class="keyword">String</span>,Int]) = (<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">1</span>),Failure(boom))
</pre></td></tr></table></figure>

<p>two sequentially-dependent idiomatic effects
can generally be fused into one, their composition.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Applicative</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Apply</span>[<span class="title">F</span>] <span class="keyword">with</span> <span class="title">Pointed</span>[<span class="title">F</span>] {</span> self =&gt;
...
  <span class="javadoc">/**The composition of Applicatives `F` and `G`, `[x]F[G[x]]`, is an Applicative */</span>
  <span class="keyword">def</span> compose[G[_]](implicit G0: Applicative[G]): Applicative[({<span class="keyword">type</span> λ[α] = F[G[α]]})#λ] = <span class="keyword">new</span> CompositionApplicative[F, G] {
    implicit <span class="keyword">def</span> F = self
    implicit <span class="keyword">def</span> G = G0
  }
...
}

scala&gt; Applicative[List].compose[Option]
res7: scalaz.Applicative[[α]List[Option[α]]] = scalaz.Applicative$$anon$<span class="number">1</span>@<span class="number">461800</span>f1

scala&gt; Applicative[List].compose[Option].point(<span class="number">1</span>)
res8: List[Option[Int]] = List(Some(<span class="number">1</span>))
</pre></td></tr></table></figure>

<h2 id="idiomatic-traversal">Idiomatic traversal</h2>
<p>The corresponding typeclass in Scalaz 7 is called Traverse:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Traverse</span>[<span class="title">F</span>[<span class="title">_</span>]] <span class="keyword">extends</span> <span class="title">Functor</span>[<span class="title">F</span>] <span class="keyword">with</span> <span class="title">Foldable</span>[<span class="title">F</span>] {</span> self =&gt;
  <span class="keyword">def</span> traverseImpl[G[_]:Applicative,A,B](fa: F[A])(f: A =&gt; G[B]): G[F[B]]
}

<span class="class"><span class="keyword">trait</span> <span class="title">TraverseOps</span>[<span class="title">F</span>[<span class="title">_</span>],<span class="title">A</span>] <span class="keyword">extends</span> <span class="title">Ops</span>[<span class="title">F</span>[<span class="title">A</span>]] {</span>
  <span class="keyword">final</span> <span class="keyword">def</span> traverse[G[_], B](f: A =&gt; G[B])(implicit G: Applicative[G]): G[F[B]] =
    G.traverse(self)(f)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) traverse <span class="list">{ x =&gt; (x &gt; 0) option (x + 1) }</span>
res14: Option[<span class="keyword">List</span>[Int]] = Some(<span class="keyword">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))

scala&gt; <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>) traverse <span class="list">{ x =&gt; (x &gt; 0) option (x + 1) }</span>
res15: Option[<span class="keyword">List</span>[Int]] = <span class="keyword">None</span>
</pre></td></tr></table></figure>

<h2 id="sequence">sequence</h2>
<p>There’s a useful method that Traverse introduces called sequence.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>/<span class="emphasis">** Traverse with the identity function *</span>/
final def sequence[<span class="link_label">G[_</span>], B](implicit ev: A === G[B], G: Applicative[G]): G[F[B]] = {
  val fgb: F[<span class="link_label">G[B</span>]] = ev.subst[<span class="link_label">F</span>](<span class="link_url">self</span>)
  F.sequence(fgb)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; <span class="keyword">List</span>(<span class="number">1.</span>some, <span class="number">2.</span>some).sequence
res156: Option[<span class="keyword">List</span>[Int]] = Some(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>))

scala&gt; <span class="keyword">List</span>(<span class="number">1.</span>some, <span class="number">2.</span>some, none).sequence
res157: Option[<span class="keyword">List</span>[Int]] = <span class="keyword">None</span>
</pre></td></tr></table></figure>

<h1 id="import-guide">import guide</h1>
<p>In Scala, imports are used for two purposes:</p>
<ol>
<li>To include names of values and types into the scope.</li>
<li>To include implicits into the scope.</li>
</ol>
<h2 id="import-scalaz-_">import scalaz._</h2>
<ol>
<li>First, the names. Typeclasses like <code>Equal[A]</code> and <code>Functor[F[_]]</code>
are implemented as trait,
and are defined under scalaz package.</li>
<li>also the names, but type aliases. scalaz’s package object
declares most of the major type aliases like <code>@@[T, Tag]</code> and <code>Reader[E, A]</code>,
which is treated as a specialization of ReaderT transformer.</li>
<li>idInstance is defined as typeclass instance of <code>Id[A]</code> for <code>Traverse[F[_]]</code>, <code>Monad[F[_]]</code></li>
</ol>
<h2 id="import-scalaz-_">import Scalaz._</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz

object Scalaz
  extends StateFunctions        // Functions related <span class="keyword">to</span> the state monad
  <span class="keyword">with</span> syntax.ToTypeClassOps    // syntax associated <span class="keyword">with</span> <span class="keyword">type</span> classes
  <span class="keyword">with</span> syntax.ToDataOps         // syntax associated <span class="keyword">with</span> Scalaz data structures
  <span class="keyword">with</span> std.AllInstances         // <span class="keyword">Type</span> class instances <span class="keyword">for</span> the standard <span class="keyword">library</span> types
  <span class="keyword">with</span> std.AllFunctions         // Functions related <span class="keyword">to</span> standard <span class="keyword">library</span> types
  <span class="keyword">with</span> syntax.std.ToAllStdOps   // syntax associated <span class="keyword">with</span> standard <span class="keyword">library</span> types
  <span class="keyword">with</span> IdInstances              // Identity <span class="keyword">type</span> <span class="keyword">and</span> instances
</pre></td></tr></table></figure>

<h3 id="statefunctions">StateFunctions</h3>
<p>Remember, import brings in names and implicits. First, the names.
StateFunctions defines several functions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>package scalaz

trait StateFunctions {
  <span class="function"><span class="keyword">def</span> <span class="title">constantState</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A, s: =&gt; S)</span>:</span> State[S, A] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">state</span>[<span class="title">S</span>, <span class="title">A</span>]<span class="params">(a: A)</span>:</span> State[S, A] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">init</span>[<span class="title">S</span>]:</span> State[S, S] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">get</span>[<span class="title">S</span>]:</span> State[S, S] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">gets</span>[<span class="title">S</span>, <span class="title">T</span>]<span class="params">(f: S =&gt; T)</span>:</span> State[S, T] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">put</span>[<span class="title">S</span>]<span class="params">(s: S)</span>:</span> State[S, Unit] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">modify</span>[<span class="title">S</span>]<span class="params">(f: S =&gt; S)</span>:</span> State[S, Unit] = ...
  <span class="function"><span class="keyword">def</span> <span class="title">delta</span>[<span class="title">A</span>]<span class="params">(a: A)</span><span class="params">(implicit A: Group[A])</span>:</span> State[A, A] = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">for</span> {
  xs &lt;- <span class="keyword">get</span>[List[Int]]
  _ &lt;- put(xs.tail)
} <span class="keyword">yield</span> xs.head
</pre></td></tr></table></figure>

<h3 id="std-allfunctions">std.AllFunctions</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz
<span class="keyword">package</span> std

<span class="class"><span class="keyword">trait</span> <span class="title">AllFunctions</span></span>
  <span class="keyword">extends</span> ListFunctions
  <span class="keyword">with</span> OptionFunctions
  <span class="keyword">with</span> StreamFunctions
  <span class="keyword">with</span> math.OrderingFunctions
  <span class="keyword">with</span> StringFunctions

<span class="class"><span class="keyword">object</span> <span class="title">AllFunctions</span> <span class="keyword">extends</span> <span class="title">AllFunctions</span></span>
</pre></td></tr></table></figure>

<p>For example, ListFunctions bring in intersperse function that puts
a given element in ever other position:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">intersperse(<span class="function">List(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span>, <span class="number">7</span>)</span>
</pre></td></tr></table></figure>

<h3 id="idinstances">IdInstances</h3>
<p>defines the type alias <code>Id[A]</code> as follows:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="class"><span class="keyword">type</span> <span class="title">Id</span>[+<span class="title">X</span>] =</span> X
</pre></td></tr></table></figure>

<h3 id="std-allinstances">std.AllInstances</h3>
<p>the fact that list is a monad and that
monad introduces <code>&gt;&gt;=</code> operator are two different things.</p>
<p>one of the most interesting design of scalaz 7 is that it
rigorously separates the two concepts into “instance” and “syntax.”</p>
<p><code>std.allinstances</code> is a mixin of typeclass instances for built-in (std) data structures:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz.std

<span class="class"><span class="keyword">trait</span> <span class="title">allinstances</span></span>
  <span class="keyword">extends</span> anyvalinstances <span class="keyword">with</span> functioninstances <span class="keyword">with</span> listinstances <span class="keyword">with</span> mapinstances
  <span class="keyword">with</span> optioninstances <span class="keyword">with</span> setinstances <span class="keyword">with</span> stringinstances <span class="keyword">with</span> streaminstances <span class="keyword">with</span> tupleinstances
  <span class="keyword">with</span> eitherinstances <span class="keyword">with</span> partialfunctioninstances <span class="keyword">with</span> typeconstraintinstances
  <span class="keyword">with</span> scalaz.std.math.bigdecimalinstances <span class="keyword">with</span> scalaz.std.math.bigints
  <span class="keyword">with</span> scalaz.std.math.orderinginstances
  <span class="keyword">with</span> scalaz.std.util.parsing.combinator.parsers
  <span class="keyword">with</span> scalaz.std.java.util.mapinstances
  <span class="keyword">with</span> scalaz.std.java.math.bigintegerinstances
  <span class="keyword">with</span> scalaz.std.java.util.concurrent.callableinstances
  <span class="keyword">with</span> nodeseqinstances
  <span class="comment">// intentionally omitted: iterableinstances</span>

<span class="class"><span class="keyword">object</span> <span class="title">allinstances</span> <span class="keyword">extends</span> <span class="title">allinstances</span></span>
</pre></td></tr></table></figure>

<h3 id="syntax-totypeclassops">syntax.totypeclassops</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz
<span class="keyword">package</span> syntax

<span class="class"><span class="keyword">trait</span> <span class="title">totypeclassops</span></span>
  <span class="keyword">extends</span> tosemigroupops <span class="keyword">with</span> tomonoidops <span class="keyword">with</span> togroupops <span class="keyword">with</span> toequalops <span class="keyword">with</span> tolengthops <span class="keyword">with</span> toshowops
  <span class="keyword">with</span> toorderops <span class="keyword">with</span> toenumops <span class="keyword">with</span> tometricspaceops <span class="keyword">with</span> toplusemptyops <span class="keyword">with</span> toeachops <span class="keyword">with</span> toindexops
  <span class="keyword">with</span> tofunctorops <span class="keyword">with</span> topointedops <span class="keyword">with</span> tocontravariantops <span class="keyword">with</span> tocopointedops <span class="keyword">with</span> toapplyops
  <span class="keyword">with</span> toapplicativeops <span class="keyword">with</span> tobindops <span class="keyword">with</span> tomonadops <span class="keyword">with</span> tocojoinops <span class="keyword">with</span> tocomonadops
  <span class="keyword">with</span> tobifoldableops <span class="keyword">with</span> tocozipops
  <span class="keyword">with</span> toplusops <span class="keyword">with</span> toapplicativeplusops <span class="keyword">with</span> tomonadplusops <span class="keyword">with</span> totraverseops <span class="keyword">with</span> tobifunctorops
  <span class="keyword">with</span> tobitraverseops <span class="keyword">with</span> toarridops <span class="keyword">with</span> tocomposeops <span class="keyword">with</span> tocategoryops
  <span class="keyword">with</span> toarrowops <span class="keyword">with</span> tofoldableops <span class="keyword">with</span> tochoiceops <span class="keyword">with</span> tosplitops <span class="keyword">with</span> tozipops <span class="keyword">with</span> tounzipops <span class="keyword">with</span> tomonadwriterops <span class="keyword">with</span> tolistenablemonadwriterops
</pre></td></tr></table></figure>

<h3 id="syntax-todataops">syntax.todataops</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">todataops</span> <span class="keyword">extends</span> <span class="title">toidops</span> <span class="keyword">with</span> <span class="title">totreeops</span> <span class="keyword">with</span> <span class="title">towriterops</span> <span class="keyword">with</span> <span class="title">tovalidationops</span> <span class="keyword">with</span> <span class="title">toreducerops</span> <span class="keyword">with</span> <span class="title">tokleisliops</span></span>

<span class="comment">///</span>
<span class="keyword">package</span> scalaz.syntax

<span class="class"><span class="keyword">trait</span> <span class="title">idops</span>[<span class="title">a</span>] <span class="keyword">extends</span> <span class="title">ops</span>[<span class="title">a</span>] {</span>
  <span class="keyword">final</span> <span class="keyword">def</span> ??(d: =&gt; a)(implicit ev: <span class="keyword">null</span> &lt;:&lt; a): a = ...
  <span class="keyword">final</span> <span class="keyword">def</span> |&gt;[b](f: a =&gt; b): b = ...
  <span class="keyword">final</span> <span class="keyword">def</span> squared: (a, a) = ...
  <span class="keyword">def</span> left[b]: (a \/ b) = ...
  <span class="keyword">def</span> right[b]: (b \/ a) = ...
  <span class="keyword">final</span> <span class="keyword">def</span> wrapnel: nonemptylist[a] = ...
  <span class="keyword">def</span> matchorzero[b: monoid](pf: partialfunction[a, b]): b = ...
  <span class="keyword">final</span> <span class="keyword">def</span> dowhile(f: a =&gt; a, p: a =&gt; boolean): a = ...
  <span class="keyword">final</span> <span class="keyword">def</span> whiledo(f: a =&gt; a, p: a =&gt; boolean): a = ...
  <span class="keyword">def</span> visit[f[_] : pointed](p: partialfunction[a, f[a]]): f[a] = ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">toidops</span> {</span>
  implicit <span class="keyword">def</span> toidops[a](a: a): idops[a] = <span class="keyword">new</span> idops[a] {
    <span class="keyword">def</span> self: a = a
  }
}

<span class="comment">///</span>
<span class="keyword">package</span> scalaz
<span class="keyword">package</span> syntax

<span class="class"><span class="keyword">trait</span> <span class="title">treeops</span>[<span class="title">a</span>] <span class="keyword">extends</span> <span class="title">ops</span>[<span class="title">a</span>] {</span>
  <span class="keyword">def</span> node(subforest: tree[a]*): tree[a] = ...
  <span class="keyword">def</span> leaf: tree[a] = ...
}

<span class="class"><span class="keyword">trait</span> <span class="title">totreeops</span> {</span>
  implicit <span class="keyword">def</span> totreeops[a](a: a) = <span class="keyword">new</span> treeops[a]{ <span class="keyword">def</span> self = a }
}
</pre></td></tr></table></figure>

<p>the same goes for <code>writerops[a]</code>, <code>validationops[a]</code>,
<code>reducerops[a]</code>, and <code>kleisliidops[a]</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; <span class="number">1.</span>node(<span class="number">2.</span>leaf)
<span class="label">res7:</span> scalaz<span class="preprocessor">.tree</span>[int] = &lt;tree&gt;

scala&gt; <span class="number">1.</span><span class="keyword">set</span>(<span class="string">"log1"</span>)
<span class="label">res8:</span> scalaz<span class="preprocessor">.writer</span>[string,int] = scalaz<span class="preprocessor">.writertfunctions</span>$$anon$26<span class="localvars">@2375</span>d245

scala&gt; <span class="string">"log2"</span><span class="preprocessor">.tell</span>
<span class="label">res9:</span> scalaz<span class="preprocessor">.writer</span>[string,unit] = scalaz<span class="preprocessor">.writertfunctions</span>$$anon$26<span class="localvars">@699289</span>fb

scala&gt; <span class="number">1.</span>success[string]
<span class="label">res11:</span> scalaz<span class="preprocessor">.validation</span>[string,int] = success(<span class="number">1</span>)

scala&gt; <span class="string">"boom"</span><span class="preprocessor">.failurenel</span>[int]
<span class="label">res12:</span> scalaz<span class="preprocessor">.validationnel</span>[string,int] = failure(nonemptylist(boom))
</pre></td></tr></table></figure>

<h3 id="syntax-std-toallstdops">syntax.std.toallstdops</h3>
<p>introduces methods and operators to scala’s standard types.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">package</span> scalaz
<span class="keyword">package</span> syntax
<span class="keyword">package</span> std

<span class="class"><span class="keyword">trait</span> <span class="title">toallstdops</span></span>
  <span class="keyword">extends</span> tobooleanops <span class="keyword">with</span> tooptionops <span class="keyword">with</span> tooptionidops <span class="keyword">with</span> tolistops <span class="keyword">with</span> tostreamops
  <span class="keyword">with</span> tofunction2ops <span class="keyword">with</span> tofunction1ops <span class="keyword">with</span> tostringops <span class="keyword">with</span> totupleops <span class="keyword">with</span> tomapops <span class="keyword">with</span> toeitherops
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>scala&gt; <span class="constant">false</span> /\ <span class="constant">true</span>
res14: <span class="type">boolean</span> = <span class="constant">false</span>

scala&gt; <span class="constant">false</span> \/ <span class="constant">true</span>
res15: <span class="type">boolean</span> = <span class="constant">true</span>

scala&gt; <span class="constant">true</span> option <span class="string">"foo"</span>
res16: option[<span class="type">string</span>] = <span class="keyword">some</span>(foo)

scala&gt; (<span class="number">1</span> &gt; <span class="number">10</span>)? <span class="string">"foo"</span> | <span class="string">"bar"</span>
res17: <span class="type">string</span> = bar

scala&gt; (<span class="number">1</span> &gt; <span class="number">10</span>)?? {<span class="type">list</span>(<span class="string">"foo"</span>)}
res18: <span class="type">list</span>[<span class="type">string</span>] = <span class="type">list</span>()


scala&gt; <span class="number">1.</span><span class="keyword">some</span>? <span class="string">"foo"</span> | <span class="string">"bar"</span>
res28: <span class="type">string</span> = foo

scala&gt; <span class="number">1.</span><span class="keyword">some</span> | <span class="number">2</span>
res30: int = <span class="number">1</span>


scala&gt; <span class="type">list</span>(<span class="number">1</span>, <span class="number">2</span>) filterm {_ =&gt; <span class="type">list</span>(<span class="constant">true</span>, <span class="constant">false</span>)}
res37: <span class="type">list</span>[<span class="type">list</span>[int]] = <span class="type">list</span>(<span class="type">list</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">list</span>(<span class="number">1</span>), <span class="type">list</span>(<span class="number">2</span>), <span class="type">list</span>())
</pre></td></tr></table></figure>

<h1 id="hacking-on-a-project">hacking on a project</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>git clone <span class="attribute">-b</span> scalaz<span class="attribute">-seven</span> git:<span class="comment">//github.com/scalaz/scalaz.git scalaz-seven</span>
git branch topic/vectorinstance
git co topic/vectorinstance
</pre></td></tr></table></figure>

<p>What’s actually going on is not just the combination of applicative
<code>functors (m ⊠ n)</code>, but the combination of applicative functions:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="label">(⊗)::</span>(Functor m,Functor n) ⇒ (<span class="literal">a</span> → m b) → (<span class="literal">a</span> → n b) → (<span class="literal">a</span> → (m ⊠ n) b)
(f ⊗ g) x = Prod (f x) (g x)
</pre></td></tr></table></figure>

<p>Int is a Monoid, and any Monoid can be treated as an applicative functor,
which is called monoidal applicatives.
The problem is that when we make that into a function, it’s not distinguishable
from <code>Int =&gt; Int</code>, but we need <code>Int =&gt; [α]Int</code></p>
<p>TODO</p>
<h1 id="arrow">Arrow</h1>
<p>An arrow is the term used in category theory as an abstract
notion of thing that behaves like a function.</p>
<p>In Scalaz, these are <code>Function1[A, B]</code>, <code>PartialFunction[A, B]</code>,
<code>Kleisli[F[_], A, B], and CoKleisli[F[_], A, B]</code>. Arrow
abstracts them all similar to the way other typeclasses abtracts containers.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>// Looks like Arrow[=&gt;:[_, _]] extends Category[=&gt;:].
trait Arrow[=&gt;:[_, _]] extends Category[=&gt;:] { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">id</span>[<span class="title">A</span>]:</span> A =&gt;: A
  <span class="function"><span class="keyword">def</span> <span class="title">arr</span>[<span class="title">A</span>, <span class="title">B</span>]<span class="params">(f: A =&gt; B)</span>:</span> A =&gt;: B
  <span class="function"><span class="keyword">def</span> <span class="title">first</span>[<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>]<span class="params">(f: <span class="params">(A =&gt;: B)</span>)</span>:</span> ((A, C) =&gt;: (B, C))
}
</pre></td></tr></table></figure>

<h2 id="category-and-compose">Category and Compose</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>trait Category[=&gt;:[_, _]] extends Compose[=&gt;:] { self =&gt;
  /** The left <span class="keyword">and</span> right identity over `compose`. */
  <span class="function"><span class="keyword">def</span> <span class="title">id</span>[<span class="title">A</span>]:</span> A =&gt;: A
}

trait Compose[=&gt;:[_, _]]  { self =&gt;
  <span class="function"><span class="keyword">def</span> <span class="title">compose</span>[<span class="title">A</span>, <span class="title">B</span>, <span class="title">C</span>]<span class="params">(f: B =&gt;: C, g: A =&gt;: B)</span>:</span> (A =&gt;: C)
}
</pre></td></tr></table></figure>

<p>compose function composes two arrows into one. Using compose, Compose
introduces the following operators:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>trait ComposeOps[F[_, _],A, B] extends Ops[F[A, B]] {
  final <span class="function"><span class="keyword">def</span> &lt;&lt;&lt;[<span class="title">C</span>]<span class="params">(x: F[C, A])</span>:</span> F[C, B] = F.compose(self, x)
  final <span class="function"><span class="keyword">def</span> &gt;&gt;&gt;[<span class="title">C</span>]<span class="params">(x: F[B, C])</span>:</span> F[A, C] = F.compose(x, self)
}
</pre></td></tr></table></figure>

<p>The meaning of <code>&gt;&gt;&gt;</code> and <code>&lt;&lt;&lt;</code> depends on the arrow, but for functions,
it’s the same as andThen and compose:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; val f = (_:<span class="built_in">Int</span>) + <span class="number">1</span>
f: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span> = &lt;function1&gt;

scala&gt; val g = (_:<span class="built_in">Int</span>) * <span class="number">100</span>
g: <span class="built_in">Int</span> =&gt; <span class="built_in">Int</span> = &lt;function1&gt;

scala&gt; (f &gt;&gt;&gt; g)(<span class="number">2</span>)
res0: <span class="built_in">Int</span> = <span class="number">300</span>

scala&gt; (f &lt;&lt;&lt; g)(<span class="number">2</span>)
res1: <span class="built_in">Int</span> = <span class="number">201</span>
</pre></td></tr></table></figure>

<h2 id="arrow-again">Arrow, again</h2>
<p><code>=&gt;:[A, B]</code> as <code>A =&gt;: B</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>trait ArrowOps[F[_, _],A, B] extends Ops[F[A, B]] {
  final <span class="function"><span class="keyword">def</span> ***[<span class="title">C</span>, <span class="title">D</span>]<span class="params">(k: F[C, D])</span>:</span> F[(A, C), (B, D)] = F.splitA(self, k)
  final <span class="function"><span class="keyword">def</span> &&&[<span class="title">C</span>]<span class="params">(k: F[A, C])</span>:</span> F[A, (B, C)] = F.combine(self, k)
  ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>scala&gt; val f = (<span class="attribute">_</span>:Int) + <span class="number">1</span>
<span class="attribute">f</span>: Int<span class="function"> =&gt;</span> Int = &lt;function1&gt;

scala&gt; val g = (<span class="attribute">_</span>:Int) * <span class="number">100</span>
<span class="attribute">g</span>: Int<span class="function"> =&gt;</span> Int = &lt;function1&gt;

<span class="regexp">//</span> combines two arrows into a <span class="keyword">new</span> arrow <span class="keyword">by</span> running
<span class="regexp">//</span> the two arrows <span class="literal">on</span> a pair <span class="keyword">of</span> values
scala&gt; (f *** g)(<span class="number">1</span>, <span class="number">2</span>)
<span class="attribute">res3</span>: (Int, Int) = (<span class="number">2</span>,<span class="number">200</span>)

<span class="regexp">//</span> combines two arrows into a <span class="keyword">new</span> arrow <span class="keyword">by</span> running the
<span class="regexp">//</span> two arrows <span class="literal">on</span> the same value
scala&gt; (f &&& g)(<span class="number">2</span>)
<span class="attribute">res4</span>: (Int, Int) = (<span class="number">3</span>,<span class="number">200</span>)
</pre></td></tr></table></figure>

<h1 id="unapply">Unapply</h1>
<p>One thing that I’ve been fighting the Scala compiler over
is the lack of type inference support across the different kinded types
like <code>F[M[_, _]]</code> and <code>F[M[_]]</code>, and <code>M[_] and F[M[_]]</code>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>scala&gt; Applicative[Function1[Int, Int]]
&lt;<span class="built_in">console</span>&gt;:<span class="number">14</span>: <span class="attribute">error</span>: Int<span class="function"> =&gt;</span> Int takes <span class="literal">no</span> type parameters, <span class="attribute">expected</span>: one
              Applicative[Function1[Int, Int]]
                          ^
<span class="regexp">//</span> an instance <span class="keyword">of</span> Applicative[M[_]] <span class="keyword">is</span> <span class="function"><span class="params">(* -&gt; *)</span> -&gt;</span> *                          
scala&gt; Applicative[({type l[A]=Function1[Int, A]})<span class="comment">#l]</span>
<span class="attribute">res14</span>: scalaz.Applicative[[A]Int<span class="function"> =&gt;</span> A] = scalaz.std.FunctionInstances$$anon$<span class="number">2</span>@<span class="number">56</span>ae78ac
</pre></td></tr></table></figure>

<p>One of the way Scalaz helps you out is to provide
meta-instances of typeclass instance called Unapply.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Unapply</span>[<span class="title">TC</span>[<span class="title">_</span>[<span class="title">_</span>]], <span class="title">MA</span>] {</span>
  <span class="javadoc">/** The type constructor */</span>
  <span class="keyword">type</span> M[_]
  <span class="javadoc">/** The type that `M` was applied to */</span>
  <span class="keyword">type</span> A
  <span class="javadoc">/** The instance of the type class */</span>
  <span class="keyword">def</span> TC: TC[M]
  <span class="javadoc">/** Evidence that MA =:= M[A] */</span>
  <span class="keyword">def</span> apply(ma: MA): M[A]
}
</pre></td></tr></table></figure>

<p>TODO</p>
<h2 id="parallel-composition">parallel composition</h2>
<p>TODO</p>
<h1 id="momo">Momo</h1>
<p>Pure functions don’t imply they are computationally cheap.</p>
<p>Given you have some space in RAM, we could trade some of the
expensive calculations for space by caching the result.
This is called memoization.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>sealed trait Memo[<span class="decorator">@specialized(Int) K, @specialized(Int, Long, Double) V] {</span>
  <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(z: K =&gt; V)</span>:</span> K =&gt; V
}
</pre></td></tr></table></figure>

<p>We pass in a potentially expensive function as an input
and you get back a function that behaves the same but may cache the result.</p>
<p>Memo object there are some default implementations of Memo like
<code>Memo.mutableHashMapMemo[K, V]</code>, <code>Memo.weakHashMapMemo[K, V]</code>, and <code>Memo.arrayMemo[V]</code>.</p>
<p>缓存每次运算的结果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>scala&gt; val slowFib: Int =&gt; Int = {
         <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">0</span>
         <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="number">1</span>
         <span class="keyword">case</span> n =&gt; slowFib(n - <span class="number">2</span>) + slowFib(n - <span class="number">1</span>)
       }
slowFib: Int =&gt; Int = &lt;function1&gt;

scala&gt; slowFib(<span class="number">45</span>)
res2: Int = <span class="number">1134903170</span>

scala&gt; val memoizedFib: Int =&gt; Int = Memo.mutableHashMapMemo {
         <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">0</span>
         <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="number">1</span>
         <span class="keyword">case</span> n =&gt; memoizedFib(n - <span class="number">2</span>) + memoizedFib(n - <span class="number">1</span>)
       }
memoizedFib: Int =&gt; Int = &lt;function1&gt;

scala&gt; memoizedFib(<span class="number">45</span>)
res14: Int = <span class="number">1134903170</span>
</pre></td></tr></table></figure>

<h1 id="functional-programming">functional programming</h1>
<p>An expression e is referentially transparent if every occurrence e can
be replaced with its value without affecting the observable result of the program.</p>
<h1 id="effect-system">Effect system</h1>
<h2 id="st">ST</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>sealed trait ST[S, A] {
  private[effect] <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(s: World[S])</span>:</span> (World[S], A)
}
</pre></td></tr></table></figure>

<p>This looks similar to State monad, but the difference I think is that
the state is mutated in-place, and in return is not observable from outside.</p>
<h2 id="stref">STRef</h2>
<p>STRef is a mutable variable that’s used only within
the context of ST monad. It’s created using ST.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">STRef</span>[<span class="title">S</span>, <span class="title">A</span>] {</span>
  <span class="keyword">protected</span> <span class="keyword">var</span> value: A

  <span class="javadoc">/**Reads the value pointed at by this reference. */</span>
  <span class="keyword">def</span> read: ST[S, A] = returnST(value)
  <span class="javadoc">/**Modifies the value at this reference with the given function. */</span>
  <span class="keyword">def</span> mod[B](f: A =&gt; A): ST[S, STRef[S, A]] = ...
  <span class="javadoc">/**Associates this reference with the given value. */</span>
  <span class="keyword">def</span> write(a: =&gt; A): ST[S, STRef[S, A]] = ...
  <span class="javadoc">/**Synonym for write*/</span>
  <span class="keyword">def</span> |=(a: =&gt; A): ST[S, STRef[S, A]] = ...
  <span class="javadoc">/**Swap the value at this reference with the value at another. */</span>
  <span class="keyword">def</span> swap(that: STRef[S, A]): ST[S, Unit] = ...
}

<span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">STArray</span>[<span class="title">S</span>, <span class="title">A</span>] {</span>
  <span class="keyword">val</span> size: Int
  <span class="keyword">val</span> z: A
  <span class="keyword">private</span> <span class="keyword">val</span> value: Array[A] = Array.fill(size)(z)
  <span class="javadoc">/**Reads the value at the given index. */</span>
  <span class="keyword">def</span> read(i: Int): ST[S, A] = returnST(value(i))
  <span class="javadoc">/**Writes the given value to the array, at the given offset. */</span>
  <span class="keyword">def</span> write(i: Int, a: A): ST[S, STArray[S, A]] = ...
  <span class="javadoc">/**Turns a mutable array into an immutable one which is safe to return. */</span>
  <span class="keyword">def</span> freeze: ST[S, ImmutableArray[A]] = ...
  <span class="javadoc">/**Fill this array from the given association list. */</span>
  <span class="keyword">def</span> fill[B](f: (A, B) =&gt; A, xs: Traversable[(Int, B)]): ST[S, Unit] = ...
  <span class="javadoc">/**Combine the given value with the value at the given index, using the given function. */</span>
  <span class="keyword">def</span> update[B](f: (A, B) =&gt; A, i: Int, v: B) = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="title">scala</span>&gt; <span class="import"><span class="keyword">import</span> effect._</span>
<span class="import"><span class="keyword">import</span> effect._</span>

<span class="title">scala</span>&gt; <span class="import"><span class="keyword">import</span> ST.{newVar, runST, newArr, returnST}</span>
<span class="import"><span class="keyword">import</span> ST.{newVar, runST, newArr, returnST}</span>

<span class="title">scala</span>&gt; def e1[<span class="type">S</span>] = for {
         x &lt;- newVar[<span class="type">S</span>](<span class="number">0</span>)
         r &lt;- x mod {_ + <span class="number">1</span>}
       } yield x
<span class="title">e1</span>: [<span class="type">S</span>]=&gt; scalaz.effect.<span class="type">ST</span>[<span class="type">S</span>,scalaz.effect.<span class="type">STRef</span>[<span class="type">S</span>,<span class="type">Int</span>]]

<span class="title">scala</span>&gt; def e2[<span class="type">S</span>]: <span class="type">ST</span>[<span class="type">S</span>, <span class="type">Int</span>] = for {
         x &lt;- e1[<span class="type">S</span>]
         r &lt;- x.read
       } yield r 
<span class="title">e2</span>: [<span class="type">S</span>]=&gt; scalaz.effect.<span class="type">ST</span>[<span class="type">S</span>,<span class="type">Int</span>]

<span class="title">scala</span>&gt; <span class="typedef"><span class="keyword">type</span> <span class="type">ForallST</span>[<span class="type">A</span>] = <span class="type">Forall</span>[<span class="container">({<span class="title">type</span> λ[<span class="type">S</span>] = <span class="type">ST</span>[<span class="type">S</span>, <span class="type">A</span>]})</span>#λ]</span>
<span class="title">defined</span> <span class="typedef"><span class="keyword">type</span> alias <span class="type">ForallST</span></span>

<span class="title">scala</span>&gt; runST(new <span class="type">ForallST</span>[<span class="type">Int</span>] { def apply[<span class="type">S</span>] = e2[<span class="type">S</span>] })
<span class="title">res5</span>: <span class="type">Int</span> = <span class="number">1</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="string">"STArray"</span> <span class="keyword">in</span> {
  def e1[S] = <span class="keyword">for</span> {
    arr &lt;- newArr[S, <span class="built_in">Boolean</span>](<span class="number">3</span>, <span class="literal">true</span>)
    _ &lt;- arr.write(<span class="number">0</span>, <span class="literal">false</span>)
    r &lt;- arr.freeze
  } <span class="keyword">yield</span> r
  runST(<span class="keyword">new</span> ForallST[ImmutableArray[<span class="built_in">Boolean</span>]] { def apply[S] = e1[S] }).toList must be_===(
    List(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>))
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>scala&gt; def mapM[<span class="link_label">A, S, B</span>](<span class="link_url">xs: List[A]</span>)(f: A =&gt; ST[S, B]): ST[S, List[B]] =
<span class="code">         Monad[({type λ[α] = ST[S, α]})#λ].sequence(xs map f)</span>
mapM: [<span class="link_label">A, S, B</span>](<span class="link_url">xs: List[A]</span>)(f: A =&gt; scalaz.effect.ST[S,B])scalaz.effect.ST[S,List[B]]

scala&gt; def sieve[<span class="link_label">S</span>](<span class="link_url">n: Int</span>) = for {
<span class="code">         arr &lt;- newArr[S, Boolean](n + 1, true)</span>
<span class="code">         _ &lt;- arr.write(0, false)</span>
<span class="code">         _ &lt;- arr.write(1, false)</span>
<span class="code">         val nsq = (math.sqrt(n.toDouble).toInt + 1)</span>
<span class="code">         _ &lt;- mapM (1 |-&gt; nsq) { i =&gt;</span>
<span class="code">           for {</span>
<span class="code">             x &lt;- arr.read(i)</span>
<span class="code">             _ &lt;-</span>
<span class="code">               if (x) mapM (i * i |--&gt; (i, n)) { j =&gt; arr.write(j, false) }</span>
<span class="code">               else returnST[S, List[Boolean]] {Nil}</span>
<span class="code">           } yield ()</span>
<span class="code">         }</span>
<span class="code">         r &lt;- arr.freeze</span>
<span class="code">       } yield r</span>
sieve: [<span class="link_label">S</span>](<span class="link_url">n: Int</span>)scalaz.effect.ST[S,scalaz.ImmutableArray[Boolean]]

scala&gt; type ForallST[A] = Forall[({type λ[S] = ST[S, A]})#λ]
defined type alias ForallST

scala&gt; def prime(n: Int) =
<span class="code">         runST(new ForallST[ImmutableArray[Boolean]] { def apply[S] = sieve[S](n) }).toArray.</span>
<span class="code">         zipWithIndex collect { case (true, x) =&gt; x }</span>
prime: (n: Int)Array[Int]

scala&gt; prime(1000)
</pre></td></tr></table></figure>

<h1 id="io-monad">IO Monad</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>sealed trait IO[+A] {
  private[effect] <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(rw: World[RealWorld])</span>:</span> Trampoline[(World[RealWorld], A)]
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; import scalaz._, Scalaz._, effect._, IO._
scala&gt; val action1 = for {
         _ &lt;- putStrLn(<span class="string">"Hello, world!"</span>)
       } yield ()
<span class="label">action1:</span> scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IO</span>[Unit] = scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IOFunctions</span>$$anon$4<span class="localvars">@149</span>f6f65

scala&gt; action1<span class="preprocessor">.unsafePerformIO</span>
Hello, world!
</pre></td></tr></table></figure>

<p>IO actions</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>  /** Reads a character <span class="keyword">from</span> standard input. */
  <span class="function"><span class="keyword">def</span> <span class="title">getChar</span>:</span> IO[Char] = ...
  /** Writes a character to standard output. */
  <span class="function"><span class="keyword">def</span> <span class="title">putChar</span><span class="params">(c: Char)</span>:</span> IO[Unit] = ...
  /** Writes a string to standard output. */
  <span class="function"><span class="keyword">def</span> <span class="title">putStr</span><span class="params">(s: String)</span>:</span> IO[Unit] = ...
  /** Writes a string to standard output, followed by a newline.*/
  <span class="function"><span class="keyword">def</span> <span class="title">putStrLn</span><span class="params">(s: String)</span>:</span> IO[Unit] = ...
  /** Reads a line of standard input. */
  <span class="function"><span class="keyword">def</span> <span class="title">readLn</span>:</span> IO[String] = ...
  /** Write the given value to standard output. */
  <span class="function"><span class="keyword">def</span> <span class="title">putOut</span>[<span class="title">A</span>]<span class="params">(a: A)</span>:</span> IO[Unit] = ...
  // Mutable variables <span class="keyword">in</span> the IO monad
  <span class="function"><span class="keyword">def</span> <span class="title">newIORef</span>[<span class="title">A</span>]<span class="params">(a: =&gt; A)</span>:</span> IO[IORef[A]] = ...
  /**Throw the given error <span class="keyword">in</span> the IO monad. */
  <span class="function"><span class="keyword">def</span> <span class="title">throwIO</span>[<span class="title">A</span>]<span class="params">(e: Throwable)</span>:</span> IO[A] = ...
  /** An IO action that does nothing. */
  val ioUnit: IO[Unit] = ...
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; val action2 = IO {
         val source = scala<span class="preprocessor">.io</span><span class="preprocessor">.Source</span><span class="preprocessor">.fromFile</span>(<span class="string">"./README.md"</span>)
         source<span class="preprocessor">.getLines</span><span class="preprocessor">.toStream</span>
       }
<span class="label">action2:</span> scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IO</span>[scala<span class="preprocessor">.collection</span><span class="preprocessor">.immutable</span><span class="preprocessor">.Stream</span>[String]] = scalaz<span class="preprocessor">.effect</span><span class="preprocessor">.IOFunctions</span>$$anon$4@bab4387

scala&gt; action2<span class="preprocessor">.unsafePerformIO</span><span class="preprocessor">.toList</span>
<span class="label">res57:</span> List[String] = List(<span class="preprocessor"># Scalaz, "", Scalaz is a Scala library for functional programming., "", It provides purely functional data structures to complement those from the Scala standard library., ...</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">program</span>:</span> IO[Unit] = <span class="keyword">for</span> {
  line &lt;- readLn
  _    &lt;- putStrLn(line)
} <span class="keyword">yield</span> ()

scala&gt; (program |+| program).unsafePerformIO
<span class="number">123</span>
<span class="number">123</span>
</pre></td></tr></table></figure>

<h2 id="enumeration-based-i-o-with-iteratees">Enumeration-Based I/O with Iteratees</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>sealed trait Input[E] {
  def fold[<span class="link_label">Z</span>](<span class="link_url">empty: =&gt; Z, el: (=&gt; E</span>) =&gt; Z, eof: =&gt; Z): Z
  def apply[<span class="link_label">Z</span>](<span class="link_url">empty: =&gt; Z, el: (=&gt; E</span>) =&gt; Z, eof: =&gt; Z) =
<span class="code">    fold(empty, el, eof)</span>
}

sealed trait IterateeT[E, F[_], A] {
  def value: F[StepT[E, F, A]]
}
type Iteratee[E, A] = IterateeT[E, Id, A]

object Iteratee
  extends IterateeFunctions
  with IterateeTFunctions
  with EnumeratorTFunctions
  with EnumeratorPFunctions
  with EnumerateeTFunctions
  with StepTFunctions
  with InputFunctions {

  def apply[<span class="link_label">E, A</span>](<span class="link_url">s: Step[E, A]</span>): Iteratee[E, A] = iteratee(s)
}

type &gt;@&gt;[E, A] = Iteratee[E, A]
</pre></td></tr></table></figure>

<p>Let’s try implementing the counter example from EBIOI.
For that we switch to iteratee project using sbt:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>sealed trait IterateeT[E, F[_], A] {
  <span class="function"><span class="keyword">def</span> <span class="title">value</span>:</span> F[StepT[E, F, A]]
}
type Iteratee[E, A] = IterateeT[E, Id, A]

object Iteratee
  extends IterateeFunctions
  <span class="keyword">with</span> IterateeTFunctions
  <span class="keyword">with</span> EnumeratorTFunctions
  <span class="keyword">with</span> EnumeratorPFunctions
  <span class="keyword">with</span> EnumerateeTFunctions
  <span class="keyword">with</span> StepTFunctions
  <span class="keyword">with</span> InputFunctions {

  <span class="function"><span class="keyword">def</span> <span class="title">apply</span>[<span class="title">E</span>, <span class="title">A</span>]<span class="params">(s: Step[E, A])</span>:</span> Iteratee[E, A] = iteratee(s)
}

type &gt;<span class="decorator">@&gt;[E, A] = Iteratee[E, A]</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://zhpooer.github.io/tags/scala/"/>
    
      <category term="scalaz" scheme="http://zhpooer.github.io/tags/scalaz/"/>
    
  </entry>
  
</feed>
